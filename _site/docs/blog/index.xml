<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Kwangmin Kim</title>
<link>kk3225.netlify.app/docs/blog/</link>
<atom:link href="kk3225.netlify.app/docs/blog/index.xml" rel="self" type="application/rss+xml"/>
<description>blog</description>
<generator>quarto-1.5.56</generator>
<lastBuildDate>Tue, 31 Dec 2999 15:00:00 GMT</lastBuildDate>
<item>
  <title>Blog Content List</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/content_list.html</link>
  <description><![CDATA[ 




<section id="contents" class="level1">

<ul>
<li><a href="../posts/Surveilance/guide_map/_index.qmd">Data Governance</a></li>
<li><a href="../posts/Engineering/guide_map/_index.qmd">Engineering</a></li>
<li><a href="../posts/Surveilance/guide_map/_index.qmd">Surveilance</a></li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Scalars are denoted with a lower-case letter (ex a ) or a non-bolded lower-case Greek letter (ex <img src="https://latex.codecogs.com/png.latex?%5Calpha"> ).</li>
<li>Vectors are denoted using a bold-faced lower-case letter (ex <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%20a">).</li>
<li>Matrices are denoted using a bold-faced upper-case letter (ex <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%20A">, <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%20%5Cphi">) or a bold-faced upper-case Greek letter (ex <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%20%5CPhi">).</li>
<li>Tensors are denoted using a bold-faced upper-case letter with multiple subscripts or superscripts, indicating the number of indices and the dimensions of the tensor along each axis.
<ul>
<li>A second-order tensor (also known as a matrix) <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%20A"> with dimensions <img src="https://latex.codecogs.com/png.latex?n%20%5Ctimes%20m"> can be represented as: <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%20A_%7Bij%7D"> where <img src="https://latex.codecogs.com/png.latex?i%20=%201,%5Cdots,m"> and <img src="https://latex.codecogs.com/png.latex?j%20=%201,%5Cdots,n">, which are the indices that run over the rows and columns of the matrix, respectively.</li>
<li>A third-order tensor <img src="https://latex.codecogs.com/png.latex?T"> with dimensions <img src="https://latex.codecogs.com/png.latex?n%20%5Ctimes%20m%20%5Ctimes%20p"> can be represented as: <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%20A_%7Bijk%7D"> where <img src="https://latex.codecogs.com/png.latex?i%20=%201,%5Cdots,m">, <img src="https://latex.codecogs.com/png.latex?j%20=%201,%5Cdots,n">, which are <img src="https://latex.codecogs.com/png.latex?i">, and <img src="https://latex.codecogs.com/png.latex?k%20=%201,%5Cdots,p"> <img src="https://latex.codecogs.com/png.latex?j">, and <img src="https://latex.codecogs.com/png.latex?k">, which are the indices that run over the three dimensions of the tensor.</li>
</ul></li>
</ul>
</div>
</div>


</section>

 ]]></description>
  <guid>kk3225.netlify.app/docs/blog/posts/content_list.html</guid>
  <pubDate>Tue, 31 Dec 2999 15:00:00 GMT</pubDate>
</item>
<item>
  <title>개발 환경의 숨은 암초, PATH 환경변수 오염</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Engineering/Conda/path_pollution.html</link>
  <description><![CDATA[ 




<section id="들어가며-개발자를-괴롭히는-path-문제" class="level2">
<h2 class="anchored" data-anchor-id="들어가며-개발자를-괴롭히는-path-문제">들어가며: 개발자를 괴롭히는 PATH 문제</h2>
<ul>
<li>나는 생화학, 수학, 통계 전공을 한터라 컴퓨터 공학을 전공하는 것이 아니었기 때문에 환경변수를 관리하지 않고 업무를 했고 그 결과 누적된 문제들이 얽혀 프로그램 오류를 찾아내는데 많은 시간을 소비하였다.</li>
<li>개발 환경을 설정하다 보면 예상치 못한 문제에 직면하게 된다. 특히 여러 도구와 언어를 함께 사용할 때, PATH 환경변수 오염은 마치 숨은 암초처럼 개발자를 괴롭힌다.</li>
<li>이 글에서는 복잡하게 꼬여버린 PATH 환경변수 문제의 진단부터 해결, 그리고 예방까지의 과정을 상세히 공유하고자 한다.</li>
<li><code>'conda.bat' is not recognized</code>, <code>reticulate 오류</code>, <code>Quarto 렌더링 실패</code> 등 겉보기엔 서로 다른 문제들이 사실은 하나의 거대한 PATH 오염에서 비롯된 것임을 밝혀내는 여정을 함께 따라가보자.</li>
</ul>
</section>
<section id="문제-상황-총체적-난국-오염된-path" class="level2">
<h2 class="anchored" data-anchor-id="문제-상황-총체적-난국-오염된-path">문제 상황: 총체적 난국, 오염된 PATH</h2>
<p>모든 문제의 시작은 처참하게 오염된 PATH 환경변수였다. 마치 뒤죽박죽 엉킨 실타래처럼, PATH는 다음과 같은 심각한 문제들을 안고 있었다.</p>
<section id="치명적인-경로-손상" class="level3">
<h3 class="anchored" data-anchor-id="치명적인-경로-손상">치명적인 경로 손상</h3>
<p>가장 심각한 문제는 Conda 환경 경로를 포함한 여러 경로가 완전히 깨져버린 것이다.</p>
<ul>
<li><code>miniconda3\\envs\\blog</code> 가 <code>miniconda3vlog</code> 로</li>
<li><code>mingw-w64\\bin</code> 가 <code>mingw-w6in</code> 로</li>
<li><code>usr\\bin</code> 가 <code>usin</code> 로</li>
<li><code>Library\\bin</code> 가 <code>Librarin</code> 로</li>
</ul>
<p>이러한 손상은 시스템이 정상적으로 실행 파일을 찾는 것을 불가능하게 만들었다.</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 예시: Git Bash에서 확인한 깨진 PATH의 일부</span></span>
<span id="cb1-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Users\\kmkim\\AppData\\Local\\miniconda3vlog</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span>                           <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 깨진 경로 (envs\\blog → vlog)</span></span>
<span id="cb1-3"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Users\\kmkim\\AppData\\Local\\miniconda3vlog\\Library\\mingw-w6in</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span>        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 심각하게 깨진 경로 (mingw-w64\\bin → mingw-w6in)</span></span>
<span id="cb1-4"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Users\\kmkim\\AppData\\Local\\miniconda3vlog\\Library\\usin</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span>              <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 깨진 경로 (usr\\bin → usin)</span></span>
<span id="cb1-5"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Users\\kmkim\\AppData\\Local\\miniconda3vlog\\Librarin</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span>                  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 깨진 경로 (Library\\bin → Librarin)</span></span>
<span id="cb1-6"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Users\\kmkim\\AppData\\Local\\miniconda3vlog\\Scripts</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span>                   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 깨진 경로</span></span>
<span id="cb1-7"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Users\\kmkim\\AppData\\Local\\miniconda3vloin</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span>                          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 완전히 깨진 경로</span></span></code></pre></div>
</section>
<section id="끝없는-경로-중복" class="level3">
<h3 class="anchored" data-anchor-id="끝없는-경로-중복">끝없는 경로 중복</h3>
<p>마치 복사-붙여넣기를 반복한 듯, 동일한 경로가 5번에서 10번 이상 중복되어 PATH를 극도로 길고 비효율적으로 만들었다.</p>
<ul>
<li>PowerShell 관련 경로는 10번 이상 반복</li>
<li>ffmpeg, MySQL, R tools 등 거의 모든 경로가 중복</li>
</ul>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 예시: 중복된 경로들</span></span>
<span id="cb2-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\ffmpeg</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span>                                                             <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ⚠️ 중복 (시스템/사용자 모두 존재)</span></span>
<span id="cb2-3"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\ffmpeg\\</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span>                                                            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 슬래시 중복</span></span>
<span id="cb2-4"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Program</span> Files<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\\</span>PowerShell<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\\</span>7<span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span>                                         <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ⚠️ 중복</span></span>
<span id="cb2-5"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Program</span> Files<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\\</span>PowerShell<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\\</span>7<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\\</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">;</span>                                        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 슬래시 중복</span></span>
<span id="cb2-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ... 기타 수많은 중복 경로 ...</span></span></code></pre></div>
</section>
<section id="일관성-없는-슬래시-사용" class="level3">
<h3 class="anchored" data-anchor-id="일관성-없는-슬래시-사용">일관성 없는 슬래시 사용</h3>
<p>경로 마지막에 슬래시(<code>/</code> 또는 <code>\\</code>)가 있거나 없는 경우가 혼재하여, 같은 경로가 다른 것으로 인식될 여지를 남겼다.</p>
<ul>
<li><code>C:\\path</code> 와 <code>C:\\path\\</code> 가 동시에 존재</li>
</ul>
</section>
<section id="사용자-path와-시스템-path의-혼란" class="level3">
<h3 class="anchored" data-anchor-id="사용자-path와-시스템-path의-혼란">사용자 PATH와 시스템 PATH의 혼란</h3>
<p>개인용 도구의 경로가 시스템 전체에 적용되는 시스템 PATH에 섞여 있었고, 그 반대의 경우도 존재하여 관리를 어렵게 만들었다.</p>
</section>
</section>
<section id="해결-과정-path-대청소" class="level2">
<h2 class="anchored" data-anchor-id="해결-과정-path-대청소">해결 과정: PATH 대청소</h2>
<p>엉망진창이 된 PATH를 정상으로 되돌리기 위한 대청소 작전은 다음과 같이 진행되었다.</p>
<section id="단계-path-현황-파악" class="level3">
<h3 class="anchored" data-anchor-id="단계-path-현황-파악">1단계: PATH 현황 파악</h3>
<p>가장 먼저 현재 PATH 상태를 정확히 파악하는 것이 중요했다.</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">where</span> python  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Python 실행 파일 위치 확인</span></span>
<span id="cb3-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">where</span> conda   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Conda 실행 파일 위치 확인</span></span>
<span id="cb3-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">echo</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$PATH</span>    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># (Git Bash 등에서) 전체 PATH 문자열 확인</span></span></code></pre></div>
<p>PowerShell에서는 다음과 같이 사용자 PATH와 시스템 PATH를 각각 확인할 수 있다.</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode powershell code-with-copy"><code class="sourceCode powershell"><span id="cb4-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 사용자 PATH (개인 도구 및 설정)</span></span>
<span id="cb4-2"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>Environment<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]::</span>GetEnvironmentVariable<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Path"</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"User"</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span id="cb4-3"></span>
<span id="cb4-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 시스템 PATH (모든 사용자 및 시스템 전역 도구)</span></span>
<span id="cb4-5"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>Environment<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]::</span>GetEnvironmentVariable<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Path"</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Machine"</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span></code></pre></div>
</section>
<section id="단계-사용자-path와-시스템-path-분리-및-재정렬" class="level3">
<h3 class="anchored" data-anchor-id="단계-사용자-path와-시스템-path-분리-및-재정렬">2단계: 사용자 PATH와 시스템 PATH 분리 및 재정렬</h3>
<p>진단 결과를 바탕으로, 각 경로의 성격에 맞게 사용자 PATH와 시스템 PATH로 명확히 분리했다.</p>
<ul>
<li><strong>사용자 PATH</strong>: 개인적으로 설치한 프로그램(Conda, VS Code, Quarto 등) 및 사용자별 도구</li>
<li><strong>시스템 PATH</strong>: Windows 기본 구성 요소, 모든 사용자에게 필요한 프로그램(Git, PowerShell 등)</li>
</ul>
</section>
<section id="단계-오류-수정-및-중복-제거" class="level3">
<h3 class="anchored" data-anchor-id="단계-오류-수정-및-중복-제거">3단계: 오류 수정 및 중복 제거</h3>
<ul>
<li><strong>깨진 경로 복구</strong>: <code>miniconda3vlog</code> 와 같이 손상된 부분을 원래의 <code>miniconda3\\envs\\blog\\Scripts</code> 등으로 수정했다.</li>
<li><strong>중복 경로 통합</strong>: 반복되는 경로들을 하나만 남기고 모두 제거했다. 슬래시 유무로 인한 중복도 통일했다.</li>
<li><strong>불필요한 경로 삭제</strong>: 예를 들어 Java JDK의 <code>bin\\server</code> 같이 실제 실행에 필요 없는 하위 경로를 제거했다.</li>
</ul>
</section>
<section id="단계-conda-환경-우선순위-조정" class="level3">
<h3 class="anchored" data-anchor-id="단계-conda-환경-우선순위-조정">4단계: Conda 환경 우선순위 조정</h3>
<p>여러 Python/Conda 환경이 존재할 때, 특정 프로젝트(예: <code>blog</code>)의 환경이 기본 Conda 환경보다 우선적으로 인식되도록 PATH 순서를 조정했다.</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode diff code-with-copy"><code class="sourceCode diff"><span id="cb5-1"># 수정 전 (일반 Conda가 우선될 수 있음)</span>
<span id="cb5-2">C:\Users\kmkim\AppData\Local\miniconda3\Scripts</span>
<span id="cb5-3">C:\Users\kmkim\AppData\Local\miniconda3\envs\blog\Scripts</span>
<span id="cb5-4"></span>
<span id="cb5-5"># 수정 후 (blog 환경 스크립트 최우선)</span>
<span id="cb5-6"><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">+ C:\Users\kmkim\AppData\Local\miniconda3\envs\blog\Scripts</span></span>
<span id="cb5-7">  C:\Users\kmkim\AppData\Local\miniconda3\Scripts</span>
<span id="cb5-8">  C:\Users\kmkim\AppData\Local\miniconda3\condabin</span>
<span id="cb5-9">  C:\Users\kmkim\AppData\Local\miniconda3</span></code></pre></div>
</section>
</section>
<section id="개선-후-평화를-되찾은-path" class="level2">
<h2 class="anchored" data-anchor-id="개선-후-평화를-되찾은-path">개선 후: 평화를 되찾은 PATH</h2>
<p>대대적인 정리 작업 끝에, PATH는 다음과 같이 깔끔하게 정돈되었다.</p>
<section id="사용자-path-개인-도구" class="level3">
<h3 class="anchored" data-anchor-id="사용자-path-개인-도구">사용자 PATH (개인 도구)</h3>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\miniconda3\envs\blog\Scripts</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ 최우선 (특정 Conda 환경)</span></span>
<span id="cb6-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\miniconda3\Scripts</span>            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ 일반 Conda 스크립트</span></span>
<span id="cb6-3"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\miniconda3\condabin</span>          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Conda 실행 파일 경로</span></span>
<span id="cb6-4"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\miniconda3</span>                   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Conda 기본 경로</span></span>
<span id="cb6-5"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\Programs\Quarto\bin</span>         <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Quarto</span></span>
<span id="cb6-6"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\Programs\Microsoft</span> VS Code<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\b</span>in <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ VS Code</span></span>
<span id="cb6-7"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\Programs\cursor\resources\app\bin</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Cursor</span></span>
<span id="cb6-8"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\scoop\shims</span>                                <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Scoop 패키지</span></span>
<span id="cb6-9"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\Microsoft\WindowsApps</span>       <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Windows Store 앱</span></span>
<span id="cb6-10"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\ffmpeg</span>                                                 <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ 사용자 ffmpeg</span></span>
<span id="cb6-11"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\R\rtools43\usr\bin</span>                                    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ R 도구</span></span></code></pre></div>
</section>
<section id="시스템-path-전역-도구" class="level3">
<h3 class="anchored" data-anchor-id="시스템-path-전역-도구">시스템 PATH (전역 도구)</h3>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Windows\system32</span>                                       <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Windows 기본</span></span>
<span id="cb7-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Windows</span>                                               <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Windows 기본</span></span>
<span id="cb7-3"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Windows\System32\Wbem</span>                                <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ WMI</span></span>
<span id="cb7-4"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Windows\System32\WindowsPowerShell\v1.0</span>             <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ 구 PowerShell</span></span>
<span id="cb7-5"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Windows\System32\OpenSSH</span>                            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ SSH</span></span>
<span id="cb7-6"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Program</span> Files<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\P</span>owerShell<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\7</span>                          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ 신 PowerShell</span></span>
<span id="cb7-7"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Program</span> Files<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\G</span>it<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\c</span>md                               <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Git</span></span>
<span id="cb7-8"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\ProgramData\chocolatey\bin</span>                          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Chocolatey</span></span>
<span id="cb7-9"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Program</span> Files<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\J</span>ava<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\o</span>penjdk-23.0.1_windows-x64_bin<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\j</span>dk-23.0.1<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\b</span>in <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Java</span></span>
<span id="cb7-10"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Program</span> Files<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\M</span>ATLAB<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\R</span>2022b<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\b</span>in                     <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ MATLAB</span></span>
<span id="cb7-11"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Program</span> Files <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">(</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">x86</span><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">)</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">\Microsoft</span> SDKs<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\A</span>zure<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\C</span>LI2<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\w</span>bin  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Azure CLI</span></span></code></pre></div>
</section>
</section>
<section id="개선-효과-숫자로-보는-변화" class="level2">
<h2 class="anchored" data-anchor-id="개선-효과-숫자로-보는-변화">개선 효과: 숫자로 보는 변화</h2>
<table class="caption-top table">
<thead>
<tr class="header">
<th>항목</th>
<th>개선 전</th>
<th>개선 후</th>
<th>개선율</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>총 PATH 항목 수</strong></td>
<td>~80개</td>
<td>~20개</td>
<td><strong>75% 감소</strong></td>
</tr>
<tr class="even">
<td><strong>중복 제거</strong></td>
<td>대량 중복</td>
<td>중복 없음</td>
<td><strong>100% 해결</strong></td>
</tr>
<tr class="odd">
<td><strong>깨진 경로</strong></td>
<td>5개 이상</td>
<td>0개</td>
<td><strong>100% 해결</strong></td>
</tr>
<tr class="even">
<td><strong>Python 인식</strong></td>
<td>실패</td>
<td>성공</td>
<td><strong>✅ 해결</strong></td>
</tr>
<tr class="odd">
<td><strong>Quarto 렌더링</strong></td>
<td>실패</td>
<td>성공</td>
<td><strong>✅ 해결</strong></td>
</tr>
</tbody>
</table>
</section>
<section id="최종-결과-평화로운-개발-환경" class="level2">
<h2 class="anchored" data-anchor-id="최종-결과-평화로운-개발-환경">최종 결과: 평화로운 개발 환경</h2>
<p>PATH 정리가 완료되자, 이전에 발생했던 모든 문제들이 거짓말처럼 사라졌다.</p>
<p><strong>이전</strong>: - <code>'conda.bat' is not recognized as an internal or external command...</code> - <code>Reticulate: Python N/A</code> - <code>Quarto failed to render (exit code: N)</code></p>
<p><strong>현재</strong>: - <code>conda activate blog</code> (정상 작동) - <code>python --version</code> (원하는 버전 출력) - <code>quarto preview</code> (성공적인 문서 미리보기)</p>
</section>
<section id="주요-오염-원인-분석" class="level2">
<h2 class="anchored" data-anchor-id="주요-오염-원인-분석">주요 오염 원인 분석</h2>
<p>이러한 대규모 PATH 오염은 왜 발생했을까? 몇 가지 가능한 원인들을 추정해볼 수 있다.</p>
<ol type="1">
<li><p><strong>설치 프로그램의 무분별한 PATH 수정</strong>: 일부 프로그램 설치 시, 기존 PATH를 정확히 파싱하지 못하거나, 잘못된 형식으로 경로를 추가/덮어쓰면서 문제가 누적될 수 있다. <code>bash     # 문제 패턴 예시     C:\Users\kmkim\AppData\Local\miniconda3vlog  # ← 'envs\blog'가 'vlog'로 깨짐     C:\R\rtools43\\usr\bin\                      # ← 백슬래시 중복</code></p></li>
<li><p><strong>빈번한 프로그램 설치/제거/업데이트</strong>: 다양한 버전의 Java, Python/Conda, PowerShell 등을 설치하고 제거하는 과정에서 PATH 항목이 정리되지 않고 계속 누적되어 중복과 꼬임을 유발한다.</p></li>
<li><p><strong>Conda 환경 관리 중 오류</strong>: Conda 환경을 생성하거나 삭제하는 도중 프로세스가 중단되거나, 특정 환경(예: 한글 경로)에서 인코딩 문제가 발생하면 PATH가 손상될 수 있다. <code>bash     # 정상적이라면: C:\...\miniconda3\envs\blog     # 실제 발생: C:\...\miniconda3vlog, C:\...\miniconda3\Library\usin 등</code></p></li>
<li><p><strong>Windows PATH 길이 제한 (구버전)</strong>: 과거 Windows 버전에서는 PATH 문자열의 최대 길이가 약 2048자로 제한되었다. 경로가 과도하게 길어지면 잘리면서 중간 부분이 손상될 수 있다.</p></li>
<li><p><strong>다양한 개발 도구의 독립적인 PATH 수정</strong>: MATLAB, R, Python, Java, Git, VS Code, Quarto 등 수많은 개발 도구들이 각자의 방식으로 PATH를 수정하면서 예기치 않은 충돌이나 꼬임이 발생할 수 있다.</p></li>
</ol>
</section>
<section id="예방-조치-건강한-path-유지를-위한-습관" class="level2">
<h2 class="anchored" data-anchor-id="예방-조치-건강한-path-유지를-위한-습관">예방 조치: 건강한 PATH 유지를 위한 습관</h2>
<p>향후 유사한 문제를 예방하기 위해 다음과 같은 습관을 들이는 것이 좋다.</p>
<ol type="1">
<li><p><strong>중요 작업 전 PATH 백업</strong>: 새로운 개발 도구를 설치하거나 환경 설정을 크게 변경하기 전에는 현재 PATH 상태를 백업한다. <code>powershell     $env:PATH | Out-File path_backup_YYYYMMDD.txt</code></p></li>
<li><p><strong>설치 프로그램 사용 시 신중함 유지</strong>:</p>
<ul>
<li>한 번에 하나의 프로그램만 설치하고, 설치 후 PATH 변경 사항 및 정상 작동 여부를 확인한다.</li>
<li>가능하다면 “Add to PATH” 옵션을 해제하고 수동으로 필요한 경로만 추가하는 것을 고려한다.</li>
<li>설치 후에는 시스템을 재부팅하여 변경사항이 완전히 적용되도록 한다.</li>
</ul></li>
<li><p><strong>정기적인 PATH 점검 및 정리</strong>: 주기적으로 PATH를 점검하여 불필요하거나 중복된 경로, 깨진 경로가 있는지 확인하고 정리한다. <code>powershell     # PowerShell에서 중복 없는 정렬된 PATH 목록 확인     $env:PATH -split ';' | Sort-Object | Get-Unique</code></p></li>
</ol>
</section>
<section id="교훈-모든-것은-path로-통한다" class="level2">
<h2 class="anchored" data-anchor-id="교훈-모든-것은-path로-통한다">교훈: 모든 것은 PATH로 통한다</h2>
<p>이번 PATH 오염 사태를 통해 얻은 교훈은 다음과 같다.</p>
<ul>
<li><strong>환경변수 오염은 소리 없는 암살자</strong>: 눈에 잘 보이지 않지만 시스템 전반의 안정성과 프로그램 작동에 치명적인 영향을 미칠 수 있다.</li>
<li><strong>PATH 순서의 중요성</strong>: 시스템은 PATH에 등록된 순서대로 실행 파일을 찾는다. 원하는 버전이나 환경의 도구가 먼저 실행되도록 순서를 올바르게 설정해야 한다.</li>
<li><strong>사용자 PATH와 시스템 PATH의 명확한 분리</strong>: 역할에 맞게 경로를 분리해야 충돌을 예방하고 관리가 용이해진다.</li>
<li><strong>복잡한 개발 스택일수록 PATH 관리는 필수</strong>: 특히 Quarto, R, Python처럼 여러 언어와 도구가 연동되는 환경에서는 깨끗하고 정확한 PATH 설정이 무엇보다 중요하다.</li>
</ul>
<p>결국, 겉으로 드러난 수많은 오류 메시지들은 “근본 원인”인 PATH 오염이 해결되자 모두 사라졌다. 복잡한 문제일수록 기본으로 돌아가 시스템의 가장 기초적인 설정부터 점검하는 자세가 필요함을 다시 한번 깨닫게 되었다.</p>


</section>

 ]]></description>
  <category>Engineering</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Engineering/Conda/path_pollution.html</guid>
  <pubDate>Wed, 30 Apr 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>데이터 플랫폼 리소스 계획 및 구현</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Engineering/data_engineering/2.IaaS.html</link>
  <description><![CDATA[ 




<section id="azure-sql을-사용하여-iaas-솔루션-배포" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="azure-sql을-사용하여-iaas-솔루션-배포"><span class="header-section-number">1</span> Azure SQL을 사용하여 IaaS 솔루션 배포</h2>
<section id="introduction" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">1.1</span> <a href="https://learn.microsoft.com/en-us/training/modules/deploy-iaas-solutions-with-azure-sql/1-introduction">Introduction</a></h3>
<p>데이터베이스 시스템의 성능 최적화를 위한 주요 고려사항:</p>
<ul>
<li>데이터베이스 워크로드 성능 보장
<ul>
<li>가상 머신의 적절한 크기 선택이 필수적
<ul>
<li>CPU, 메모리, IOPS 등 리소스 요구사항 분석</li>
<li>워크로드 특성에 맞는 VM 시리즈 선택</li>
</ul></li>
<li>스토리지 구성의 최적화
<ul>
<li>Premium SSD, Ultra Disk 등 적절한 스토리지 타입 선택</li>
<li>데이터, 로그, 템프DB 파일의 효율적인 배치</li>
</ul></li>
<li>네트워크 설정 최적화
<ul>
<li>대역폭 요구사항에 맞는 네트워크 구성</li>
<li>보안 및 접근성 고려</li>
</ul></li>
</ul></li>
<li>고가용성 구성
<ul>
<li>비즈니스 요구사항에 맞는 가용성 수준 결정</li>
<li>Always On 가용성 그룹, 장애 조치 클러스터 등 적절한 솔루션 선택</li>
<li>백업 및 복구 전략 수립</li>
</ul></li>
<li>Azure VM에서의 SQL Server 배포 이점
<ul>
<li>기존 온프레미스 환경의 손쉬운 클라우드 마이그레이션</li>
<li>최소한의 아키텍처 변경으로 신속한 전환 가능</li>
<li>기존 라이선스 및 구성의 재사용 가능</li>
</ul></li>
<li>성공적인 마이그레이션을 위한 핵심 요소
<ul>
<li>상세한 마이그레이션 계획 수립</li>
<li>적절한 배포 옵션 선택</li>
<li>철저한 테스트 및 검증 절차</li>
</ul></li>
</ul>
<section id="자유도의-차이-iaas자유도가-높음-vs-paas자유도가-중간-vs-saas자유도가-낮음" class="level4">
<h4 class="anchored" data-anchor-id="자유도의-차이-iaas자유도가-높음-vs-paas자유도가-중간-vs-saas자유도가-낮음">자유도의 차이: IaaS(자유도가 높음) vs PaaS(자유도가 중간) vs SaaS(자유도가 낮음)</h4>
<ul>
<li>Software as a Service (SaaS)
<ul>
<li><strong>관리 수준</strong>: 완전 관리형으로 모든 것이 서비스 제공업체에 의해 관리됨</li>
<li><strong>유지보수</strong>: 서비스 제공업체가 모든 유지보수 담당</li>
<li><strong>확장성</strong>: 자동 확장, 사용자는 구독 수준만 선택</li>
<li><strong>비용</strong>: 구독 기반 과금, 사용량에 따른 요금제</li>
<li><strong>유연성</strong>: 매우 제한적, 제공되는 기능만 사용 가능</li>
<li><strong>적합 사례</strong>: 표준화된 소프트웨어 필요 시 (예: Office 365, Salesforce)</li>
</ul></li>
<li>Azure SQL Database (PaaS)
<ul>
<li><strong>관리 수준</strong>: 완전 관리형 서비스로 Microsoft가 OS, 하드웨어, 백업, 고가용성 등을 관리</li>
<li><strong>유지보수</strong>: 자동 패치 및 업그레이드</li>
<li><strong>확장성</strong>: 자동 확장 기능 지원</li>
<li><strong>비용</strong>: 사용한 리소스에 따라 비용 지불, 일반적으로 관리 오버헤드가 적음</li>
<li><strong>제한사항</strong>: 일부 고급 SQL Server 기능 사용 불가(CLR, SQL Agent 등)</li>
<li><strong>적합 사례</strong>: 새 애플리케이션 개발, 관리 오버헤드 최소화가 필요한 경우</li>
</ul></li>
<li>IaaS SQL Server (Azure VM)
<ul>
<li><strong>관리 수준</strong>: 셀프 관리형으로 사용자가 OS, 소프트웨어 업데이트, 백업 등 직접 관리</li>
<li><strong>유지보수</strong>: 수동 패치 및 업그레이드</li>
<li><strong>확장성</strong>: 수동 확장, VM 크기 변경 필요</li>
<li><strong>비용</strong>: VM 인프라에 대한 비용 지불, 관리 오버헤드가 더 많음</li>
<li><strong>유연성</strong>: 모든 SQL Server 기능 사용 가능(SSAS, SSIS, SSRS 등)</li>
<li><strong>적합 사례</strong>: 기존 온프레미스 SQL Server 마이그레이션, 특정 버전/기능 필요 시</li>
</ul></li>
<li>주요 차이점
<ul>
<li><strong>제어 수준</strong>: IaaS는 더 많은 제어를 제공하지만 더 많은 관리 책임이 따름</li>
<li><strong>호환성</strong>: IaaS는 온프레미스 SQL Server와 100% 호환, PaaS는 일부 제한</li>
<li><strong>운영 비용</strong>: PaaS는 일반적으로 운영 비용이 더 낮음</li>
</ul></li>
</ul>
</section>
</section>
<section id="azure에서-sql-server를-배포하기-위한-iaas-옵션-설명" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="azure에서-sql-server를-배포하기-위한-iaas-옵션-설명"><span class="header-section-number">1.2</span> <a href="https://learn.microsoft.com/en-us/training/modules/deploy-iaas-solutions-with-azure-sql/2-explain-iaas-options-deploy-azure">Azure에서 SQL Server를 배포하기 위한 IaaS 옵션 설명</a></h3>
<ul>
<li><p>Azure VM에서 SQL Server를 실행해야 하는 주요 시나리오들:</p>
<ol type="1">
<li>이전 버전의 SQL Server가 필요한 경우</li>
</ol>
<ul>
<li>일부 애플리케이션은 특정 이전 버전의 SQL Server에서만 작동</li>
<li>공급업체가 지원하는 특정 SQL Server 버전을 사용해야 하는 경우</li>
<li>이런 경우 VM에 원하는 버전을 직접 설치하여 실행하는 것이 가장 좋은 방법</li>
</ul>
<ol start="2" type="1">
<li>여러 SQL Server 서비스를 함께 사용해야 하는 경우</li>
</ol>
<ul>
<li>SQL Server 데이터베이스 엔진과 함께 Analysis Services(분석 서비스)나 Integration Services(통합 서비스), Reporting Services(보고 서비스)를 같이 사용해야 할 때</li>
<li>이들을 한 VM에서 함께 실행하면 라이선스 비용을 절약할 수 있음</li>
<li>Azure에서 일부 서비스는 PaaS로 제공되지만, 비용 효율성을 위해 VM에서 함께 실행하는 것이 유리할 수 있음</li>
</ul>
<ol start="3" type="1">
<li>애플리케이션 호환성 문제가 있는 경우</li>
</ol>
<ul>
<li>일부 애플리케이션은 여러 데이터베이스 간의 쿼리(교차 데이터베이스 쿼리)가 필요</li>
<li>Azure SQL Database는 이를 지원하지 않아 VM 사용이 필요</li>
<li>데이터베이스와 다른 서비스들이 특별한 방식으로 함께 동작해야 하는 경우</li>
</ul></li>
<li><p>IaaS(Infrastructure as a Service)의 장점과 특징:</p>
<ul>
<li>관리자의 세밀한 시스템 제어
<ul>
<li>Azure가 서버 하드웨어와 네트워크를 관리하지만, 관리자는 다음을 직접 제어 가능:
<ul>
<li>가상 스토리지 설정</li>
<li>가상 네트워크 구성</li>
<li>SQL Server 설치 및 설정</li>
<li>추가 소프트웨어 설치</li>
</ul></li>
</ul></li>
<li>인프라 구성의 높은 자유도
<ul>
<li>OS 레벨부터 완전한 제어 가능</li>
<li>커스텀 설정 및 튜닝의 자유로움</li>
</ul></li>
<li>세부적인 구성 계획의 중요성
<ul>
<li>성능 요구사항에 맞는 리소스 할당</li>
<li>확장성을 고려한 아키텍처 설계</li>
<li>비용 효율적인 리소스 사용 계획</li>
</ul></li>
</ul></li>
</ul>
<section id="azure-서비스-control-granularity제어-정밀도-비교" class="level4">
<h4 class="anchored" data-anchor-id="azure-서비스-control-granularity제어-정밀도-비교">Azure 서비스 Control Granularity(제어 정밀도) 비교</h4>
<ul>
<li>IaaS, PaaS, SaaS의 제어 수준 차이
<ul>
<li>IaaS: 가장 높은 제어 수준 제공</li>
<li>PaaS: 중간 수준의 제어 제공</li>
<li>SaaS: 가장 제한된 제어 수준</li>
</ul></li>
<li>각 서비스 별 관리 책임
<ul>
<li>SaaS: 사용자는 보안과 데이터 관리만 담당</li>
<li>PaaS: 클라우드 제공업체가 OS와 기본 소프트웨어 관리</li>
<li>IaaS: 사용자가 OS 패치, 네트워크, 스토리지 구성 등 대부분 관리</li>
</ul></li>
<li>Azure IaaS에서의 책임 분담
<ul>
<li>Microsoft 담당:
<ul>
<li>물리적 서버</li>
<li>스토리지</li>
<li>물리적 네트워킹</li>
</ul></li>
<li>사용자 담당:
<ul>
<li>OS 관리</li>
<li>SQL Server 인스턴스 구성</li>
<li>추가 소프트웨어 설치/관리</li>
</ul></li>
</ul></li>
<li>IaaS가 필요한 특수 상황
<ul>
<li>특정 SQL Server/Windows 버전 조합이 필요한 경우</li>
<li>SQL Server와 함께 추가 소프트웨어 설치가 필요한 경우</li>
<li>CLR, 복제 등 특수 기능 사용이 필요한 경우</li>
<li>기존 Active Directory 인증이 필요한 경우</li>
<li>OS 직접 접근이 필요한 애플리케이션 운영 시</li>
</ul></li>
<li>IaaS의 장점
<ul>
<li>높은 유연성과 제어 가능성</li>
<li>기존 온프레미스 환경과 유사한 구성 가능</li>
<li>클라우드의 이점과 기존 기능의 동시 활용</li>
<li>특수한 요구사항 수용 가능</li>
</ul></li>
</ul>
</section>
<section id="sql-server-iaas-agent-extensionsql-server-iaas-에이전트-확장" class="level4">
<h4 class="anchored" data-anchor-id="sql-server-iaas-agent-extensionsql-server-iaas-에이전트-확장">SQL Server IaaS Agent Extension(SQL Server IaaS 에이전트 확장)</h4>
<ul>
<li>Azure Marketplace에서 SQL Server VM을 배포할 때, 프로세스의 일부로 IaaS Agent Extension이 설치된다.</li>
<li>확장(Extension)은 VM 배포 후 실행되는 코드로, 일반적으로 배포 후 구성을 수행한다.</li>
<li>예를 들어 백신 소프트웨어 설치나 Windows 기능 활성화 등이 있다.</li>
<li>SQL Server IaaS Agent Extension은 관리 부담을 줄일 수 있는 다음과 같은 주요 기능을 제공한다:
<ul>
<li>자동 백업</li>
<li>자동 패치 적용</li>
<li>Azure Key Vault 통합</li>
<li>Microsoft Defender for Cloud 통합</li>
<li>포털에서 디스크 사용량 확인</li>
<li>유연한 라이선싱</li>
<li>유연한 버전/에디션 선택</li>
<li>SQL 모범 사례 평가</li>
</ul></li>
</ul>
<p>이러한 기능 외에도, 이 확장을 통해 SQL Server의 구성 및 스토리지 사용량 정보를 확인할 수 있다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="kk3225.netlify.app/images/azure/IaaS Agent Extension.PNG" class="img-fluid figure-img"></p>
<figcaption>IaaS Agent Extension</figcaption>
</figure>
</div>
</section>
<section id="sql-server-라이선싱-모델" class="level4">
<h4 class="anchored" data-anchor-id="sql-server-라이선싱-모델">SQL Server 라이선싱 모델</h4>
<ul>
<li>Azure VM에서 SQL Server 라이선스 사용 방법은 크게 두 가지</li>
</ul>
<ol type="1">
<li>종량제(Pay as you Go) 방식
<ul>
<li>Azure Marketplace에서 SQL Server가 설치된 VM 이미지 사용</li>
<li>사용한 시간만큼 VM 비용 + SQL Server 라이선스 비용 지불</li>
</ul></li>
<li>기존 라이선스 사용(BYOL) 방식
<ul>
<li>Software Assurance(SA) 프로그램 참여 고객만 가능</li>
<li>기존 보유한 SQL Server 라이선스를 Azure VM에 적용</li>
<li>VM 구현 후 10일 이내에 Microsoft에 라이선스 사용 보고 필요</li>
<li>SQL Server를 직접 설치하거나 커스텀 이미지 업로드 가능</li>
</ul></li>
</ol>
<p>비용 절감을 위한 추가 옵션: - Windows Server 라이선스도 기존 것 사용 가능 (Azure Hybrid Benefit) - VM을 1-3년 예약 구매 시 추가 할인 - 선불 결제 없이 월별 청구 가능 - 장기 사용 예정인 대형 VM에 특히 유리</p>
</section>
<section id="azure-vm-제품군-종류" class="level4">
<h4 class="anchored" data-anchor-id="azure-vm-제품군-종류">Azure VM 제품군 종류</h4>
<p>Azure VM은 다양한 제품군(시리즈)을 제공하며, 각각 특정 용도에 최적화되어 있다.</p>
<ol type="1">
<li>범용(General Purpose)
<ul>
<li>CPU와 메모리의 균형잡힌 구성</li>
<li>테스트/개발 환경, 소/중규모 DB 서버, 중소 트래픽 웹서버에 적합</li>
</ul></li>
<li>컴퓨팅 최적화(Compute Optimized)
<ul>
<li>높은 CPU 대 메모리 비율</li>
<li>중규모 웹서버, 네트워크 어플라이언스, 배치 처리에 적합</li>
<li>기본적인 머신러닝 워크로드 지원</li>
</ul></li>
<li>메모리 최적화(Memory Optimized)
<ul>
<li>높은 메모리 대 CPU 비율 (최대 4TB RAM)</li>
<li>대부분의 데이터베이스 워크로드에 적합</li>
</ul></li>
<li>스토리지 최적화(Storage Optimized)
<ul>
<li>고속 로컬 NVMe 임시 스토리지 제공</li>
<li>Cassandra 등 스케일아웃 데이터 워크로드에 적합</li>
<li>SQL Server 사용 시 Always On 가용성 그룹 등 데이터 보호 구성 필요</li>
</ul></li>
<li>GPU 최적화
<ul>
<li>비디오 렌더링/처리</li>
<li>GPU 기반 대규모 병렬 머신러닝 워크로드에 적합</li>
</ul></li>
<li>FPGA 가속
<ul>
<li>컴퓨팅 집약적 워크로드용</li>
<li>높은 스토리지 처리량과 네트워크 대역폭 제공</li>
</ul></li>
<li>고성능 컴퓨팅(HPC)
<ul>
<li>수천 개 CPU 코어로 수평 확장 가능</li>
<li>RDMA 네트워킹을 통한 낮은 지연시간 제공</li>
</ul></li>
</ol>
<ul>
<li>VM 크기 선택 방법
<ul>
<li>Azure 포털의 VM 생성 블레이드에서 ‘모든 크기 보기’ 선택</li>
<li>각 크기별 상세 정보 확인 가능:
<ul>
<li>vCPU 수</li>
<li>RAM 용량</li>
<li>데이터 디스크 수</li>
<li>최대 IOPS</li>
<li>임시 스토리지 용량</li>
<li>프리미엄 스토리지 지원 여부</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="azure-marketplace" class="level4">
<h4 class="anchored" data-anchor-id="azure-marketplace">Azure Marketplace</h4>
<p>Azure Marketplace는 Azure에서 제공하는 리소스 스토어로, 미리 만들어진 템플릿을 사용해 쉽게 리소스를 생성할 수 있다.</p>
<ul>
<li>주요 특징:
<ul>
<li>간단한 설정: 기본 정보만 입력하면 빠르게 리소스 생성 가능</li>
<li>빠른 구축: 몇 분 안에 리소스 사용 가능</li>
<li>다양한 옵션: SQL Server, Windows Server 등 다양한 제품 제공</li>
<li>사전 구성: OLTP, Data Warehouse 등 용도에 맞는 설정 제공</li>
</ul></li>
<li>장점
<ul>
<li>쉽고 빠른 시작 가능</li>
<li>직관적인 인터페이스</li>
<li>상세 설정 없이도 사용 가능</li>
</ul></li>
<li>단점
<ul>
<li>반복 작업이 어려움</li>
<li>자동화하기 불편함</li>
</ul></li>
</ul>
</section>
<section id="sql-server-configuration" class="level4">
<h4 class="anchored" data-anchor-id="sql-server-configuration">SQL Server configuration</h4>
<p>Azure VM에서 SQL Server를 설치할 때 다음과 같은 기본적인 설정들을 할 수 있다:</p>
<ul>
<li>보안 설정: 방화벽 규칙, 접근 권한 등을 설정</li>
<li>네트워크 설정: 가상 네트워크, 서브넷 등을 구성<br>
</li>
<li>SQL 인증: 사용자 계정과 비밀번호 설정</li>
<li>SQL 인스턴스: 데이터베이스 엔진 설정</li>
</ul>
</section>
</section>
<section id="understand-hybrid-scenarios" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="understand-hybrid-scenarios"><span class="header-section-number">1.3</span> <a href="https://learn.microsoft.com/en-us/training/modules/deploy-iaas-solutions-with-azure-sql/3-understand-hybrid-scenarios">Understand hybrid scenarios</a></h3>
<ul>
<li>하이브리드 인프라의 필요성
<ul>
<li>온프레미스/로컬 데이터센터의 SQL Server 인프라 투자 활용 가능</li>
<li>클라우드와 온프레미스의 장점을 모두 활용 가능</li>
<li>운영 복원력 향상과 비용 절감 효과</li>
</ul></li>
<li>하이브리드 인프라의 장점
<ul>
<li>클라우드 전환에 신중한 조직을 위한 좋은 시작점</li>
<li>물리적/가상화된 SQL Server 온프레미스 배포를 클라우드로 확장 가능</li>
<li>온프레미스와 클라우드 서비스의 상호 보완적 운영</li>
<li>IaaS 서비스(스토리지, SQL Server VM 등) 활용 가능</li>
</ul></li>
<li>하이브리드 구현 범위
<ul>
<li>온프레미스와 클라우드 간 하이브리드</li>
<li>여러 클라우드 서비스 간 하이브리드 구현 가능</li>
<li>다양한 SQL Server 하이브리드 시나리오 적용 가능</li>
</ul></li>
</ul>
<section id="sql-server를-위한-하이브리드-시나리오" class="level4">
<h4 class="anchored" data-anchor-id="sql-server를-위한-하이브리드-시나리오">SQL Server를 위한 하이브리드 시나리오</h4>
<p>SQL Server를 위한 하이브리드 솔루션을 배포할 때 고려할 수 있는 몇 가지 전략</p>
</section>
<section id="재해-복구" class="level4">
<h4 class="anchored" data-anchor-id="재해-복구">재해 복구</h4>
<p>재해 복구는 SQL Server를 하이브리드로 운영할 때 가장 많이 사용되는 방식</p>
<ul>
<li>주요 특징
<ul>
<li>재난 상황에서도 비즈니스 연속성 보장</li>
<li>여러 데이터 센터에 분산 배치 가능</li>
<li>Azure VM을 활용해 비용 효율적인 DR 구축</li>
</ul></li>
<li>운영 방식
<ul>
<li>일상적인 처리는 온프레미스 서버 사용</li>
<li>재해 발생 시 Azure로 전환(장애 조치)</li>
<li>여러 지역에 걸쳐 백업 가능</li>
</ul></li>
</ul>
</section>
<section id="sql-server-백업" class="level4">
<h4 class="anchored" data-anchor-id="sql-server-백업">SQL Server 백업</h4>
<p>SQL Server의 데이터를 안전하게 보관하기 위한 백업 전략</p>
<ul>
<li>백업 방식
<ul>
<li>Azure Storage에 직접 백업 (URL 사용)</li>
<li>Azure 파일 공유 활용 (SMB 프로토콜)</li>
</ul></li>
<li>주요 이점
<ul>
<li>현장 백업 실패 시에도 데이터 보호</li>
<li>Azure VM에서 백업 데이터 복원 테스트 가능</li>
<li>클라우드의 안정적인 스토리지 활용</li>
</ul></li>
</ul>
</section>
<section id="azure-arc-지원-sql-server" class="level4">
<h4 class="anchored" data-anchor-id="azure-arc-지원-sql-server">Azure Arc 지원 SQL Server</h4>
<p>여러 환경의 SQL Server를 Azure에서 통합 관리할 수 있게 해주는 서비스</p>
<ul>
<li>지원 환경
<ul>
<li>온프레미스</li>
<li>데이터 센터</li>
<li>엣지 환경</li>
<li>멀티클라우드</li>
</ul></li>
<li>주요 기능
<ul>
<li>모든 SQL Server 배포 현황 파악</li>
<li>구성/사용 패턴/보안 평가</li>
<li>실시간 보안 경고</li>
<li>취약점 보고</li>
</ul></li>
</ul>
</section>
<section id="보안-고려사항" class="level4">
<h4 class="anchored" data-anchor-id="보안-고려사항">보안 고려사항</h4>
<p>하이브리드 SQL 환경을 안전하게 운영하기 위한 보안 요소</p>
<ul>
<li>기본 요구사항
<ul>
<li>Active Directory와 DNS 설정 (온프레미스/Azure 모두)</li>
<li>안전한 양방향 통신 구축</li>
</ul></li>
<li>연결 방식
<ul>
<li>사이트 간(S2S) VPN</li>
<li>ExpressRoute</li>
</ul></li>
<li>ExpressRoute 특징
<ul>
<li>장점
<ul>
<li>최고 수준의 보안</li>
<li>최소 지연 시간</li>
<li>공용 인터넷과 분리된 전용 채널</li>
</ul></li>
<li>단점
<ul>
<li>높은 비용</li>
<li>멀티클라우드 환경에서 제한적 사용</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section id="explore-performance-and-security" class="level3" data-number="1.4">
<h3 data-number="1.4" class="anchored" data-anchor-id="explore-performance-and-security"><span class="header-section-number">1.4</span> <a href="https://learn.microsoft.com/en-us/training/modules/deploy-iaas-solutions-with-azure-sql/4-explore-performance-and-security">Explore performance and security</a></h3>
<ul>
<li>Azure 에코시스템은 Azure 가상 머신의 SQL Server 인스턴스에 대한 다양한 성능 및 보안 옵션을 제공한다</li>
<li>각 옵션은 워크로드의 용량 및 성능 요구사항을 충족하는 다양한 디스크 유형과 같은 기능을 제공한다.</li>
</ul>
<section id="스토리지-고려사항" class="level4">
<h4 class="anchored" data-anchor-id="스토리지-고려사항">스토리지 고려사항</h4>
<ul>
<li>SQL Server는 Azure VM이나 온프레미스 환경에서 모두 고성능을 위해 우수한 스토리지 성능이 필수적</li>
<li>Azure는 다양한 스토리지 솔루션을 제공하는데, SQL Server 워크로드는 주로 Azure 관리 디스크를 사용</li>
<li>Azure 관리 디스크는 VM에 제공되는 블록 수준 스토리지로, 높은 가용성과 확장성을 제공</li>
</ul>
<p>Azure 관리 디스크의 주요 특징:</p>
<ul>
<li>스토리지 유형
<ul>
<li>Blob, 파일, 큐, 테이블 등 다양한 유형 제공</li>
<li>SQL Server는 주로 관리 디스크 사용</li>
<li>장애 조치 클러스터는 파일 스토리지 사용 가능</li>
<li>백업은 blob 스토리지 활용</li>
</ul></li>
<li>관리 디스크의 장점
<ul>
<li>99.999%의 높은 가용성</li>
<li>지역당 구독당 최대 50,000개 VM 디스크 지원</li>
<li>가용성 집합/영역과의 통합으로 높은 복원력</li>
</ul></li>
<li>암호화 옵션
<ul>
<li>Azure 서버 측 암호화: 스토리지 서비스 레벨의 암호화</li>
<li>Azure 디스크 암호화: VM 내부의 OS/데이터 디스크 암호화</li>
<li>두 옵션 모두 Azure Key Vault 통합 지원</li>
</ul></li>
</ul>
<p>VM에 연결되는 디스크 유형:</p>
<ol type="1">
<li>운영 체제 디스크
<ul>
<li>부팅 볼륨 포함</li>
<li>Windows: C: 드라이브</li>
<li>Linux: /dev/sda1</li>
</ul></li>
<li>임시 디스크
<ul>
<li>임시 스토리지용</li>
<li>페이지/스왑 파일 등 비영구 데이터 저장</li>
<li>Windows: D:&nbsp;드라이브</li>
<li>Linux: /dev/sdb1</li>
<li>중요 데이터 저장 금지</li>
</ul></li>
<li>데이터 디스크
<ul>
<li>VM에 추가되는 관리 디스크</li>
<li>Windows: Storage Spaces로 풀링 가능</li>
<li>Linux: 논리 볼륨 관리로 풀링 가능</li>
<li>IOPS와 스토리지 용량 확장 가능</li>
</ul></li>
</ol>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 15%">
<col style="width: 20%">
<col style="width: 16%">
<col style="width: 17%">
<col style="width: 17%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Ultra Disk</th>
<th>Premium SSD v2</th>
<th>Premium SSD</th>
<th>Standard SSD</th>
<th>Standard HDD</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Disk type</td>
<td>SSD</td>
<td>SSD</td>
<td>SSD</td>
<td>SSD</td>
<td>HDD</td>
</tr>
<tr class="even">
<td>Best for</td>
<td>IO-intensive workloads</td>
<td>Performance-sensitive workloads</td>
<td>Performance-sensitive workloads</td>
<td>Lightweight workloads</td>
<td>Backups, non-critical workloads</td>
</tr>
<tr class="odd">
<td>Max disk size</td>
<td>65,536 GiB</td>
<td>64,000 GiB</td>
<td>32,767 GiB</td>
<td>32,767 GiB</td>
<td>32,767 GiB</td>
</tr>
<tr class="even">
<td>Max throughput</td>
<td>10,000 MB/s</td>
<td>1,200 MB/s</td>
<td>900 MB/s</td>
<td>750 MB/s</td>
<td>500 MB/s</td>
</tr>
<tr class="odd">
<td>Max IOPS</td>
<td>160,000</td>
<td>80,000</td>
<td>20,000</td>
<td>6,000</td>
<td>2,000</td>
</tr>
</tbody>
</table>
<p>Azure SQL Server의 스토리지 구성에 대한 모범 사례를 살펴보면, 성능 최적화를 위해 여러 디스크를 적절히 구성하는 것이 중요. 특히 IOPS와 스토리지 용량을 효과적으로 관리하기 위해서는 프리미엄 디스크를 풀링하여 사용하는 것이 권장됨</p>
<p>각 데이터 유형별 스토리지 구성 권장사항:</p>
<ul>
<li>데이터 파일
<ul>
<li>프리미엄 디스크의 자체 풀에 저장</li>
<li>읽기 캐싱 기능 활성화</li>
<li>높은 IOPS와 처리량 확보</li>
</ul></li>
<li>트랜잭션 로그 파일
<ul>
<li>별도의 디스크 풀에 저장</li>
<li>캐싱 기능 비활성화 (캐싱의 이점 없음)</li>
<li>안정적인 쓰기 성능 보장</li>
</ul></li>
<li>TempDB
<ul>
<li>두 가지 옵션 중 선택:
<ol type="1">
<li>자체 디스크 풀에 저장</li>
<li>VM의 임시 디스크 활용 (물리 서버와 직접 연결되어 낮은 지연시간 제공)</li>
</ol></li>
</ul></li>
</ul>
<p>성능 요구사항에 따른 디스크 선택: - 일반적인 워크로드: 프리미엄 SSD (밀리초 단위의 지연시간) - 미션 크리티컬 워크로드: Ultra SSD (더 낮은 지연시간 필요시)</p>
</section>
<section id="보안-고려사항-1" class="level4">
<h4 class="anchored" data-anchor-id="보안-고려사항-1">보안 고려사항</h4>
<p>Azure는 가상 머신에서 실행되는 SQL Server의 규정 준수 솔루션을 위해 다양한 보안 도구와 기능을 제공합니다.</p>
<p>주요 보안 도구:</p>
<ol type="1">
<li>SQL용 Microsoft Defender
<ul>
<li>취약성 평가 및 보안 경고 기능 제공</li>
<li>SQL Server 인스턴스와 데이터베이스의 잠재적 취약점 식별</li>
<li>보안 위험 감지 및 해결 방안 제시</li>
<li>보안 상태 모니터링 및 개선을 위한 실행 가능한 단계 제공</li>
</ul></li>
<li>Azure Security Center
<ul>
<li>통합 보안 관리 시스템</li>
<li>하이브리드 클라우드 워크로드 전반의 보안 상태 모니터링</li>
<li>공격 노출 감소 및 위협 대응 기능</li>
<li>보안 개선 기회 식별 및 제안</li>
</ul></li>
</ol>
</section>
<section id="성능-최적화-방안" class="level4">
<h4 class="anchored" data-anchor-id="성능-최적화-방안">성능 최적화 방안</h4>
<p>Azure VM의 SQL Server는 온프레미스 환경과 유사한 성능 최적화 기능을 제공합니다.</p>
<p>주요 성능 최적화 기능:</p>
<ol type="1">
<li>테이블 파티셔닝
<ul>
<li>대규모 테이블의 효율적 관리</li>
<li>쿼리 성능 향상</li>
<li>유지보수 작업 효율화</li>
</ul>
구현 단계:
<ul>
<li>파일 그룹 생성</li>
<li>파티션 함수 정의</li>
<li>파티션 스키마 생성</li>
<li>테이블 파티션 설정</li>
</ul></li>
<li>데이터 압축 압축 유형:
<ul>
<li>행 압축
<ul>
<li>기본적인 압축 방식</li>
<li>최소 저장 공간 사용</li>
<li>낮은 시스템 부하</li>
</ul></li>
<li>페이지 압축
<ul>
<li>행 압축 포함</li>
<li>접두사 압축과 사전 압축 기술 적용</li>
<li>높은 압축률 제공</li>
</ul></li>
<li>컬럼스토어 아카이브 압축
<ul>
<li>XPRESS 압축 알고리즘 사용</li>
<li>자주 접근하지 않는 보관 데이터에 적합</li>
<li>높은 CPU 사용률</li>
</ul></li>
</ul></li>
<li>추가 최적화 옵션
<ul>
<li>백업 압축 기능 활성화</li>
<li>즉각적인 파일 초기화 설정</li>
<li>데이터베이스 자동 증가 제한 설정</li>
<li>자동 축소/자동 닫기 기능 비활성화</li>
<li>시스템 데이터베이스 데이터 디스크 이전</li>
<li>로그 및 추적 파일 데이터 디스크 이전</li>
</ul></li>
</ol>
<pre><code>-- Partition function
CREATE PARTITION FUNCTION PartitionByMonth (datetime2)
    AS RANGE RIGHT
    -- The boundary values defined is the first day of each month, where the table will be partitioned into 13 partitions
    FOR VALUES ('20210101', '20210201', '20210301',
      '20210401', '20210501', '20210601', '20210701',
      '20210801', '20210901', '20211001', '20211101', 
      '20211201');

-- The partition scheme below will use the partition function created above, and assign each partition to a specific filegroup.
CREATE PARTITION SCHEME PartitionByMonthSch
    AS PARTITION PartitionByMonth
    TO (FILEGROUP1, FILEGROUP2, FILEGROUP3, FILEGROUP4,
        FILEGROUP5, FILEGROUP6, FILEGROUP7, FILEGROUP8,
        FILEGROUP9, FILEGROUP10, FILEGROUP11, FILEGROUP12);

-- Creates a partitioned table called Order that applies PartitionByMonthSch partition scheme to partition the OrderDate column  
CREATE TABLE Order ([Id] int PRIMARY KEY, OrderDate datetime2)  
    ON PartitionByMonthSch (OrderDate) ;  
GO
</code></pre>
</section>
<section id="데이터-압축" class="level4">
<h4 class="anchored" data-anchor-id="데이터-압축">데이터 압축</h4>
<p>SQL Server의 데이터 압축은 데이터베이스의 성능과 저장 공간을 최적화하는 중요한 기능입니다.</p>
<p>데이터 압축의 기본 구조: - SQL Server는 8KB 크기의 페이지 단위로 데이터를 저장 - 압축을 통해 한 페이지에 더 많은 데이터를 저장 가능</p>
<p>데이터 압축의 주요 효과: 1. 물리적 IO 감소 - 쿼리 실행 시 읽어야 할 페이지 수가 줄어듦 - 디스크 읽기/쓰기 작업이 감소</p>
<ol start="2" type="1">
<li>메모리 사용 효율성 향상
<ul>
<li>버퍼 풀의 메모리를 더 효율적으로 사용</li>
<li>동일한 메모리로 더 많은 데이터 처리 가능</li>
</ul></li>
</ol>
<p>데이터 압축의 주요 특징과 장단점은 다음과 같습니다:</p>
<ol type="1">
<li><p>주요 이점</p>
<ul>
<li>물리적 IO 감소</li>
<li>버퍼 풀의 효율적인 메모리 사용</li>
<li>저장 공간 절약</li>
<li>대부분의 경우 전반적인 성능 향상</li>
</ul></li>
<li><p>잠재적 단점</p>
<ul>
<li>CPU 사용량 증가</li>
<li>압축/해제 과정에서의 추가 처리 시간</li>
</ul></li>
<li><p>구현 특성</p>
<ul>
<li>개체 수준에서 구현 가능</li>
<li>개별 인덱스나 테이블 단위로 압축 가능</li>
<li>파티션 단위로도 압축 설정 가능</li>
<li>sp_estimate_data_compression_savings 프로시저로 압축 효과 예측 가능</li>
</ul></li>
<li><p>압축 유형별 특징</p>
<p>행 압축:</p>
<ul>
<li>기본적인 압축 방식으로 최소한의 시스템 부하</li>
<li>각 열의 값을 최소 필요 공간으로 저장</li>
<li>숫자 데이터는 가변 길이로 저장</li>
<li>고정 길이 문자열을 가변 길이로 변환</li>
</ul>
<p>페이지 압축:</p>
<ul>
<li>행 압축을 포함한 고급 압축 방식</li>
<li>접두사 압축으로 중복 데이터 제거</li>
<li>사전 압축으로 반복 값을 포인터로 대체</li>
<li>데이터 중복성이 높을수록 압축률 증가</li>
</ul>
<p>컬럼스토어 아카이브 압축:</p>
<ul>
<li>XPRESS 압축 알고리즘 사용</li>
<li>자주 접근하지 않는 보관용 데이터에 적합</li>
<li>높은 압축률 제공</li>
<li>CPU 사용량이 상대적으로 높음</li>
</ul></li>
</ol>
</section>
<section id="추가-옵션" class="level4">
<h4 class="anchored" data-anchor-id="추가-옵션">추가 옵션</h4>
<p>다음은 프로덕션 워크로드에 대해 고려해야 할 추가 SQL Server 기능 및 작업 목록:</p>
<ul>
<li>백업 압축 활성화</li>
<li>데이터 파일에 대한 즉각적인 파일 초기화 활성화</li>
<li>데이터베이스 자동 증가 제한</li>
<li>데이터베이스에 대한 자동 축소/자동 닫기 비활성화</li>
<li>시스템 데이터베이스를 포함한 모든 데이터베이스를 데이터 디스크로 이동</li>
<li>SQL Server 오류 로그 및 추적 파일 디렉터리를 데이터 디스크로 이동</li>
<li>최대 SQL Server 메모리 제한 설정</li>
<li>메모리의 페이지 잠금 활성화</li>
<li>OLTP 중심 환경을 위한 임시 워크로드 최적화 활성화</li>
<li>쿼리 스토어 활성화</li>
<li>DBCC CHECKDB, 인덱스 재구성, 인덱스 재구축 및 통계 업데이트 작업을 실행하도록 SQL Server Agent 작업 예약</li>
<li>트랜잭션 로그 파일의 상태 및 크기 모니터링 및 관리</li>
</ul>
</section>
</section>
</section>
<section id="explain-high-availability-and-disaster-recovery-options" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="explain-high-availability-and-disaster-recovery-options"><span class="header-section-number">2</span> <a href="https://learn.microsoft.com/en-us/training/modules/deploy-iaas-solutions-with-azure-sql/5-explain-high-availability-and-disaster-recovery-options">Explain high availability and disaster recovery options</a></h2>
<p>Azure 플랫폼의 고가용성 옵션:</p>
<ol type="1">
<li>기본 제공 고가용성
<ul>
<li>VM과 PaaS 워크로드에 기본적으로 제공</li>
</ul></li>
<li>추가 고가용성 옵션
<ul>
<li>가용성 영역(Availability Zones)</li>
<li>가용성 집합(Availability Sets)</li>
</ul></li>
<li>주요 보호 기능
<ul>
<li>계획된 유지보수 활동으로부터 보호</li>
<li>잠재적인 하드웨어 장애로부터 보호</li>
<li>더 높은 수준의 가용성 제공</li>
</ul></li>
</ol>
<section id="high-availability-options" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="high-availability-options"><span class="header-section-number">2.1</span> High availability options</h3>
<p>SQL Server 고가용성 솔루션의 Azure VM 지원:</p>
<ul>
<li>Azure 전용 솔루션
<ul>
<li>전체 HADR 시스템이 Azure에서 실행</li>
<li>완전한 클라우드 기반 운영 가능</li>
</ul></li>
<li>하이브리드 구성
<ul>
<li>일부는 Azure에서 실행</li>
<li>일부는 온프레미스에서 실행</li>
<li>유연한 구성 가능</li>
</ul></li>
<li>Azure 환경의 장점
<ul>
<li>예산에 맞춘 단계적 마이그레이션 가능</li>
<li>HADR 요구사항에 따른 유연한 구성</li>
<li>부분 또는 완전 마이그레이션 선택 가능</li>
</ul></li>
</ul>
<section id="availability-zones" class="level4">
<h4 class="anchored" data-anchor-id="availability-zones">Availability Zones</h4>
<section id="가용성-영역-개요" class="level5">
<h5 class="anchored" data-anchor-id="가용성-영역-개요">가용성 영역 개요</h5>
<ul>
<li>한 지역 내의 고유한 물리적 위치</li>
<li>각 영역은 독립적인 전원, 냉각, 네트워킹을 갖춘 데이터센터로 구성</li>
<li>지원되는 Azure 지역마다 3개의 가용성 영역 제공</li>
</ul>
</section>
<section id="가용성-영역-특징" class="level5">
<h5 class="anchored" data-anchor-id="가용성-영역-특징">가용성 영역 특징</h5>
<ul>
<li>VM 생성 시 배치할 영역 지정 가능</li>
<li>여러 VM을 다른 영역에 분산 배포하여 데이터센터 장애 대비</li>
<li>Microsoft는 한 번에 하나의 영역만 업데이트 (업데이트 도메인 사용)</li>
<li>VM 에코시스템을 3개 영역에 분산 가능</li>
</ul>
</section>
<section id="가용성-영역-장점" class="level5">
<h5 class="anchored" data-anchor-id="가용성-영역-장점">가용성 영역 장점</h5>
<ul>
<li>가동 시간 99.99% 보장 (연간 최대 52.60분 다운타임)</li>
<li>애플리케이션에 가장 높은 수준의 가용성 제공</li>
<li>docs.microsoft.com에서 지원 지역 확인 가능</li>
</ul>
</section>
<section id="가용성-영역-배포" class="level5">
<h5 class="anchored" data-anchor-id="가용성-영역-배포">가용성 영역 배포</h5>
<ul>
<li>Zone 1, 2, 3 중 선택하여 배포 가능</li>
<li>물리적 데이터센터의 논리적 표현</li>
<li>구독별로 Zone 번호가 다른 데이터센터를 나타낼 수 있음</li>
</ul>
</section>
<section id="사용-조건" class="level5">
<h5 class="anchored" data-anchor-id="사용-조건">사용 조건</h5>
<ul>
<li>해당 지역에서 가용성 영역 지원 필요</li>
<li>애플리케이션이 최소한의 영역 간 지연 시간 지원 필요</li>
</ul>
</section>
</section>
<section id="availability-sets" class="level4">
<h4 class="anchored" data-anchor-id="availability-sets">Availability Sets</h4>
<section id="가용성-집합-개요" class="level5">
<h5 class="anchored" data-anchor-id="가용성-집합-개요">가용성 집합 개요</h5>
<ul>
<li>가용성 영역과의 차이점
<ul>
<li>가용성 영역: 지역의 데이터 센터에 워크로드 분산</li>
<li>가용성 집합: 데이터 센터 내의 서버와 랙에 워크로드 분산</li>
</ul></li>
</ul>
</section>
<section id="주요-특징" class="level5">
<h5 class="anchored" data-anchor-id="주요-특징">주요 특징</h5>
<ul>
<li>VM 분산 배치 보장
<ul>
<li>Always On 가용성 그룹 멤버 VM들이 서로 다른 물리적 호스트에서 실행되도록 보장</li>
<li>Azure의 대부분 워크로드가 가상화되어 있어 효과적</li>
</ul></li>
</ul>
</section>
<section id="성능-및-사용-조건" class="level5">
<h5 class="anchored" data-anchor-id="성능-및-사용-조건">성능 및 사용 조건</h5>
<ul>
<li>가용성 보장
<ul>
<li>최대 99.95%의 가용성 제공</li>
</ul></li>
<li>사용 시나리오
<ul>
<li>가용성 영역을 사용할 수 없는 지역</li>
<li>애플리케이션이 영역 내 지연 시간을 허용할 수 없는 경우</li>
</ul></li>
</ul>
</section>
</section>
<section id="always-on-availability-groups-ag" class="level4">
<h4 class="anchored" data-anchor-id="always-on-availability-groups-ag">Always On availability groups (AG)</h4>
<ul>
<li>구현 범위
<ul>
<li>Azure 가상 머신에서 실행되는 두 개 이상(최대 9개)의 SQL Server 인스턴스 간</li>
<li>온프레미스 데이터 센터와 Azure 간 구현 가능</li>
</ul></li>
<li>작동 방식
<ul>
<li>데이터베이스 트랜잭션이 기본 복제본에 커밋</li>
<li>동기식 또는 비동기식으로 모든 보조 복제본으로 전송</li>
</ul></li>
<li>가용성 모드 선택 기준
<ul>
<li>서버 간 물리적 거리에 따라 결정</li>
<li>비동기식 가용성 모드 권장 상황:
<ul>
<li>워크로드가 낮은 지연 시간 요구</li>
<li>보조 복제본이 지리적으로 분산된 경우</li>
</ul></li>
<li>동기식 커밋 모드 권장 상황:
<ul>
<li>복제본이 동일한 Azure 지역 내 위치</li>
<li>애플리케이션이 일정 수준의 지연 시간 허용 가능</li>
</ul></li>
</ul></li>
<li>동기식 모드 특징
<ul>
<li>각 트랜잭션이 하나 이상의 보조 복제본에 커밋된 후 애플리케이션 진행</li>
</ul></li>
<li>장점
<ul>
<li>단일 가용성 그룹이 동기식과 비동기식 가용성 모드 모두 지원</li>
<li>고가용성과 재해 복구 동시 제공</li>
<li>장애 조치 단위는 데이터베이스 그룹(전체 인스턴스가 아님)</li>
</ul></li>
<li>재해 복구 기능
<ul>
<li>Azure 지역 전체에 걸쳐 최대 9개의 데이터베이스 복제본 구현 가능</li>
<li>분산 가용성 그룹을 통한 아키텍처 확장 가능</li>
<li>기본 지역 외 다른 위치에 데이터베이스 실행 가능한 복사본 보장</li>
<li>자연 재해와 인위적 재해로부터 데이터 생태계 보호</li>
</ul></li>
<li>구성 예시
<ul>
<li>Windows Server 장애 조치 클러스터에서 실행</li>
<li>하나의 기본 복제본과 4개의 보조 복제본 구성 가능</li>
<li>모든 복제본이 동기식이거나, 동기식과 비동기식 복제본 조합 가능</li>
<li>장애 조치 단위는 데이터베이스 그룹(인스턴스가 아님)</li>
<li>장애 조치 클러스터 인스턴스는 인스턴스 수준 HA 제공(재해 복구는 제공하지 않음)</li>
</ul></li>
</ul>
</section>
<section id="sql-server-failover-cluster-instances" class="level4">
<h4 class="anchored" data-anchor-id="sql-server-failover-cluster-instances">SQL Server Failover Cluster instances</h4>
<ul>
<li>SQL Server 장애 조치 클러스터 인스턴스(FCI) 개요
<ul>
<li>전체 인스턴스 보호를 위한 솔루션</li>
<li>단일 지역에서 전체 인스턴스에 대한 고가용성 제공</li>
<li>단독으로는 재해 복구 기능 제공하지 않음
<ul>
<li>가용성 그룹이나 로그 전달과 같은 기능과 결합 필요</li>
</ul></li>
<li>공유 스토리지 요구사항 존재
<ul>
<li>Azure에서 공유 파일 스토리지 사용 가능</li>
<li>Windows Server의 Storage Spaces Direct 활용 가능</li>
</ul></li>
</ul></li>
<li>Azure 환경에서의 FCI 고려사항
<ul>
<li>새로운 배포에서는 가용성 그룹이 선호됨
<ul>
<li>FCI의 공유 스토리지 요구사항이 배포 복잡성 증가</li>
</ul></li>
<li>온프레미스 솔루션 마이그레이션 시 FCI 필요 가능성
<ul>
<li>기존 애플리케이션 지원을 위한 요구사항 고려</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="disaster-recovery-options" class="level4">
<h4 class="anchored" data-anchor-id="disaster-recovery-options">Disaster Recovery options</h4>
<ul>
<li>Azure 플랫폼 기본 특성
<ul>
<li>기본적으로 99.9%의 가동 시간 제공</li>
<li>재해 발생 가능성 여전히 존재</li>
<li>애플리케이션 가동 시간에 영향을 미칠 수 있음</li>
</ul></li>
<li>재해 복구 계획의 중요성
<ul>
<li>마이그레이션 수행 시 적절한 계획 수립 필요</li>
<li>데이터 및 서비스 연속성 보장</li>
</ul></li>
<li>Azure의 SQL Server 보호 방법 (두 가지 구성 요소)
<ul>
<li>Azure 플랫폼 옵션
<ul>
<li>지역 복제 스토리지 (백업용)</li>
<li>Azure Site Recovery (포괄적인 재해 복구 솔루션)</li>
</ul></li>
<li>SQL Server 전용 기능
<ul>
<li>가용성 그룹(Availability Groups)</li>
<li>네이티브 백업 기능</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="native-sql-server-backups" class="level4">
<h4 class="anchored" data-anchor-id="native-sql-server-backups">Native SQL Server backups</h4>
<ul>
<li>백업의 중요성
<ul>
<li>모든 데이터베이스 관리자에게 있어 생명줄과 같은 역할</li>
<li>클라우드 솔루션에서도 동일하게 중요</li>
</ul></li>
<li>Azure VM의 SQL Server 백업 특징
<ul>
<li>백업 시기와 저장 위치에 대한 세밀한 제어 가능</li>
<li>SQL 에이전트 작업을 통한 Azure blob 스토리지 직접 백업 지원</li>
<li>URL을 통한 백업 연결 방식 제공</li>
</ul></li>
<li>Azure 스토리지 옵션
<ul>
<li>지역 중복 스토리지(GRS) 제공</li>
<li>읽기 액세스 지역 중복 스토리지(RA-GRS) 제공</li>
<li>지리적으로 분산된 환경에서 백업 파일 안전 보장</li>
</ul></li>
<li>자동화 옵션
<ul>
<li>Azure SQL VM 서비스 제공자를 통한 자동 백업 관리 가능</li>
<li>플랫폼 수준의 백업 자동화 지원</li>
</ul></li>
</ul>
</section>
<section id="azure-backup-for-sql-server" class="level4">
<h4 class="anchored" data-anchor-id="azure-backup-for-sql-server">Azure Backup for SQL Server</h4>
<ul>
<li>기본 구성 요소
<ul>
<li>가상 머신에 에이전트 설치 필요</li>
<li>SQL Server 데이터베이스의 자동 백업 관리</li>
<li>Azure 서비스와 에이전트 간 통신</li>
</ul></li>
<li>주요 기능
<ul>
<li>지정된 RPO/RTO 메트릭 충족 관리</li>
<li>백업 모니터링을 위한 중앙 집중식 인터페이스 제공</li>
<li>장기 데이터 보존 지원</li>
<li>자동화된 백업 관리 기능</li>
<li>추가적인 데이터 보호 기능</li>
</ul></li>
<li>비용 및 가치
<ul>
<li>직접 백업보다 높은 비용</li>
<li>SQL Server용 Azure 리소스 공급자보다 비용 증가</li>
<li>더 포괄적인 엔터프라이즈 백업 솔루션 제공</li>
<li>완벽한 백업 기능 세트 제공</li>
</ul></li>
</ul>
</section>
<section id="azure-site-recovery" class="level4">
<h4 class="anchored" data-anchor-id="azure-site-recovery">Azure Site Recovery</h4>
<ul>
<li>개요
<ul>
<li>Azure 가상 머신의 블록 수준 복제를 수행하는 저비용 솔루션</li>
<li>재해 복구 전략을 테스트하고 검증할 수 있는 다양한 기능 제공</li>
</ul></li>
<li>적합한 사용 환경
<ul>
<li>상태가 없는 환경(예: 웹 서버)에 가장 적합</li>
<li>트랜잭션 데이터베이스 가상 머신에는 덜 적합</li>
</ul></li>
<li>SQL Server와 함께 사용 시 고려사항
<ul>
<li>더 높은 복구 지점 설정 필요 (잠재적 데이터 손실 의미)</li>
<li>RTO(복구 시간 목표)가 본질적으로 RPO(복구 지점 목표)가 됨</li>
</ul></li>
<li>작동 프로세스
<ul>
<li>VM이 Azure Site Recovery에 등록</li>
<li>데이터가 캐시로 지속적으로 복제</li>
<li>캐시가 대상 스토리지 계정으로 복제</li>
<li>장애 조치(failover) 중에 가상 머신이 대상 환경에 추가</li>
</ul></li>
</ul>


</section>
</section>
</section>

 ]]></description>
  <category>Engineering</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Engineering/data_engineering/2.IaaS.html</guid>
  <pubDate>Wed, 02 Apr 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Azure 가상 머신의 SQL Server</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Engineering/data_engineering/1.azure_server_based_db_management.html</link>
  <description><![CDATA[ 




<section id="microsoft-intelligent-data-platform-역할-설명" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="microsoft-intelligent-data-platform-역할-설명"><span class="header-section-number">1</span> <a href="https://learn.microsoft.com/ko-kr/training/modules/prepare-to-maintain-sql-databases-azure/2-describe-azure-data-platform-roles">Microsoft Intelligent Data Platform 역할 설명</a></h2>
<p>Microsoft는 클라우드(Microsoft Intelligent Data Platform 서비스 활용) 데이터 관련 업무를 위한 5가지 주요 역할을 정의하고 있다:</p>
<ol type="1">
<li>Azure 데이터베이스 관리자
<ul>
<li>Azure 데이터 서비스와 SQL Server 기반 데이터 플랫폼 솔루션 관리 (데이터 관리, 모니터링, 보안 및 개인정보 보호 설계)</li>
<li>T-SQL을 활용한 일상적인 운영 및 관리 작업 수행</li>
</ul></li>
<li>Azure 데이터 분석가
<ul>
<li>Microsoft Power BI를 사용</li>
<li>확장 가능한 데이터 모델을 설계 및 구축하고, 데이터를 정리 및 변환하며, 이해하기 쉬운 데이터 시각화</li>
</ul></li>
<li>Azure 데이터 분석가
<ul>
<li>Power BI를 활용한 데이터 모델링 및 시각화</li>
<li>데이터 정제/변환을 통한 비즈니스 인사이트 도출</li>
</ul></li>
<li>Azure 데이터 과학자
<ul>
<li>Azure Machine Learning 기반 ML 워크로드 구현</li>
<li>데이터 과학/머신러닝 지식 활용</li>
</ul></li>
<li>Azure 인공지능 엔지니어
<ul>
<li>Cognitive Services, ML, Knowledge Mining 활용</li>
<li>자연어처리, 음성, 컴퓨터 비전, 봇 등 AI 솔루션 구현</li>
</ul></li>
</ol>
</section>
<section id="azure-vm의-sql-server" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="azure-vm의-sql-server"><span class="header-section-number">2</span> <a href="https://learn.microsoft.com/ko-kr/training/modules/prepare-to-maintain-sql-databases-azure/3-understand-sql-server-azure-virtual-machine">Azure VM의 SQL Server</a></h2>
<section id="azure-가상-머신의-sql-server-특징-백업-고가용성" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="azure-가상-머신의-sql-server-특징-백업-고가용성"><span class="header-section-number">2.1</span> Azure 가상 머신의 SQL Server: 특징, 백업, 고가용성</h3>
<ul>
<li>Azure 가상 머신에서 실행되는 SQL Server(IaaS)는 온프레미스 SQL Server와 동등</li>
<li>가상 머신에서 SQL Server를 선택하는 주요 이유:</li>
</ul>
<ol type="1">
<li><strong>애플리케이션 호환성</strong>: 특정 버전의 SQL Server가 필요하거나 PaaS와 호환되지 않는 설치 요구사항이 있는 경우</li>
<li><strong>다양한 SQL Server 서비스 활용</strong>: SQL Server Analysis Services(SSAS), Integration Services(SSIS), Reporting Services(SSRS)를 데이터베이스 엔진과 함께 실행할 수 있음</li>
</ol>
</section>
<section id="백업-솔루션" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="백업-솔루션"><span class="header-section-number">2.2</span> 백업 솔루션</h3>
<p>최근 SQL Server 릴리스에서는 다음 두 가지 주요 백업 기능을 제공: - <strong>URL로 백업</strong>: Azure Blob Storage 서비스에 데이터베이스를 백업 * Azure Blob Storage란? * Blob (Binary Large Object): 이미지, 오디오, 비디오, 문서 등과 같은 대용량 비정형 데이터를 저장하는 데 사용되는 데이터 형식 * Azure의 클라우드 기반 스토리지 서비스 * 비교적 저렴한 비용으로 높은 가용성, 내구성, 확장성을 제공 * 데이터 암호화, 보안, 백업 등 다양한 기능 제공 * <strong>Azure Backup</strong>: SQL Server VM을 위한 포괄적인 엔터프라이즈 백업 솔루션</p>
</section>
<section id="배포-옵션" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="배포-옵션"><span class="header-section-number">2.3</span> 배포 옵션</h3>
<ul>
<li>Azure의 모든 리소스는 Azure Resource Manager를 통해 관리되고 배포</li>
<li>최종적으로 JSON 문서인 Azure Resource Manager 템플릿으로 변환됨</li>
<li>대규모 배포에는 선언적 접근 방식이 권장됨</li>
</ul>
</section>
<section id="azure-스토리지-개요" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="azure-스토리지-개요"><span class="header-section-number">2.4</span> Azure 스토리지 개요</h3>
<p>SQL Server 운영 환경에서는 다음 4가지 스토리지 유형 제공:</p>
<ul>
<li><strong>Standard HDD</strong>: 비용 절감을 위해 사용, 데이터베이스 백업에는 표준 스토리지를 사용</li>
<li><strong>Standard SSD</strong>: 비교적 빠른 속도와 비교적 저렴한 비용</li>
<li><strong>Premium SSD</strong>: 5-10ms 지연 시간</li>
<li><strong>Ultra Disk</strong>: 1-2ms 지연 시간(최적화 시 1ms 미만 가능)</li>
</ul>
</section>
<section id="azure의-high-availability" class="level3" data-number="2.5">
<h3 data-number="2.5" class="anchored" data-anchor-id="azure의-high-availability"><span class="header-section-number">2.5</span> Azure의 High Availability</h3>
<ul>
<li>Azure 플랫폼은 fault tolerance을 갖추고 있으며 서비스 중단과 일시적 오류로부터 빠르게 복구됨</li>
<li>Premium SSD 또는 Ultra Disk를 사용하는 단일 인스턴스 Azure 가상 머신의 경우 최소 99.9%(1년의 0.01%인 약 9시간 정도의 가동 중단 리스크)의 가동 시간을 보장</li>
<li>가용성 집합, 가용성 영역, 부하 분산 기술을 통해 high availability을 제공</li>
</ul>
</section>
<section id="azure-arc-지원-sql-server" class="level3" data-number="2.6">
<h3 data-number="2.6" class="anchored" data-anchor-id="azure-arc-지원-sql-server"><span class="header-section-number">2.6</span> Azure Arc 지원 SQL Server</h3>
<ul>
<li>Azure Arc는 Azure 관리 기능을 온프레미스, 다른 클라우드 또는 엣지에서 실행되는 SQL Server 인스턴스로 확장</li>
<li>Azure Arc를 통해 기존 SQL Server를 Azure로 이전하지 않고도 일관된 정책 적용, 규정 준수, Azure Monitor 및 Security Center 활용이 가능</li>
<li>중앙 집중식 관리, 자동 업데이트, 백업 및 복원, 재해 복구와 같은 고급 기능을 활용할 수 있으며, Azure의 머신러닝과 AI 기능도 기존 데이터에 적용 가능</li>
</ul>
</section>
</section>
<section id="클라우드-기반-azure-sql-database-설계" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="클라우드-기반-azure-sql-database-설계"><span class="header-section-number">3</span> <a href="https://learn.microsoft.com/ko-kr/training/modules/prepare-to-maintain-sql-databases-azure/4-design-azure-sql-database-for-cloud-native-applications">클라우드 기반 Azure SQL Database 설계</a></h2>
<p>Azure SQL Database는 PaaS(Platform as a Service) 형태로 제공되는 고확장성 데이터베이스 서비스로, 최소한의 유지 관리로 특정 워크로드에 최적화되어 있다. 개발자에게 유연성과 세분화된 배포 옵션을 제공하여 새로운 애플리케이션 개발에 적합하다.</p>
<section id="구매-모델" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="구매-모델"><span class="header-section-number">3.1</span> 구매 모델</h3>
<section id="vcore-기반-모델" class="level4">
<h4 class="anchored" data-anchor-id="vcore-기반-모델">1. vCore 기반 모델</h4>
<ul>
<li>컴퓨팅과 스토리지 리소스를 독립적으로 확장 가능</li>
<li>서비스 Tier:
<ul>
<li><strong>범용(General Purpose)</strong>: 덜 집약적인 작업용, 프로비저닝 및 서버리스 컴퓨팅 계층 제공</li>
<li><strong>비즈니스 크리티컬(Business Critical)</strong>: In-Memory OLTP, 읽기 전용 복제본, 로컬 SSD 지원
<ul>
<li>OLTP: In-Memory OLTP(Online Transaction Processing)는 Microsoft SQL Server에서 제공하는 메모리 최적화 기술</li>
<li>이 기술은 데이터베이스 테이블과 저장 프로시저를 메인 메모리(RAM)에 저장하여 디스크 I/O 작업을 최소화함으로써 트랜잭션 처리 성능을 크게 향상</li>
<li>주요 특징
<ul>
<li>데이터를 디스크가 아닌 메모리에 저장하여 액세스 속도 향상</li>
<li>락(lock)이나 래치(latch) 없는 동시성 제어 메커니즘으로 경합 감소</li>
<li>높은 처리량과 낮은 지연 시간이 필요한 트랜잭션 중심 애플리케이션에 적합</li>
</ul></li>
</ul></li>
<li><strong>하이퍼스케일(Hyperscale)</strong>: 수평적 확장 기능, 대규모 데이터 처리에 적합</li>
</ul></li>
</ul>
</section>
<section id="dtu-기반-모델" class="level4">
<h4 class="anchored" data-anchor-id="dtu-기반-모델">2. DTU 기반 모델</h4>
<ul>
<li>컴퓨팅과 스토리지가 DTU 수준에 종속
<ul>
<li>DTU(Database Transaction Unit): Azure SQL Database에서 사용하는 성능 측정 단위</li>
<li>Microsoft가 개발한 이 단위는 CPU, 메모리, 데이터 I/O 및 트랜잭션 로그 I/O의 혼합된 측정값으로, 데이터베이스 성능을 단일 값으로 표현</li>
<li>DTU 기반 구매 모델에서는 데이터베이스에 특정 DTU 레벨을 할당하며, 이 레벨은 해당 데이터베이스가 사용할 수 있는 컴퓨팅 및 스토리지 리소스의 양을 결정 (DTU 계층에 따라 성능과 비용이 증가)</li>
<li>이 모델은 vCore 모델과 달리 컴퓨팅과 스토리지가 함께 묶여 있어, 스토리지만 늘리고 싶어도 DTU 수준을 전체적으로 올려야 하는 단점이 있다.</li>
</ul></li>
<li>Basic, Standard, and Premium 세 가지 서비스 tier 제공</li>
<li>스토리지 한도 도달 시 컴퓨팅 사용률과 무관하게 DTU 증가 필요</li>
</ul>
</section>
</section>
<section id="서버리스-컴퓨팅" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="서버리스-컴퓨팅"><span class="header-section-number">3.2</span> 서버리스 컴퓨팅</h3>
<ul>
<li>자동 확장 및 일시 중지 기능을 제공하여 개발/테스트 환경의 비용 절감에 효과적</li>
<li>워크로드에 따라 동적으로 확장되며 비활성 상태일 때는 자동으로 일시 중지되어 스토리지 비용만 발생</li>
</ul>
</section>
<section id="배포-모델" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="배포-모델"><span class="header-section-number">3.3</span> 배포 모델</h3>
<section id="단일-데이터베이스" class="level4">
<h4 class="anchored" data-anchor-id="단일-데이터베이스">1.단일 데이터베이스</h4>
<ul>
<li>각 데이터베이스를 개별적으로 관리</li>
<li>동일 서버에 배포되어도 각 데이터베이스는 전용 리소스 보유</li>
<li>Azure 포털을 통한 리소스 모니터링 가능</li>
</ul>
</section>
<section id="탄력적-풀" class="level4">
<h4 class="anchored" data-anchor-id="탄력적-풀">2.탄력적 풀</h4>
<ul>
<li>여러 데이터베이스가 리소스를 공유하는 모델</li>
<li>개별 데이터베이스 스케일링이 불필요해 관리 용이</li>
<li>SaaS 애플리케이션에 비용 효율적</li>
<li>사용률이 낮은 멀티테넌트 환경에 적합</li>
</ul>
</section>
</section>
<section id="주요-기능" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="주요-기능"><span class="header-section-number">3.4</span> 주요 기능</h3>
<section id="네트워크-옵션" class="level4">
<h4 class="anchored" data-anchor-id="네트워크-옵션">네트워크 옵션</h4>
<p>방화벽 규칙, 가상 네트워크 엔드포인트, Private Link 등으로 액세스 제어가 가능</p>
</section>
<section id="백업-및-복원" class="level4">
<h4 class="anchored" data-anchor-id="백업-및-복원">백업 및 복원</h4>
<p>Azure는 SQL Database 및 SQL Managed Instance에 대한 원활한 백업 및 복원 기능을 제공</p>
<ul>
<li><strong>지속적 백업(seamless backup)</strong>: 정기적인 백업과 지역 중복 스토리지, 전체 백업은 매주 수행되고, 차등 백업은 12~24시간마다 수행되며, 트랜잭션 로그 백업은 5~10분마다 수행됨</li>
<li><strong>지역 복원(geo-restore)</strong>: 다른 지리적 지역으로 복원 가능, 덜 엄격한 재해 복구 시나리오에 특히 유용</li>
<li><strong>시점 복원(PITR, point-in-time restore)</strong>: 특정 시점 복원 가능, 1-35일 보존 기간 설정 가능, 실제로 지정하지 않으면 기본 구성은 7일</li>
<li><strong>장기 보존(LTR, long-term retention)</strong>: 최대 10년까지 보존 정책 설정, 이 옵션은 기본적으로 사용하지 않도록 설정</li>
</ul>
</section>
<section id="자동-튜닝" class="level4">
<h4 class="anchored" data-anchor-id="자동-튜닝">자동 튜닝</h4>
<p>머신러닝 기반으로 쿼리 성능을 자동 최적화 - 비용 많은 쿼리 식별 - 실행 계획 최적화 - 인덱스 추가/제거 기능</p>
</section>
<section id="탄력적-쿼리-및-작업" class="level4">
<h4 class="anchored" data-anchor-id="탄력적-쿼리-및-작업">탄력적 쿼리 및 작업</h4>
<ul>
<li>여러 데이터베이스에 걸친 쿼리 실행과 유지 관리 작업 자동화를 지원</li>
<li>여러 데이터베이스를 연결하는 T-SQL 쿼리를 실행 가능하고 이 기능은 변경할 수 없는 세 부분 및 네 부분으로 된 이름을 사용하는 애플리케이션에 유용</li>
<li>마이그레이션을 허용하기 때문에 이식성이 향상</li>
<li>다음 분할 전략을 지원
<ul>
<li>수직 분할: 데이터베이스 간 쿼리라고도 합니다. 데이터는 여러 데이터베이스 간에 세로로 분할 (컬럼 단위 분할도 가능).</li>
<li>가로 분할: 데이터는 여러 확장된 데이터베이스에 행을 분산하기 위해 수평(행또는 record 단위)으로 분할</li>
</ul></li>
</ul>
</section>
<section id="microsoft-fabric-통합" class="level4">
<h4 class="anchored" data-anchor-id="microsoft-fabric-통합">Microsoft Fabric 통합</h4>
<ul>
<li>Microsoft 생태계와 완벽하게 통합되어 데이터 워크플로 간소화, 협업 강화, 고급 분석 지원 등의 이점을 제공</li>
<li>Microsoft Fabric은 모든 데이터 및 분석 요구 사항을 위한 통합 플랫폼
<ul>
<li>Microsoft의 SaaS(Software as a Service) 분석 제품군</li>
<li>Power BI, Azure Synapse Analytics, Azure Data Factory 등의 Microsoft 서비스를 하나의 통합된 환경으로 결합</li>
</ul></li>
<li>주요 특징:
<ul>
<li>데이터 수집, 처리, 저장, 분석, 시각화를 위한 end-to-end 솔루션</li>
<li>공통 데이터 저장소인 OneLake를 중심으로 구축</li>
<li>다양한 워크로드 지원: 데이터 엔지니어링, 데이터 과학, 실시간 분석, BI 등</li>
<li>통합된 거버넌스 및 보안 모델</li>
<li>Microsoft 365와 긴밀한 통합</li>
<li>Fabric은 SQL Database와 같은 여러 데이터 서비스를 통합하여 조직이 데이터 사일로를 제거하고 더 효율적으로 데이터를 활용하도록 지원</li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="azure-sql-managed-instance" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="azure-sql-managed-instance"><span class="header-section-number">4</span> <a href="https://learn.microsoft.com/ko-kr/training/modules/prepare-to-maintain-sql-databases-azure/5-explore-azure-sql-database-managed-instance">Azure SQL Managed Instance</a></h2>
<p>Azure SQL Managed Instance는 Azure SQL Database와 많은 공통 코드를 공유하는 완전 관리형 PaaS 솔루션으로 SQL Server 잘 작동하는 완전 관리형 데이터베이스 서비스</p>
<section id="주요-이점" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="주요-이점"><span class="header-section-number">4.1</span> 주요 이점</h3>
<ul>
<li>자동 백업 및 패치</li>
<li>기본 제공 고가용성(99.99% 가동시간 보장, 년간 52분 가동 중단 시간 허용 리스크)</li>
<li>보안 및 성능 도구</li>
<li>통합 감사 기능</li>
<li>SQL Server 설치 및 패치 불필요로 유지 관리 감소</li>
</ul>
</section>
<section id="sql-database와의-차별점" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="sql-database와의-차별점"><span class="header-section-number">4.2</span> SQL Database와의 차별점</h3>
<p>SQL Database가 단일 데이터베이스 중심인 반면, SQL Managed Instance는 다음을 지원: - 데이터베이스 간 쿼리 - CLR(Common Language Runtime, 공통 언어 런타임) - 다양한 .NET 언어(C#, Visual Basic .NET 등)로 작성된 코드를 SQL Server 내에서 실행 가능 - 스토어드 프로시저, 트리거, 사용자 정의 함수, 사용자 정의 형식, 사용자 정의 집계 등을 .NET 언어로 작성 가능 - T-SQL로 구현하기 어려운 복잡한 비즈니스 로직, 문자열 처리, 수학 계산 등을 효율적으로 처리 가능 - T-SQL(Transact-SQL): Microsoft SQL Server에서 사용되는, SQL(Structured Query Language)의 확장 버전 - 외부 리소스(파일 시스템, 네트워크 등)에 접근하는 코드 실행 가능 - 시스템 데이터베이스 액세스 - SQL 에이전트 기능 - Microsoft SQL Server의 작업 자동화 서비스 - 작업 예약, 작업 모니터링, 작업 로깅 등 다양한 기능 제공</p>
</section>
<section id="하이브리드-라이선스-옵션" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="하이브리드-라이선스-옵션"><span class="header-section-number">4.3</span> 하이브리드 라이선스 옵션</h3>
<ul>
<li>Active Software Assurance가 있는 기존 라이선스를 활용해 PaaS(SQL Database 및 SQL Managed Instance) 비용 절감(최대 40%)
<ul>
<li>Enterprise Edition: 코어당 비즈니스 크리티컬 vCore 1개 또는 범용 vCore 8개</li>
<li>Standard Edition: 코어당 범용 vCore 1개</li>
</ul></li>
</ul>
</section>
<section id="connectivity-architecture" class="level3" data-number="4.4">
<h3 data-number="4.4" class="anchored" data-anchor-id="connectivity-architecture"><span class="header-section-number">4.4</span> Connectivity Architecture</h3>
<ul>
<li>SQL Managed Instance에 대한 연결은 TDS 엔드포인트를 통한 연결
<ul>
<li>TDS(Tabular Data Stream)는 Microsoft SQL Server 및 Sybase에서 클라이언트와 데이터베이스 서버 간의 통신에 사용되는 네트워크 프로토콜</li>
</ul></li>
<li>고가용성 방식으로 배포된 게이트웨이 구성 요소</li>
<li>자동화된 백업(지역 중복 및 자동 복제)</li>
<li>자동 장애 조치 그룹 지원</li>
</ul>
</section>
<section id="migration-options" class="level3" data-number="4.5">
<h3 data-number="4.5" class="anchored" data-anchor-id="migration-options"><span class="header-section-number">4.5</span> Migration Options</h3>
<ol type="1">
<li><strong>Log 재생 서비스</strong>: 온라인 마이그레이션, 세부 제어 가능</li>
<li><strong>Azure Data Studio 확장</strong>: 준비 상태 평가, 리소스 추천, 중소규모 DB에 적합</li>
<li><strong>Managed Instance 링크</strong>: 분산 가용성 그룹 사용, 즉시 데이터 복제</li>
<li><strong>네이티브 백업 및 복원</strong>: 간단한 마이그레이션 방법</li>
<li><strong>트랜잭션 복제</strong>: 대규모 DB의 온/오프라인 마이그레이션에 적합</li>
</ol>
</section>
<section id="machine-learning-services" class="level3" data-number="4.6">
<h3 data-number="4.6" class="anchored" data-anchor-id="machine-learning-services"><span class="header-section-number">4.6</span> Machine Learning Services</h3>
<ul>
<li>Python 및 R 패키지 지원</li>
<li>데이터 이동 없이 기계 학습 모델 학습 및 배포</li>
<li>T-SQL 저장 프로시저를 통한 모델 배포</li>
<li>scikit-learn, PyTorch, TensorFlow 등 오픈소스 라이브러리 지원</li>
<li>T-SQL PREDICT 함수로 예측 가속화</li>
<li><code>sp_configure 'external scripts enabled', 1;</code> 명령으로 활성화</li>
</ul>


</section>
</section>

 ]]></description>
  <category>Engineering</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Engineering/data_engineering/1.azure_server_based_db_management.html</guid>
  <pubDate>Tue, 01 Apr 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Azure SQL Database 관리</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Engineering/data_engineering/0.azure_dba_intro.html</link>
  <description><![CDATA[ 




<section id="한눈에-보기" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 한눈에 보기</h1>
<ul>
<li>관련 서비스: Azure SQL Database, Azure SQL Managed Instance, Azure Virtual Machines의 SQL Server</li>
<li>역할: 데이터 분석가, 데이터 엔지니어, 데이터베이스 관리자</li>
<li>주제: 데이터베이스 관리</li>
</ul>
<section id="데이터베이스와-관리-시스템의-이해" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="데이터베이스와-관리-시스템의-이해"><span class="header-section-number">1.1</span> 데이터베이스와 관리 시스템의 이해</h2>
<section id="데이터베이스의-기본-개념" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="데이터베이스의-기본-개념"><span class="header-section-number">1.1.1</span> 데이터베이스의 기본 개념</h3>
<p>데이터베이스는 데이터를 체계적으로 저장하고 관리하는 시스템이다. 데이터의 저장, 검색, 갱신을 효율적으로 수행할 수 있는 기능을 제공한다.</p>
</section>
<section id="데이터베이스-관리-시스템dbms" class="level3" data-number="1.1.2">
<h3 data-number="1.1.2" class="anchored" data-anchor-id="데이터베이스-관리-시스템dbms"><span class="header-section-number">1.1.2</span> 데이터베이스 관리 시스템(DBMS)</h3>
<p>DBMS(Database Management System)는 데이터베이스를 운영하고 관리하는 소프트웨어 시스템으로, 다음과 같은 핵심 기능을 제공한다:</p>
<ul>
<li>데이터베이스 생성 및 스키마 관리</li>
<li>데이터 입력, 수정, 삭제 기능</li>
<li>데이터 무결성 유지</li>
<li>보안 및 접근 제어</li>
</ul>
</section>
<section id="데이터베이스-관리자dba의-역할" class="level3" data-number="1.1.3">
<h3 data-number="1.1.3" class="anchored" data-anchor-id="데이터베이스-관리자dba의-역할"><span class="header-section-number">1.1.3</span> 데이터베이스 관리자(DBA)의 역할</h3>
<p>DBA(Database Administrator)는 데이터베이스의 전반적인 운영을 책임지는 전문가로서 다음과 같은 업무를 하는 사람이다:</p>
<ul>
<li>데이터베이스 설계 및 구현</li>
<li>성능 최적화 및 모니터링</li>
<li>보안 관리 및 백업/복구</li>
<li>사용자 권한 관리</li>
</ul>
</section>
</section>
<section id="azure-클라우드-환경에서의-데이터베이스-관리" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="azure-클라우드-환경에서의-데이터베이스-관리"><span class="header-section-number">1.2</span> Azure 클라우드 환경에서의 데이터베이스 관리</h2>
<section id="azure-데이터베이스-서비스의-중요성" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="azure-데이터베이스-서비스의-중요성"><span class="header-section-number">1.2.1</span> Azure 데이터베이스 서비스의 중요성</h3>
<ul>
<li>현대 비즈니스 운영에서 클라우드 플랫폼 활용은 필수적</li>
<li>Azure는 안정적이고 확장 가능한 데이터베이스 서비스 제공</li>
<li>Microsoft와의 협업을 통한 지속적인 서비스 개선</li>
</ul>
</section>
<section id="azure-서비스-모델" class="level3" data-number="1.2.2">
<h3 data-number="1.2.2" class="anchored" data-anchor-id="azure-서비스-모델"><span class="header-section-number">1.2.2</span> Azure 서비스 모델</h3>
<p>Azure는 세 가지 주요 서비스 모델을 제공한다:</p>
<ol type="1">
<li>Infrastructure as a Service (IaaS)
<ul>
<li>가상 머신, 스토리지, 네트워킹 제공</li>
<li>사용자가 직접 패치 및 소프트웨어 관리</li>
<li>높은 수준의 커스터마이징 가능</li>
</ul></li>
<li>Platform as a Service (PaaS)
<ul>
<li>클라우드 제공업체가 더 많은 관리 작업 담당</li>
<li>사용자는 애플리케이션과 데이터에 집중 가능</li>
<li>관리 부담 감소</li>
</ul></li>
<li>Software as a Service (SaaS)
<ul>
<li>완전히 관리되는 소프트웨어 애플리케이션 제공</li>
<li>사용자는 서비스만 이용</li>
<li>설치, 유지보수, 업그레이드가 모두 자동화</li>
</ul></li>
</ol>


</section>
</section>
</section>

 ]]></description>
  <category>Engineering</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Engineering/data_engineering/0.azure_dba_intro.html</guid>
  <pubDate>Mon, 31 Mar 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>텍스트 벡터화: 신경망 기반 방법론</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Deep_Learning/NLP/4-2.pre_prcs_vectorization.html</link>
  <description><![CDATA[ 




<section id="요약" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 요약</h1>
<p>이 문서는 통계 기반 벡터화의 한계를 넘어 텍스트 데이터로부터 풍부한 의미론적, 문맥적 정보를 추출하는 신경망 기반 벡터화 방법론을 소개한다.</p>
<ul>
<li><strong>DTM 방식의 한계와 신경망 접근법의 등장</strong>:
<ul>
<li>전통적인 DTM(문서-단어 행렬) 방식의 문제점(차원의 저주, 희소성, 의미 관계 표현 불가)을 지적하고, 이를 극복하기 위한 신경망 기반 밀집 벡터 표현(워드 임베딩)의 필요성을 설명한다.</li>
</ul></li>
<li><strong>워드 임베딩 (Word Embedding) - 정적 임베딩</strong>:
<ul>
<li><strong>핵심 원리</strong>: “같은 문맥에 나타나는 단어는 비슷한 의미를 가진다”는 분포 가설에 기반하여 단어를 저차원 밀집 벡터로 표현한다.</li>
<li><strong>Embedding Layer</strong>: 정수 인코딩된 단어를 밀집 벡터로 변환하는 신경망의 핵심 구성 요소로, 그 구조와 Look-up Table 방식을 설명한다.</li>
<li><strong>주요 모델</strong>:
<ul>
<li><strong>Word2Vec (CBOW, Skip-gram)</strong>: 주변 단어로 중심 단어를 예측(CBOW)하거나 중심 단어로 주변 단어를 예측(Skip-gram)하며 벡터를 학습한다.</li>
<li><strong>GloVe</strong>: 전체 단어 동시 등장 통계 정보를 직접 활용하여 벡터를 학습한다.</li>
<li><strong>FastText</strong>: 단어를 문자 n-gram으로 분해하여 벡터를 학습함으로써 OOV(Out-of-Vocabulary) 문제에 강직한 형태론적 특징을 포착한다.</li>
</ul></li>
</ul></li>
<li><strong>실용적 응용 및 평가</strong>:
<ul>
<li>임베딩 모델의 성능을 평가하는 내재적 평가(단어 유사도, 관계 유추)와 외재적 평가(다운스트림 태스크 성능) 방법을 소개한다.</li>
</ul></li>
<li><strong>결론</strong>: 신경망 기반 벡터화 기법들의 발전 과정과 그 의의를 요약한다.</li>
</ul>
</section>
<section id="텍스트-인코딩-및-벡터화" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 텍스트 인코딩 및 벡터화</h1>
<pre><code>텍스트 벡터화
├── 전통적 방법 (통계 기반)
│   ├── DTM (Document Term Matrix)
│   ├── BoW (Bag of Words)  
│   └── TF-IDF
└── 신경망 기반 방법
    ├── Embedding Layer (핵심 구성 요소)
    └── 구체적 모델들
        ├── Word2Vec (CBOW, Skip-gram)
        ├── GloVe
        ├── FastText
        └── 문맥 기반 모델 (BERT, GPT 등)</code></pre>
<section id="신경망-사용-20082018" class="level3" data-number="2.0.1">
<h3 data-number="2.0.1" class="anchored" data-anchor-id="신경망-사용-20082018"><span class="header-section-number">2.0.1</span> 신경망 사용 (2008~2018)</h3>
</section>
<section id="dtm-방식의-한계와-신경망-접근법의-등장" class="level3" data-number="2.0.2">
<h3 data-number="2.0.2" class="anchored" data-anchor-id="dtm-방식의-한계와-신경망-접근법의-등장"><span class="header-section-number">2.0.2</span> DTM 방식의 한계와 신경망 접근법의 등장</h3>
<p><strong>DTM 방식의 문제점:</strong> - <strong>차원의 저주</strong>: 어휘집 크기 = 벡터 차원 (예: 50,000개 단어 → 50,000차원) - <strong>희소성</strong>: 대부분의 값이 0인 sparse vector - <strong>의미적 관계 부재</strong>: “왕”과 “여왕”의 관계를 벡터가 표현하지 못함 - <strong>문제 상황:</strong></p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 기존 방식 (원-핫 인코딩)</span></span>
<span id="cb2-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"사과"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, ...]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 50,000차원 벡터</span></span>
<span id="cb2-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"바나나"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, ...]</span>
<span id="cb2-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"과일"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, ...]</span></code></pre></div>
<ul>
<li>모든 단어가 서로 똑같이 멀어 보임 (유클리드 거리 = √2)</li>
<li>“사과”와 “바나나”가 비슷한 과일이라는 정보가 없음</li>
<li>메모리 낭비 (대부분이 0)</li>
</ul>
<p><strong>신경망 접근법의 혁신:</strong> - <strong>밀집 벡터(Dense Vector)</strong>: 고정된 낮은 차원 (예: 300차원)에 0/1 값이 아닌 실수 값을 가짐. - <strong>의미적 유사도</strong>: 벡터 간 거리로 단어 유사도 측정 가능 - <strong>문맥 학습</strong>: 주변 단어들을 통해 의미 학습</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 신경망 모델: 워드 임베딩 (300차원)</span></span>
<span id="cb3-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"사과"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, ...]     <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 300개 실수</span></span>
<span id="cb3-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"바나나"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, ...]   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 비슷한 값들</span></span>
<span id="cb3-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"과일"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.25</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.45</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.65</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.15</span>, ...] <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 과일 카테고리</span></span></code></pre></div>
<ul>
<li>문맥 고려 방법 (Neural / Context-dependent)</li>
<li>신경망을 통해 단어의 의미를 주변 문맥을 고려하여 학습하고, 이를 밀집 벡터(Dense Vector)로 표현.</li>
</ul>
</section>
<section id="워드-임베딩-word-embedding" class="level3" data-number="2.0.3">
<h3 data-number="2.0.3" class="anchored" data-anchor-id="워드-임베딩-word-embedding"><span class="header-section-number">2.0.3</span> 워드 임베딩 (Word Embedding)</h3>
<ul>
<li><p>문맥 속에서 각 단어가 어떻게 사용되는지까지 신경망을 통해 벡터값을 구해 벡터에 담아내려 시도.</p></li>
<li><p><a href="https://projector.tensorflow.org/">체험: 단어 유사도 측정 - https://projector.tensorflow.org/</a></p></li>
<li><p>학습 후에는 각 단어 벡터 간의 유사도(의미반영)를 계산할 수 있다.</p></li>
<li><p>즉, 신경망 기반의 벡터화라는 것은 벡터의 값이 학습에 의해 결정된다는 것을 의미.</p></li>
<li><p>워드 임베딩 모델의 예시</p>
<ul>
<li>Word2Vec, GloVe, FastText, 모델 내 <code>Embedding</code> Layer 사용.<br>
</li>
</ul></li>
<li><p>어떻게 단어를 벡터화?</p>
<ul>
<li>단어가 정수화 되면 차원이 정해진 임의의 가중치 테이블의 내적으로 벡터화된다.</li>
<li>이때, 이 가중치 테이블을 embedding table (= embedding layer) 이라고 하고 각 행이 단어를 의미한다.</li>
<li>따라서, embedding table의 행의 크기 = vocab_size가 되고 내적의 결과가 단어의 벡터가 되어 딥러닝 입력값으로 사용된다.</li>
<li>딥러닝의 학습을 통해 이 embedding table (가중치 행렬)의 값이 최적화되고 이 값이 단어의 벡터가 된다.</li>
<li>딥러닝 자연어 처리 시 거의 항상 하게 되는 작업</li>
<li>vocab_size (고차원, 20k~30k) x embedding_dim (저차원, 128,256,512 등) 크기의 가중치 행렬이 학습되어 임베딩 벡터가 된다.</li>
<li>단어 -&gt; 정수 인코딩 -&gt; Embedding Layer -&gt; 임베딩 벡터(=밀집 벡터)</li>
<li>자연어 처리에서 단어를 정수로 바꿔주는 이유가 Embedding Layer를 통해 밀집 벡터로 변환하기 위해서이다.</li>
<li>Lookup table: 정수 인코딩을 밀집 벡터로 변환하는 테이블</li>
</ul></li>
<li><p>워드 임베딩 2가지 유형</p>
<ul>
<li>랜덤 초기화 임베딩
<ul>
<li>NNLM(Neural Network Language Model)과 마찬가지로 초기에 랜덤값의 가중치를 가지고 오차를 구하는 과정에서 embedding table의 값이 학습</li>
<li>NNLM은 이전 단어가 주어졌을 때, 다음 단어를 구하는 학습과정에서 오차를 줄이면서 학습되었으나 텍스트 분류, 개체명 인식등 수많은 task에서도 오차를 줄이며 학습 가능</li>
<li>task에 맞도록 embedding vector값이 최적화된다.</li>
<li>pytorch, keras 등 딥러닝 프레임워크에서 랜덤 초기화된 embedding layer를 제공한다.</li>
<li>모델이 역전파하는 과정에서 embedding layer의 가중치가 학습되어 최적화된다.</li>
</ul></li>
<li>사전 훈련된 임베딩 (Pre-trained Word Embedding)
<ul>
<li>이미 만들어진 임베딩 테이블을 사용</li>
<li>정해진 특정 알고리즘에 방대한 데이터를 입력으로 학습시킨 후 여러 task의 입력으로 사용</li>
<li>대표적인 알고리즘으로 word2vec, glove, fasttext가 있음</li>
<li>이미 방대한 양의 텍스트 데이터로 훈련되어져 있는 임베딩 벡터값들을 갖고와서 딥러닝 모델의 입력값으로 사용</li>
<li>이때 이 임베딩 벡터들은 word2vec, glove, fasttext 등 특정 알고리즘으로 훈련되어져 있는 임베딩 벡터값들이다.</li>
<li>이미 학습된 임베딩 벡터를 사용하므로 모델 학습 시간이 줄어들고 더 좋은 성능을 보임</li>
</ul></li>
</ul></li>
<li><p>핵심 원리</p>
<ul>
<li><strong>분포 가설(Distributional Hypothesis):</strong>
<ul>
<li>“같은 문맥에서 나타나는 단어들은 유사한 의미를 가진다”</li>
<li>수학적으로 표현하면: <img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bsimilarity%7D(w_i,%20w_j)%20%5Cpropto%20%5Ctext%7Bcontext%5C_overlap%7D(w_i,%20w_j)"></li>
</ul></li>
<li><strong>“같은 문맥에 나타나는 단어들은 비슷한 의미를 가진다”</strong></li>
<li><strong>예시:</strong></li>
</ul>
<pre><code>문장1: "나는 사과를 먹었다"
문장2: "나는 바나나를 먹었다"  
문장3: "나는 딸기를 먹었다"</code></pre>
<p>→ “사과”, “바나나”, “딸기”는 같은 위치(문맥)에 나타남 → 비슷한 벡터를 가져야 함</p></li>
<li><p>임베딩 벡터의 의미</p>
<ul>
<li><p>벡터 간 유사도</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1">cosine_similarity(v_사과, v_바나나) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 높음 (비슷함)</span></span>
<span id="cb5-2">cosine_similarity(v_사과, v_컴퓨터) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 낮음 (다름)</span></span></code></pre></div>
<ul>
<li>수식: <img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bsimilarity%7D(%5Cmathbf%7Bv%7D_1,%20%5Cmathbf%7Bv%7D_2)%20=%20%5Cfrac%7B%5Cmathbf%7Bv%7D_1%20%5Ccdot%20%5Cmathbf%7Bv%7D_2%7D%7B%7C%7C%5Cmathbf%7Bv%7D_1%7C%7C%20%5Ccdot%20%7C%7C%5Cmathbf%7Bv%7D_2%7C%7C%7D"></li>
<li>직관적 해석
<ul>
<li>1에 가까울수록 비슷한 의미</li>
<li>0에 가까울수록 관련 없음</li>
<li>-1에 가까울수록 반대 의미</li>
</ul></li>
</ul></li>
<li><p>벡터 연산의 마법</p>
<ul>
<li>유명한 예시:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cvec%7B%5Ctext%7Bking%7D%7D%20-%20%5Cvec%7B%5Ctext%7Bman%7D%7D%20+%20%5Cvec%7B%5Ctext%7Bwoman%7D%7D%20%5Capprox%20%5Cvec%7B%5Ctext%7Bqueen%7D%7D"></li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cvec%7B%5Ctext%7Bking%7D%7D%20-%20%5Cvec%7B%5Ctext%7Bman%7D%7D">: “남성성”을 제거 → “왕권” 개념만 남음</li>
<li><img src="https://latex.codecogs.com/png.latex?+%20%5Cvec%7B%5Ctext%7Bwoman%7D%7D">: “여성성” 추가</li>
<li>결과: “여성 + 왕권” → “여왕”</li>
</ul></li>
<li>수학적 설명:
<ul>
<li>각 벡터를 의미 성분들의 조합으로 생각:</li>
</ul>
<pre><code>king = [왕권: 0.9, 남성: 0.8, 권력: 0.7, ...]
man = [남성: 0.9, 성인: 0.6, ...]  
woman = [여성: 0.9, 성인: 0.6, ...]</code></pre>
<ul>
<li>연산 후:</li>
</ul>
<pre><code>king - man + woman ≈ [왕권: 0.9, 여성: 0.9, 권력: 0.7, ...]</code></pre>
→ “queen”과 가장 유사!</li>
</ul></li>
</ul></li>
<li><p>실제 학습 예시</p>
<ul>
<li><p>초기 상태 (랜덤)</p>
<pre><code>"사과" = [0.1, -0.3, 0.7, ...]  (랜덤)
"바나나" = [-0.8, 0.2, -0.1, ...] (랜덤)</code></pre>
<ul>
<li>서로 전혀 관련 없어 보임</li>
</ul></li>
<li><p>학습 진행</p>
<pre><code>문장들을 계속 보면서:
"사과를 먹었다", "바나나를 먹었다", "딸기를 먹었다"
...

* 점차 비슷한 벡터로 수렴:
</code></pre>
<p>“사과” = [0.2, -0.4, 0.6, …] “바나나” = [0.3, -0.5, 0.7, …]<br>
“딸기” = [0.25, -0.45, 0.65, …] ```</p></li>
<li><p>학습 완료 후</p>
<ul>
<li>의미가 비슷한 단어들 → 벡터 공간에서 가까운 위치</li>
<li>반대 의미 단어들 → 먼 위치 또는 반대 방향</li>
<li>유추 관계 → 벡터 연산으로 표현 가능</li>
</ul></li>
</ul></li>
<li><p><strong>핵심</strong>: 신경망이 “문맥”이라는 단서를 통해 <strong>단어의 의미</strong>를 수치로 학습</p></li>
</ul>
<section id="embedding-layer-구조-분석" class="level4" data-number="2.0.3.1">
<h4 data-number="2.0.3.1" class="anchored" data-anchor-id="embedding-layer-구조-분석"><span class="header-section-number">2.0.3.1</span> Embedding Layer 구조 분석</h4>
<ul>
<li>Embedding Layer란?
<ul>
<li>정수 인코딩 → 밀집 벡터 변환기</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 이런 변환을 해주는 것</span></span>
<span id="cb10-2"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span> → [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 300차원 벡터</span></span>
<span id="cb10-3"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">23</span> → [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>]   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 300차원 벡터  </span></span>
<span id="cb10-4"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>  → [<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.9</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 300차원 벡터</span></span></code></pre></div>
<ul>
<li>왜 정수 인코딩이 필요한가?
<ul>
<li>문제: 컴퓨터는 “사과”라는 글자를 직접 처리할 수 없음</li>
<li>해결 과정:</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1단계: 단어 → 정수 (정수 인코딩)</span></span>
<span id="cb11-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"사과"</span> → <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span></span>
<span id="cb11-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"바나나"</span> → <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">23</span>  </span>
<span id="cb11-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"딸기"</span> → <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span></span>
<span id="cb11-5"></span>
<span id="cb11-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2단계: 정수 → 벡터 (Embedding Layer)</span></span>
<span id="cb11-7"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span> → [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>, ...]</span>
<span id="cb11-8"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">23</span> → [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, ...]</span>
<span id="cb11-9"><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>  → [<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, ...]</span></code></pre></div>
<ul>
<li><p>Look-up Table의 구체적 동작</p>
<ul>
<li>Embedding Matrix 구조: <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BE%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7BV%20%5Ctimes%20d%7D"></li>
<li>실제 예시:</li>
</ul>
<div class="sourceCode" id="cb12" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># V = 5 (어휘 크기), d = 3 (임베딩 차원)</span></span>
<span id="cb12-2">embedding_matrix <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [</span>
<span id="cb12-3">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>],    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 단어 ID 0의 벡터</span></span>
<span id="cb12-4">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span>],    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 단어 ID 1의 벡터  </span></span>
<span id="cb12-5">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.9</span>],    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 단어 ID 2의 벡터</span></span>
<span id="cb12-6">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>],   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 단어 ID 3의 벡터</span></span>
<span id="cb12-7">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>],   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 단어 ID 4의 벡터</span></span>
<span id="cb12-8">]</span></code></pre></div></li>
<li><p>행렬의 의미:</p>
<ul>
<li>행(row): 각 단어의 임베딩 벡터</li>
<li>열(column): 임베딩 벡터의 각 차원</li>
<li>전체: 모든 단어의 벡터를 저장하는 “사전”</li>
</ul></li>
<li><p>Look-up 연산 과정</p>
<ul>
<li>입력: <code>input_ids = [2, 0, 4]</code></li>
</ul>
<div class="sourceCode" id="cb13" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1단계: 각 ID에 해당하는 행을 추출</span></span>
<span id="cb13-2">embedding_matrix[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>] → [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.9</span>]    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ID 2의 벡터</span></span>
<span id="cb13-3">embedding_matrix[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>] → [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>]    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ID 0의 벡터  </span></span>
<span id="cb13-4">embedding_matrix[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>] → [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>]   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ID 4의 벡터</span></span>
<span id="cb13-5"></span>
<span id="cb13-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2단계: 결과 (3개 벡터)</span></span>
<span id="cb13-7">output <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [</span>
<span id="cb13-8">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.9</span>],     <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 첫 번째 단어</span></span>
<span id="cb13-9">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>],     <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 두 번째 단어</span></span>
<span id="cb13-10">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>]     <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 세 번째 단어  </span></span>
<span id="cb13-11">]</span></code></pre></div></li>
<li><p>수학적 의미</p>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bembedding%7D(i)%20=%20%5Cmathbf%7BE%7D%5Bi,%20:%5D">
<ul>
<li><img src="https://latex.codecogs.com/png.latex?i">: 단어의 정수 ID</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BE%7D%5Bi,%20:%5D">: 행렬 E의 i번째 행 전체</li>
<li>결과: i번째 단어의 임베딩 벡터</li>
</ul></li>
<li>구체적 예시:</li>
</ul>
<div class="sourceCode" id="cb14" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1">i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "딸기"의 ID라고 가정</span></span>
<span id="cb14-2">embedding(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> E[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>, :] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.9</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2번째 행</span></span></code></pre></div></li>
<li><p>실제 PyTorch 코드</p></li>
</ul>
<div class="sourceCode" id="cb15" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch</span>
<span id="cb15-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> torch.nn <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> nn</span>
<span id="cb15-3"></span>
<span id="cb15-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. Embedding Layer 생성</span></span>
<span id="cb15-5">vocab_size <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span>      <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 어휘 크기</span></span>
<span id="cb15-6">embedding_dim <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">300</span>    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 벡터 차원</span></span>
<span id="cb15-7">embedding <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nn.Embedding(vocab_size, embedding_dim)</span>
<span id="cb15-8"></span>
<span id="cb15-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. 내부 구조 확인</span></span>
<span id="cb15-10"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(embedding.weight.shape)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># torch.Size([1000, 300])</span></span>
<span id="cb15-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># → 1000×300 크기의 look-up table</span></span>
<span id="cb15-12"></span>
<span id="cb15-13"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3. 입력 데이터</span></span>
<span id="cb15-14">input_ids <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.tensor([<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">23</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>])  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3개 단어의 ID</span></span>
<span id="cb15-15"></span>
<span id="cb15-16"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 4. 임베딩 변환</span></span>
<span id="cb15-17">output <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> embedding(input_ids)</span>
<span id="cb15-18"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(output.shape)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># torch.Size([3, 300])</span></span>
<span id="cb15-19"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># → 3개 단어 × 300차원 벡터</span></span></code></pre></div>
<ul>
<li>Look-up Table이 학습되는 과정
<ul>
<li>초기화 (랜덤)</li>
</ul>
<div class="sourceCode" id="cb16" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 처음에는 랜덤 값들</span></span>
<span id="cb16-2">embedding_matrix <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.randn(vocab_size, embedding_dim)</span></code></pre></div></li>
<li>학습 과정</li>
</ul>
<div class="sourceCode" id="cb17" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 예: "사과는 맛있다"라는 문장 학습</span></span>
<span id="cb17-2">input_ids <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">23</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [사과는, 맛있다, &lt;</span><span class="re">END</span><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;]</span></span>
<span id="cb17-3"></span>
<span id="cb17-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. 현재 임베딩으로 예측</span></span>
<span id="cb17-5">embeddings <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> embedding_matrix[input_ids]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Look-up</span></span>
<span id="cb17-6">prediction <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model(embeddings)</span>
<span id="cb17-7"></span>
<span id="cb17-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. 손실 계산</span></span>
<span id="cb17-9">loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> criterion(prediction, target)</span>
<span id="cb17-10"></span>
<span id="cb17-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3. 역전파로 embedding_matrix 업데이트  </span></span>
<span id="cb17-12">loss.backward()  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># embedding_matrix의 gradient 계산</span></span>
<span id="cb17-13">optimizer.step()  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># embedding_matrix 값들 업데이트</span></span></code></pre></div>
<ul>
<li><p>핵심: 학습이 진행되면서 embedding_matrix의 각 행(단어 벡터)이 점점 더 의미 있는 값으로 변함!</p></li>
<li><p>왜 “Look-up Table”이라고 부르는가?</p>
<ul>
<li>전통적인 사전과 비교</li>
</ul>
<div class="sourceCode" id="cb18" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 일반 사전</span></span>
<span id="cb18-2">사전 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {</span>
<span id="cb18-3">   <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"빨간 과일"</span>,</span>
<span id="cb18-4">   <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"바나나"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"노란 과일"</span>, </span>
<span id="cb18-5">   <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"컴퓨터"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"전자 기기"</span></span>
<span id="cb18-6">}</span>
<span id="cb18-7">의미 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> 사전[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과"</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "빨간 과일"</span></span>
<span id="cb18-8"></span>
<span id="cb18-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Embedding Table  </span></span>
<span id="cb18-10">임베딩_테이블 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {</span>
<span id="cb18-11">   <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span>: [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>, ...],   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "사과"</span></span>
<span id="cb18-12">   <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">23</span>: [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, ...],   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "바나나"</span></span>
<span id="cb18-13">   <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">78</span>: [<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, ...]    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "컴퓨터"</span></span>
<span id="cb18-14">}</span>
<span id="cb18-15">벡터 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> 임베딩_테이블[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [0.2, -0.4, 0.7, ...]</span></span></code></pre></div>
<ul>
<li>차이점:
<ul>
<li>일반 사전: 단어 → 설명 (텍스트)</li>
<li>임베딩 테이블: 단어 ID → 숫자 벡터</li>
</ul></li>
</ul></li>
<li><p>전체 과정 정리</p></li>
</ul>
<div class="sourceCode" id="cb19" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전체 파이프라인</span></span>
<span id="cb19-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"사과는 맛있다"</span> </span>
<span id="cb19-3">→ [<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과는"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"맛있다"</span>]           <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 토큰화</span></span>
<span id="cb19-4">→ [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">23</span>]                      <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 정수 인코딩  </span></span>
<span id="cb19-5">→ [[<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>],           <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Embedding Layer (Look-up)</span></span>
<span id="cb19-6">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>]]</span>
<span id="cb19-7">→ 신경망 처리                    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 후속 레이어들</span></span></code></pre></div>
<ul>
<li>핵심
<ul>
<li>Embedding Layer는 단순히 “정수 ID를 인덱스로 사용해서 미리 저장된 벡터를 가져오는” 매우 단순한 연산.</li>
<li>하지만 이 벡터들이 학습을 통해 의미 있는 값으로 변하기 때문에 강력한 도구가 되는 것</li>
</ul></li>
</ul>
</section>
<section id="주요-모델별-특징" class="level4" data-number="2.0.3.2">
<h4 data-number="2.0.3.2" class="anchored" data-anchor-id="주요-모델별-특징"><span class="header-section-number">2.0.3.2</span> 주요 모델별 특징</h4>
<ul>
<li><p><strong>Word2Vec (2013)</strong>의 두 가지 아키텍처:</p>
<ul>
<li>전제: 같은 문잭에서의 단어들은 유사한 단어들이 주로 출현하게 된다.
<ul>
<li>강아지 문맥: 귀여운, 개, 놀이터, 애견, 등</li>
<li>법률 문맥: 판사, 변호사, 검사, 소송, 법정 등</li>
</ul></li>
<li><a href="https://w.elnn.kr/search">한국어 word2vec 예시</a><br>
</li>
<li><strong>CBOW (Continuous Bag of Words)</strong>
<ul>
<li>주변 단어들로 중심 단어 예측</li>
<li>목적 함수: <img src="https://latex.codecogs.com/png.latex?%5Cmax%20%5Csum_%7Bw%20%5Cin%20V%7D%20%5Clog%20P(w%7Ccontext(w))"></li>
<li>기본 구조
<ul>
<li><strong>목표</strong>: 주변 단어들을 보고 가운데 단어를 맞추기</li>
</ul>
<pre><code>입력: [나는] [___] [먹었다]  
출력: [사과를]</code></pre></li>
<li>수학적 모델링
<ul>
<li><strong>1단계: 입력 표현</strong>
<ul>
<li>문맥 단어들: <img src="https://latex.codecogs.com/png.latex?w_%7B-2%7D,%20w_%7B-1%7D,%20w_%7B+1%7D,%20w_%7B+2%7D"> (윈도우 크기 2)</li>
<li>각 단어의 원-핫 벡터: <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bx%7D_%7Bw%7D%20%5Cin%20%5C%7B0,1%5C%7D%5EV"> (V = 어휘 크기)</li>
</ul></li>
<li><strong>2단계: 임베딩 변환</strong>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bv%7D_w%20=%20%5Cmathbf%7BW%7D_%7B%5Ctext%7Bin%7D%7D%20%5Cmathbf%7Bx%7D_w"></li>
<li>여기서:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BW%7D_%7B%5Ctext%7Bin%7D%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd%20%5Ctimes%20V%7D">: 입력 임베딩 행렬</li>
<li><img src="https://latex.codecogs.com/png.latex?d">: 임베딩 차원 (예: 300)</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bv%7D_w%20%5Cin%20%5Cmathbb%7BR%7D%5Ed">: 단어의 임베딩 벡터</li>
</ul></li>
<li><strong>직관적 해석</strong>:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7BW%7D_%7B%5Ctext%7Bin%7D%7D"> 는 “단어 ID → 의미 벡터” 변환표</li>
<li>원-핫 벡터와의 곱은 단순히 해당 행을 선택하는 것</li>
</ul></li>
</ul></li>
<li><strong>3단계: 문맥 벡터 계산</strong>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bh%7D%20=%20%5Cfrac%7B1%7D%7BC%7D%20%5Csum_%7Bc%20%5Cin%20%5Ctext%7Bcontext%7D%7D%20%5Cmathbf%7Bv%7D_c"></li>
<li><strong>직관적 해석</strong>:
<ul>
<li>주변 단어들의 평균 벡터</li>
<li>“이 위치에 올 수 있는 단어의 특징”을 나타냄</li>
</ul></li>
</ul></li>
<li><strong>4단계: 출력 확률 계산</strong>
<ul>
<li><img src="https://latex.codecogs.com/png.latex?P(w_%7B%5Ctext%7Bcenter%7D%7D%7C%5Ctext%7Bcontext%7D)%20=%20%5Cfrac%7B%5Cexp(%5Cmathbf%7Bu%7D_%7Bw_%7B%5Ctext%7Bcenter%7D%7D%7D%5ET%20%5Cmathbf%7Bh%7D)%7D%7B%5Csum_%7Bw'=1%7D%5EV%20%5Cexp(%5Cmathbf%7Bu%7D_%7Bw'%7D%5ET%20%5Cmathbf%7Bh%7D)%7D"></li>
<li><strong>직관적 해석</strong>:
<ul>
<li>분자: 정답 단어가 이 문맥에 얼마나 적합한지</li>
<li>분모: 모든 단어 중에서 정규화 (확률의 합 = 1)</li>
</ul></li>
<li>예시
<ul>
<li><strong>예시 문장</strong>: “나는 사과를 먹었다”</li>
</ul>
<pre><code>Step 1: 문맥 = ["나는", "먹었다"], 정답 = "사과를"
Step 2: 현재 모델이 "바나나를" 높은 확률로 예측
Step 3: 손실 계산 → "사과를"의 확률을 높이도록 가중치 업데이트
Step 4: 반복 학습 후 → "나는 ___ 먹었다" 문맥에서 과일 단어들이 높은 확률</code></pre>
<ul>
<li><strong>학습 결과</strong>:
<ul>
<li>비슷한 문맥에 나타나는 단어들 → 비슷한 벡터</li>
<li>“사과”, “바나나”, “딸기” → 가까운 위치의 벡터</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Skip-gram:</strong>
<ul>
<li><p>CBoW보다 Skip-gram이 더 좋은 성능을 보임</p></li>
<li><p>구버전(중심 단어로 주변 단어들 예측)과 신버전(주변 단어들로 중심 단어 예측)으로 나뉨<br>
</p></li>
<li><p>중심 단어로 주변 단어들 예측, window size (중심 단어를 중심으로 앞뒤 몇 개의 단어를 문맥으로 설정) 존재.</p></li>
<li><p>window가 슬라이딩하면서 모든 단어에 대해 중심 단어로 주변 단어들 예측</p></li>
<li><p>window size가 크면 (7~25) 문맥이 넓어지고 작으면(2~7) 문맥이 좁아짐</p>
<ul>
<li>윈도우 사이즈가 작으면 상호 교환할 수 있을 정도의 높은 유사도를 가진다.</li>
<li>여기서 상호 교환이 가능하다는 것은 반의어도 포함될 수 있다.</li>
<li>반면, 윈도우 사이즈가 크면 관련 단어들을 군집하는 효과가 있다.</li>
</ul></li>
<li><p>목적 함수: <img src="https://latex.codecogs.com/png.latex?%5Cmax%20%5Csum_%7Bw%20%5Cin%20V%7D%20%5Csum_%7Bc%20%5Cin%20context(w)%7D%20%5Clog%20P(c%7Cw)"></p></li>
<li><p>특징:</p>
<ul>
<li>선형 관계 학습: <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bking%7D%20-%20%5Cvec%7Bman%7D%20+%20%5Cvec%7Bwoman%7D%20%5Capprox%20%5Cvec%7Bqueen%7D"></li>
<li>속도가 빠름</li>
<li>단어별 고정된 하나의 벡터</li>
</ul></li>
<li><p>구버전 예시</p>
<pre><code>문장: Thou shalt not make a machine in the likeness of a human mind.
Input word: [not] 일 때,
Target word: [thou], [shalt], [make], [a]
따라서, 4개의 다중 클래스 분류 문제로 딥러닝을 써서 학습

"중심 단어로 문맥 예측하기": 슬라이딩 하면서 중심단어를 바꿔가며 학습
Input words: [Thou], [shalt], [not], [make], [a], [machine], [in], [the], [likeness], [of], [a], [human], [mind]

예를 들어, 중심 단어가 [not]일 때, 주변 단어들은 [thou], [shalt], [make], [a]가 되도록 학습
softmax 와 cross entropy 손실 함수를 사용하여 학습
input layer, projection layer, output layer 3개의 층으로 구성된 신경망
소프트맥스 함수를 지난 예측값과 실제값으로부터 오차를 구한다.
하지만 이 구버전으로 사용하지 않는 방법이다.
그 이유는 속도가 너무 느리고 단어 집합의 크기에 대해서 softmax + cross entropy 손실 함수를 사용하면 연산이 너무 무겁다.
통상적으로, 단어 집합의 크기는 일반적으로 수 만개 이상이다.</code></pre></li>
<li><p>신버전 예시</p>
<pre><code>Skip-gram with Negative Sampling (SGNS)
다중 클래스 분류를 이진분류 문제로 바꾸어 연산량을 줄임
중심단어와 주변 단어를 입력값으로 주고 이 둘의 내적으로부터 0,1로 이진 분류: 1이면 이웃단어, 0이면 비이웃단어
중심 단어 데이터셋에 레이블을 1로 할당하고 Negative Sampling을 통해 비이웃 단어 샘플들도 추가
Negative Sampling: 비이웃 단어 샘플들을 전체 데이터셋에서 랜덤하게 추출한다.
2개의 Embedding Table을 사용
  * 하나는 임베딩 테이블 (size = 단어의 개수를 행으로 갖고 embedding dimension을 열로 갖는 행렬): 임베딩 디멘션은 사용자가 지정
  * 하나는 주변 단어 정보를 갖는 context 테이블 (임베딩 테이블의 동일한 크기를 갖는 테이블)

문장: Thou shalt not make a machine in the likeness of a human mind.
Input word: [not, not, not] = [0.2, 0.2, 0.2]
output words: [thou, taco, you] = [0.1, 0.7, -0.6]
target = [1, 0, 0]
input x output = [0.02 0.14 -0.12]
sigmoid(x) = [0.505 0.535 0.47]
error = target - sigmoid(x) = [1-0.505, 0-0.535, 0-0.47] = [0.495, -0.535, -0.47]
역전파를 통해 error를 최소화하는 input word와 output word의 임베딩 벡터를 학습

embedding vector의 차원을 정하는 것은 사용자의 몫
Negative Sampling의 비율 또한 성능에 영향을 주는 결정 요소
논문에서는 5-20을 최적의 숫자로 제안한다.
데이터가 방대하다면 2-5로도 충분하다.</code></pre></li>
<li><p>수학적 모델</p>
<ul>
<li>목적 함수: <img src="https://latex.codecogs.com/png.latex?%5Cmax%20%5Csum_%7Bw%20%5Cin%20V%7D%20%5Csum_%7Bc%20%5Cin%20context(w)%7D%20%5Clog%20P(c%7Cw)"></li>
<li>단계별 해석:
<ul>
<li><strong>1단계</strong>: <img src="https://latex.codecogs.com/png.latex?w%20%5Cin%20V"> (모든 단어에 대해)
<ul>
<li>말뭉치의 모든 단어를 중심 단어로 한 번씩 사용</li>
</ul></li>
<li><strong>2단계</strong>: <img src="https://latex.codecogs.com/png.latex?c%20%5Cin%20context(w)"> (각 중심 단어의 모든 문맥 단어에 대해)
<ul>
<li>윈도우 크기만큼 주변 단어들을 문맥으로 설정</li>
</ul></li>
<li><strong>3단계</strong>: <img src="https://latex.codecogs.com/png.latex?%5Clog%20P(c%7Cw)"> (확률의 로그값)
<ul>
<li>중심 단어 w가 주어졌을 때 문맥 단어 c가 나타날 확률</li>
</ul></li>
</ul></li>
<li>예시
<ul>
<li><strong>문장</strong>: “나는 사과를 정말 좋아한다” (윈도우 크기 = 2)</li>
</ul>
<pre><code>중심 단어: "사과를"
문맥 단어들: ["나는", "정말", "좋아한다"] (앞뒤 2개씩)

Skip-gram이 학습하는 것:
P("나는"|"사과를")     → 높아야 함
P("정말"|"사과를")     → 높아야 함  
P("좋아한다"|"사과를") → 높아야 함
P("컴퓨터"|"사과를")   → 낮아야 함 (문맥에 없음)</code></pre></li>
<li>확률 계산: <img src="https://latex.codecogs.com/png.latex?P(c%7Cw)%20=%20%5Cfrac%7B%5Cexp(%5Cmathbf%7Bu%7D_c%5ET%20%5Cmathbf%7Bv%7D_w)%7D%7B%5Csum_%7Bc'=1%7D%5EV%20%5Cexp(%5Cmathbf%7Bu%7D_%7Bc'%7D%5ET%20%5Cmathbf%7Bv%7D_w)%7D">
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bv%7D_w"> : 중심 단어 w의 입력 벡터 (우리가 원하는 임베딩)</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bu%7D_c"> : 문맥 단어 c의 출력 벡터</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bu%7D_c%5ET%20%5Cmathbf%7Bv%7D_w"> : 두 단어가 “같이 나타날 가능성” 점수</li>
<li>Softmax로 정규화하여 확률로 변환</li>
</ul></li>
<li>학습 과정 예시
<ul>
<li><p>초기 상태 (랜덤 벡터)</p>
<div class="sourceCode" id="cb25" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1">v_사과 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 중심 단어 벡터</span></span>
<span id="cb25-2">u_나는 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 문맥 단어 벡터</span></span>
<span id="cb25-3">u_컴퓨터 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>]</span></code></pre></div></li>
<li><p>점수 계산</p>
<div class="sourceCode" id="cb26" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1">score_나는 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> dot(u_나는, v_사과) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> (<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>)<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.01</span></span>
<span id="cb26-2">score_컴퓨터 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> dot(u_컴퓨터, v_사과) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.08</span></span></code></pre></div></li>
<li><p>확률 계산 (간단히)</p>
<div class="sourceCode" id="cb27" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1">P(나는<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span>사과) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> exp(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.01</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> (exp(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.01</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> exp(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.08</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> ...) ≈ <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span></span>
<span id="cb27-2">P(컴퓨터<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span>사과) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> exp(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.08</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> (exp(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.01</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> exp(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.08</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> ...) ≈ <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span></span></code></pre></div></li>
<li><p>학습 업데이트</p>
<ul>
<li>목표: P(나는|사과)는 높이고, P(컴퓨터|사과)는 낮추기</li>
</ul>
<div class="sourceCode" id="cb28" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 실제로 "나는"이 문맥에 있었으므로</span></span>
<span id="cb28-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># v_사과와 u_나는을 더 비슷하게 만들기</span></span>
<span id="cb28-3">v_사과 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> learning_rate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> u_나는  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 벡터를 가까워지게</span></span>
<span id="cb28-4">u_나는 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> learning_rate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> v_사과</span>
<span id="cb28-5"></span>
<span id="cb28-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "컴퓨터"는 문맥에 없었으므로  </span></span>
<span id="cb28-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># v_사과와 u_컴퓨터를 더 멀게 만들기</span></span>
<span id="cb28-8">v_사과 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-=</span> learning_rate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> u_컴퓨터  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 벡터를 멀어지게</span></span>
<span id="cb28-9">u_컴퓨터 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-=</span> learning_rate <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> v_사과</span></code></pre></div></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>GloVe (2014)</strong></p>
<ul>
<li>전역 통계 정보 활용</li>
<li>단어 동시 출현 행렬(Co-occurrence Matrix) 기반</li>
<li>목적 함수: <img src="https://latex.codecogs.com/png.latex?%5Cmin%20%5Csum_%7Bi,j=1%7D%5EV%20f(X_%7Bij%7D)(%5Cvec%7Bw_i%7D%5ET%20%5Cvec%7Bw_j%7D%20+%20b_i%20+%20b_j%20-%20%5Clog%20X_%7Bij%7D)%5E2"></li>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?X_%7Bij%7D"> 는 단어 <img src="https://latex.codecogs.com/png.latex?i"> 와 <img src="https://latex.codecogs.com/png.latex?j"> 의 동시 출현 빈도</li>
<li>Word2Vec의 한계:
<ul>
<li>지역적 문맥 정보만 사용 (윈도우 크기 내)</li>
<li>전체 말뭉치의 통계 정보를 충분히 활용하지 못함</li>
</ul></li>
<li>GloVe의 해결책:
<ul>
<li>전체 말뭉치의 동시 출현 통계를 미리 계산</li>
<li>이 통계 정보를 직접 활용하여 벡터 학습</li>
</ul></li>
<li>동시 출현 행렬 (Co-occurrence Matrix)</li>
<li>구체적 예시
<ul>
<li><p>말뭉치:</p>
<pre><code>문장1: "나는 사과를 좋아한다"
문장2: "사과는 맛있는 과일이다"  
문장3: "바나나도 좋은 과일이다"</code></pre></li>
<li><p>윈도우 크기 2로 동시 출현 계산:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 8%">
<col style="width: 20%">
<col style="width: 13%">
<col style="width: 11%">
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 8%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>나는</th>
<th>사과를/사과는</th>
<th>좋아한다</th>
<th>맛있는</th>
<th>과일이다</th>
<th>바나나도</th>
<th>좋은</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>나는</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>사과를/사과는</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>좋아한다</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>맛있는</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>과일이다</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>바나나도</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="odd">
<td>좋은</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table></li>
<li><p>해석: <img src="https://latex.codecogs.com/png.latex?X_%7Bij%7D"> = 단어 i와 j가 윈도우 내에서 함께 나타난 횟수</p></li>
</ul></li>
<li>GloVe 목적 함수 해부
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmin%20%5Csum_%7Bi,j=1%7D%5EV%20f(X_%7Bij%7D)(%5Cmathbf%7Bw%7D_i%5ET%20%5Cmathbf%7Bw%7D_j%20+%20b_i%20+%20b_j%20-%20%5Clog%20X_%7Bij%7D)%5E2"></li>
<li>각 항목의 의미
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bw%7D_i%5ET%20%5Cmathbf%7Bw%7D_j"> : 단어 벡터들의 내적
<ul>
<li>두 단어의 유사도를 나타냄</li>
<li>자주 함께 나타나는 단어들은 높은 내적값을 가져야 함</li>
</ul></li>
<li><img src="https://latex.codecogs.com/png.latex?b_i%20+%20b_j"> : 편향(bias) 항
<ul>
<li>각 단어의 전반적인 빈도를 조정</li>
<li>자주 나타나는 단어는 높은 편향값</li>
</ul></li>
<li><img src="https://latex.codecogs.com/png.latex?%5Clog%20X_%7Bij%7D"> : 실제 동시 출현 빈도의 로그
<ul>
<li>목표값 (우리가 맞추려는 값)</li>
<li>로그를 취하는 이유: 빈도의 분포가 매우 치우쳐 있어서</li>
</ul></li>
<li><img src="https://latex.codecogs.com/png.latex?f(X_%7Bij%7D)"> : 가중치 함수
<ul>
<li>너무 희귀한 동시 출현은 신뢰도가 낮음 → 낮은 가중치</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><img src="https://latex.codecogs.com/png.latex?%0Af(x)%20=%20%5Cbegin%7Bcases%7D%0A(%5Cfrac%7Bx%7D%7Bx_%7Bmax%7D%7D)%5E%7B%5Calpha%7D%20&amp;%20%5Ctext%7Bif%20%7D%20x%20%3C%20x_%7Bmax%7D%20%5C%5C%0A1%20&amp;%20%5Ctext%7Botherwise%7D%0A%5Cend%7Bcases%7D%0A"></p>
<pre><code>   * 가중치 함수의 역할:
      * 너무 희귀한 동시 출현은 신뢰도가 낮음 → 낮은 가중치
      * 너무 흔한 동시 출현도 정보량이 적음 → 가중치 제한
      * 적당한 빈도의 동시 출현에 높은 가중치</code></pre>
<ul>
<li>학습 과정 예시
<ul>
<li>예시: “사과”와 “과일” 관계 학습</li>
</ul>
<div class="sourceCode" id="cb31" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 실제 동시 출현: X_사과_과일 = 10번</span></span>
<span id="cb31-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 목표: w_사과^T * w_과일 + b_사과 + b_과일 ≈ log(10) = 2.3</span></span>
<span id="cb31-3"></span>
<span id="cb31-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 초기 (랜덤)</span></span>
<span id="cb31-5">w_사과 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>]</span>
<span id="cb31-6">w_과일 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>]  </span>
<span id="cb31-7">내적 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span>(<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.01</span></span>
<span id="cb31-8">편향합 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span></span>
<span id="cb31-9">예측값 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.01</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.81</span></span>
<span id="cb31-10"></span>
<span id="cb31-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 손실: (0.81 - 2.3)^2 = 2.22 (크다!)</span></span>
<span id="cb31-12"></span>
<span id="cb31-13"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 업데이트 후</span></span>
<span id="cb31-14">w_사과 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 더 큰 값들로</span></span>
<span id="cb31-15">w_과일 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>]</span>
<span id="cb31-16">내적 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.34</span></span>
<span id="cb31-17">편향합 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.2</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.9</span></span>
<span id="cb31-18">예측값 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.34</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.9</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">2.24</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 목표 2.3에 가까워짐!</span></span></code></pre></div></li>
</ul></li>
<li><p><strong>FastText (2017)</strong></p>
<ul>
<li>Sub-word 정보 활용</li>
<li>단어를 character n-gram으로 분해</li>
<li>예: “apple” → {“ap”, “pp”, “pl”, “le”} + “apple”</li>
<li>장점:
<ul>
<li>OOV(Out-of-Vocabulary) 문제 해결</li>
<li>형태학적 정보 포착</li>
<li>한국어와 같은 교착어에 효과적</li>
</ul></li>
<li>기존 방법의 한계
<ul>
<li><p>Word2Vec/GloVe 문제:</p>
<div class="sourceCode" id="cb32" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 훈련 데이터에 없는 단어 (OOV)</span></span>
<span id="cb32-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"사과"</span> → [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, ...]  ✓ (학습됨)</span>
<span id="cb32-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"사과들"</span> → ???  ✗ (학습 안됨)</span>
<span id="cb32-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"사과나무"</span> → ???  ✗ (학습 안됨)</span></code></pre></div></li>
<li><p>한국어의 특별한 어려움:</p>
<pre><code>"먹다" → "먹는다", "먹었다", "먹고", "먹어서", "먹지만", ...
수천 가지 변형이 가능하지만 모두 같은 어근 "먹"을 공유</code></pre></li>
<li><p>FastText의 해결책: Subword 분해</p>
<ul>
<li>Character n-gram 분해
<ul>
<li>예시: “사과” (n=2,3으로 설정)</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb34" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"사과"</span> 분해:</span>
<span id="cb34-2"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>gram: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;사"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"과&gt;"</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># &lt;, &gt;는 단어 경계 표시</span></span>
<span id="cb34-3"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>gram: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;사과"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과&gt;"</span></span>
<span id="cb34-4"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> 전체 단어: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과"</span></span>
<span id="cb34-5"></span>
<span id="cb34-6">최종 n<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>gram 집합: {<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;사"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"과&gt;"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;사과"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과&gt;"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과"</span>}</span></code></pre></div></li>
<li><p>벡터 표현</p>
<ul>
<li><p>기존 Word2Vec:</p>
<div class="sourceCode" id="cb35" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1">vector(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> lookup_table[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과"</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 하나의 벡터</span></span></code></pre></div></li>
<li><p>FastText:</p>
<div class="sourceCode" id="cb36" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1">vector(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> vector(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;사"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> vector(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> vector(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"과&gt;"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> </span>
<span id="cb36-2">    vector(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;사과"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> vector(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과&gt;"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> vector(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과"</span>)</span>
<span id="cb36-3">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># n-gram 벡터들의 합</span></span></code></pre></div></li>
</ul></li>
<li><p>OOV 문제 해결 과정</p>
<ul>
<li>새로운 단어 처리</li>
</ul>
<div class="sourceCode" id="cb37" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 훈련 시 보지 못한 단어: "사과나무"</span></span>
<span id="cb37-2"></span>
<span id="cb37-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1단계: n-gram 분해</span></span>
<span id="cb37-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"사과나무"</span> → {<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;사"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"과나"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나무"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"무&gt;"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;사과"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과나"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"과나무"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나무&gt;"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과나무"</span>}</span>
<span id="cb37-5"></span>
<span id="cb37-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2단계: 학습된 n-gram 벡터 찾기</span></span>
<span id="cb37-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"&lt;사"</span>: [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, ...]     ✓ (있음)</span>
<span id="cb37-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"사과"</span>: [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, ...]    ✓ (있음)  </span>
<span id="cb37-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"과나"</span>: [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span>, ...]    ✗ (없음 → <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">벡터</span>)</span>
<span id="cb37-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"나무"</span>: [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, ...]    ✓ (있음)</span>
<span id="cb37-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"무&gt;"</span>: [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, ...]     ✓ (있음)</span>
<span id="cb37-12"></span>
<span id="cb37-13"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3단계: 합계 계산</span></span>
<span id="cb37-14">vector(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과나무"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">sum</span>(존재하는_ngram_벡터들) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> 개수</span></code></pre></div>
<ul>
<li>결과: “사과나무”는 “사과”와 “나무”의 의미를 모두 반영한 벡터를 얻음!</li>
</ul></li>
<li><p>형태학적 정보 포착</p>
<ul>
<li>한국어 예시</li>
</ul>
<div class="sourceCode" id="cb38" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1">훈련 데이터:</span>
<span id="cb38-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"먹는다"</span> → {<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;먹"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"먹는"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"는다"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"다&gt;"</span>, ...}</span>
<span id="cb38-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"먹었다"</span> → {<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;먹"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"먹었"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"었다"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"다&gt;"</span>, ...}  </span>
<span id="cb38-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"먹고"</span> → {<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;먹"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"먹고"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"고&gt;"</span>, ...}</span>
<span id="cb38-5"></span>
<span id="cb38-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 공통 n-gram "&lt;먹", "먹"이 반복 학습됨</span></span>
<span id="cb38-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># → "먹" 관련 의미가 강화됨</span></span>
<span id="cb38-8"></span>
<span id="cb38-9">새로운 단어 <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"먹거나"</span>:</span>
<span id="cb38-10">{<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;먹"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"먹거"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"거나"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나&gt;"</span>, ...}</span>
<span id="cb38-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "&lt;먹" n-gram을 통해 "먹다"와 관련된 의미를 자동으로 얻음!</span></span></code></pre></div>
<ul>
<li>영어 예시</li>
</ul>
<div class="sourceCode" id="cb39" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"running"</span> ↔ <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"run"</span></span>
<span id="cb39-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"running"</span> → {<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ru"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"un"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"nn"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ni"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"in"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ng"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"run"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"unn"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"nni"</span>, ...}</span>
<span id="cb39-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"run"</span> → {<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ru"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"un"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"run"</span>, ...}</span>
<span id="cb39-4"></span>
<span id="cb39-5">공통 부분: {<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ru"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"un"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"run"</span>}을 통해 관계 학습</span></code></pre></div></li>
<li><p>실제 성능 비교</p>
<ul>
<li>한국어 형태소 분석 없이도 효과적</li>
<li><strong>Word2Vec</strong>:</li>
</ul>
<div class="sourceCode" id="cb40" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"좋다"</span>: [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, ...]</span>
<span id="cb40-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"좋은"</span>: ??? (없으면 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>UNK<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span>)</span>
<span id="cb40-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"좋아서"</span>: ??? (없으면 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>UNK<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span>)</span></code></pre></div>
<ul>
<li><strong>FastText</strong>:</li>
</ul>
<div class="sourceCode" id="cb41" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"좋다"</span>: [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, ...]</span>
<span id="cb41-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"좋은"</span>: [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.18</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.38</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.12</span>, ...]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "좋" n-gram으로 유추</span></span>
<span id="cb41-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"좋아서"</span>: [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.19</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.39</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.11</span>, ...]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "좋" n-gram으로 유추</span></span></code></pre></div>
<ul>
<li>결과: 형태소 분석기 없이도 어근의 의미를 공유하는 벡터들을 얻을 수 있음!</li>
<li>Trade-off:
<ul>
<li>장점: OOV 해결, 형태학적 정보 포착</li>
<li>단점: n-gram 개수만큼 파라미터 증가</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>Word2Vec: 단어 수 × 벡터 차원</p></li>
<li><p>FastText: (단어 수 + 모든_ngram_수) × 벡터 차원</p></li>
</ul>
<p><strong>실용적 해결책</strong>: 빈도가 낮은 n-gram은 제외하여 크기 조절</p>
</section>
</section>
<section id="결론" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="결론"><span class="header-section-number">2.1</span> 결론</h2>
<p>본 문서에서는 자연어 처리(NLP) 분야에서 텍스트 데이터의 의미를 효과적으로 포착하기 위해 통계 기반 방법의 한계를 넘어, 신경망은 단어와 문맥의 복잡한 관계를 학습하여 풍부한 정보를 담은 벡터 표현을 생성한다.</p>
<ul>
<li><strong>워드 임베딩의 발전</strong>:
<ul>
<li><strong>정적 임베딩 (Word2Vec, GloVe, FastText)</strong>: ’분포 가설’에 기반하여 단어를 저차원 밀집 벡터로 표현함으로써 단어 간 의미적 유사성과 관계(예: 유추)를 포착했다. <code>Embedding Layer</code>는 이러한 변환의 핵심이며, FastText는 하위 단어(subword) 정보를 활용하여 OOV 문제와 형태론적 특징 처리에 강점을 보였다.</li>
<li>이러한 초기 신경망 기반 방법들은 단어의 의미를 고정된 벡터로 표현하여 NLP 성능을 크게 향상시켰다.</li>
</ul></li>
<li><strong>벡터화 방법 선택의 중요성</strong>:
<ul>
<li>단순한 단어 유사도 측정부터 복잡한 문서 이해 및 생성에 이르기까지, 해결하고자 하는 문제의 특성, 데이터의 규모와 성격, 그리고 사용하려는 모델의 요구사항을 종합적으로 고려하여 적절한 벡터화 전략을 선택하는 것이 중요하다.</li>
<li>이러한 신경망 기반 벡터화 기법들은 현대 대규모 언어 모델(LLM) 발전의 핵심적인 토대가 되었으며, 자연어 이해 및 생성 능력의 비약적인 발전을 이끌고 있다.</li>
</ul></li>
</ul>


</section>
</section>

 ]]></description>
  <category>NLP</category>
  <category>Deep Learning</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Deep_Learning/NLP/4-2.pre_prcs_vectorization.html</guid>
  <pubDate>Sun, 05 Jan 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>텍스트 벡터화: 신경망 기반 방법론</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Deep_Learning/NLP/4-3.pre_prcs_vectorization.html</link>
  <description><![CDATA[ 




<section id="요약" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 요약</h1>
<p>이 문서는 단어의 의미가 문맥에 따라 변하는 현상을 효과적으로 다루기 위해 등장한 <strong>동적/문맥적 임베딩(Contextualized Embedding)</strong> 방법론을 탐구한다. 정적 임베딩의 한계를 지적하고, 이를 극복하기 위한 주요 모델들의 핵심 아이디어와 특징을 소개한다.</p>
<p>주요 내용은 다음과 같다.</p>
<ul>
<li><strong>정적 임베딩 vs.&nbsp;동적 임베딩</strong>:
<ul>
<li>정적 임베딩(예: Word2Vec, GloVe)은 단어마다 고정된 벡터를 할당하여 문맥에 따른 의미 변화(다의성)를 포착하지 못하는 한계가 있다.</li>
<li>동적 임베딩은 동일한 단어라도 문맥에 따라 다른 벡터 표현을 생성하여 이러한 문제를 해결한다.</li>
</ul></li>
<li><strong>주요 문맥 기반 임베딩 모델</strong>:
<ul>
<li><strong>ELMo (Embeddings from Language Models)</strong>: 양방향 LSTM(BiLSTM)의 각 계층에서 얻은 내부 상태들을 가중합하여 문맥 정보를 풍부하게 담은 임베딩을 생성한다. 문자 단위 표현부터 시작하여 다양한 수준의 정보를 결합한다.</li>
<li><strong>BERT (Bidirectional Encoder Representations from Transformers)</strong>: 트랜스포머(Transformer)의 인코더 구조를 활용하여 문장 내 모든 단어의 양방향 문맥을 동시에 고려한다. ’Masked Language Model(MLM)’과 ’Next Sentence Prediction(NSP)’이라는 두 가지 혁신적인 사전 학습(pre-training) 목표를 통해 깊은 언어 이해 능력을 학습한다. 문서 전체의 표현으로는 <code>[CLS]</code> 토큰의 출력을 사용하거나 토큰 출력들의 풀링(pooling) 결과를 활용한다.</li>
<li><strong>SBERT (Sentence-BERT)</strong>: BERT의 출력을 문장 수준의 의미론적 벡터로 효율적으로 변환하기 위해 Siamese 또는 Triplet 네트워크 구조를 사용한다. 이를 통해 문장 간 유사도 계산 및 대규모 검색 작업의 효율성을 크게 향상시킨다.</li>
<li><strong>GPT (Generative Pre-trained Transformer)</strong>: 트랜스포머의 디코더 구조를 기반으로 하는 단방향(autoregressive) 언어 모델이다. 이전 단어들을 바탕으로 다음 단어를 예측하도록 학습하며, 이 과정에서 문맥을 이해하고 생성하는 능력을 키운다. 특히, 가중치 업데이트 없이 프롬프트에 몇 가지 예시(few-shot)를 제공하는 것만으로 새로운 작업을 수행하는 ‘In-context Learning’ 능력으로 주목받았다. 문서 표현으로는 첫 번째 토큰([BOS])의 출력을 활용하기도 한다.</li>
</ul></li>
<li><strong>실용적 응용 및 평가</strong>:
<ul>
<li>이러한 모델들은 문서 분류, 정보 검색, 질의응답, 기계 번역 등 다양한 NLP 태스크에서 혁신적인 성능 향상을 가져왔다.</li>
<li>모델 평가는 단어 유사도나 관계 유추 같은 내재적 평가(intrinsic evaluation)와 실제 다운스트림 태스크에서의 성능을 측정하는 외재적 평가(extrinsic evaluation)로 이루어진다.</li>
</ul></li>
</ul>
<p>이 문서를 통해 독자는 문맥을 이해하는 동적 임베딩 기술의 발전 과정과 핵심 원리를 파악하고, 다양한 NLP 문제 해결에 이를 어떻게 활용할 수 있는지에 대한 통찰을 얻을 수 있다.</p>
</section>
<section id="텍스트-인코딩-및-벡터화" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 텍스트 인코딩 및 벡터화</h1>
<p>텍스트 벡터화</p>
<pre><code>├── 전통적 방법 (통계 기반)
│   ├── DTM (Document Term Matrix)
│   ├── BoW (Bag of Words)  
│   └── TF-IDF
└── 신경망 기반 방법
    ├── Embedding Layer (핵심 구성 요소)
    └── 구체적 모델들
        ├── Word2Vec (CBOW, Skip-gram)
        ├── GloVe
        ├── FastText
        └── 문맥 기반 모델 (BERT, GPT 등)</code></pre>
<section id="문맥을-고려한-벡터화-2018-현재" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="문맥을-고려한-벡터화-2018-현재"><span class="header-section-number">2.1</span> 문맥을 고려한 벡터화 (2018-현재)</h2>
<section id="정적-vs-동적-임베딩" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="정적-vs-동적-임베딩"><span class="header-section-number">2.1.1</span> 정적 vs 동적 임베딩</h3>
<ul>
<li>문제 상황: 동음이의어와 다의어
<ul>
<li><strong>영어 예시: “bank”</strong></li>
</ul>
<pre><code>문장1: "I went to the bank to deposit money"  (은행)
문장2: "The river bank was muddy"            (강둑)</code></pre>
<ul>
<li><strong>한국어 예시: “배”</strong></li>
</ul>
<pre><code>문장1: "배가 고파서 밥을 먹었다"  (배 = 위장)
문장2: "배를 타고 바다에 나갔다"  (배 = 선박)  
문장3: "달콤한 배를 먹었다"      (배 = 과일)</code></pre></li>
<li>정적 임베딩의 한계
<ul>
<li><strong>Word2Vec/GloVe 방식:</strong>
<ul>
<li>서로 다른 의미임에도 같은 벡터 사용</li>
<li>문맥 정보를 활용하지 못함</li>
<li>의미 구분이 불가능</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 단어별로 고정된 하나의 벡터만 존재</span></span>
<span id="cb4-2">embedding_table <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {</span>
<span id="cb4-3">   <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"bank"</span>: [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, ...],  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 항상 같은 벡터</span></span>
<span id="cb4-4">   <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"배"</span>: [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>, ...],    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 항상 같은 벡터</span></span>
<span id="cb4-5">}</span>
<span id="cb4-6"></span>
<span id="cb4-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 문맥에 관계없이 항상 같은 벡터 반환</span></span>
<span id="cb4-8">vector_bank_1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> embedding_table[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"bank"</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 은행 문맥</span></span>
<span id="cb4-9">vector_bank_2 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> embedding_table[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"bank"</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 강둑 문맥</span></span>
<span id="cb4-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># vector_bank_1 == vector_bank_2 (문제!)</span></span></code></pre></div></li>
<li>동적 임베딩의 해결책
<ul>
<li><strong>BERT/ELMo 방식:</strong></li>
</ul>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 같은 단어라도 문맥에 따라 다른 벡터 생성</span></span>
<span id="cb5-2">sentence1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"I went to the bank to deposit money"</span></span>
<span id="cb5-3">sentence2 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"The river bank was muddy"</span></span>
<span id="cb5-4"></span>
<span id="cb5-5">vector_bank_1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> contextual_embedding(sentence1, word_position<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>)  </span>
<span id="cb5-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># → [0.8, 0.2, -0.1, ...]  (은행 의미)</span></span>
<span id="cb5-7"></span>
<span id="cb5-8">vector_bank_2 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> contextual_embedding(sentence2, word_position<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)  </span>
<span id="cb5-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># → [-0.3, 0.9, 0.4, ...]  (강둑 의미)</span></span>
<span id="cb5-10"></span>
<span id="cb5-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># vector_bank_1 ≠ vector_bank_2 (해결!)</span></span></code></pre></div></li>
</ul>
</section>
<section id="주요-모델별-분석" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="주요-모델별-분석"><span class="header-section-number">2.1.2</span> 주요 모델별 분석</h3>
<section id="rnn-recurrent-neural-network" class="level4" data-number="2.1.2.1">
<h4 data-number="2.1.2.1" class="anchored" data-anchor-id="rnn-recurrent-neural-network"><span class="header-section-number">2.1.2.1</span> RNN (Recurrent Neural Network)</h4>
<ul>
<li>FFNN(Feed Forward Neural Network): 행렬과 벡터 연산으로 이루어진다.</li>
<li>RNN: 행렬과 벡터 연산 + 자기 자신의 출력을 다시 입력으로 사용한다.
<ul>
<li>연속적인 시퀀스를 처리하기 위한 신경망</li>
<li>사람은 이전 단어들에 대한 이해를 바탕으로 다음 단어를 이해한다.</li>
<li>기존의 MLP에 비해서 RNN은 이러한 이슈를 다루며, 내부에 정보를 지속하는 루프로 구성된 신경망</li>
<li>단순한 행렬과 벡터 연산을 넘어, <strong>이전 시점의 은닉 상태(hidden state)를 현재 시점의 입력으로 다시 활용</strong>하는 순환 구조</li>
<li>이러한 “기억” 메커니즘 덕분에 RNN은 시간의 흐름에 따른 연속적인 데이터(시퀀스 데이터) 처리에 매우 효과적</li>
<li><strong>핵심 원리</strong>: 신경망 내부에 루프(loop)를 만들어 정보가 지속되도록 함으로써, 마치 사람이 이전 대화 내용을 기억하며 다음 문장을 이해하는 것과 유사한 방식으로 작동</li>
<li>RNN은 입력의 길이만큼 신경망이 펼쳐진다. (unrolled)</li>
<li>이때, 입력 받는 각 순간을 시점(time step)이라고 한다.</li>
<li>시점 <img src="https://latex.codecogs.com/png.latex?t"> 에서 입력 <img src="https://latex.codecogs.com/png.latex?x_t"> 와 이전 시점의 은닉 상태 <img src="https://latex.codecogs.com/png.latex?h_%7Bt-1%7D"> 을 받아 현재 시점의 은닉 상태 <img src="https://latex.codecogs.com/png.latex?h_t"> 를 계산</li>
<li>매시점마다 새로운 입력값을 받고 은닉층에서 이전 시점의 정보를 다음 시점의 은닉층에 전달하는데 이것을 시간순대로 쭉 나열하여 도식화하면 그림이 너무 길어져 은닉층을 하나의 loop형태로 표현한다.</li>
<li>RNN은 FFNN (or MLP)에 시점을 도입한 개념과 같다.</li>
<li>RNN의 입력과 출력은 모두 기본적으로 벡터 단위를 가정한다. 따라서, 일반 RNN다이어 그램에선 입력층, 은닉층과 출력층이 소문자로 되어 있지만 모두 벡터라고 생각해야한다.</li>
<li>NLP에서 각 시점(time step)은 주로 단어 하나 (단어 벡터값) 또는 형태소 (한국어) 하나가 (형태소 벡터)가 된다.</li>
</ul></li>
<li>RNN의 설계
<ul>
<li>RNN의 구조는 설계하기 나름이지만 다음과 같은 유형을 갖는다.</li>
<li>One to Many
<ul>
<li>Image Captioning</li>
<li>이미지를 첫 시점에서 입력받아 각 시점에서 출력</li>
</ul></li>
<li>Many to One
<ul>
<li>단어를 각 시점에서 입력받아 맨 마지막 시점의 은닉 상태를 출력</li>
<li>Text Classification
<ul>
<li>단어들을 입력 받아 이것이 스펨메일인지 아닌지 맨 마지막 시점에서 분류</li>
</ul></li>
</ul></li>
<li>Many to Many
<ul>
<li>각 시점에서 입력받은 단어를 각 시점에서 출력</li>
<li>Name Entity Recognition</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="elmo-embeddings-from-language-models-2018" class="level4" data-number="2.1.2.2">
<h4 data-number="2.1.2.2" class="anchored" data-anchor-id="elmo-embeddings-from-language-models-2018"><span class="header-section-number">2.1.2.2</span> ELMo (Embeddings from Language Models, 2018)</h4>
<ul>
<li>양방향 LSTM 기반</li>
<li>문맥화된 표현: <img src="https://latex.codecogs.com/png.latex?%5Ctext%7BELMo%7D_k%5E%7Btask%7D%20=%20%5Cgamma%5E%7Btask%7D%20%5Csum_%7Bj=0%7D%5EL%20s_j%5E%7Btask%7D%20%5Cmathbf%7Bh%7D_%7Bk,j%7D%5E%7BLM%7D"></li>
<li>여기서 <img src="https://latex.codecogs.com/png.latex?s_j%5E%7Btask%7D">는 학습 가능한 가중치, <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bh%7D_%7Bk,j%7D%5E%7BLM%7D">는 각 레이어의 hidden state</li>
<li>핵심 아이디어
<ul>
<li><strong>“언어 모델의 내부 표현을 임베딩으로 사용하자”</strong></li>
</ul></li>
<li>기본 구조</li>
</ul>
<pre><code>입력 문장: "The bank was closed"

Forward LSTM:  [The] → [bank] → [was] → [closed]
Backward LSTM: [closed] ← [was] ← [bank] ← [The]</code></pre>
<ul>
<li>ELMo 수식: <img src="https://latex.codecogs.com/png.latex?%5Ctext%7BELMo%7D_k%5E%7Btask%7D%20=%20%5Cgamma%5E%7Btask%7D%20%5Csum_%7Bj=0%7D%5EL%20s_j%5E%7Btask%7D%20%5Cmathbf%7Bh%7D_%7Bk,j%7D%5E%7BLM%7D">
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bh%7D_%7Bk,j%7D%5E%7BLM%7D">: 각 레이어의 hidden state</strong></li>
</ul>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 예시: 3층 BiLSTM에서 "bank" 단어 (k번째 위치)</span></span>
<span id="cb7-2">h_{bank,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>} <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> character_embedding(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"bank"</span>)     <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 레이어 0 (입력)</span></span>
<span id="cb7-3">h_{bank,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>} <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> first_LSTM_layer_output        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 레이어 1  </span></span>
<span id="cb7-4">h_{bank,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>} <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> second_LSTM_layer_output       <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 레이어 2</span></span>
<span id="cb7-5">h_{bank,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>} <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> third_LSTM_layer_output        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 레이어 3 (최상위)</span></span></code></pre></div>
<ul>
<li><strong><img src="https://latex.codecogs.com/png.latex?s_j%5E%7Btask%7D">: 학습 가능한 가중치</strong>
<ul>
<li>각 레이어의 중요도를 태스크별로 학습</li>
<li>문법적 태스크 → 낮은 레이어 중시</li>
<li>의미적 태스크 → 높은 레이어 중시</li>
</ul></li>
<li><strong><img src="https://latex.codecogs.com/png.latex?%5Cgamma%5E%7Btask%7D">: 전체 스케일 조정</strong>
<ul>
<li>ELMo 벡터의 전체적인 크기 조정</li>
</ul></li>
</ul></li>
<li>계산 예시</li>
</ul>
<div class="sourceCode" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "bank" 단어의 ELMo 벡터 (감정 분석 태스크)</span></span>
<span id="cb8-2">h_0 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 문자 레벨</span></span>
<span id="cb8-3">h_1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 낮은 레벨 (문법적)  </span></span>
<span id="cb8-4">h_2 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.9</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 높은 레벨 (의미적)</span></span>
<span id="cb8-5"></span>
<span id="cb8-6">s_0 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 문자 레벨 가중치 (낮음)</span></span>
<span id="cb8-7">s_1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 문법 레벨 가중치  </span></span>
<span id="cb8-8">s_2 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 의미 레벨 가중치 (높음)</span></span>
<span id="cb8-9"></span>
<span id="cb8-10">ELMo_bank <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> γ × (s_0×h_0 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> s_1×h_1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> s_2×h_2)</span>
<span id="cb8-11">          <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">2.0</span> × (<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>×[<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>,<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>,<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>×[<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>,<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>,<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span>×[<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>,<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>,<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.9</span>])</span>
<span id="cb8-12">          <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">2.0</span> × [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.55</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.65</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.75</span>]</span>
<span id="cb8-13">          <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.3</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1.5</span>]</span></code></pre></div>
<ul>
<li>양방향 정보의 중요성
<ul>
<li><strong>Forward만 사용할 경우:</strong></li>
</ul>
<pre><code>"The bank was closed because of ___"
→ "bank"를 이해할 때 "The"만 참고</code></pre>
<ul>
<li><strong>Backward까지 사용할 경우:</strong></li>
</ul>
<pre><code>"The bank was closed because of ___"
→ "bank"를 이해할 때 "was closed" 정보도 참고
→ 금융 기관으로 해석 가능성 증가</code></pre></li>
</ul>
</section>
<section id="bert-bidirectional-encoder-representations-from-transformers-2018" class="level4" data-number="2.1.2.3">
<h4 data-number="2.1.2.3" class="anchored" data-anchor-id="bert-bidirectional-encoder-representations-from-transformers-2018"><span class="header-section-number">2.1.2.3</span> BERT (Bidirectional Encoder Representations from Transformers, 2018)</h4>
<ul>
<li>양방향 문맥 동시 고려
<ul>
<li>15% 단어를 마스킹하여 예측</li>
<li>문장 간 관계 학습</li>
</ul></li>
<li><strong>핵심 혁신:</strong>
<ul>
<li><strong>Transformer 기반</strong>: 양방향 문맥 동시 고려
<ul>
<li><p><strong>기존 RNN의 한계:</strong></p>
<div class="sourceCode" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># RNN은 순차적 처리 (병렬화 어려움)</span></span>
<span id="cb11-2">h_1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> RNN(x_1)</span>
<span id="cb11-3">h_2 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> RNN(x_2, h_1)      <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># h_1이 완료되어야 시작 가능</span></span>
<span id="cb11-4">h_3 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> RNN(x_3, h_2)      <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># h_2가 완료되어야 시작 가능</span></span></code></pre></div></li>
<li><p><strong>Transformer의 장점:</strong></p>
<div class="sourceCode" id="cb12" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 모든 위치를 동시에 처리 (병렬화 가능)</span></span>
<span id="cb12-2">attention_weights <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> compute_attention(all_words)</span>
<span id="cb12-3">all_representations <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> apply_attention(all_words, attention_weights)</span></code></pre></div></li>
</ul></li>
<li><strong>Masked Language Model</strong>: 15% 단어를 마스킹하여 예측
<ul>
<li>BERT의 핵심 학습 방법
<ul>
<li><strong>기본 아이디어</strong>: 일부 단어를 숨기고 맞추게 하기</li>
</ul>
<div class="sourceCode" id="cb13" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 원본 문장</span></span>
<span id="cb13-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"나는 [MASK]를 좋아한다"</span></span>
<span id="cb13-3"></span>
<span id="cb13-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 모델이 학습하는 것</span></span>
<span id="cb13-5">P(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나는 [MASK]를 좋아한다"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span></span>
<span id="cb13-6">P(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"바나나"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나는 [MASK]를 좋아한다"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>  </span>
<span id="cb13-7">P(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"컴퓨터"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나는 [MASK]를 좋아한다"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.01</span></span></code></pre></div>
<ul>
<li><strong>15% 마스킹 전략:</strong></li>
</ul>
<div class="sourceCode" id="cb14" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1">입력 문장의 <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> 단어에 대해:</span>
<span id="cb14-2"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">80</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span>: [MASK] 토큰으로 교체</span>
<span id="cb14-3"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span>: 랜덤한 다른 단어로 교체  </span>
<span id="cb14-4"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span>: 원래 단어 그대로 유지</span></code></pre></div>
<ul>
<li><p><strong>왜 이렇게 하는가?</strong> ```python # 80% [MASK]: 메인 학습 목적 “나는 [MASK]를 좋아한다”</p>
<p># 10% 랜덤 교체: 노이즈에 강한 표현 학습 “나는 컴퓨터를 좋아한다” # 원래는 “사과”</p>
<p># 10% 원본 유지: 실제 사용 시와 동일한 조건 “나는 사과를 좋아한다” ```</p></li>
</ul></li>
</ul></li>
<li><strong>Next Sentence Prediction</strong>: 문장 간 관계 학습</li>
</ul>
<div class="sourceCode" id="cb15" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 실제 연속된 문장 (Positive)</span></span>
<span id="cb15-2">문장A: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나는 아침에 일어났다"</span></span>
<span id="cb15-3">문장B: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"그리고 아침 식사를 했다"</span></span>
<span id="cb15-4">Label: IsNext <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span></span>
<span id="cb15-5"></span>
<span id="cb15-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 랜덤하게 조합된 문장 (Negative)  </span></span>
<span id="cb15-7">문장A: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나는 아침에 일어났다"</span></span>
<span id="cb15-8">문장B: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"축구는 재미있는 스포츠다"</span></span>
<span id="cb15-9">Label: IsNext <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span></span></code></pre></div></li>
<li><strong>BERT의 문서 벡터화 방법:</strong>
<ul>
<li><strong>[CLS] 토큰</strong>: 문장/문서 전체 표현</li>
</ul>
<div class="sourceCode" id="cb16" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1">입력: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"[CLS] 문장 내용 [SEP]"</span></span>
<span id="cb16-2">출력: [CLS]_벡터가 전체 문장의 의미를 담음</span>
<span id="cb16-3"></span>
<span id="cb16-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 예시</span></span>
<span id="cb16-5">input_tokens <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"[CLS]"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나는"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과를"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"좋아한다"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"[SEP]"</span>]</span>
<span id="cb16-6">bert_output <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> bert_model(input_tokens)</span>
<span id="cb16-7">sentence_vector <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> bert_output[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [CLS] 위치의 벡터</span></span></code></pre></div>
<ul>
<li><strong>Pooling 전략</strong>:
<ul>
<li>Mean pooling: <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bi=1%7D%5En%20%5Cmathbf%7Bh%7D_i"></li>
<li>Max pooling: <img src="https://latex.codecogs.com/png.latex?%5Cmax(%5Cmathbf%7Bh%7D_1,%20...,%20%5Cmathbf%7Bh%7D_n)"></li>
</ul>
<div class="sourceCode" id="cb17" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 모든 토큰의 BERT 출력</span></span>
<span id="cb17-2">token_representations <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [</span>
<span id="cb17-3">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>],  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [CLS]</span></span>
<span id="cb17-4">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span>],  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "나는"  </span></span>
<span id="cb17-5">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.9</span>],  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "사과를"</span></span>
<span id="cb17-6">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>],  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "좋아한다"</span></span>
<span id="cb17-7">   [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>],  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [SEP]</span></span>
<span id="cb17-8">]</span>
<span id="cb17-9"></span>
<span id="cb17-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Mean Pooling</span></span>
<span id="cb17-11">mean_vector <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> mean(token_representations[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>])  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [CLS], [SEP] 제외</span></span>
<span id="cb17-12"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.2</span>)<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, (<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.5</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.3</span>)<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>, (<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.6</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.9</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.4</span>)<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span></span>
<span id="cb17-13"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.43</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.53</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.63</span>]</span>
<span id="cb17-14"></span>
<span id="cb17-15"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Max Pooling  </span></span>
<span id="cb17-16">max_vector <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>(token_representations[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>])  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 각 차원별 최댓값</span></span>
<span id="cb17-17"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.7</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.8</span>, <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.9</span>]</span></code></pre></div></li>
</ul></li>
<li><strong>특징</strong>:
<ul>
<li>단어의 의미적, 문법적 정보를 벡터 공간에 학습.</li>
<li>벡터 간 연산을 통해 단어 간 유사도, 유추 등 관계 표현 가능 (예: “king” - “man” + “woman” ≈ “queen”).</li>
</ul></li>
<li><strong>중요성</strong>: 현대 NLP 딥러닝 모델의 핵심 구성 요소로, 성능 향상에 크게 기여.</li>
</ul>
</section>
<section id="sbert-sentence-bert" class="level4" data-number="2.1.2.4">
<h4 data-number="2.1.2.4" class="anchored" data-anchor-id="sbert-sentence-bert"><span class="header-section-number">2.1.2.4</span> SBERT (Sentence-BERT)</h4>
<ul>
<li><p>최근 가장 보편적인 문장 또는 문서 임베딩 방법으로 SBERT가 이용된다.</p></li>
<li><p>문서의 유사도를 구할 때는 SBERT 사용을 권장</p></li>
<li><p>문장 벡터화 전략</p>
<ul>
<li>문장 간 유사도 계산</li>
<li>문장 간 유사도 계산 시 문장 임베딩 사용</li>
</ul></li>
<li><p>기존 BERT의 한계: 문장 유사도 계산의 비효율성</p>
<div class="sourceCode" id="cb18" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1000개 문장의 유사도를 모두 구하려면</span></span>
<span id="cb18-2">sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"문장1"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"문장2"</span>, ..., <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"문장1000"</span>]</span>
<span id="cb18-3"></span>
<span id="cb18-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 기존 BERT 방식 (비효율적)</span></span>
<span id="cb18-5"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span>):</span>
<span id="cb18-6">   <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> j <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span>):</span>
<span id="cb18-7">      combined <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"[CLS] </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>sentences[i]<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;"> [SEP] </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>sentences[j]<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;"> [SEP]"</span></span>
<span id="cb18-8">      similarity <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> bert_classifier(combined)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 매번 BERT 실행</span></span>
<span id="cb18-9"></span>
<span id="cb18-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 총 계산 횟수: 1000 × 999 / 2 = 499,500번!</span></span></code></pre></div>
<ul>
<li>BERT로 문장 유사도를 계산하려면:
<ul>
<li>두 문장을 [SEP]로 연결</li>
<li>BERT에 입력하여 분류</li>
<li><img src="https://latex.codecogs.com/png.latex?O(n%5E2)"> 시간 복잡도 (n개 문장 비교 시)</li>
</ul></li>
</ul></li>
<li><p>SBERT의 해결책: Siamese Network 구조</p></li>
</ul>
<div class="sourceCode" id="cb19" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># SBERT 방식 (효율적)</span></span>
<span id="cb19-2"></span>
<span id="cb19-3">문장 A → BERT → Pooling → Vector A</span>
<span id="cb19-4">문장 B → BERT → Pooling → Vector B</span>
<span id="cb19-5">유사도 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> cosine_similarity(Vector A, Vector B)</span>
<span id="cb19-6"></span>
<span id="cb19-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1단계: 모든 문장을 미리 벡터화</span></span>
<span id="cb19-8">sentence_vectors <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb19-9"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> sentence <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> sentences:</span>
<span id="cb19-10">    vector <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sbert_model(sentence)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 각 문장마다 1번씩만 실행</span></span>
<span id="cb19-11">    sentence_vectors.append(vector)</span>
<span id="cb19-12"></span>
<span id="cb19-13"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2단계: 벡터 간 코사인 유사도로 빠른 계산</span></span>
<span id="cb19-14"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span>):</span>
<span id="cb19-15">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> j <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span>):</span>
<span id="cb19-16">        similarity <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> cosine_similarity(sentence_vectors[i], sentence_vectors[j])</span>
<span id="cb19-17">        </span>
<span id="cb19-18"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 총 SBERT 실행 횟수: 1000번 (대폭 감소!)</span></span></code></pre></div>
<ul>
<li><strong>학습 목적 함수:</strong>
<ul>
<li><strong>Classification</strong>: <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BL%7D%20=%20-%5Csum_%7Bi%7D%20y_i%20%5Clog(%5Ctext%7Bsoftmax%7D(W%5B%5Cmathbf%7Bu%7D;%20%5Cmathbf%7Bv%7D;%20%7C%5Cmathbf%7Bu%7D-%5Cmathbf%7Bv%7D%7C%5D))"></li>
</ul>
<div class="sourceCode" id="cb20" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 두 문장의 SBERT 벡터</span></span>
<span id="cb20-2">u <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sbert(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나는 사과를 좋아한다"</span>)      <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [0.2, 0.4, 0.1, ...]</span></span>
<span id="cb20-3">v <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sbert(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나는 바나나를 좋아한다"</span>)    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [0.3, 0.5, 0.2, ...]</span></span>
<span id="cb20-4"></span>
<span id="cb20-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 특성 벡터 구성</span></span>
<span id="cb20-6">concat <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [u<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span> v]                    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 연결: [0.2, 0.4, 0.1, 0.3, 0.5, 0.2, ...]</span></span>
<span id="cb20-7">abs_diff <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span>u <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span>                <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 절댓값 차이: [0.1, 0.1, 0.1, ...]</span></span>
<span id="cb20-8">features <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [u<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span> v<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">;</span> abs_diff]        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 최종 특성 벡터</span></span>
<span id="cb20-9"></span>
<span id="cb20-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 분류 (유사/비유사)</span></span>
<span id="cb20-11">logits <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> W <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">@</span> features <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> b</span>
<span id="cb20-12">probability <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> softmax(logits)</span>
<span id="cb20-13">loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> cross_entropy(probability, true_label)</span></code></pre></div>
<ul>
<li><strong>Regression</strong>: <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BL%7D%20=%20%5Ctext%7BMSE%7D(%5Ctext%7Bcosine%5C_sim%7D(%5Cmathbf%7Bu%7D,%20%5Cmathbf%7Bv%7D),%20%5Ctext%7Blabel%7D)"></li>
</ul>
<div class="sourceCode" id="cb21" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 예측 유사도</span></span>
<span id="cb21-2">predicted_sim <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> cosine_similarity(u, v) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.85</span></span>
<span id="cb21-3"></span>
<span id="cb21-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 실제 라벨 (0~1 점수)</span></span>
<span id="cb21-5">true_sim <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.9</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 사람이 평가한 유사도</span></span>
<span id="cb21-6"></span>
<span id="cb21-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 손실 계산</span></span>
<span id="cb21-8">loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (predicted_sim <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> true_sim)² <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> (<span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.85</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.9</span>)² <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0025</span></span></code></pre></div></li>
<li><strong>성능 개선:</strong>
<ul>
<li>시간 복잡도: <img src="https://latex.codecogs.com/png.latex?O(n%5E2)%20%5Crightarrow%20O(n)"></li>
</ul>
<div class="sourceCode" id="cb22" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 시간 복잡도 비교</span></span>
<span id="cb22-2">기존_BERT_시간 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> O(n²) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">²</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">000</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">000</span></span>
<span id="cb22-3">SBERT_시간 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> O(n) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span></span>
<span id="cb22-4"></span>
<span id="cb22-5">속도_향상 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">000</span>,<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">000</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">배</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!</span></span></code></pre></div>
<ul>
<li>의미적 유사도 정확도 대폭 향상</li>
<li>대규모 문서 검색 시스템</li>
<li>실시간 문장 유사도 계산</li>
<li>추천 시스템에서의 텍스트 매칭</li>
</ul></li>
</ul>
</section>
<section id="gptgenerative-pre-trained-transformer" class="level4" data-number="2.1.2.5">
<h4 data-number="2.1.2.5" class="anchored" data-anchor-id="gptgenerative-pre-trained-transformer"><span class="header-section-number">2.1.2.5</span> GPT(Generative Pre-trained Transformer)</h4>
<ul>
<li><p>단방향 언어 모델의 핵심 개념</p></li>
<li><p>BERT vs GPT의 근본적 차이</p></li>
<li><p><strong>BERT (양방향)</strong>:</p>
<pre><code>입력: "나는 [MASK]를 좋아한다"
모델이 보는 정보: "나는" + "를 좋아한다" (양쪽 모두)
예측: [MASK] = "사과"</code></pre></li>
<li><p><strong>GPT (단방향)</strong>:</p>
<pre><code>입력: "나는 사과를"
모델이 보는 정보: "나는 사과를" (왼쪽만)
예측: 다음 단어 = "좋아한다"</code></pre></li>
<li><p>왜 단방향일까?</p>
<ul>
<li><p><strong>생성 태스크의 특성</strong>:</p>
<div class="sourceCode" id="cb25" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 실제 텍스트 생성 시</span></span>
<span id="cb25-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"안녕하세요, 오늘 날씨가"</span></span>
<span id="cb25-3">→ 모델: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"좋네요"</span> (미래 정보는 알 수 없음)</span>
<span id="cb25-4"></span>
<span id="cb25-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 만약 양방향이라면?</span></span>
<span id="cb25-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"안녕하세요, 오늘 날씨가 [미래정보] 입니다"</span></span>
<span id="cb25-7">→ 실제 생성 시에는 미래 정보가 없으므로 불일치</span></code></pre></div></li>
</ul></li>
<li><p><strong>GPT의 학습 방식: Autoregressive Language Modeling</strong></p>
<ul>
<li><p>이전 토큰들로 다음 토큰 예측</p></li>
<li><p>수학적 목적 함수: <img src="https://latex.codecogs.com/png.latex?P(%5Ctext%7B%EB%AC%B8%EC%9E%A5%7D)%20=%20%5Cprod_%7Bt=1%7D%5ET%20P(w_t%20%7C%20w_1,%20w_2,%20...,%20w_%7Bt-1%7D)"></p>
<ul>
<li>문장의 확률 = 각 단어가 이전 단어들 조건 하에 나타날 확률의 곱</li>
</ul></li>
<li><p>구체적 학습 예시</p>
<ul>
<li><strong>훈련 문장</strong>: “나는 사과를 좋아한다”</li>
</ul>
<div class="sourceCode" id="cb26" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 학습 데이터 구성</span></span>
<span id="cb26-2">입력 → 정답</span>
<span id="cb26-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"나는"</span> → <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과를"</span></span>
<span id="cb26-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"나는 사과를"</span> → <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"좋아한다"</span>  </span>
<span id="cb26-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"나는 사과를 좋아한다"</span> → <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;끝&gt;"</span></span>
<span id="cb26-6"></span>
<span id="cb26-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 손실 함수</span></span>
<span id="cb26-8">loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>log P(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"사과를"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나는"</span>) </span>
<span id="cb26-9">      <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>log P(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"좋아한다"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나는 사과를"</span>)</span>
<span id="cb26-10">      <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>log P(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;끝&gt;"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"나는 사과를 좋아한다"</span>)</span></code></pre></div></li>
<li><p>Causal Masking (인과 마스킹)</p>
<ul>
<li>Attention에서 미래 정보 차단</li>
</ul>
<div class="sourceCode" id="cb27" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Attention Matrix (4개 단어 예시)</span></span>
<span id="cb27-2">        나는  사과를  좋아한다  <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>끝<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span></span>
<span id="cb27-3">나는     ✓     ✗      ✗      ✗</span>
<span id="cb27-4">사과를    ✓     ✓      ✗      ✗  </span>
<span id="cb27-5">좋아한다  ✓     ✓      ✓      ✗</span>
<span id="cb27-6"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span>끝<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span>     ✓     ✓      ✓      ✓</span>
<span id="cb27-7"></span>
<span id="cb27-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✓: 참고 가능, ✗: 마스킹 (참고 불가)</span></span></code></pre></div></li>
<li><p><strong>코드 구현</strong>:</p>
<div class="sourceCode" id="cb28" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 마스킹 행렬</span></span>
<span id="cb28-2">mask <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> torch.tril(torch.ones(seq_len, seq_len))</span>
<span id="cb28-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 상삼각 부분을 -무한대로 설정</span></span>
<span id="cb28-4">attention_scores.masked_fill_(mask <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>, <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">1e9</span>)</span>
<span id="cb28-5">attention_weights <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> softmax(attention_scores)</span></code></pre></div></li>
</ul></li>
<li><p><strong>첫 번째 토큰을 문서 표현으로 활용</strong></p>
<ul>
<li>정보 흐름의 특성
<ul>
<li>입력: “[BOS] 문장 내용들…”</li>
<li>각 토큰이 보는 정보량</li>
<li>토큰1 ([BOS]): 자기 자신만</li>
<li>토큰2: [BOS] + 토큰2<br>
</li>
<li>토큰3: [BOS] + 토큰2 + 토큰3</li>
</ul></li>
</ul></li>
<li><p><strong>왜 첫 번째 토큰인가?</strong></p>
<ul>
<li>정보 흐름의 특성
<ul>
<li>입력: “[BOS] 문장 내용들…”</li>
<li>각 토큰이 보는 정보량</li>
<li>토큰1 ([BOS]): 자기 자신만</li>
<li>토큰2: [BOS] + 토큰2<br>
</li>
<li>토큰3: [BOS] + 토큰2 + 토큰3</li>
<li>마지막토큰: [BOS] + 전체 문장</li>
<li>역설적으로, [BOS]는 전체 문장을 “예측”해야 하므로</li>
<li>전체 문장 정보를 압축한 표현을 학습하게 됨</li>
</ul></li>
<li>구체적 메커니즘
<ul>
<li>학습 과정에서의 압축</li>
</ul>
<div class="sourceCode" id="cb29" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># GPT가 학습하는 것</span></span>
<span id="cb29-2">P(전체_문장 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span> [BOS]) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> P(w1<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span>[BOS]) × P(w2<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span>[BOS],w1) × ... × P(wn<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">|</span>[BOS],w1,...,wn<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb29-3"></span>
<span id="cb29-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [BOS] 토큰은 "이 문장이 어떤 내용일까?"를 예측해야 함</span></span>
<span id="cb29-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># → 문장의 주제, 감정, 스타일 등을 함축하는 표현을 학습</span></span></code></pre></div></li>
</ul></li>
<li><p><strong>실제 활용 예시</strong>:</p>
<div class="sourceCode" id="cb30" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 문서 분류</span></span>
<span id="cb30-2">document <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"[BOS] 이 영화는 정말 재미있었다. 스토리도 좋고..."</span></span>
<span id="cb30-3">gpt_output <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> gpt_model(document)</span>
<span id="cb30-4">document_vector <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> gpt_output[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [BOS] 위치의 벡터</span></span>
<span id="cb30-5">classification <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> classifier(document_vector)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 긍정/부정 분류</span></span></code></pre></div></li>
<li><p><strong>In-context Learning 심화 분석</strong></p>
<ul>
<li>기존 학습 방식과의 차이
<ul>
<li><p><strong>전통적 학습 (Fine-tuning)</strong>:</p>
<div class="sourceCode" id="cb31" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1단계: 새로운 태스크 데이터로 모델 가중치 업데이트</span></span>
<span id="cb31-2">model.train()</span>
<span id="cb31-3"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> batch <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> task_data:</span>
<span id="cb31-4">   loss <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> compute_loss(model(batch.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">input</span>), batch.target)</span>
<span id="cb31-5">   loss.backward()</span>
<span id="cb31-6">   optimizer.step()</span>
<span id="cb31-7"></span>
<span id="cb31-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2단계: 추론</span></span>
<span id="cb31-9">prediction <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> model(new_input)</span></code></pre></div></li>
<li><p><strong>In-context Learning</strong>:</p>
<div class="sourceCode" id="cb32" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 가중치 업데이트 없이, 입력에 예시를 포함</span></span>
<span id="cb32-2">context <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"""</span></span>
<span id="cb32-3"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">번역 예시:</span></span>
<span id="cb32-4"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">영어: Hello → 한국어: 안녕하세요</span></span>
<span id="cb32-5"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">영어: Thank you → 한국어: 감사합니다  </span></span>
<span id="cb32-6"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">영어: Good morning → 한국어: 좋은 아침</span></span>
<span id="cb32-7"></span>
<span id="cb32-8"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">영어: How are you? → 한국어:</span></span>
<span id="cb32-9"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"""</span></span>
<span id="cb32-10"></span>
<span id="cb32-11">result <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> gpt_model(context)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># "어떻게 지내세요?" 출력</span></span></code></pre></div></li>
</ul></li>
</ul></li>
<li><p><strong>왜 In-context Learning이 가능한가?</strong></p>
<ul>
<li><p>패턴 인식 능력</p>
<ul>
<li>GPT가 학습 중 본 패턴들</li>
<li>“A는 B이다. C는 D이다. E는” → F 예측</li>
<li>“1+1=2, 2+2=4, 3+3=” → 6 예측</li>
<li>“cat→고양이, dog→개, bird→” → 새 예측</li>
</ul></li>
<li><p>메타 학습 (Learning to Learn)</p>
<div class="sourceCode" id="cb33" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 다양한 패턴을 학습하면서 "학습하는 방법"을 학습</span></span>
<span id="cb33-2">패턴<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>: 번역 (A→B 형태)</span>
<span id="cb33-3">패턴<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>: 수학 (계산 규칙)  </span>
<span id="cb33-4">패턴<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">3</span>: 분류 (라벨링 규칙)</span>
<span id="cb33-5"></span>
<span id="cb33-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 새로운 패턴이 주어져도 빠르게 적응</span></span></code></pre></div></li>
</ul></li>
<li><p><strong>실제 In-context Learning 예시</strong></p>
<ul>
<li><p><strong>감정 분석 태스크</strong>:</p>
<div class="sourceCode" id="cb34" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1">prompt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"""</span></span>
<span id="cb34-2"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">다음은 리뷰와 감정을 분류한 예시입니다:</span></span>
<span id="cb34-3"></span>
<span id="cb34-4"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">리뷰: "이 영화 정말 재미있어요!" 감정: 긍정</span></span>
<span id="cb34-5"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">리뷰: "시간 낭비였습니다." 감정: 부정</span></span>
<span id="cb34-6"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">리뷰: "그냥 그래요." 감정: 중립</span></span>
<span id="cb34-7"></span>
<span id="cb34-8"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">리뷰: "배우들 연기가 훌륭했습니다!" 감정:</span></span>
<span id="cb34-9"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"""</span></span>
<span id="cb34-10"></span>
<span id="cb34-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># GPT 출력: "긍정"</span></span></code></pre></div></li>
<li><p><strong>번역 태스크</strong>:</p>
<div class="sourceCode" id="cb35" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1">prompt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"""</span></span>
<span id="cb35-2"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">English to Korean translation:</span></span>
<span id="cb35-3"></span>
<span id="cb35-4"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">English: I love programming</span></span>
<span id="cb35-5"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">Korean: 나는 프로그래밍을 좋아합니다</span></span>
<span id="cb35-6"></span>
<span id="cb35-7"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">English: The weather is nice today  </span></span>
<span id="cb35-8"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">Korean: 오늘 날씨가 좋네요</span></span>
<span id="cb35-9"></span>
<span id="cb35-10"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">English: What time is it now?</span></span>
<span id="cb35-11"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">Korean:</span></span>
<span id="cb35-12"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"""</span></span>
<span id="cb35-13"></span>
<span id="cb35-14"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># GPT 출력: "지금 몇 시인가요?"</span></span></code></pre></div></li>
</ul></li>
<li><p><strong>GPT 발전사와 특징</strong></p>
<ul>
<li><strong>GPT-1 (2018)</strong>
<ul>
<li>크기: 117M 파라미터</li>
<li>특징: Transformer 디코더만 사용</li>
<li>성능: 간단한 텍스트 생성</li>
</ul></li>
<li><strong>GPT-2 (2019)</strong>
<ul>
<li>크기: 1.5B 파라미터</li>
<li>특징: 스케일 확장의 효과 입증</li>
<li>성능: 일관성 있는 긴 텍스트 생성</li>
</ul></li>
<li><strong>GPT-3 (2020)</strong>
<ul>
<li>크기: 175B 파라미터<br>
</li>
<li>특징: In-context Learning의 강력한 능력</li>
<li>성능: Few-shot Learning으로 다양한 태스크 수행</li>
</ul></li>
<li><strong>GPT-4 (2023)</strong>
<ul>
<li>크기: 공개되지 않음 (추정 수조 개)</li>
<li>특징: 멀티모달 (텍스트 + 이미지)</li>
<li>성능: 인간 수준에 근접한 성능</li>
</ul></li>
</ul></li>
<li><p><strong>GPT vs BERT 비교 정리</strong></p></li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th>측면</th>
<th>GPT</th>
<th>BERT</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>방향성</strong></td>
<td>단방향 (왼쪽→오른쪽)</td>
<td>양방향</td>
</tr>
<tr class="even">
<td><strong>학습 목표</strong></td>
<td>다음 토큰 예측</td>
<td>마스킹된 토큰 예측</td>
</tr>
<tr class="odd">
<td><strong>주요 용도</strong></td>
<td>생성 태스크</td>
<td>이해 태스크</td>
</tr>
<tr class="even">
<td><strong>문서 벡터</strong></td>
<td>첫 번째 토큰</td>
<td>[CLS] 토큰</td>
</tr>
<tr class="odd">
<td><strong>특별 능력</strong></td>
<td>In-context Learning</td>
<td>Fine-tuning 효율성</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>결론</strong>: GPT는 “다음에 올 단어를 예측”하는 단순한 목표로 학습하지만, 이 과정에서 언어의 패턴, 의미, 추론 능력까지 학습하게 되어 강력한 생성 및 추론 모델이 되었다.</li>
</ul>
</section>
</section>
<section id="실용적-응용-및-평가" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="실용적-응용-및-평가"><span class="header-section-number">2.1.3</span> 실용적 응용 및 평가</h3>
<section id="평가-지표" class="level4" data-number="2.1.3.1">
<h4 data-number="2.1.3.1" class="anchored" data-anchor-id="평가-지표"><span class="header-section-number">2.1.3.1</span> 평가 지표</h4>
<p><strong>Intrinsic Evaluation (내재적 평가):</strong> - <strong>단어 유사도</strong>: WordSim-353, SimLex-999 - 사람이 평가한 단어 유사도와 모델 예측의 상관관계 측정 - <strong>단어 관계</strong>: “king - man + woman = queen” - 벡터 연산으로 의미 관계 포착 정도 평가</p>
<p><strong>Extrinsic Evaluation (외재적 평가):</strong> - <strong>문서 분류 정확도</strong>: 실제 분류 태스크에서의 성능 - <strong>정보 검색 성능</strong>: NDCG, MAP - 검색 결과의 관련성 및 순위 정확도 - <strong>의미적 텍스트 유사도</strong>: STS benchmark - 문장 간 의미적 유사성 예측 성능</p>
</section>
<section id="모델-선택-가이드" class="level4" data-number="2.1.3.2">
<h4 data-number="2.1.3.2" class="anchored" data-anchor-id="모델-선택-가이드"><span class="header-section-number">2.1.3.2</span> 모델 선택 가이드</h4>
<ul>
<li><strong>소규모 데이터</strong>: FastText (OOV 처리)</li>
<li><strong>대규모 문서 분류</strong>: BERT fine-tuning</li>
<li><strong>실시간 유사도 계산</strong>: SBERT</li>
<li><strong>창작/생성 태스크</strong>: GPT 계열</li>
</ul>
</section>
<section id="통계적-해석" class="level4" data-number="2.1.3.3">
<h4 data-number="2.1.3.3" class="anchored" data-anchor-id="통계적-해석"><span class="header-section-number">2.1.3.3</span> 통계적 해석</h4>
<p>임베딩 공간에서의 기하학적 관계: <img src="https://latex.codecogs.com/png.latex?%5Ccos(%5Cmathbf%7Bv%7D_%7B%5Ctext%7Bsimilar%20words%7D%7D)%20%3E%20%5Ccos(%5Cmathbf%7Bv%7D_%7B%5Ctext%7Bdissimilar%20words%7D%7D)"></p>
<p><strong>시각화 도구</strong>: t-SNE/UMAP을 통한 의미적 클러스터링 확인</p>
</section>
</section>
</section>
<section id="결론" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="결론"><span class="header-section-number">2.2</span> 결론</h2>
<p>본 문서에서는 단어의 고정된 의미 표현을 넘어, 문맥에 따라 유연하게 변화하는 의미를 포착하는 동적 임베딩 방법론들을 심층적으로 살펴보았다. ELMo에서 시작하여 BERT, GPT, SBERT에 이르기까지, 이러한 문맥 기반 임베딩 모델들은 자연어 처리(NLP) 분야에 혁명적인 발전을 가져왔다.</p>
<p>주요 내용을 다시 한번 정리하면 다음과 같다.</p>
<ul>
<li><p><strong>정적 임베딩의 한계 극복</strong>: 초기의 워드 임베딩(Word2Vec, GloVe 등)은 단어의 의미를 단일 벡터로 표현하여 문맥에 따른 다의성을 반영하지 못했다. 동적 임베딩은 이 한계를 극복하고, 동일한 단어라도 문맥에 따라 다른 벡터 표현을 생성함으로써 보다 정교한 의미 이해를 가능하게 했다.</p></li>
<li><p><strong>주요 모델들의 혁신과 기여</strong>:</p>
<ul>
<li><strong>ELMo</strong>: 양방향 LSTM을 통해 문맥 정보를 통합하고, 여러 계층의 표현을 활용하여 풍부한 임베딩을 제공했다.</li>
<li><strong>BERT</strong>: 트랜스포머 아키텍처와 Masked Language Model, Next Sentence Prediction과 같은 혁신적인 사전 학습 방식을 도입하여 양방향 문맥 이해의 새로운 지평을 열었다. 이는 다양한 NLP 다운스트림 태스크에서 SOTA(State-of-the-Art) 성능을 달성하는 데 크게 기여했다.</li>
<li><strong>GPT</strong>: 단방향 트랜스포머 디코더를 기반으로 강력한 텍스트 생성 능력을 보여주었으며, 특히 GPT-3 이후 모델들은 In-context Learning이라는 새로운 패러다임을 제시하며 모델 활용의 유연성을 크게 확장했다.</li>
<li><strong>SBERT</strong>: 기존 BERT 모델을 문장 임베딩 생성에 효율적으로 사용할 수 있도록 Siamese 및 Triplet 네트워크 구조를 활용하여, 의미적으로 유사한 문장 벡터를 효과적으로 생성하고 문장 간 유사도 비교 작업의 속도와 정확도를 크게 향상시켰다.</li>
</ul></li>
<li><p><strong>패러다임의 전환과 LLM의 토대</strong>: 이러한 문맥 기반 임베딩 모델들의 발전은 단순한 특징 추출기를 넘어, 언어 자체를 깊이 이해하고 생성할 수 있는 대규모 언어 모델(Large Language Models, LLMs) 시대로 나아가는 핵심적인 발판이 되었다. 사전 학습과 미세 조정(fine-tuning) 패러다임, 그리고 최근의 프롬프트 기반 학습은 모델의 활용 범위를 크게 넓혔다.</p></li>
<li><p><strong>적절한 전략 선택의 지속적 중요성</strong>: 해결하고자 하는 특정 문제의 요구사항, 가용 데이터의 특성, 계산 자원 등을 고려하여 가장 적합한 임베딩 전략과 모델을 선택하는 것은 여전히 중요하다. 실용적인 응용을 위해서는 모델의 성능뿐만 아니라 효율성, 해석 가능성 등도 함께 고려해야 한다.</p></li>
</ul>
<p>문맥을 이해하는 텍스트 벡터화 기술은 앞으로도 계속 발전하여, 기계가 인간의 언어를 더욱 정교하게 이해하고 상호작용하는 미래를 앞당길 것이다. 이러한 기술의 발전은 정보 검색, 질의응답, 창작, 교육 등 사회 여러 분야에 걸쳐 혁신적인 변화를 주도할 잠재력을 지니고 있다.</p>


</section>
</section>

 ]]></description>
  <category>NLP</category>
  <category>Deep Learning</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Deep_Learning/NLP/4-3.pre_prcs_vectorization.html</guid>
  <pubDate>Sun, 05 Jan 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>텍스트 인코딩 및 벡터화: NLP 숫자 변환의 모든 것</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Deep_Learning/NLP/4-1.pre_prcs_vectorization.html</link>
  <description><![CDATA[ 




<section id="이-문서-한눈에-보기" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 이 문서 한눈에 보기</h1>
<p>이 문서는 자연어 처리(NLP)를 위해 텍스트 데이터를 기계가 이해할 수 있는 숫자 형태로 변환하는 주요 과정인 <strong>인코딩(Encoding)</strong>과 <strong>벡터화(Vectorization)</strong>에 대해 심층적으로 다룬다.</p>
<p>주요 내용은 다음과 같다.</p>
<ul>
<li><strong>인코딩 (Encoding)</strong>:
<ul>
<li><strong>정의 및 필요성</strong>: 텍스트를 숫자(주로 정수 인덱스)로 변환하는 과정이다.</li>
<li><strong>정수 인코딩</strong>: 각 단어에 고유 정수를 부여하는 방법과 어휘 집합 크기 결정, 그리고 학습 데이터에 없는 단어(OOV: Out-of-Vocabulary)를 <code>UNK</code> 토큰으로 처리하는 방법을 설명한다.</li>
</ul></li>
<li><strong>패딩 (Padding)</strong>:
<ul>
<li><strong>정의 및 필요성</strong>: 길이가 다른 텍스트 시퀀스들을 모델 입력을 위해 동일한 길이로 맞춰주는 작업으로, <code>PAD</code> 토큰을 사용한다.</li>
</ul></li>
<li><strong>벡터화 (Vectorization)</strong>:
<ul>
<li><strong>정의</strong>: 정수 인코딩된 데이터를 숫자 벡터로 변환하여 텍스트의 의미나 통계적 정보를 표현한다.</li>
<li><strong>통계적 방법</strong>:
<ul>
<li><strong>원-핫 인코딩</strong>: 각 단어를 고유한 희소 벡터로 표현하며, 장단점(차원의 저주)을 다룬다.</li>
<li><strong>빈도 기반 방법 (DTM, BoW, TF-IDF)</strong>: 문서 내 단어 빈도를 기반으로 문서를 벡터화하는 DTM(Document Term Matrix), Bag-of-Words(BoW), TF-IDF 기법의 개념과 특징, 활용 방안을 설명한다.</li>
</ul></li>
<li><strong>벡터 표현의 단위</strong>: 단어는 벡터로, 문서는 벡터 또는 행렬로 표현될 수 있음을 설명한다.</li>
</ul></li>
<li><strong>결론</strong>: 효과적인 인코딩 및 벡터화 전략 선택의 중요성을 강조한다.</li>
</ul>
<p>이 문서를 통해 텍스트 데이터가 NLP 모델에서 어떻게 처리될 수 있도록 준비되는지에 대한 기본적인 이해를 얻을 수 있다.</p>
</section>
<section id="텍스트-인코딩-및-벡터화" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 텍스트 인코딩 및 벡터화</h1>
<pre><code>텍스트 벡터화
├── 전통적 방법 (통계 기반)
│   ├── DTM (Document Term Matrix)
│   ├── BoW (Bag of Words)  
│   └── TF-IDF
└── 신경망 기반 방법
    ├── Embedding Layer (핵심 구성 요소)
    └── 구체적 모델들
        ├── Word2Vec (CBOW, Skip-gram)
        ├── GloVe
        ├── FastText
        └── 문맥 기반 모델 (BERT, GPT 등)</code></pre>
<section id="인코딩encoding" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="인코딩encoding"><span class="header-section-number">2.1</span> 인코딩(Encoding)</h2>
<ul>
<li><strong>인코딩 (Encoding)</strong>:
<ul>
<li><strong>정의</strong>: 자연어 처리(NLP)에서 <strong>텍스트 데이터를 기계가 이해하고 처리할 수 있는 숫자 형태로 변환하는 과정</strong> 전반을 의미. 컴퓨터는 텍스트를 직접 이해할 수 없으므로, 토큰화된 각 구성 요소(단어 등)를 숫자 표현(주로 정수 인덱스)으로 바꾸는 단계.</li>
<li><strong>핵심</strong>: 토큰화 후, 토큰들을 숫자로 매핑.</li>
</ul></li>
<li><strong>주요 기법</strong>: 정수 인코딩 결과를 바탕으로 한 원-핫 인코딩, 그리고 더 나아가 단어 임베딩 등.</li>
</ul>
<section id="정수-인코딩-integer-encoding" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="정수-인코딩-integer-encoding"><span class="header-section-number">2.1.1</span> 정수 인코딩 (Integer Encoding)</h3>
<ul>
<li><strong>개념</strong>: 어휘 집합(Vocabulary) 내 각 고유 토큰에 <strong>고유한 정수 인덱스를 부여</strong>.</li>
<li><strong>과정</strong>:
<ol type="1">
<li>어휘 집합 구축: 전체 텍스트에서 고유 토큰 추출</li>
</ol>
<ul>
<li>빈도, 최대 크기 고려하여 어휘 집합 크기 제한하는 것이 현실적인 전략</li>
</ul>
<ol start="2" type="1">
<li>각 토큰에 정수 할당</li>
</ol>
<ul>
<li>빈도 높은 단어에 낮은 숫자 할당</li>
</ul>
<ol start="3" type="1">
<li>텍스트의 토큰 시퀀스를 정수 시퀀스로 변환</li>
</ol></li>
<li><strong>예시</strong>:
<ul>
<li>어휘 집합 구축:
<ul>
<li>예시 문장: <code>"I love natural language processing"</code></li>
<li>토큰화 결과: <code>["i", "love", "natural", "language", "processing"]</code></li>
<li>초기 어휘 집합 (<code>word_to_index</code>)의 정수 인코딩 * <code>{"i": 1, "love": 2, "natural": 3, "language": 4, "processing": 5}</code></li>
<li>정수 시퀀스: <code>[1, 2, 3, 4, 5]</code></li>
<li>이때 어휘 집합의 크기는 5이다.</li>
</ul></li>
</ul></li>
<li><strong>한계</strong>
<ul>
<li>텍스트간 유사도 측정 불가: 숫자 값 자체가 단어 간 의미/관계 표현 못 함 (모델 오해 가능성).</li>
</ul></li>
</ul>
</section>
<section id="oov-out-of-vocabulary-문제" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="oov-out-of-vocabulary-문제"><span class="header-section-number">2.1.2</span> OOV (Out-of-Vocabulary) 문제</h3>
<ul>
<li><strong>정의</strong>: 학습 시 구축된 어휘 집합에 <strong>포함되지 않은 단어</strong>가 입력될 때 발생.</li>
<li><strong>원인</strong>: 신조어, 전문 용어, 오타, 제한된 어휘 크기 등.</li>
<li><strong>영향</strong>: 정보 손실, 잘못된 예측, 모델 성능 저하.</li>
<li><strong><code>UNK</code> (Unknown) 토큰 처리</strong>:
<ul>
<li>OOV 단어를 미리 정의된 <code>UNK</code> 토큰의 인덱스로 일괄 대체.</li>
<li>모든 OOV가 동일 토큰으로 매핑되어 원래 단어의 고유 정보는 손실.</li>
</ul></li>
<li><strong>어휘 집합 크기 및 신규 단어(OOV) 처리 예시 (영문)</strong>:
<ul>
<li>어휘 집합의 크기는 모델의 성능과 효율성에 영향을 미치며, 너무 작으면 OOV 문제가, 너무 크면 계산 비용 및 과적합 문제가 발생할 수 있다.</li>
<li><strong>신규 단어(OOV) 발생 시 <code>UNK</code> 토큰 처리</strong>:
<ul>
<li>기존 예시 문장: <code>"I love natural language processing"</code></li>
<li>새로운 문장: <code>"I also love deep learning"</code> 이 입력되었다고 가정</li>
<li>이 문장의 토큰: <code>["i", "also", "love", "deep", "learning"]</code></li>
<li>여기서 “also”, “deep”, “learning”은 기존 어휘 집합에 없는 새로운 단어(OOV)이다.</li>
<li>이런 OOV 단어를 처리하기 위해, 특별 토큰인 <code>"UNK"</code> (Unknown)를 어휘 집합에 추가하고, 이 <code>"UNK"</code> 토큰에 어휘 집합의 <strong>가장 마지막 다음 번호</strong>를 부여</li>
<li>업데이트된 어휘 집합 (<code>word_to_index</code>): <code>{"i": 1, "love": 2, "natural": 3, "language": 4, "processing": 5, "UNK": 6}</code></li>
<li>어휘 집합의 크기: 6 (<code>UNK</code> 토큰 포함).</li>
<li>새로운 문장 <code>"I also love deep learning"</code>의 정수 시퀀스</li>
<li>OOV 단어인 “also”, “deep”, “learning”은 <code>"UNK"</code> 토큰의 인덱스인 6으로 매핑되어 <code>[1, 6, 2, 6, 6]</code> 이 된다.</li>
<li>이렇게 <code>UNK</code> 토큰을 사용하면 모델이 학습하지 않은 단어에 대해서도 일관된 처리가 가능하지만, 모든 OOV 단어가 하나의 인덱스로 매핑되므로 원래 단어의 정보는 일부 손실된다.</li>
</ul></li>
</ul></li>
<li><strong>근본적 해결 시도</strong>: 서브워드 토큰화 (BPE, WordPiece 등)는 단어를 더 작은 단위로 나눠 OOV 발생 빈도를 크게 줄임.</li>
</ul>
</section>
</section>
<section id="패딩-padding" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="패딩-padding"><span class="header-section-number">2.2</span> 패딩 (Padding)</h2>
<ul>
<li><strong>개념</strong>: 입력되는 텍스트 길이가 다르기 때문에 토큰화 후 서로 다른 길이의 정수 시퀀스들의 <strong>길이를 동일하게 맞춰주는</strong> 작업.</li>
<li><strong>필요성</strong>: 딥러닝 모델의 고정된 입력 크기 요구 충족, 배치 단위 병렬 처리 효율 증대.</li>
<li><strong><code>PAD</code> 토큰 사용</strong>: 특별한 <code>PAD</code> 토큰 (주로 인덱스 0)을 사용.</li>
<li><strong>방법</strong>:
<ul>
<li><code>post-padding</code> (뒷부분 채움): 시퀀스 뒤에 <code>PAD</code> 인덱스 추가. (일반적)
<ul>
<li>예: <code>[[1,2,3,4], [5,6]]</code> -&gt; <code>maxlen=4</code> 가정 시 <code>[[1,2,3,4], [5,6,0,0]]</code>, 집합의 크기는 4</li>
</ul></li>
<li><code>pre-padding</code> (앞부분 채움): 시퀀스 앞에 <code>PAD</code> 인덱스 추가. (RNN 계열에서 마지막 정보 중요시할 때)
<ul>
<li>예: <code>[[1,2,3,4], [5,6]]</code> -&gt; <code>maxlen=4</code> 가정 시 <code>[[1,2,3,4], [0,0,5,6]]</code>, 집합의 크기는 4</li>
</ul></li>
</ul></li>
<li><strong>어휘 집합 크기</strong>: <code>PAD</code> 토큰 사용 시 어휘 집합 크기에 영향</li>
<li><strong>주의</strong>: 과도한 패딩은 실제 정보 비율 낮춰 학습에 부정적 영향 가능.</li>
</ul>
</section>
<section id="벡터화-vectorization" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="벡터화-vectorization"><span class="header-section-number">2.3</span> 벡터화 (Vectorization)</h2>
<ul>
<li><strong>정의</strong>: 정수 인코딩 등 숫자 표현을 바탕으로, 각 텍스트 단위(단어, 문장, 문서)를 <strong>숫자 벡터(Numeric Vector)로 변환</strong>하는 과정.</li>
<li><strong>목적</strong>: 기계 학습 모델 처리 가능 형태 변환, 텍스트의 의미/문맥 정보 표현, 데이터 효율적 처리.</li>
</ul>
<section id="통계적-방법" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="통계적-방법"><span class="header-section-number">2.3.1</span> 통계적 방법</h3>
<ul>
<li>신경망 미사용: 신경망을 사용하지 않는 전통적 통계 방식으로 벡터화</li>
<li>문맥 미고려 방법 (Non-neural / Context-independent)</li>
<li>각 단어를 주변 문맥과 독립적으로 고정된 벡터로 표현 (Sparse Vector).</li>
</ul>
<section id="단어-벡터-표현-방법-원-핫-인코딩-one-hot-encoding" class="level4" data-number="2.3.1.1">
<h4 data-number="2.3.1.1" class="anchored" data-anchor-id="단어-벡터-표현-방법-원-핫-인코딩-one-hot-encoding"><span class="header-section-number">2.3.1.1</span> 단어 벡터 표현 방법: 원-핫 인코딩 (One-Hot Encoding)</h4>
<ul>
<li>어휘 집합 크기의 벡터에서, 해당 단어의 정수 인덱스 위치만 1이고 나머지는 모두 0인 벡터로 표현.</li>
<li>예: 어휘집 <code>{"apple":0, "banana":1, "cherry":2, "PAD":3}</code> (4은 패딩용 가정), <code>vocab_size=4</code></li>
<li><code>apple</code> (인덱스 0) -&gt; <code>[1, 0, 0, 0]</code></li>
<li><code>banana</code> (인덱스 1) -&gt; <code>[0, 1, 0, 0]</code></li>
<li><code>cherry</code> (인덱스 2) -&gt; <code>[0, 0, 1, 0]</code></li>
<li><code>PAD</code> (인덱스 3) -&gt; <code>[0, 0, 0, 1]</code></li>
<li>장점: 단어 간 순서/크기에 의한 관계 없음 명확히 표현.</li>
<li>단점:</li>
<li>차원의 저주: 어휘 집합 크면 벡터 차원 매우 커짐 (희소 벡터) -&gt; 계산 비효율, 데이터 부족 문제.
<ul>
<li>차원의 저주란? 고차원 공간(많은 feature 또는 여기서는 매우 큰 어휘 집합으로 인한 고차원 벡터)으로 갈수록 데이터 포인트들이 해당 공간을 매우 드문드문(희소하게, sparsely) 채우게 되는 현상</li>
<li>희소성의 문제점:
<ul>
<li><strong>거리 계산의 무의미화</strong>: 고차원 공간에서는 대부분의 데이터 포인트들이 서로 멀리 떨어져 있게 되어, 유클리드 거리와 같은 전통적인 거리 척도가 의미를 잃어갑니다. 즉, 가장 가까운 이웃과 가장 먼 이웃 간의 거리 차이가 거의 없어지거나, 모든 점이 샘플링된 점들의 껍질(hull)에 가깝게 위치한다. 이는 최근접 이웃(Nearest Neighbor)과 같은 거리 기반 알고리즘의 성능을 저하시킵니다.</li>
<li><strong>데이터 부족 심화</strong>: 동일한 밀도로 데이터를 채우기 위해서는 차원이 증가할수록 기하급수적으로 더 많은 데이터가 필요합니다. 예를 들어, 1차원에서 10개의 구간을 커버하는데 10개의 데이터 포인트가 필요했다면, 10차원에서는 각 차원마다 10개의 구간을 커버하기 위해 (10^{10})개의 데이터 포인트가 필요하게 된다. 현실적으로 이만큼의 데이터를 확보하기는 매우 어렵다.</li>
<li><strong>과적합(Overfitting) 가능성 증가</strong>: 제한된 데이터로 고차원 모델을 학습시키면, 모델이 실제 데이터의 분포보다는 학습 데이터의 노이즈에 과도하게 적응하여 새로운 데이터에 대한 일반화 성능이 떨어질 수 있다.</li>
<li><strong>모델 학습의 어려움</strong>: 데이터가 희소해지면, 의미 있는 패턴을 찾거나 변수 간의 관계를 모델링하는 것이 더욱 어려워지고, 모델의 복잡도에 비해 학습할 수 있는 정보가 부족해집니다.</li>
<li><strong>단어 간 유사도 표현 불가</strong>: 모든 단어 벡터 직교.</li>
</ul></li>
</ul></li>
<li><strong>최근 동향</strong>: 단점들로 인해 NLP 딥러닝에서는 단어 임베딩으로 대체되는 추세.</li>
</ul>
</section>
<section id="문서-벡터-표현-방법-빈도-기반-방법-frequency-based-methods" class="level4" data-number="2.3.1.2">
<h4 data-number="2.3.1.2" class="anchored" data-anchor-id="문서-벡터-표현-방법-빈도-기반-방법-frequency-based-methods"><span class="header-section-number">2.3.1.2</span> 문서 벡터 표현 방법: 빈도 기반 방법 (Frequency-based Methods)</h4>
<ul>
<li>Document Term Matrix (DTM): 텍스트 마이닝과 자연어처리에서 문서 내 단어 빈도를 표현하는 <strong>문서-단어 행렬의 데이터 구조</strong>이다.
<ul>
<li>벡터가 단어 집합의 크기를 가지며 대부분의 원소가 0을 가진다.</li>
<li>DTM의 기본 구조
<ul>
<li><strong>행(rows)</strong>: 각 문서 (document), 즉, 문서가 행벡터가 된다.</li>
<li><strong>열(columns)</strong>: 어휘집(vocabulary)의 각 단어 (term)</li>
<li><strong>셀 값</strong>: 해당 문서에서 해당 단어의 빈도 또는 가중치</li>
</ul></li>
<li>수학적으로 표현하면 <img src="https://latex.codecogs.com/png.latex?M%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bd%20%5Ctimes%20v%7D"> 형태의 행렬이며, 여기서 <img src="https://latex.codecogs.com/png.latex?d"> 는 문서 수, <img src="https://latex.codecogs.com/png.latex?v"> 는 어휘집 크기</li>
</ul></li>
<li>DTM(행렬)의 셀 값을 채우는 방법
<ul>
<li><strong>Bag-of-Words (BoW)</strong>:
<ul>
<li>Raw Count (단순 빈도): 단어를 한 가방에 넣고 흔들면 단어의 순서는 무의미해지기 때문에 단어가 등장한 빈도수를 벡터화하는 이론</li>
<li>표현: 각 문서는 어휘 집합 크기의 벡터로, 각 차원은 해당 단어의 빈도수 (또는 존재 유무 0/1).</li>
<li>예: 문서1: “나는 바나나 사과 바나나”, 어휘집: <code>{"나는":0, "바나나":1, "사과":2}</code> -&gt; <code>[1, 2, 1]</code></li>
<li>장점: 단순하고 구현 용이.</li>
<li>단점: 어순 무시로 문맥 정보 손실, 단어 의미 모호성 해결 불가, 차원이 크고 희소(sparse)할 수 있음.</li>
<li>DTM[i,j] = count(word_j in document_i)</li>
</ul></li>
<li>Binary (이진)
<ul>
<li>DTM[i,j] = 1 if word_j appears in document_i, else 0</li>
<li>{“데이터”: 1, “과학”: 1, “분석”: 1}</li>
</ul></li>
<li><strong>TF (Term Frequency)</strong>
<ul>
<li>특정 문서 내 특정 단어의 등장 빈도를 정규화하여 BoW로 표현된 벡터에 가중치를 주는 방법</li>
<li>DTM[i,j] = TF(word_j, document_i)</li>
<li>{“데이터”: 2/4=0.5, “과학”: 1/4=0.25, “분석”: 1/4=0.25}</li>
</ul></li>
<li><strong>TF-IDF (Inverse Document Frequency)</strong>
<ul>
<li>여러 문서가 있을때 단어의 변별력을 측정하는 지표</li>
<li>문서의 유사도, 검색 시스템에서 검색 결과의 순위 등을 구하는데 사용</li>
<li>단어 빈도(TF)와 역문서 빈도(IDF)를 곱하여, 특정 문서 내 단어의 상대적 중요도를 가중치로 부여.</li>
<li>통계적 방법 (신경망 미사용)론 중 여전히 실무에서 괴장히 많이 쓰이는 벡터화 방법.<br>
</li>
<li>결과값이 벡터이므로 신경망의 입력값으로도 사용될 수 있다.</li>
<li>문서를 벡터화 한다면 문서 간 유사도 구할 수 있다.</li>
<li>문서 간 유사도 구하면 가능한 작업
<ul>
<li>문서 클러스터링, 유사한 문서 찾기, 문서 분류 문제</li>
</ul></li>
<li>IDF: 특정 문서에만 자주 나오는 단어일수록 높은 값을 가짐. 전체 문서 중 해당 단어가 등장한 문서 수의 역수</li>
<li>예: “the” 같이 여러 문서에 자주 나오는 단어는 낮은 TF-IDF, 특정 주제 문서에만 나오는 전문용어는 높은 TF-IDF.</li>
<li>장점: BoW보다 단어의 중요도를 더 잘 반영 (예: 불용어의 영향력 감소).</li>
<li>단점: 어순 무시, 의미적 유사도 표현에는 여전히 한계.</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Ctext%7BIDF%7D(w_j)%20=%20%5Clog%5Cleft(%5Cfrac%7BN%7D%7B1+%5Ctext%7Bdf%7D(w_j)%7D%5Cright)"></li>
<li>여기서:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?N">: 전체 문서 수</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bdf%7D(w_j)">: 단어 <img src="https://latex.codecogs.com/png.latex?w_j">가 등장한 문서 수</li>
<li>특정 단어가 문서2,3에서 각 각 등장할 때 특정단어가 문서2에서 10000번 등장했더라도 df의 값은 2가 된다.</li>
<li>log 스케일: df값이 매우 크거나 작을 때 IDF값의 범위를 줄이기 위해 사용 (IDF값이 기하급수적으로 커질 수 있음)</li>
<li>불용어 등과 같이 자주 쓰이는 단어들은 비교적 자주 쓰이지 않는 단어들보다 최소 수십배 더 자주 등장한다.</li>
<li>비교적 자주 쓰이지 않는 단어들조차 희귀 단어들과 비교하면 최소 수백 배는 더 자주 등장하는 편이다. (is, a, I, the, and, …)</li>
<li>log를 씌우지 않으면 희귀 단어들에 엄청난 가중치가 부여될 위험이 있다.</li>
</ul></li>
<li>높은 IDF: 적은 문서에만 등장 → 희귀하고 특별한 단어</li>
<li>낮은 IDF: 많은 문서에 등장 → 일반적이고 흔한 단어</li>
</ul></li>
</ul></li>
<li>계산 예시</li>
</ul>
<pre><code>문서1: "머신러닝 알고리즘 연구"
문서2: "딥러닝 모델 개발" 
문서3: "데이터 과학 연구"
문서4: "인공지능 연구 동향"

"연구": df=4 → IDF = log(4/4) = 0  (낮음 - 흔한 단어)
"머신러닝": df=2 → IDF = log(4/2) = 0.693  (높음 - 희귀한 단어)
"딥러닝": df=2 → IDF = log(4/2) = 0.693  (높음 - 희귀한 단어)
"데이터": df=2 → IDF = log(4/2) = 0.693  (높음 - 희귀한 단어)
"알고리즘": df=2 → IDF = log(4/2) = 0.693  (높음 - 희귀한 단어)

TF만 사용할 경우 (문서1 기준):
"연구": TF = 1/3 = 0.333
"머신러닝": TF = 1/3 = 0.333
"알고리즘": TF = 1/3 = 0.333   

IDF (문서1 기준):
"연구": IDF = log(4/4) = 0
"머신러닝": IDF = log(4/2) = 0.693
"알고리즘": IDF = log(4/2) = 0.693         

TF-IDF 사용할 경우 (문서1 기준):
"연구": TF × IDF = 0.333 × 0 = 0  (낮음 - 일반적 단어)
"머신러닝": TF × IDF = 0.333 × 0.693 = 0.231  (높음 - 문서의 특징)
"알고리즘": TF × IDF = 0.333 × 0.693 = 0.231  (높음 - 문서의 특징)
→ 문서를 특징짓는 단어들이 강조됨</code></pre>
<ul>
<li>구체적 예시
<ul>
<li><strong>DTM with BoW:</strong>
<ul>
<li><p>문서 <img src="https://latex.codecogs.com/png.latex?D_i"> 에 대해 BoW 벡터 <img src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bx%7D_i%20=%20%5Bx_%7Bi1%7D,%20x_%7Bi2%7D,%20...,%20x_%7Biv%7D%5D"> 는 다음과 같이 정의: <img src="https://latex.codecogs.com/png.latex?x_%7Bij%7D%20=%20%5Ctext%7Bcount%7D(w_j,%20D_i)"></p></li>
<li><p>여기서 <img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bcount%7D(w_j,%20D_i)">는 문서 <img src="https://latex.codecogs.com/png.latex?D_i">에서 단어 <img src="https://latex.codecogs.com/png.latex?w_j">의 등장 횟수이다.</p></li>
<li><p><strong>문서 집합:</strong></p>
<ul>
<li>문서1: “데이터 과학은 흥미로운 분야다”</li>
<li>문서2: “머신러닝은 데이터 과학의 핵심이다”<br>
</li>
<li>문서3: “딥러닝도 머신러닝의 한 분야다”</li>
</ul></li>
<li><p><strong>어휘집 구성:</strong> {“데이터”, “과학은”, “흥미로운”, “분야다”, “머신러닝은”, “과학의”, “핵심이다”, “딥러닝도”, “머신러닝의”, “한”}</p></li>
<li><p><strong>DTM (BoW):</strong></p></li>
</ul>
<pre><code>         데이터 과학은 흥미로운 분야다 머신러닝은 과학의 핵심이다 딥러닝도 머신러닝의 한
문서1        1     1      1      1       0      0      0      0       0    0
문서2        1     0      0      0       1      1      1      0       0    0  
문서3        0     0      0      1       0      0      0      1       1    1</code></pre>
<ul>
<li><strong>통계적 특성</strong>
<ul>
<li><strong>희소성(Sparsity)</strong>: 대부분의 셀이 0인 희소 행렬</li>
<li><strong>차원의 저주</strong>: 어휘집 크기가 클수록 벡터 차원이 증가</li>
<li><strong>코사인 유사도</strong>: 문서 간 유사도 측정에 자주 사용 <img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bcosine%5C_similarity%7D(D_i,%20D_j)%20=%20%5Cfrac%7B%5Cmathbf%7Bx%7D_i%20%5Ccdot%20%5Cmathbf%7Bx%7D_j%7D%7B%7C%7C%5Cmathbf%7Bx%7D_i%7C%7C%20%5Ccdot%20%7C%7C%5Cmathbf%7Bx%7D_j%7C%7C%7D"></li>
</ul></li>
</ul></li>
<li><strong>DTM with TF-IDF</strong>
<ul>
<li>TF-IDF는 두 구성요소의 곱으로 정의:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Ctext%7BTF-IDF%7D(w_j,%20D_i)%20=%20%5Ctext%7BTF%7D(w_j,%20D_i)%20%5Ctimes%20%5Ctext%7BIDF%7D(w_j)"></li>
</ul></li>
<li>Term Frequency (TF)
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Ctext%7BTF%7D(w_j,%20D_i)%20=%20%5Cfrac%7B%5Ctext%7Bcount%7D(w_j,%20D_i)%7D%7B%5Csum_%7Bk=1%7D%5E%7B%7CD_i%7C%7D%20%5Ctext%7Bcount%7D(w_k,%20D_i)%7D"></li>
<li>또는 로그 정규화 (가장 보편적으로 사용):
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Ctext%7BTF%7D(w_j,%20D_i)%20=%20%5Clog(1%20+%20%5Ctext%7Bcount%7D(w_j,%20D_i))"></li>
</ul></li>
</ul></li>
<li>Inverse Document Frequency (IDF)
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Ctext%7BIDF%7D(w_j)%20=%20%5Clog%5Cleft(%5Cfrac%7BN%7D%7B%5Ctext%7Bdf%7D(w_j)%7D%5Cright)"></li>
<li>여기서:
<ul>
<li><img src="https://latex.codecogs.com/png.latex?N"> : 전체 문서 수</li>
<li><img src="https://latex.codecogs.com/png.latex?%5Ctext%7Bdf%7D(w_j)"> : 단어 <img src="https://latex.codecogs.com/png.latex?w_j">가 등장한 문서 수</li>
</ul></li>
</ul></li>
<li>예시 (위의 동일한 문서 집합 사용):
<ul>
<li><p><strong>1단계: TF 계산 (로그 정규화 사용)</strong></p>
<ul>
<li><p>TF(“데이터”) = 1/4 = 0.25</p></li>
<li><p>TF(“과학은”) = 1/4 = 0.25<br>
</p></li>
<li><p>TF(“흥미로운”) = 1/4 = 0.25</p></li>
<li><p>TF(“분야다”) = 1/4 = 0.25</p></li>
<li><p>TF(“머신러닝은”) = 1/4 = 0.25</p></li>
<li><p>TF(“데이터”) = 1/4 = 0.25</p></li>
<li><p>TF(“과학의”) = 1/4 = 0.25<br>
</p></li>
<li><p>TF(“핵심이다”) = 1/4 = 0.25</p></li>
<li><p>TF(“딥러닝도”) = 1/4 = 0.25</p></li>
<li><p>TF(“머신러닝의”) = 1/4 = 0.25</p></li>
<li><p>TF(“한”) = 1/4 = 0.25</p></li>
<li><p>TF(“분야다”) = 1/4 = 0.25</p>
<pre><code>         데이터  과학은  흥미로운  분야다  머신러닝은  과학의  핵심이다  딥러닝도  머신러닝의  한
문서1      0.25    0.25    0.25    0.25     0       0       0       0       0       0
문서2      0.25    0       0       0      0.25     0.25    0.25     0        0      0
문서3       0       0       0      0.25     0        0       0     0.25    0.25  0.25</code></pre></li>
</ul></li>
<li><p><strong>2단계: IDF 계산</strong></p>
<ul>
<li>“데이터”: 문서1, 문서2 → df = 2</li>
<li>“분야다”: 문서1, 문서3 → df = 2<br>
</li>
<li>“과학은”: 문서1만 → df = 1</li>
<li>“흥미로운”: 문서1만 → df = 1</li>
<li>“머신러닝은”: 문서2만 → df = 1</li>
<li>“과학의”: 문서2만 → df = 1</li>
<li>“핵심이다”: 문서2만 → df = 1</li>
<li>“딥러닝도”: 문서3만 → df = 1</li>
<li>“머신러닝의”: 문서3만 → df = 1<br>
</li>
<li>“한”: 문서3만 → df = 1</li>
<li>IDF(“데이터”) = log(3/(1+2)) = log(1) = 0.000</li>
<li>IDF(“분야다”) = log(3/(1+2)) = log(1) = 0.000</li>
<li>IDF(“과학은”) = log(3/(1+1)) = log(1.5) = 0.405</li>
<li>IDF(“흥미로운”) = log(3/(1+1)) = log(1.5) = 0.405<br>
</li>
<li>IDF(“머신러닝은”) = log(3/(1+1)) = log(1.5) = 0.405</li>
<li>IDF(“과학의”) = log(3/(1+1)) = log(1.5) = 0.405</li>
<li>IDF(“핵심이다”) = log(3/(1+1)) = log(1.5) = 0.405</li>
<li>IDF(“딥러닝도”) = log(3/(1+1)) = log(1.5) = 0.405</li>
<li>IDF(“머신러닝의”) = log(3/(1+1)) = log(1.5) = 0.405</li>
<li>IDF(“한”) = log(3/(1+1)) = log(1.5) = 0.405</li>
</ul></li>
<li><p><strong>3단계: TF-IDF 최종 계산</strong></p>
<pre><code>         데이터   과학은   흥미로운  분야다   머신러닝은  과학의   핵심이다  딥러닝도  머신러닝의   한
문서1      0     0.101    0.101   0.101      0        0        0       0        0      0
문서2      0       0        0       0       0.081    0.081    0.081    0        0      0
문서3      0       0        0       0        0        0        0     0.081    0.081  0.081</code></pre></li>
</ul></li>
<li>TF-IDF의 통계적 해석
<ul>
<li><strong>정보 이론적 관점</strong>: IDF는 단어의 정보량(information content)을 측정
<ul>
<li><img src="https://latex.codecogs.com/png.latex?%5Ctext%7BInformation%7D(w_j)%20=%20-%5Clog%20P(w_j)%20%5Capprox%20-%5Clog%5Cleft(%5Cfrac%7B%5Ctext%7Bdf%7D(w_j)%7D%7BN%7D%5Cright)%20=%20%5Ctext%7BIDF%7D(w_j)"></li>
</ul></li>
<li><strong>가중치 효과</strong>:
<ul>
<li>높은 TF: 해당 문서에서 <strong>중요한 단어</strong></li>
<li>높은 IDF: 전체 문서 집합에서 <strong>희귀한 단어</strong></li>
<li>높은 TF-IDF: 특정 문서의 <strong>특징을 잘 나타내는 중요한 단어</strong></li>
</ul></li>
<li><strong>정규화 효과</strong>: 문서 길이에 따른 편향을 줄임</li>
</ul></li>
</ul></li>
<li>실용적 고려사항
<ul>
<li><strong>불용어 처리</strong>: “은”, “는”, “이” 등은 보통 전처리 단계에서 제거</li>
<li><strong>최소 문서 빈도</strong>: 너무 희귀한 단어들을 필터링하여 차원 축소</li>
<li><strong>최대 문서 빈도</strong>: 너무 일반적인 단어들도 제외 가능</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="결론" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="결론"><span class="header-section-number">2.4</span> 결론</h2>
<p>본 문서에서는 자연어 처리(NLP)의 핵심 전처리 단계인 텍스트 인코딩과 벡터화 기법들을 살펴보았다. 주요 내용을 요약하면 다음과 같다.</p>
<ul>
<li><strong>텍스트 인코딩의 중요성</strong>: 기계가 텍스트를 이해하기 위한 첫걸음으로, 정수 인코딩과 같은 방법을 통해 토큰을 숫자 표현으로 변환합니다. 이때 어휘 집합에 없는 단어(OOV) 처리가 중요하며, <code>UNK</code> 토큰 사용이 일반적인 해결책이다.</li>
<li><strong>일관된 입력 처리를 위한 패딩</strong>: 모델의 고정된 입력 크기 요구를 충족시키기 위해, 다양한 길이의 시퀀스를 <code>PAD</code> 토큰을 사용하여 동일한 길이로 맞추는 패딩 작업이 필수적이다.</li>
<li><strong>다양한 벡터화 기법</strong>:
<ul>
<li><strong>통계 기반 방법</strong>: 원-핫 인코딩은 간단하지만 차원의 저주 문제가 있으며, 단어 빈도 기반의 DTM, BoW, TF-IDF 등은 문서 수준의 벡터 표현에 효과적이다. 특히 TF-IDF는 단어의 중요도를 반영하여 널리 사용된다.</li>
<li><strong>벡터 표현의 의미</strong>: 이러한 기법들은 단어를 벡터로, 문서를 벡터 또는 행렬로 변환하여 기계 학습 모델이 처리할 수 있도록 한다.</li>
</ul></li>
<li><strong>방법 선택의 기준</strong>: 최적의 인코딩 및 벡터화 전략은 당면한 문제의 특성, 데이터의 양과 질, 그리고 사용하려는 모델 등을 종합적으로 고려하여 선택해야 한다.</li>
</ul>


</section>
</section>

 ]]></description>
  <category>NLP</category>
  <category>Deep Learning</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Deep_Learning/NLP/4-1.pre_prcs_vectorization.html</guid>
  <pubDate>Fri, 03 Jan 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>정규표현식 기본 규칙</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Deep_Learning/NLP/3.pre_prcs_regular_expression.html</link>
  <description><![CDATA[ 




<section id="정규표현식-기초" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 정규표현식 기초</h1>
<section id="정규표현식이란" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="정규표현식이란"><span class="header-section-number">1.1</span> 정규표현식이란?</h2>
<ul>
<li>토큰화같은 텍스트 전처리에 필수적으로 사용되는 도구</li>
<li>정규표현식(Regular Expression)은 특정한 패턴을 가진 문자열을 검색, 매칭, 치환하는 데 사용되는 형식 언어</li>
<li>자연어 처리(NLP)에서 텍스트 전처리 단계에서 중요한 도구로 활용</li>
</ul>
</section>
<section id="기본-문자-매칭" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="기본-문자-매칭"><span class="header-section-number">1.2</span> 기본 문자 매칭</h2>
<ol type="1">
<li>일반 문자: 문자 자체를 매칭</li>
<li>메타 문자: 특별한 의미를 가진 문자들 (., ^, $, *, +, ? 등)</li>
</ol>
</section>
<section id="기본-패턴-규칙" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="기본-패턴-규칙"><span class="header-section-number">1.3</span> 기본 패턴 규칙</h2>
<ol type="1">
<li><code>.</code>: 임의의 한 문자와 매칭
<ul>
<li>예시: <code>a.c</code>는 “abc”, “adc”, “a3c” 등과 매칭됨</li>
</ul></li>
<li><code>^</code>: 문자열의 시작
<ul>
<li>예시: <code>^Hello</code>는 “Hello World”와 매칭되지만 “World Hello”와는 매칭되지 않음<br>
</li>
</ul></li>
<li><code>$</code>: 문자열의 끝
<ul>
<li>예시: <code>world$</code>는 “Hello world”와 매칭되지만 “world hello”와는 매칭되지 않음</li>
</ul></li>
<li><code>*</code>: 앞의 요소가 0번 이상 반복
<ul>
<li>예시: <code>ab*c</code>는 “ac”, “abc”, “abbc”, “abbbc” 등과 매칭됨</li>
</ul></li>
<li><code>+</code>: 앞의 요소가 1번 이상 반복
<ul>
<li>예시: <code>ab+c</code>는 “abc”, “abbc”, “abbbc” 등과 매칭되지만 “ac”와는 매칭되지 않음</li>
</ul></li>
<li><code>?</code>: 앞의 요소가 0번 또는 1번 등장
<ul>
<li>예시: <code>colou?r</code>는 “color”와 “colour” 모두와 매칭됨</li>
</ul></li>
<li><code>{n}</code>: 앞의 요소가 정확히 n번 반복
<ul>
<li>예시: <code>a{3}</code>는 “aaa”와 매칭됨</li>
</ul></li>
<li><code>{n,}</code> - 앞의 요소가 n번 이상 반복
<ul>
<li>예시: <code>a{2,}</code>는 “aa”, “aaa”, “aaaa” 등과 매칭됨</li>
</ul></li>
<li><code>{n,m}</code> - 앞의 요소가 n번 이상 m번 이하 반복
<ul>
<li>예시: <code>a{1,3}</code>는 “a”, “aa”, “aaa”와 매칭됨</li>
</ul></li>
</ol>
</section>
<section id="문자-클래스" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="문자-클래스"><span class="header-section-number">1.4</span> 문자 클래스</h2>
<ol type="1">
<li><code>[abc]</code>: a, b, c 중 하나와 매칭
<ul>
<li>예시: <code>[abc]at</code>는 “aat”, “bat”, “cat”과 매칭됨</li>
</ul></li>
<li><code>[^abc]</code>: ^ 문자는 문자 클래스 [ ] 내에서 사용될 때 <strong>부정(negation)</strong>을 의미하며, a, b, c를 제외한 문자와 매칭
<ul>
<li>예시: <code>[^abc]at</code>는 “dat”, “eat”, “fat” 등과 매칭되지만 “aat”, “bat”, “cat”과는 매칭되지 않음</li>
</ul></li>
<li><code>[a-z]</code>: - 문자는 문자 클래스 [ ] 내에서 사용될 때 <strong>범위(range)</strong>를 의미하며, a부터 z까지의 소문자와 매칭
<ul>
<li>예시: <code>[a-z]oo</code>는 “foo”, “zoo” 등과 매칭됨</li>
</ul></li>
<li><code>[A-Z]</code>: A부터 Z까지의 대문자와 매칭
<ul>
<li>예시: <code>[A-Z]ello</code>는 “Hello”, “Jello” 등과 매칭됨</li>
</ul></li>
<li><code>[0-9]</code> - 숫자와 매칭
<ul>
<li>예시: <code>page[0-9]</code>는 “page0”, “page1” 등과 매칭됨</li>
</ul></li>
<li><code>[_]</code>: 문자 클래스 [ ] 내에서 사용될 때 <strong>문자 클래스</strong>를 의미하며, 언더바(_)와 매칭
<ul>
<li>예시 ```python import re # [^a-zA-Z0-9_] 패턴은 영문자, 숫자, 언더스코어를 제외한 모든 문자와 일치 text = “Hello_world! This-is a sample@123.” cleaned = re.sub(r’[^a-zA-Z0-9_]‘,’ ’, text) # 특수문자만 공백으로 됨 print(cleaned) # “Hello_world This is a sample 123”</li>
</ul></li>
</ol>
</section>
<section id="미리-정의된-문자-클래스" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="미리-정의된-문자-클래스"><span class="header-section-number">1.5</span> 미리 정의된 문자 클래스</h2>
<ol type="1">
<li><code>\d</code> - 숫자와 매칭 (=[0-9])
<ul>
<li>예시: <code>\d\d\d</code>는 “123”, “456” 등 세 자리 숫자와 매칭됨</li>
</ul></li>
<li><code>\D</code> - 숫자가 아닌 문자와 매칭 (=[^0-9])
<ul>
<li>예시: <code>\D\D\D</code>는 “abc”, “XYZ” 등 숫자가 아닌 세 문자와 매칭됨</li>
</ul></li>
<li><code>\w</code> - 단어 문자와 매칭 (=[a-zA-Z0-9_])
<ul>
<li><p>예시: <code>\w+</code>는 단어 문자가 1회 이상 반복되어야 한다.</p></li>
<li><p>“hello123”, “Python_3”, “user_name”, “variable42”, “data_science2023” 등과 매칭됨</p></li>
<li><p>예시:</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> re</span>
<span id="cb1-2">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"hello123 @special! Python_3"</span></span>
<span id="cb1-3">words <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.findall(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'\w+'</span>, text)</span>
<span id="cb1-4"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(words)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ['hello123', 'Python_3']</span></span></code></pre></div></li>
</ul></li>
<li><code>\W</code> - 단어 문자가 아닌 문자와 매칭
<ul>
<li>예시: <code>\W+</code>는 “!@#”, ” ” 등과 매칭됨</li>
</ul></li>
<li><code>\s</code> - 공백 문자와 매칭 (스페이스, 탭, 줄바꿈 등)
<ul>
<li>예시: <code>hello\sworld</code>는 “hello world”와 매칭됨</li>
</ul></li>
<li><code>\S</code> - 공백이 아닌 문자와 매칭
<ul>
<li>예시: <code>\S+</code>는 “hello”, “world” 등 공백이 없는 문자열과 매칭됨</li>
</ul></li>
</ol>
</section>
<section id="그룹과-참조" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="그룹과-참조"><span class="header-section-number">1.6</span> 그룹과 참조</h2>
<ol type="1">
<li><code>(...)</code> - 그룹화 및 캡처
<ul>
<li>예시: <code>(ab)+</code>는 “ab”, “abab”, “ababab” 등과 매칭됨</li>
<li>예시: <code>(a+b+)</code>는 “ab”, “aab”, “abb”, “aaabbb” 등 a가 하나 이상, b가 하나 이상 연속된 패턴과 매칭됨</li>
<li>예시: <code>(a{2}b{2})</code>는 “aabb”와 같이 정확히 a가 2번, b가 2번 반복되는 패턴과 매칭됨</li>
<li>예시: <code>(a{2,3}b{2,3})</code>는 “aabb”, “aaabb”, “aabbb”, “aaabbb” 등 a가 2~3번, b가 2~3번 반복되는 패턴과 매칭됨</li>
</ul></li>
<li><code>(?:...)</code> - 그룹화만 하고 캡처하지 않음 (non-capturing group)
<ul>
<li>일반 그룹 <code>(...)</code>은 패턴을 그룹화하고 매칭된 부분을 메모리에 저장(캡처)함</li>
<li>반면 <code>(?:...)</code>는 패턴을 그룹화하지만 매칭된 부분을 메모리에 저장하지 않음</li>
<li>단순히 패턴을 묶어서 처리하고 싶을 때 사용하며, 나중에 참조할 필요가 없을 때 메모리 효율을 위해 사용함</li>
<li>예시: <code>(?:ab)+c</code>는 “abc”, “ababc”, “abababc” 등과 매칭됨</li>
<li>예시: <code>(?:ab)+</code>는 “ab”가 1회 이상 반복됨</li>
<li>예시: <code>(?:ab)+c</code>는 “ab”가 1회 이상 반복된 후 “c”가 오는 패턴</li>
<li>예시: <code>ab</code>는 정확히 “ab”라는 문자열과 매칭</li>
<li>예시: <code>(ab)</code>는 “ab”를 하나의 단위로 그룹화하고 캡처함</li>
<li>예시: <code>(ab)+c</code>는 “ab”가 1회 이상 반복된 후 “c”가 오는 패턴</li>
<li>주요 차이점:
<ol type="1">
<li><strong>패턴 자체의 차이</strong>:
<ul>
<li><code>(?:ab)+</code>: “ab”의 반복만 매치</li>
<li><code>(ab)+c</code>: “ab”의 반복 + “c”를 매치</li>
</ul></li>
<li><strong>캡처 여부</strong>:
<ul>
<li><code>(?:ab)+</code>: 비캡처 그룹이므로 매치된 내용을 캡처하지 않음</li>
<li><code>(ab)+c</code>: 캡처 그룹이므로 마지막으로 매치된 “ab”를 캡처함</li>
</ul></li>
<li><strong>매치되는 문자열</strong>:
<ul>
<li><code>(?:ab)+</code>: “ab”, “abab”, “ababab”…</li>
<li><code>(ab)+c</code>: “abc”, “ababc”, “abababc”…</li>
</ul></li>
</ol></li>
</ul>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> re</span>
<span id="cb2-2"></span>
<span id="cb2-3">pattern <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'(?:ab)+'</span></span>
<span id="cb2-4">strings <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ab'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'abab'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ababab'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'a'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'abc'</span>]</span>
<span id="cb2-5"></span>
<span id="cb2-6"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> s <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> strings:</span>
<span id="cb2-7">    match <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.fullmatch(pattern, s)</span>
<span id="cb2-8">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> match:</span>
<span id="cb2-9">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"'</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>s<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">' 매치됨"</span>)</span>
<span id="cb2-10">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"  그룹: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>match<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>groups()<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 빈 튜플 () - 캡처된 그룹 없음</span></span>
<span id="cb2-11">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb2-12">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"'</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>s<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">' 매치되지 않음"</span>)</span>
<span id="cb2-13"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 결과</span></span>
<span id="cb2-14"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 'ab' 매치됨</span></span>
<span id="cb2-15"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#   그룹: ()</span></span>
<span id="cb2-16"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 'abab' 매치됨</span></span>
<span id="cb2-17"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#   그룹: ()</span></span>
<span id="cb2-18"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 'ababab' 매치됨</span></span>
<span id="cb2-19"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#   그룹: ()</span></span>
<span id="cb2-20"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 'a' 매치되지 않음</span></span>
<span id="cb2-21"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 'abc' 매치되지 않음</span></span>
<span id="cb2-22"></span>
<span id="cb2-23">pattern <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'(ab)+c'</span></span>
<span id="cb2-24">strings <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'abc'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ababc'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'abababc'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ab'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'c'</span>]</span>
<span id="cb2-25"></span>
<span id="cb2-26"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> s <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> strings:</span>
<span id="cb2-27">    match <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.fullmatch(pattern, s)</span>
<span id="cb2-28">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> match:</span>
<span id="cb2-29">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"'</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>s<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">' 매치됨"</span>)</span>
<span id="cb2-30">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"  그룹: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>match<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>groups()<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ('ab',) - 마지막 'ab'가 캡처됨</span></span>
<span id="cb2-31">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb2-32">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"'</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>s<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">' 매치되지 않음"</span>)</span>
<span id="cb2-33"></span>
<span id="cb2-34"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 결과:</span></span>
<span id="cb2-35"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># </span></span>
<span id="cb2-36"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 'abc' 매치됨</span></span>
<span id="cb2-37"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#   그룹: ('ab',)</span></span>
<span id="cb2-38"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 'ababc' 매치됨</span></span>
<span id="cb2-39"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#   그룹: ('ab',)</span></span>
<span id="cb2-40"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 'abababc' 매치됨</span></span>
<span id="cb2-41"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#   그룹: ('ab',)</span></span>
<span id="cb2-42"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 'ab' 매치되지 않음</span></span>
<span id="cb2-43"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 'c' 매치되지 않음</span></span></code></pre></div></li>
<li><code>\1, \2, ...</code> - 이전에 캡처된 그룹을 참조하는 역참조(backreference) 기능
<ul>
<li>\1: 첫 번째 캡처 그룹과 동일한 내용을 의미</li>
<li>\2: 두 번째 캡처 그룹과 동일한 내용을 의미</li>
<li>\3: 세 번째 캡처 그룹과 동일한 내용을 의미</li>
<li>예시: <code>(\w+) \1</code>는
<ul>
<li>첫 번째 캡처 그룹(단어)이 그대로 반복되는 패턴</li>
<li>매치됨: “hello hello”, “python python”</li>
<li>매치되지 않음: “hello world”, “python java”</li>
</ul></li>
<li>예시: <code>(\w+) (\w+) \2</code>는
<ul>
<li>첫 번째 단어 다음에 두 번째 단어가 나오고, 그 다음에 두 번째 단어가 반복되는 패턴</li>
<li>매치됨: “hello world world”, “python java java”</li>
<li>매치되지 않음: “hello hello world”, “python python java”</li>
</ul></li>
<li>예시: <code>(\w+) (\w+) (\w+) \3</code>는
<ul>
<li>세 개의 단어가 나오고, 그 다음에 세 번째 단어가 반복되는 패턴</li>
<li>매치됨: “apple banana cherry cherry”, “one two three three”</li>
<li>매치되지 않음: “apple banana cherry banana”, “one two three one” ## 경계 매칭</li>
</ul></li>
</ul></li>
<li><code>\b</code>: 단어 경계
<ul>
<li>예시: <code>\bcat\b</code>는 “The cat sat” 문장에서 “cat”과 매칭되지만 “category”의 일부와는 매칭되지 않음</li>
</ul></li>
<li><code>\B</code>: 단어 경계가 아닌 위치
<ul>
<li>예시: <code>\Bcat\B</code>는 “location”의 “cat”과 매칭되지만 독립된 단어 “cat”과는 매칭되지 않음</li>
</ul></li>
</ol>
</section>
<section id="선택과-대안" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="선택과-대안"><span class="header-section-number">1.7</span> 선택과 대안</h2>
<ol type="1">
<li><code>|</code> - 대안 패턴 (OR 연산자)
<ul>
<li>예시: <code>cat|dog</code>는 “cat”과 “dog” 모두와 매칭됨 ### NLP에서의 정규표현식 활용 예시</li>
</ul></li>
</ol>
<ul>
<li>정규표현식은 자연어 처리(NLP)에서 다양한 텍스트 전처리 및 정보 추출 작업에 활용</li>
</ul>
<section id="이메일-주소-추출" class="level4" data-number="1.7.0.1">
<h4 data-number="1.7.0.1" class="anchored" data-anchor-id="이메일-주소-추출"><span class="header-section-number">1.7.0.1</span> 이메일 주소 추출</h4>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> re</span>
<span id="cb3-2"></span>
<span id="cb3-3">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"연락처: john.doe@example.com, support@company.co.kr, help-desk@org.net"</span></span>
<span id="cb3-4"></span>
<span id="cb3-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 이메일 패턴</span></span>
<span id="cb3-6">email_pattern <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'</span></span>
<span id="cb3-7"></span>
<span id="cb3-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 모든 이메일 주소 추출</span></span>
<span id="cb3-9">emails <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.findall(email_pattern, text)</span>
<span id="cb3-10"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(emails)</span>
<span id="cb3-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력: ['john.doe@example.com', 'support@company.co.kr', 'help-desk@org.net']</span></span></code></pre></div>
</section>
<section id="url-추출" class="level4" data-number="1.7.0.2">
<h4 data-number="1.7.0.2" class="anchored" data-anchor-id="url-추출"><span class="header-section-number">1.7.0.2</span> URL 추출</h4>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> re</span>
<span id="cb4-2"></span>
<span id="cb4-3">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"참고 링크는 https://example.com/page, http://test.co.kr 그리고 www.resources.org/docs 입니다."</span></span>
<span id="cb4-4"></span>
<span id="cb4-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># URL 패턴</span></span>
<span id="cb4-6">url_pattern <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'https?://[^\s]+|www\.[^\s]+'</span></span>
<span id="cb4-7"></span>
<span id="cb4-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 모든 URL 추출</span></span>
<span id="cb4-9">urls <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.findall(url_pattern, text)</span>
<span id="cb4-10"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(urls)</span>
<span id="cb4-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력: ['https://example.com/page', 'http://test.co.kr', 'www.resources.org/docs']</span></span></code></pre></div>
</section>
<section id="문장-토큰화" class="level4" data-number="1.7.0.3">
<h4 data-number="1.7.0.3" class="anchored" data-anchor-id="문장-토큰화"><span class="header-section-number">1.7.0.3</span> 문장 토큰화</h4>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> re</span>
<span id="cb5-2"></span>
<span id="cb5-3">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"안녕하세요. 정규표현식을 배우고 있습니다! 어렵지만 유용하죠? 화이팅..."</span></span>
<span id="cb5-4"></span>
<span id="cb5-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 문장 경계 패턴 (마침표, 느낌표, 물음표 뒤에 공백)</span></span>
<span id="cb5-6">sentence_pattern <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'[.!?]+\s+'</span></span>
<span id="cb5-7"></span>
<span id="cb5-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 문장으로 분리</span></span>
<span id="cb5-9">sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.split(sentence_pattern, text)</span>
<span id="cb5-10"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(sentences)</span>
<span id="cb5-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력: ['안녕하세요', '정규표현식을 배우고 있습니다', '어렵지만 유용하죠', '화이팅...']</span></span></code></pre></div>
</section>
<section id="해시태그-추출-소셜-미디어-분석" class="level4" data-number="1.7.0.4">
<h4 data-number="1.7.0.4" class="anchored" data-anchor-id="해시태그-추출-소셜-미디어-분석"><span class="header-section-number">1.7.0.4</span> 해시태그 추출 (소셜 미디어 분석)</h4>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> re</span>
<span id="cb6-2"></span>
<span id="cb6-3">tweet <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"오늘 날씨가 좋네요 #날씨 #봄 #산책 @친구 같이 가자!"</span></span>
<span id="cb6-4"></span>
<span id="cb6-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 해시태그 패턴</span></span>
<span id="cb6-6">hashtag_pattern <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'#\w+'</span></span>
<span id="cb6-7"></span>
<span id="cb6-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 모든 해시태그 추출</span></span>
<span id="cb6-9">hashtags <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.findall(hashtag_pattern, tweet)</span>
<span id="cb6-10"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(hashtags)</span>
<span id="cb6-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력: ['#날씨', '#봄', '#산책']</span></span></code></pre></div>
</section>
<section id="날짜-형식-표준화" class="level4" data-number="1.7.0.5">
<h4 data-number="1.7.0.5" class="anchored" data-anchor-id="날짜-형식-표준화"><span class="header-section-number">1.7.0.5</span> 날짜 형식 표준화</h4>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> re</span>
<span id="cb7-2"></span>
<span id="cb7-3">dates <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [</span>
<span id="cb7-4">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"2023-05-15"</span>, </span>
<span id="cb7-5">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"05/15/2023"</span>, </span>
<span id="cb7-6">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"15.05.2023"</span>,</span>
<span id="cb7-7">    <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"May 15, 2023"</span></span>
<span id="cb7-8">]</span>
<span id="cb7-9"></span>
<span id="cb7-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 다양한 날짜 패턴 처리</span></span>
<span id="cb7-11"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> date <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> dates:</span>
<span id="cb7-12">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># YYYY-MM-DD 패턴</span></span>
<span id="cb7-13">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> re.match(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'^\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{4}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">-\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{2}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">-\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{2}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">$'</span>, date):</span>
<span id="cb7-14">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>date<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;"> -&gt; 이미 표준 형식"</span>)</span>
<span id="cb7-15">    </span>
<span id="cb7-16">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># MM/DD/YYYY 패턴</span></span>
<span id="cb7-17">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> re.match(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'^\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{2}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">/\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{2}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">/\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{4}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">$'</span>, date):</span>
<span id="cb7-18">        m, d, y <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.findall(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'(\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{2}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">)/(\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{2}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">)/(\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{4}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">)'</span>, date)[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb7-19">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>date<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;"> -&gt; </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>y<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">-</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>m<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">-</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>d<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb7-20">    </span>
<span id="cb7-21">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># DD.MM.YYYY 패턴</span></span>
<span id="cb7-22">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> re.match(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'^\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{2}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">\.\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{2}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">\.\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{4}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">$'</span>, date):</span>
<span id="cb7-23">        d, m, y <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.findall(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'(\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{2}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">)\.(\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{2}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">)\.(\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{4}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">)'</span>, date)[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb7-24">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>date<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;"> -&gt; </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>y<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">-</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>m<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">-</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>d<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb7-25">    </span>
<span id="cb7-26">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 월 이름 패턴</span></span>
<span id="cb7-27">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> re.match(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'^[A-Za-z]+ \d{1,2}, \d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{4}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">$'</span>, date):</span>
<span id="cb7-28">        month_names <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"January"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"01"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"February"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"02"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"March"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"03"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"April"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"04"</span>, </span>
<span id="cb7-29">                      <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"May"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"05"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"June"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"06"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"July"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"07"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"August"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"08"</span>, </span>
<span id="cb7-30">                      <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"September"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"09"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"October"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"10"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"November"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"11"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"December"</span>: <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"12"</span>}</span>
<span id="cb7-31">        </span>
<span id="cb7-32">        match <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.match(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'^([A-Za-z]+) (\d{1,2}), (\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{4}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">)$'</span>, date)</span>
<span id="cb7-33">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> match:</span>
<span id="cb7-34">            month, day, year <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> match.groups()</span>
<span id="cb7-35">            month_num <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> month_names.get(month, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"00"</span>)</span>
<span id="cb7-36">            day <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> day.zfill(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 한 자리 숫자면 앞에 0 추가</span></span>
<span id="cb7-37">            <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>date<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;"> -&gt; </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>year<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">-</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>month_num<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">-</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>day<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span></code></pre></div>
</section>
<section id="개체명-추출" class="level4" data-number="1.7.0.6">
<h4 data-number="1.7.0.6" class="anchored" data-anchor-id="개체명-추출"><span class="header-section-number">1.7.0.6</span> 개체명 추출</h4>
<ul>
<li>간단한 규칙 기반으로 정확한 원하는 답을 얻을 순 없지만 규칙을 정밀하게 보완하면 어느 정도 후보군을 추릴 수 있다.</li>
<li>이런 규칙 기반의 텍스트 추출을 할 때 정규표현식이 필수적으로 사용된다.)</li>
<li>예를 들어 아래의 인명을 추출하는 것은 다음과 같은 추가 조건을 추가하면 좋다.
<ul>
<li>사전 기반 접근법: 흔한 한국 성씨 목록을 사용해 필터링</li>
<li>문맥 분석: 이름 앞뒤로 나오는 “씨”, “님”, “대표” 등의 호칭 고려</li>
<li>기계학습 방식 (ex.NER, Named Entity Recognition 모델 사용)</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> re</span>
<span id="cb8-2"></span>
<span id="cb8-3">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"""</span></span>
<span id="cb8-4"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">김철수 대표는 삼성전자에서 5년간 근무했으며, 현재 서울특별시 강남구에 거주 중입니다.</span></span>
<span id="cb8-5"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">그는 한국대학교를 졸업했고, 현재 7,500,000원의 월급을 받고 있습니다.</span></span>
<span id="cb8-6"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"""</span></span>
<span id="cb8-7"></span>
<span id="cb8-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 인명 패턴 (성+이름) : 성이 2~4글자, 이름이 2~4글자 또는 2~5글자</span></span>
<span id="cb8-9">person_pattern <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'[가-힣]{2,4}\s[가-힣]{2,4}|[가-힣]{2,5}'</span></span>
<span id="cb8-10">persons <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.findall(person_pattern, text)</span>
<span id="cb8-11"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"인명:"</span>, persons) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 인명: ['김철수', '대표는', '현재', '서울특별시', '강남구에', '거주', '현재']</span></span>
<span id="cb8-12"></span>
<span id="cb8-13"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 기관명 패턴</span></span>
<span id="cb8-14">org_pattern <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'[가-힣a-zA-Z0-9]+[대학교|회사|전자|은행|그룹]'</span></span>
<span id="cb8-15">orgs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.findall(org_pattern, text)</span>
<span id="cb8-16"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"기관:"</span>, orgs)</span>
<span id="cb8-17"></span>
<span id="cb8-18"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 금액 패턴</span></span>
<span id="cb8-19">money_pattern <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'[0-9,]+원'</span></span>
<span id="cb8-20">money <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.findall(money_pattern, text)</span>
<span id="cb8-21"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"금액:"</span>, money)</span>
<span id="cb8-22"></span>
<span id="cb8-23"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 지역 패턴</span></span>
<span id="cb8-24">location_pattern <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'[가-힣]+[시|도|군|구](\s[가-힣]+[시|도|군|구])?'</span></span>
<span id="cb8-25">locations <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.findall(location_pattern, text)</span>
<span id="cb8-26"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"지역:"</span>, locations)</span></code></pre></div>
</section>
<section id="텍스트-정제-html-태그-제거" class="level4" data-number="1.7.0.7">
<h4 data-number="1.7.0.7" class="anchored" data-anchor-id="텍스트-정제-html-태그-제거"><span class="header-section-number">1.7.0.7</span> 텍스트 정제 (HTML 태그 제거)</h4>
<div class="sourceCode" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> re</span>
<span id="cb9-2"></span>
<span id="cb9-3">html <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"&lt;p&gt;안녕하세요. &lt;b&gt;정규표현식&lt;/b&gt;으로 &lt;span style='color:red'&gt;HTML 태그&lt;/span&gt;를 제거합니다.&lt;/p&gt;"</span></span>
<span id="cb9-4"></span>
<span id="cb9-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># HTML 태그 제거 패턴</span></span>
<span id="cb9-6">clean_text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.sub(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'&lt;[^&gt;]+&gt;'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">''</span>, html)</span>
<span id="cb9-7"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(clean_text)</span>
<span id="cb9-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력: 안녕하세요. 정규표현식으로 HTML 태그를 제거합니다.</span></span></code></pre></div>
</section>
<section id="특수문자-정규화" class="level4" data-number="1.7.0.8">
<h4 data-number="1.7.0.8" class="anchored" data-anchor-id="특수문자-정규화"><span class="header-section-number">1.7.0.8</span> 특수문자 정규화</h4>
<div class="sourceCode" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> re</span>
<span id="cb10-2"></span>
<span id="cb10-3">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"텍스트 정제 작업: 특수문자(!@#$%^&amp;*)를 제거하거나 변환합니다."</span></span>
<span id="cb10-4"></span>
<span id="cb10-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 특수문자 제거</span></span>
<span id="cb10-6">clean_text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.sub(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'[^\w\s]'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">''</span>, text)</span>
<span id="cb10-7"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(clean_text)</span>
<span id="cb10-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력: 텍스트 정제 작업 특수문자를 제거하거나 변환합니다</span></span></code></pre></div>
</section>
<section id="단어-빈도-분석" class="level4" data-number="1.7.0.9">
<h4 data-number="1.7.0.9" class="anchored" data-anchor-id="단어-빈도-분석"><span class="header-section-number">1.7.0.9</span> 단어 빈도 분석</h4>
<div class="sourceCode" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> re</span>
<span id="cb11-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> collections <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Counter</span>
<span id="cb11-3"></span>
<span id="cb11-4">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"""</span></span>
<span id="cb11-5"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">자연어 처리(NLP)는 컴퓨터가 인간의 언어를 이해하고 처리하는 기술입니다.</span></span>
<span id="cb11-6"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">자연어 처리는 텍스트 분석, 기계 번역, 감성 분석 등 다양한 분야에 활용됩니다.</span></span>
<span id="cb11-7"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"""</span></span>
<span id="cb11-8"></span>
<span id="cb11-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 단어 추출 (한글, 영문, 숫자)</span></span>
<span id="cb11-10">words <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.findall(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'\b[가-힣a-zA-Z0-9]+\b'</span>, text)</span>
<span id="cb11-11">word_counts <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Counter(words)</span>
<span id="cb11-12"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(word_counts.most_common(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>))</span></code></pre></div>
</section>
<section id="전화번호-추출-및-정규화" class="level4" data-number="1.7.0.10">
<h4 data-number="1.7.0.10" class="anchored" data-anchor-id="전화번호-추출-및-정규화"><span class="header-section-number">1.7.0.10</span> 전화번호 추출 및 정규화</h4>
<div class="sourceCode" id="cb12" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> re</span>
<span id="cb12-2"></span>
<span id="cb12-3">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"연락처 목록: 010-1234-5678, 02)987-6543, 01099998888, +82-10-5555-1234"</span></span>
<span id="cb12-4"></span>
<span id="cb12-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전화번호 패턴</span></span>
<span id="cb12-6">phone_pattern <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r'(\+\d{1,3}[-\s]?)?(\d{2,3}[-\)\s]?)?(\d{3,4}[-\s]?)(\d</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{4}</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">)'</span></span>
<span id="cb12-7">phones <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> re.findall(phone_pattern, text)</span>
<span id="cb12-8"></span>
<span id="cb12-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전화번호 정규화</span></span>
<span id="cb12-10">normalized_phones <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb12-11"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> phone <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> phones:</span>
<span id="cb12-12">    country, area, first, last <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> phone</span>
<span id="cb12-13">    normalized <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>area<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>replace(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">')'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">''</span>)<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">-</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>first<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>replace(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'-'</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">''</span>)<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">-</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>last<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span></span>
<span id="cb12-14">    normalized_phones.append(normalized)</span>
<span id="cb12-15"></span>
<span id="cb12-16"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(normalized_phones)</span>
<span id="cb12-17"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력: ['010-1234-5678', '02-987-6543', '010-9999-8888', '10-5555-1234']</span></span></code></pre></div>
<ul>
<li>이러한 정규표현식 활용은 NLP 파이프라인의 전처리 단계에서 텍스트 정제, 토큰화, 정보 추출에 매우 유용하다</li>
<li>하지만 복잡한 언어 패턴 분석에는 한계가 있어 고급 NLP 작업에는 딥러닝 모델과 함께 사용되는 경우가 많다.</li>
</ul>


</section>
</section>
</section>

 ]]></description>
  <category>NLP</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Deep_Learning/NLP/3.pre_prcs_regular_expression.html</guid>
  <pubDate>Thu, 02 Jan 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>토큰화 (Tokenization)</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Deep_Learning/NLP/2.pre_prcs_tokenization.html</link>
  <description><![CDATA[ 




<section id="내용-요약" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 내용 요약</h1>
<ul>
<li>토큰화란?:
<ul>
<li>자연어 처리(NLP)의 첫 단계로, 텍스트를 컴퓨터가 이해할 수 있는 의미 있는 단위(토큰)로 분할하는 과정</li>
</ul></li>
<li>왜 중요한가?:
<ul>
<li>텍스트를 구조화하고, 표준화하며, 후속 NLP 작업의 효율성을 높이고, 언어적 의미를 보존</li>
</ul></li>
<li>어떤 종류가 있나?:
<ul>
<li>문장 토큰화: 텍스트를 문장 단위로 나눈다. (예: 마침표, 물음표 등 구분)</li>
<li>단어 토큰화: 문장을 단어 단위로 나눈다. (예: 공백, 구두점 등 기준)</li>
<li>서브워드 토큰화: 단어를 더 작은 의미 단위(subword)로 나눈다. (예: BPE, WordPiece, SentencePiece)</li>
</ul></li>
<li>고려할 점은?:
<ul>
<li>각 토큰화 방법은 장단점이 있으며, 특히 문장/단어 토큰화는 다양한 예외 케이스(약어, 특수문자, 이메일 주소 등)로 인해 복잡할 수 있다.</li>
<li>언어별 특성(한국어 교착어 등), 도메인 특성(소셜미디어 약어 등)에 따라 상세한 규칙을 적용해 처리해야 한다.</li>
<li>규칙을 만들어 구현하는 것 보다는 이미 검증된 도구를 활용하는 것이 좋다.</li>
</ul></li>
<li>어떤 도구를 쓰나?:
<ul>
<li>NLTK, KoNLPy, spaCy, Transformers 라이브러리 등 검증된 도구를 활용하는 것이 좋다.
<ul>
<li><strong>NLTK (Natural Language Toolkit)</strong>:
<ul>
<li>설명: 영어 자연어 처리를 위한 대표적인 라이브러리. 교육 및 연구 목적으로 많이 사용됨.</li>
<li>특징: TreebankWordTokenizer (단어), sent_tokenize (문장) 등 다양한 토큰화 기능 제공.</li>
<li>장점: 사용이 간편하고 다양한 기능을 제공. Penn Treebank 규칙 등 검증된 방식 사용.</li>
<li>단점: 다른 라이브러리에 비해 처리 속도가 느릴 수 있음.</li>
</ul></li>
<li><strong>KoNLPy (Korean NLP Library)</strong>:
<ul>
<li>설명: 한국어 형태소 분석 및 자연어 처리를 위한 파이썬 패키지 모음.</li>
<li>특징: Okt, Komoran, Hannanum 등 다양한 형태소 분석기 포함.</li>
<li>장점: 한국어의 교착어 특성을 고려한 형태소 분석 가능. 다양한 분석기 선택 가능.</li>
<li>단점: 형태소 분석기마다 성능과 속도 차이가 있으며, 일부는 설치가 복잡할 수 있음.</li>
</ul></li>
<li><strong>spaCy (English Language Library)</strong>:
<ul>
<li>설명: 산업 수준의 빠르고 효율적인 NLP 라이브러리.</li>
<li>특징: 다국어 지원(한국어 포함), 빠른 처리 속도, 통합된 NLP 파이프라인 제공.</li>
<li>장점: 속도가 매우 빠르고 안정적이며, 다양한 언어 및 기능을 지원하여 실제 제품 환경에 적합.</li>
<li>단점: 특정 언어나 도메인에 대한 세밀한 조정은 NLTK나 KoNLPy보다 유연성이 떨어질 수 있음.</li>
</ul></li>
<li><strong>Transformers (Hugging Face)</strong>:
<ul>
<li>설명: 최신 딥러닝 모델(BERT, GPT 등)에서 사용되는 토크나이저를 제공하는 라이브러리.</li>
<li>특징: 서브워드 토큰화(BPE, WordPiece, SentencePiece) 기반. AutoTokenizer로 다양한 모델의 토크나이저 쉽게 로드.</li>
<li>장점: OOV(Out-of-Vocabulary) 문제에 강하고, 딥러닝 모델의 성능을 극대화. 다국어 모델 지원.</li>
<li>단점: 기존 규칙 기반 토큰화보다 직관성이 떨어질 수 있으며, 모델별 토큰화 방식이 다를 수 있음.</li>
</ul></li>
</ul></li>
</ul></li>
<li>추가적으로:
<ul>
<li>언어별 특성(한국어 교착어 등), 도메인 특성(소셜미디어 약어 등)에 따라 적절한 도구와 전략을 선택해야 한다.</li>
</ul></li>
<li>이러한 도전 과제, 평가 방법, 실제 적용 사례 및 최신 연구 동향도 간략히 소개한다.</li>
</ul>
</section>
<section id="토큰화-개요" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 토큰화 개요</h1>
<ul>
<li>토큰화(Tokenization)는 자연어 처리에서 가장 기본이 되는 전처리 과정이다. *컴퓨터가 이해할 수 있도록 연속된 텍스트를 의미 있는 단위(토큰)로 분할하는 작업을 의미한다.</li>
</ul>
<section id="토큰화의-정의와-목적" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="토큰화의-정의와-목적"><span class="header-section-number">2.1</span> 토큰화의 정의와 목적</h2>
<p><strong>토큰화</strong>란 기계에게 어느 구간까지가 문장이고 단어인지를 알려주는 과정이다. 인간은 자연스럽게 문장의 구조를 이해하지만, 컴퓨터는 명시적으로 경계를 정해줘야 한다.</p>
<section id="주요-목적" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="주요-목적"><span class="header-section-number">2.1.1</span> 주요 목적</h3>
<ul>
<li>구조화: 비구조화된 텍스트를 구조화된 형태로 변환한다.</li>
<li>표준화: 일관된 처리 단위를 제공한다.</li>
<li>효율성: 후속 NLP 작업의 효율성을 향상시킨다.</li>
<li>의미 보존: 언어의 의미를 최대한 보존하면서 분할한다.</li>
</ul>
</section>
</section>
<section id="토큰화의-종류" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="토큰화의-종류"><span class="header-section-number">2.2</span> 토큰화의 종류</h2>
<p>토큰화는 분할 단위에 따라 여러 가지 방법으로 분류할 수 있다.</p>
<section id="문장-토큰화-sentence-tokenization" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="문장-토큰화-sentence-tokenization"><span class="header-section-number">2.2.1</span> 문장 토큰화 (Sentence Tokenization)</h3>
<p>텍스트를 문장 단위로 분할하는 과정이다.</p>
<p><strong>한글 예시:</strong></p>
<pre><code>입력: "자연어 처리는 매우 흥미로운 분야입니다. 컴퓨터가 인간의 언어를 이해하고 처리할 수 있게 만드는 기술이죠. 최근 딥러닝 기술의 발전으로 놀라운 성과를 보이고 있습니다. 특히 GPT나 BERT 같은 모델들이 주목받고 있어요."

출력: [
  "자연어 처리는 매우 흥미로운 분야입니다.",
  "컴퓨터가 인간의 언어를 이해하고 처리할 수 있게 만드는 기술이죠.",
  "최근 딥러닝 기술의 발전으로 놀라운 성과를 보이고 있습니다.",
  "특히 GPT나 BERT 같은 모델들이 주목받고 있어요."
]</code></pre>
<p><strong>영어 예시:</strong></p>
<pre><code>입력: "Natural language processing is a fascinating field of study. It combines linguistics, computer science, and artificial intelligence to help computers understand human language. Recent advances in deep learning have revolutionized this area. Models like GPT and BERT have achieved remarkable performance on various NLP tasks."

출력: [
  "Natural language processing is a fascinating field of study.",
  "It combines linguistics, computer science, and artificial intelligence to help computers understand human language.",
  "Recent advances in deep learning have revolutionized this area.",
  "Models like GPT and BERT have achieved remarkable performance on various NLP tasks."
]</code></pre>
<p><strong>주요 고려사항:</strong> - 마침표, 느낌표, 물음표 등의 문장 종결 부호 - 줄임말과 약어 처리 (예: “Dr.”, “etc.”) - 인용문 내의 문장 부호</p>
<section id="문장-토큰화에-대한-고민" class="level4" data-number="2.2.1.1">
<h4 data-number="2.2.1.1" class="anchored" data-anchor-id="문장-토큰화에-대한-고민"><span class="header-section-number">2.2.1.1</span> 문장 토큰화에 대한 고민</h4>
<ul>
<li>문장 토큰화는 겉보기에는 간단해 보이지만, 실제로는 매우 복잡한 언어학적 문제들을 내포하고 있다.</li>
<li>비전문가들은 마침표, 쉼표, 느낌표, 물음표만 있으면 문장을 쉽게 구분할 수 있다고 생각하지만, 현실은 그렇게 단순하지 않다.</li>
</ul>
<p><strong>1. 마침표의 다중 의미 딜레마</strong></p>
<p>마침표가 항상 문장의 끝을 의미하는 것은 아니다. 동일한 기호가 완전히 다른 용도로 사용되는 경우가 빈번하다.</p>
<pre><code>예시 1: 약어와 문장 종료의 혼재
"Dr. Smith earned his Ph.D. from MIT in 1995. He now works at NASA."

잘못된 분할:
- "Dr."
- "Smith earned his Ph."
- "D."
- "from MIT in 1995."
- "He now works at NASA."

올바른 분할:
- "Dr. Smith earned his Ph.D. from MIT in 1995."
- "He now works at NASA."</code></pre>
<p>같은 마침표이지만 “Dr.”와 “Ph.D.”는 약어를 나타내고, 마지막 마침표만이 실제 문장의 끝을 의미한다.</p>
<p><strong>2. 이메일 주소의 함정</strong></p>
<pre><code>예시 2: 이메일과 URL이 포함된 텍스트
"Contact john.doe@company.com for details. Visit www.company.com. Our office is open 9 A.M. to 5 P.M."

잘못된 분할:
- "Contact john."
- "doe@company."
- "com for details."
- "Visit www."
- "company."
- "com."
- "Our office is open 9 A."
- "M."
- "to 5 P."
- "M."

올바른 분할:
- "Contact john.doe@company.com for details."
- "Visit www.company.com."
- "Our office is open 9 A.M. to 5 P.M."</code></pre>
<p>이메일 주소와 웹사이트 URL 내의 마침표들은 문장 구분자가 아닙니다.</p>
<p><strong>3. 숫자와 소수점의 복잡성</strong></p>
<pre><code>예시 3: 숫자와 측정값
"The temperature reached 98.6°F yesterday. Sales increased by 15.7% this quarter. Our target is $1.5M."

잘못된 분할:
- "The temperature reached 98."
- "6°F yesterday."
- "Sales increased by 15."
- "7% this quarter."
- "Our target is $1."
- "5M."

올바른 분할:
- "The temperature reached 98.6°F yesterday."
- "Sales increased by 15.7% this quarter."
- "Our target is $1.5M."</code></pre>
<p>소수점, 통화 표시, 백분율 등에서 사용되는 마침표는 문장 구분자가 아니다.</p>
<p><strong>4. IP 주소와 기술 용어</strong></p>
<pre><code>예시 4: 기술 문서
"Connect to server 192.168.1.1 on port 8080. Use API version 2.3. Check logs at /var/log/app.log for errors."

잘못된 분할:
- "Connect to server 192."
- "168."
- "1."
- "1 on port 8080."
- "Use API version 2."
- "3."
- "Check logs at /var/log/app."
- "log for errors."

올바른 분할:
- "Connect to server 192.168.1.1 on port 8080."
- "Use API version 2.3."
- "Check logs at /var/log/app.log for errors."</code></pre>
<p>IP 주소, 버전 번호, 파일 경로에서 사용되는 마침표들은 모두 문장 구분자가 아니다.</p>
<p><strong>5. 인용문과 대화체의 복잡성</strong></p>
<pre><code>예시 5: 직접 인용문
'He said, "I don't think so. Maybe tomorrow?" Then he left.'

잘못된 분할:
- 'He said, "I don't think so.'
- 'Maybe tomorrow?"'
- 'Then he left.'

올바른 분할:
- 'He said, "I don't think so. Maybe tomorrow?" Then he left.'</code></pre>
<p>인용문 내부의 문장 부호는 전체 문장의 구조를 고려해야 한다.</p>
<p><strong>6. 줄임표와 생략 표현</strong></p>
<pre><code>예시 6: 줄임표의 혼란
"Well... I'm not sure. He seemed hesitant... maybe nervous? The meeting went on and on..."

문제점:
- "Well..."의 "..."는 망설임을 표현
- "hesitant..."의 "..."는 말끝을 흐림  
- "on and on..."의 "..."는 문장의 실제 종료

이런 경우 어디서 문장을 나눠야 할지 판단하기 어렵다.</code></pre>
<ol start="7" type="1">
<li>이외에도, 다양한 유형의 문장 토큰화 문제가 있다.</li>
</ol>
<ul>
<li><strong>프로그래밍 코드가 포함된 텍스트</strong></li>
<li><strong>시간과 날짜 표기법</strong></li>
<li><strong>학술 논문과 참고문헌</strong></li>
</ul>
<p>결론적으로, 문장 토큰화는 단순한 규칙 기반 접근법으로는 해결되지 않는다. 다음과 같은 요소들을 종합적으로 고려해야 한다:</p>
<ul>
<li><strong>문맥 정보</strong>: 주변 단어와 문장의 맥락</li>
<li><strong>도메인 지식</strong>: 의학, 법률, 기술 문서의 특수성</li>
<li><strong>언어적 규칙</strong>: 각 언어의 고유한 문법과 표기법</li>
<li><strong>의미론적 이해</strong>: 문장의 완결성과 논리적 구조</li>
<li><strong>다중 언어 처리</strong>: 코드 스위칭과 외래어 처리</li>
</ul>
<p>이러한 복잡성 때문에 현대의 문장 토큰화 도구들은 기계학습 기반의 접근법을 사용하여 문맥을 이해하고 더 정확한 분할을 수행하려고 시도한다. 하지만 여전히 완벽한 해결책은 없으며, 지속적인 연구와 개선이 필요한 영역이다.</p>
</section>
</section>
<section id="단어-토큰화-word-tokenization" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="단어-토큰화-word-tokenization"><span class="header-section-number">2.2.2</span> 단어 토큰화 (Word Tokenization)</h3>
<p>문장을 단어 단위로 분할하는 과정이다.</p>
<p><strong>한글 예시:</strong></p>
<pre><code>입력: "자연어 처리는 매우 흥미로운 분야입니다. 컴퓨터가 인간의 언어를 이해하고 처리할 수 있게 만드는 기술이죠. 최근 딥러닝 기술의 발전으로 놀라운 성과를 보이고 있습니다. 특히 GPT나 BERT 같은 모델들이 주목받고 있어요."

출력: [
  "자연어", "처리", "는", "매우", "흥미로운", "분야입니다", ".", "컴퓨터가", "인간의", "언어를", "이해하고", "처리할", "수", "있게", "만드는", "기술이죠", ".", "최근", "딥러닝", "기술의", "발전으로", "놀라운", "성과를", "보이고", "있습니다", ".", "특히", "GPT나", "BERT", "같은", "모델들이", "주목받고", "있어요"
]</code></pre>
<p><strong>영어 예시:</strong></p>
<pre><code>입력: "Natural language processing is a fascinating field of study. It combines linguistics, computer science, and artificial intelligence to help computers understand human language. Recent advances in deep learning have revolutionized this area. Models like GPT and BERT have achieved remarkable performance on various NLP tasks."

출력: [
  "Natural", "language", "processing", "is", "a", "fascinating", "field", "of", "study", ".", "It", "combines", "linguistics", "computer", "science", "and", "artificial", "intelligence", "to", "help", "computers", "understand", "human", "language", ".", "Recent", "advances", "in", "deep", "learning", "have", "revolutionized", "this", "area", ".", "Models", "like", "GPT", "and", "BERT", "have", "achieved", "remarkable", "performance", "on", "various", "NLP", "tasks"
]</code></pre>
<p><strong>언어별 특성:</strong></p>
<ul>
<li>영어
<ul>
<li>공백을 기준으로 비교적 쉽게 분할 가능</li>
<li>구두점 처리가 주요 과제</li>
</ul></li>
<li>한국어
<ul>
<li>교착어 특성으로 복잡한 어미 변화</li>
<li>공백만으로는 정확한 분할 어려움</li>
</ul></li>
<li>형태소 분석이 필요</li>
</ul>
<section id="단어-토큰화에-대한-고민" class="level4" data-number="2.2.2.1">
<h4 data-number="2.2.2.1" class="anchored" data-anchor-id="단어-토큰화에-대한-고민"><span class="header-section-number">2.2.2.1</span> 단어 토큰화에 대한 고민</h4>
<p>문장 토큰화와 마찬가지로, 단어 토큰화 역시 많은 복잡한 문제들을 내포하고 있다.</p>
<p><strong>1. 특수문자 처리의 딜레마</strong></p>
<p>문장 내에서 단어를 어떻게 구분할까? 느낌표나 어포스트로피 같은 특수문자가 들어갔을 때 문제가 발생한다.</p>
<pre><code>예시:
"I can't believe it!" 

처리 방법 1: ["I", "can't", "believe", "it!"]
처리 방법 2: ["I", "can", "'", "t", "believe", "it", "!"]
처리 방법 3: ["I", "cannot", "believe", "it"]</code></pre>
<p>어떤 방법이 정답일까? 각각 장단점이 있어 선택하기 어렵다.</p>
<p><strong>2. 동일한 의미, 다른 토큰화 결과</strong></p>
<p>의미가 동일한 문장들에 대해서 <strong>띄어쓰기 단위</strong>로 단어를 나눠본다면, 같은 의미이지만 컴퓨터는 다르게 취급한다.</p>
<pre><code>문장 1: "He is a hero."
문장 2: "He is a hero?"
문장 3: "He is a hero!"

토큰화 결과:
문장 1: ["He", "is", "a", "hero."]
문장 2: ["He", "is", "a", "hero?"]  
문장 3: ["He", "is", "a", "hero!"]</code></pre>
<p>의미가 동일함에도 전부 다른 결과를 얻는다. <code>hero</code> ≠ <code>hero?</code> ≠ <code>hero!</code> 왜냐하면 컴퓨터가 인식하기에는 전부 다른 단어들이기 때문이다.</p>
<p><strong>3. 특수문자 제거의 부작용</strong></p>
<p><strong>특수 문자</strong>가 토큰화에 방해가 된다고 해서 모든 특수 문자를 제거하는 규칙을 넣는다면?</p>
<pre><code>원본: "He has a Ph.D in computer science."
특수문자 제거 후: "He has a Ph D in computer science."

토큰화 결과:
원본: ["He", "has", "a", "Ph.D", "in", "computer", "science", "."]
제거 후: ["He", "has", "a", "Ph", "D", "in", "computer", "science"]</code></pre>
<p><code>Ph.D</code> ≠ <code>Ph D</code> - 특수 문자 제거로 인해 본래 의미를 상실하는 경우가 발생한다.</p>
<p><strong>4. 더 복잡한 사례들</strong></p>
<pre><code>- "U.S.A" vs "USA" vs "U S A"
- "don't" vs "do not" vs "dont"  
- "New York" vs "New-York" vs "NewYork"
- "COVID-19" vs "COVID 19" vs "COVID19"
- "machine-learning" vs "machine learning"</code></pre>
<p>각각은 같은 의미를 담고 있지만, 토큰화 결과는 완전히 다르다.</p>
<p><strong>5. 언어별 특수성</strong></p>
<pre><code>한국어:
"안녕하세요" vs "안녕 하세요" vs "안녕하 세요"
"먹었습니다" → ["먹", "었", "습니다"] vs ["먹었습니다"]

영어:
"state-of-the-art" → ["state", "of", "the", "art"] vs ["state-of-the-art"]</code></pre>
<p><strong>결론: 섬세한 규칙 설계의 필요성</strong></p>
<ul>
<li><p>단어 토큰화 작업은 상당히 섬세한 규칙을 설계해야만 한다.</p></li>
<li><p>단순히 공백으로 나누는 것으로는 해결되지 않으며, 다음과 같은 요소들을 종합적으로 고려해야 한다:</p></li>
<li><p><strong>도메인 특성</strong>: 의학, 법률, 소셜미디어 등</p></li>
<li><p><strong>언어 특성</strong>: 형태소, 문법 구조</p></li>
<li><p><strong>목적</strong>: 번역, 감정분석, 검색 등</p></li>
<li><p><strong>일관성</strong>: 동일한 규칙의 지속적 적용</p></li>
</ul>
<p>이러한 복잡성 때문에 최근에는 서브워드 토큰화 방법들이 주목받고 있다.</p>
</section>
</section>
<section id="서브워드-토큰화-subword-tokenization" class="level3" data-number="2.2.3">
<h3 data-number="2.2.3" class="anchored" data-anchor-id="서브워드-토큰화-subword-tokenization"><span class="header-section-number">2.2.3</span> 서브워드 토큰화 (Subword Tokenization)</h3>
<p>단어보다 작은 단위로 분할하는 방법으로, 최근 딥러닝 모델에서 널리 사용된다.</p>
<section id="byte-pair-encoding-bpe" class="level4" data-number="2.2.3.1">
<h4 data-number="2.2.3.1" class="anchored" data-anchor-id="byte-pair-encoding-bpe"><span class="header-section-number">2.2.3.1</span> Byte Pair Encoding (BPE)</h4>
<p>가장 빈번하게 등장하는 문자 쌍을 반복적으로 병합하는 방법이다.</p>
<p><strong>과정:</strong> 1. 모든 단어를 문자 단위로 분할 2. 가장 빈번한 문자 쌍 찾기 3. 해당 쌍을 하나의 토큰으로 병합 4. 원하는 어휘 크기까지 반복</p>
<p><strong>예시:</strong></p>
<pre><code>초기: ["l", "o", "w", "e", "s", "t"]
1단계: ["lo", "w", "e", "s", "t"]    # "l"+"o" 병합
2단계: ["low", "e", "s", "t"]        # "lo"+"w" 병합
3단계: ["low", "es", "t"]            # "e"+"s" 병합
최종: ["low", "est"]                 # "es"+"t" 병합</code></pre>
</section>
<section id="wordpiece" class="level4" data-number="2.2.3.2">
<h4 data-number="2.2.3.2" class="anchored" data-anchor-id="wordpiece"><span class="header-section-number">2.2.3.2</span> WordPiece</h4>
<p>Google에서 개발한 방법으로, BERT 등에서 사용된다.</p>
<p><strong>특징:</strong> - 가능도(likelihood)를 최대화하는 방향으로 병합 - “##” 접두사로 서브워드 표시</p>
<p><strong>예시:</strong></p>
<pre><code>"playing" → ["play", "##ing"]
"walked" → ["walk", "##ed"]</code></pre>
</section>
<section id="sentencepiece" class="level4" data-number="2.2.3.3">
<h4 data-number="2.2.3.3" class="anchored" data-anchor-id="sentencepiece"><span class="header-section-number">2.2.3.3</span> SentencePiece</h4>
<p>언어에 독립적인 토큰화 방법이다.</p>
<p><strong>특징:</strong> - 공백도 특수 문자로 처리 - 다양한 언어에 적용 가능 - 전처리 없이 raw text 직접 처리</p>
</section>
</section>
</section>
<section id="토큰화-도구와-라이브러리" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="토큰화-도구와-라이브러리"><span class="header-section-number">2.3</span> 토큰화 도구와 라이브러리</h2>
<ul>
<li>앞서 살펴본 토큰화의 복잡성과 다양한 예외 상황들을 고려할 때, 개발자가 직접 상세한 규칙을 만들어 구현하려 하지 말고 이미 잘 개발되고 검증된 패키지들을 사용하는 것이 현명한 접근법이다.</li>
<li>기존에 검증된 패키지로 처리 불가한 예외적인 부분들만 커스터마이징해서 처리하면 된다.</li>
</ul>
<section id="영어-토큰화-도구" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="영어-토큰화-도구"><span class="header-section-number">2.3.1</span> 영어 토큰화 도구</h3>
<section id="단어-토큰화-treebankwordtokenizer" class="level4" data-number="2.3.1.1">
<h4 data-number="2.3.1.1" class="anchored" data-anchor-id="단어-토큰화-treebankwordtokenizer"><span class="header-section-number">2.3.1.1</span> 단어 토큰화: TreebankWordTokenizer</h4>
<p>Penn Treebank 코퍼스의 토큰화 규칙을 따르는 검증된 도구이다.</p>
<div class="sourceCode" id="cb18" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> nltk.tokenize <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> TreebankWordTokenizer</span>
<span id="cb18-2"></span>
<span id="cb18-3">tokenizer <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> TreebankWordTokenizer()</span>
<span id="cb18-4">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"He said, </span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\"</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">I can't believe it's working!</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\"</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;"> Dr. Smith agreed."</span></span>
<span id="cb18-5">tokens <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> tokenizer.tokenize(text)</span>
<span id="cb18-6"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(tokens)</span>
<span id="cb18-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ['He', 'said', ',', '``', 'I', 'ca', "n't", 'believe', 'it', "'s", 'working', '!', "''", 'Dr.', 'Smith', 'agreed', '.']</span></span></code></pre></div>
<p><strong>장점:</strong> - 축약형을 적절히 분리 (“can’t” → “ca”, “n’t”) - 인용문 처리 (<code></code> 와 ’’ 로 변환) - 약어 보존 (“Dr.” 유지) - 수십 년간 검증된 규칙</p>
</section>
<section id="문장-토큰화-nltk-sentence-tokenizer" class="level4" data-number="2.3.1.2">
<h4 data-number="2.3.1.2" class="anchored" data-anchor-id="문장-토큰화-nltk-sentence-tokenizer"><span class="header-section-number">2.3.1.2</span> 문장 토큰화: NLTK Sentence Tokenizer</h4>
<div class="sourceCode" id="cb19" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> nltk.tokenize <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> sent_tokenize</span>
<span id="cb19-2"></span>
<span id="cb19-3">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Dr. Smith earned his Ph.D. from MIT. He works at NASA. Contact him at john.doe@company.com."</span></span>
<span id="cb19-4">sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sent_tokenize(text)</span>
<span id="cb19-5"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(sentences)</span>
<span id="cb19-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ['Dr. Smith earned his Ph.D. from MIT.', 'He works at NASA.', 'Contact him at john.doe@company.com.']</span></span></code></pre></div>
<p><strong>특징:</strong> - 약어 목록을 내장하여 문맥 고려 - 이메일 주소 내 마침표 구분 - 다양한 언어 지원</p>
</section>
</section>
<section id="한국어-토큰화-도구" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="한국어-토큰화-도구"><span class="header-section-number">2.3.2</span> 한국어 토큰화 도구</h3>
<section id="문장-토큰화-kss-korean-sentence-splitter" class="level4" data-number="2.3.2.1">
<h4 data-number="2.3.2.1" class="anchored" data-anchor-id="문장-토큰화-kss-korean-sentence-splitter"><span class="header-section-number">2.3.2.1</span> 문장 토큰화: KSS (Korean Sentence Splitter)</h4>
<p>한국어 문장 분할에 특화된 고성능 라이브러리이다.</p>
<div class="sourceCode" id="cb20" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> kss</span>
<span id="cb20-2"></span>
<span id="cb20-3">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"안녕하세요. 제 이메일은 user@domain.co.kr입니다. 연락 주세요!"</span></span>
<span id="cb20-4">sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> kss.split_sentences(text)</span>
<span id="cb20-5"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(sentences)</span>
<span id="cb20-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ['안녕하세요.', '제 이메일은 user@domain.co.kr입니다.', '연락 주세요!']</span></span></code></pre></div>
<p><strong>장점:</strong> - 한국어 특화 규칙 - 이메일, URL 등 특수 패턴 인식 - 높은 정확도와 빠른 처리 속도</p>
</section>
<section id="단어-토큰화-konlpy-생태계" class="level4" data-number="2.3.2.2">
<h4 data-number="2.3.2.2" class="anchored" data-anchor-id="단어-토큰화-konlpy-생태계"><span class="header-section-number">2.3.2.2</span> 단어 토큰화: KoNLPy 생태계</h4>
<div class="sourceCode" id="cb21" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> konlpy.tag <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Okt, Komoran, Hannanum</span>
<span id="cb21-2"></span>
<span id="cb21-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Okt (Open Korean Text)</span></span>
<span id="cb21-4">okt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Okt()</span>
<span id="cb21-5">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"아버지가방에들어가신다"</span></span>
<span id="cb21-6">tokens <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> okt.morphs(text)</span>
<span id="cb21-7"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(tokens)</span>
<span id="cb21-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ['아버지', '가', '방', '에', '들어가', '신다']</span></span>
<span id="cb21-9"></span>
<span id="cb21-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Komoran</span></span>
<span id="cb21-11">komoran <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Komoran()</span>
<span id="cb21-12">tokens <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> komoran.morphs(text)</span>
<span id="cb21-13"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(tokens)</span>
<span id="cb21-14"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ['아버지', '가', '방', '에', '들어가', '시', 'ㄴ다']</span></span></code></pre></div>
</section>
</section>
<section id="다국어-및-고급-토큰화-도구" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="다국어-및-고급-토큰화-도구"><span class="header-section-number">2.3.3</span> 다국어 및 고급 토큰화 도구</h3>
<section id="spacy" class="level4" data-number="2.3.3.1">
<h4 data-number="2.3.3.1" class="anchored" data-anchor-id="spacy"><span class="header-section-number">2.3.3.1</span> spaCy</h4>
<p>산업 수준의 NLP 라이브러리</p>
<div class="sourceCode" id="cb22" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> spacy</span>
<span id="cb22-2"></span>
<span id="cb22-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 영어</span></span>
<span id="cb22-4">nlp_en <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> spacy.load(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"en_core_web_sm"</span>)</span>
<span id="cb22-5">doc <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nlp_en(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Dr. Smith's email is john@company.com. He earned his Ph.D. in 1995."</span>)</span>
<span id="cb22-6">sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [sent.text <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> sent <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> doc.sents]</span>
<span id="cb22-7">tokens <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [token.text <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> token <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> doc]</span>
<span id="cb22-8"></span>
<span id="cb22-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 한국어 (spacy-korean)</span></span>
<span id="cb22-10">nlp_ko <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> spacy.load(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ko_core_news_sm"</span>)</span>
<span id="cb22-11">doc <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nlp_ko(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"안녕하세요. 저는 데이터 과학자입니다."</span>)</span>
<span id="cb22-12">sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [sent.text <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> sent <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> doc.sents]</span></code></pre></div>
<p><strong>특징:</strong> - 다양한 언어 지원 - 빠른 처리 속도 - 통합된 NLP 파이프라인 - 산업 환경에 최적화</p>
</section>
<section id="transformers-토크나이저" class="level4" data-number="2.3.3.2">
<h4 data-number="2.3.3.2" class="anchored" data-anchor-id="transformers-토크나이저"><span class="header-section-number">2.3.3.2</span> Transformers 토크나이저</h4>
<p>최신 딥러닝 모델에서 사용되는 서브워드 토큰화이다.</p>
<div class="sourceCode" id="cb23" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> transformers <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> AutoTokenizer</span>
<span id="cb23-2"></span>
<span id="cb23-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># BERT 토크나이저</span></span>
<span id="cb23-4">tokenizer <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> AutoTokenizer.from_pretrained(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"bert-base-uncased"</span>)</span>
<span id="cb23-5">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Hello, I can't believe it's working!"</span></span>
<span id="cb23-6">tokens <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> tokenizer.tokenize(text)</span>
<span id="cb23-7"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(tokens)</span>
<span id="cb23-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ['hello', ',', 'i', 'can', "'", 't', 'believe', 'it', "'", 's', 'working', '!']</span></span>
<span id="cb23-9"></span>
<span id="cb23-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 한국어 BERT</span></span>
<span id="cb23-11">tokenizer_ko <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> AutoTokenizer.from_pretrained(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"klue/bert-base"</span>)</span>
<span id="cb23-12">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"안녕하세요. 한국어 토큰화입니다."</span></span>
<span id="cb23-13">tokens <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> tokenizer_ko.tokenize(text)</span>
<span id="cb23-14"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(tokens)</span>
<span id="cb23-15"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ['안녕', '##하세요', '.', '한국어', '토큰', '##화', '##입니다', '.']</span></span></code></pre></div>
</section>
</section>
<section id="도메인별-특화-도구" class="level3" data-number="2.3.4">
<h3 data-number="2.3.4" class="anchored" data-anchor-id="도메인별-특화-도구"><span class="header-section-number">2.3.4</span> 도메인별 특화 도구</h3>
<section id="소셜미디어-tweettokenizer" class="level4" data-number="2.3.4.1">
<h4 data-number="2.3.4.1" class="anchored" data-anchor-id="소셜미디어-tweettokenizer"><span class="header-section-number">2.3.4.1</span> 소셜미디어: TweetTokenizer</h4>
<div class="sourceCode" id="cb24" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> nltk.tokenize <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> TweetTokenizer</span>
<span id="cb24-2"></span>
<span id="cb24-3">tknzr <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> TweetTokenizer(strip_handles<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>, reduce_len<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>)</span>
<span id="cb24-4">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"@user This is sooooo cool! 😊 http://example.com #NLP"</span></span>
<span id="cb24-5">tokens <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> tknzr.tokenize(text)</span>
<span id="cb24-6"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(tokens)</span>
<span id="cb24-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ['This', 'is', 'sooo', 'cool', '!', '😊', 'http://example.com', '#NLP']</span></span></code></pre></div>
</section>
<section id="의학과학-텍스트-scispacy" class="level4" data-number="2.3.4.2">
<h4 data-number="2.3.4.2" class="anchored" data-anchor-id="의학과학-텍스트-scispacy"><span class="header-section-number">2.3.4.2</span> 의학/과학 텍스트: SciSpaCy</h4>
<div class="sourceCode" id="cb25" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> spacy</span>
<span id="cb25-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> scispacy</span>
<span id="cb25-3"></span>
<span id="cb25-4">nlp <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> spacy.load(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"en_core_sci_sm"</span>)</span>
<span id="cb25-5">text <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"The patient has a temperature of 101.5°F. Administer 2.5mg of medication."</span></span>
<span id="cb25-6">doc <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> nlp(text)</span>
<span id="cb25-7">sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [sent.text <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> sent <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> doc.sents]</span></code></pre></div>
</section>
</section>
<section id="언어별-권장-도구-조합" class="level3" data-number="2.3.5">
<h3 data-number="2.3.5" class="anchored" data-anchor-id="언어별-권장-도구-조합"><span class="header-section-number">2.3.5</span> 언어별 권장 도구 조합</h3>
<section id="영어" class="level4" data-number="2.3.5.1">
<h4 data-number="2.3.5.1" class="anchored" data-anchor-id="영어"><span class="header-section-number">2.3.5.1</span> 영어</h4>
<div class="sourceCode" id="cb26" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 실용적인 영어 처리 파이프라인</span></span>
<span id="cb26-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> nltk.tokenize <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> sent_tokenize, TreebankWordTokenizer</span>
<span id="cb26-3"></span>
<span id="cb26-4"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> process_english_text(text):</span>
<span id="cb26-5">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. 문장 분할</span></span>
<span id="cb26-6">    sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> sent_tokenize(text)</span>
<span id="cb26-7">    </span>
<span id="cb26-8">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. 단어 토큰화</span></span>
<span id="cb26-9">    word_tokenizer <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> TreebankWordTokenizer()</span>
<span id="cb26-10">    tokenized_sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb26-11">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> sentence <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> sentences:</span>
<span id="cb26-12">        words <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> word_tokenizer.tokenize(sentence)</span>
<span id="cb26-13">        tokenized_sentences.append(words)</span>
<span id="cb26-14">    </span>
<span id="cb26-15">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> sentences, tokenized_sentences</span></code></pre></div>
</section>
<section id="한국어" class="level4" data-number="2.3.5.2">
<h4 data-number="2.3.5.2" class="anchored" data-anchor-id="한국어"><span class="header-section-number">2.3.5.2</span> 한국어</h4>
<div class="sourceCode" id="cb27" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 실용적인 한국어 처리 파이프라인</span></span>
<span id="cb27-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> kss</span>
<span id="cb27-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> konlpy.tag <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Okt</span>
<span id="cb27-4"></span>
<span id="cb27-5"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> process_korean_text(text):</span>
<span id="cb27-6">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. 문장 분할</span></span>
<span id="cb27-7">    sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> kss.split_sentences(text)</span>
<span id="cb27-8">    </span>
<span id="cb27-9">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. 형태소 분석</span></span>
<span id="cb27-10">    okt <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Okt()</span>
<span id="cb27-11">    tokenized_sentences <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb27-12">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> sentence <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> sentences:</span>
<span id="cb27-13">        morphs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> okt.morphs(sentence)</span>
<span id="cb27-14">        tokenized_sentences.append(morphs)</span>
<span id="cb27-15">    </span>
<span id="cb27-16">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> sentences, tokenized_sentences</span></code></pre></div>
</section>
</section>
<section id="성능과-정확도-비교" class="level3" data-number="2.3.6">
<h3 data-number="2.3.6" class="anchored" data-anchor-id="성능과-정확도-비교"><span class="header-section-number">2.3.6</span> 성능과 정확도 비교</h3>
<section id="처리-속도-상대적-비교" class="level4" data-number="2.3.6.1">
<h4 data-number="2.3.6.1" class="anchored" data-anchor-id="처리-속도-상대적-비교"><span class="header-section-number">2.3.6.1</span> 처리 속도 (상대적 비교)</h4>
<ul>
<li><strong>spaCy</strong>: 매우 빠름 (산업용)</li>
<li><strong>KSS</strong>: 빠름 (한국어 특화)</li>
<li><strong>TreebankWordTokenizer</strong>: 보통</li>
<li><strong>KoNLPy</strong>: 보통-느림 (정확도 높음)</li>
</ul>
</section>
<section id="정확도-도메인별" class="level4" data-number="2.3.6.2">
<h4 data-number="2.3.6.2" class="anchored" data-anchor-id="정확도-도메인별"><span class="header-section-number">2.3.6.2</span> 정확도 (도메인별)</h4>
<ul>
<li><strong>일반 텍스트</strong>: spaCy, NLTK</li>
<li><strong>소셜미디어</strong>: TweetTokenizer</li>
<li><strong>학술/의학</strong>: SciSpaCy</li>
<li><strong>한국어</strong>: KSS + KoNLPy</li>
</ul>
</section>
</section>
<section id="선택-기준" class="level3" data-number="2.3.7">
<h3 data-number="2.3.7" class="anchored" data-anchor-id="선택-기준"><span class="header-section-number">2.3.7</span> 선택 기준</h3>
<section id="프로젝트-요구사항별-선택" class="level4" data-number="2.3.7.1">
<h4 data-number="2.3.7.1" class="anchored" data-anchor-id="프로젝트-요구사항별-선택"><span class="header-section-number">2.3.7.1</span> 프로젝트 요구사항별 선택</h4>
<ol type="1">
<li><strong>프로토타이핑</strong>: NLTK (간편함)</li>
<li><strong>제품 환경</strong>: spaCy (속도와 안정성)</li>
<li><strong>한국어 중심</strong>: KSS + KoNLPy</li>
<li><strong>딥러닝 모델</strong>: Transformers 토크나이저</li>
<li><strong>특수 도메인</strong>: 도메인별 특화 도구</li>
</ol>
</section>
<section id="실무-권장사항" class="level4" data-number="2.3.7.2">
<h4 data-number="2.3.7.2" class="anchored" data-anchor-id="실무-권장사항"><span class="header-section-number">2.3.7.2</span> 실무 권장사항</h4>
<div class="sourceCode" id="cb28" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 범용적인 다국어 처리 환경 구축</span></span>
<span id="cb28-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> spacy</span>
<span id="cb28-3"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> kss</span>
<span id="cb28-4"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> transformers <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> AutoTokenizer</span>
<span id="cb28-5"></span>
<span id="cb28-6"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">class</span> UniversalTokenizer:</span>
<span id="cb28-7">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>):</span>
<span id="cb28-8">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.en_nlp <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> spacy.load(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"en_core_web_sm"</span>)</span>
<span id="cb28-9">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.bert_tokenizer <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> AutoTokenizer.from_pretrained(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"bert-base-multilingual-cased"</span>)</span>
<span id="cb28-10">    </span>
<span id="cb28-11">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> tokenize_sentences(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, text, language<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'auto'</span>):</span>
<span id="cb28-12">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> language <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'ko'</span>:</span>
<span id="cb28-13">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> kss.split_sentences(text)</span>
<span id="cb28-14">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">elif</span> language <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'en'</span>:</span>
<span id="cb28-15">            doc <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.en_nlp(text)</span>
<span id="cb28-16">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> [sent.text <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> sent <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> doc.sents]</span>
<span id="cb28-17">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb28-18">            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 자동 언어 감지 로직</span></span>
<span id="cb28-19">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>._auto_detect_and_tokenize(text)</span>
<span id="cb28-20">    </span>
<span id="cb28-21">    <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> tokenize_for_model(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, text):</span>
<span id="cb28-22">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.bert_tokenizer.tokenize(text)</span></code></pre></div>
</section>
</section>
<section id="결론" class="level3" data-number="2.3.8">
<h3 data-number="2.3.8" class="anchored" data-anchor-id="결론"><span class="header-section-number">2.3.8</span> 결론</h3>
<ul>
<li>토큰화는 복잡한 언어학적 문제이므로, 수년간 연구되고 검증된 도구들을 활용하는 것이 가장 효율적이고 안정적인 접근법이다.</li>
<li>각 도구의 특성을 이해하고 프로젝트의 요구사항에 맞는 적절한 조합을 선택하는 것이 성공적인 NLP 프로젝트의 첫걸음이다.</li>
</ul>
</section>
</section>
<section id="토큰화의-도전과제" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="토큰화의-도전과제"><span class="header-section-number">2.4</span> 토큰화의 도전과제</h2>
<section id="언어별-특성" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="언어별-특성"><span class="header-section-number">2.4.1</span> 언어별 특성</h3>
<p><strong>한국어:</strong> - 어미 변화가 복잡 - 띄어쓰기 규칙이 일관되지 않음 - 복합어 처리 어려움</p>
<p><strong>영어:</strong> - 축약형 처리 (예: “don’t”, “I’m”) - 하이픈으로 연결된 단어 - 대소문자 처리</p>
</section>
<section id="도메인별-특수성" class="level3" data-number="2.4.2">
<h3 data-number="2.4.2" class="anchored" data-anchor-id="도메인별-특수성"><span class="header-section-number">2.4.2</span> 도메인별 특수성</h3>
<p><strong>소셜미디어:</strong> - 이모티콘과 이모지 - 해시태그와 멘션 - 비표준 언어 사용</p>
<p><strong>의학/법률 텍스트:</strong> - 전문 용어 - 약어와 기호 - 정확성이 중요</p>
</section>
<section id="vocabulary" class="level3" data-number="2.4.3">
<h3 data-number="2.4.3" class="anchored" data-anchor-id="vocabulary"><span class="header-section-number">2.4.3</span> Vocabulary</h3>
<ul>
<li><strong>Vocabulary</strong>란 텍스트를 토큰화하고, 고유한 토큰들로 이루어진 집합으로 쉽게 말해 기계가 알고있는 단어들의 집합이다.</li>
<li>기계가 텍스트를 처리하기 위해서는 이를 숫자 형태로 변환하는 과정이 필요하다.</li>
<li>이를 위해 먼저 텍스트를 토큰화하고, 토큰을 숫자로 매핑하는 과정이 필요하다.
<ol type="1">
<li>텍스트를 의미 있는 단위인 토큰으로 분할하고(토큰화),</li>
<li>각 고유 토큰에 숫자(정수 인덱스 등)를 부여하여 어휘집(Vocabulary)을 구축한 후,</li>
<li>이 어휘집을 바탕으로 원래의 토큰 시퀀스를 숫자 시퀀스로 변환하는 단계를 포함합니다.</li>
</ol></li>
<li>이렇게 매핑된 숫자를 통해 기계가 텍스트를 이해할 수 있도록 한다.</li>
</ul>
</section>
<section id="out-of-vocabulary-oov-문제" class="level3" data-number="2.4.4">
<h3 data-number="2.4.4" class="anchored" data-anchor-id="out-of-vocabulary-oov-문제"><span class="header-section-number">2.4.4</span> Out-of-Vocabulary (OOV) 문제</h3>
<p><strong>문제:</strong> - 모델이 학습한 어휘집(Vocabulary)에 포함되지 않은 단어가 입력으로 들어올 때 발생 - 이는 특히 다음과 같은 경우에 문제가 된다: - <strong>새로운 단어</strong>: 신조어, 기술 용어, 브랜드 이름 등 - <strong>오타 및 비표준 표현</strong>: 사용자의 입력 실수나 비공식적인 언어 사용 - <strong>다양한 언어적 변형</strong>: 복합어, 축약형, 방언 등 - OOV 단어가 포함된 문장을 제대로 이해하지 못하거나, 잘못된 예측을 할 수 있다.</p>
<p><strong>해결 방안:</strong> - <strong>서브워드 토큰화 사용</strong> - 최근 가장 널리 사용되는 방법 중 하나로, 다양한 자연어 처리 모델에서 효과적으로 활용되고 있다. - 이 방법들은 단어를 더 작은 의미 단위로 분할하여 처리하므로, 새로운 단어가 등장하더라도 부분적으로 이해할 수 있다. - <strong>문자 단위 처리</strong> - 단어를 문자 단위로 분할하여 처리하는 방법도 있다. - 이는 모든 단어를 개별 문자로 분해하여 처리하므로, OOV 문제를 근본적으로 해결할 수 있다. - 그러나 이 방법은 문맥 이해가 어려워질 수 있다. - <strong>사전 확장</strong> - 지속적으로 어휘집을 업데이트하여 새로운 단어를 포함시키는 방법. - 이는 시간이 지남에 따라 어휘집을 확장하여 OOV 문제를 줄일 수 있다.</p>
</section>
</section>
<section id="평가-메트릭" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="평가-메트릭"><span class="header-section-number">2.5</span> 평가 메트릭</h2>
<section id="어휘-크기-vocabulary-size" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1" class="anchored" data-anchor-id="어휘-크기-vocabulary-size"><span class="header-section-number">2.5.1</span> 어휘 크기 (Vocabulary Size)</h3>
<ul>
<li>모델의 메모리 사용량과 직결</li>
<li>너무 크면 비효율적, 너무 작으면 표현력 부족</li>
</ul>
</section>
<section id="압축률-compression-rate" class="level3" data-number="2.5.2">
<h3 data-number="2.5.2" class="anchored" data-anchor-id="압축률-compression-rate"><span class="header-section-number">2.5.2</span> 압축률 (Compression Rate)</h3>
<ul>
<li>원본 텍스트 대비 토큰 수의 비율</li>
<li>효율적인 표현을 위해 중요</li>
</ul>
</section>
<section id="의미-보존도" class="level3" data-number="2.5.3">
<h3 data-number="2.5.3" class="anchored" data-anchor-id="의미-보존도"><span class="header-section-number">2.5.3</span> 의미 보존도</h3>
<ul>
<li>토큰화 후에도 원래 의미가 유지되는 정도</li>
<li>정성적 평가가 주로 사용됨</li>
</ul>
</section>
</section>
<section id="실제-적용-사례" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="실제-적용-사례"><span class="header-section-number">2.6</span> 실제 적용 사례</h2>
<section id="기계-번역" class="level3" data-number="2.6.1">
<h3 data-number="2.6.1" class="anchored" data-anchor-id="기계-번역"><span class="header-section-number">2.6.1</span> 기계 번역</h3>
<ul>
<li>다국어 처리를 위한 공통 서브워드 어휘</li>
<li>언어 간 토큰 정렬</li>
</ul>
</section>
<section id="감정-분석" class="level3" data-number="2.6.2">
<h3 data-number="2.6.2" class="anchored" data-anchor-id="감정-분석"><span class="header-section-number">2.6.2</span> 감정 분석</h3>
<ul>
<li>감정을 나타내는 키워드 보존</li>
<li>이모티콘과 특수 문자 처리</li>
</ul>
</section>
<section id="질의응답-시스템" class="level3" data-number="2.6.3">
<h3 data-number="2.6.3" class="anchored" data-anchor-id="질의응답-시스템"><span class="header-section-number">2.6.3</span> 질의응답 시스템</h3>
<ul>
<li>질문과 답변의 일관된 토큰화</li>
<li>개체명 인식과의 연계</li>
</ul>
</section>
</section>
<section id="최신-동향" class="level2" data-number="2.7">
<h2 data-number="2.7" class="anchored" data-anchor-id="최신-동향"><span class="header-section-number">2.7</span> 최신 동향</h2>
<section id="다국어-토큰화" class="level3" data-number="2.7.1">
<h3 data-number="2.7.1" class="anchored" data-anchor-id="다국어-토큰화"><span class="header-section-number">2.7.1</span> 다국어 토큰화</h3>
<ul>
<li>mBERT, XLM-R 등 다국어 모델</li>
<li>언어별 특성을 고려한 통합 토큰화</li>
</ul>
</section>
<section id="적응형-토큰화" class="level3" data-number="2.7.2">
<h3 data-number="2.7.2" class="anchored" data-anchor-id="적응형-토큰화"><span class="header-section-number">2.7.2</span> 적응형 토큰화</h3>
<ul>
<li>도메인별 최적화</li>
<li>동적 어휘 확장</li>
</ul>
</section>
<section id="신경망-기반-토큰화" class="level3" data-number="2.7.3">
<h3 data-number="2.7.3" class="anchored" data-anchor-id="신경망-기반-토큰화"><span class="header-section-number">2.7.3</span> 신경망 기반 토큰화</h3>
<ul>
<li>학습 가능한 토큰화</li>
<li>End-to-end 학습</li>
</ul>
</section>
</section>
<section id="결론-1" class="level2" data-number="2.8">
<h2 data-number="2.8" class="anchored" data-anchor-id="결론-1"><span class="header-section-number">2.8</span> 결론</h2>
<ul>
<li>토큰화는 자연어 처리의 첫 단계이자 전체 성능을 좌우하는 중요한 과정.</li>
<li>언어의 특성과 도메인의 요구사항을 고려하여 적절한 토큰화 방법을 선택하는 것이 중요.</li>
<li>최근에는 서브워드 토큰화가 주류가 되었지만, 여전히 각 방법의 장단점을 이해하고 상황에 맞게 적용하는 것이 필요.</li>
</ul>


</section>
</section>

 ]]></description>
  <category>NLP</category>
  <category>Deep Learning</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Deep_Learning/NLP/2.pre_prcs_tokenization.html</guid>
  <pubDate>Wed, 01 Jan 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>자연어 처리(NLP) 개요</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Deep_Learning/NLP/1.nlp_overview.html</link>
  <description><![CDATA[ 




<section id="자연어-처리의-개요" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 자연어 처리의 개요</h1>
<p>자연어 처리(NLP)는 컴퓨터가 인간의 언어를 이해하고 처리하는 기술 분야다. 여기서 자연어란 우리가 일상에서 사용하는 한국어, 영어, 중국어, 일본어 같은 언어를 말한다.</p>
<p>자연어 처리는 다양한 응용 분야를 가지고 있다: - 음성 인식 - 텍스트 요약 - 기계 번역 - 감성 분석 - 텍스트 분류 - 질의 응답 시스템 - 챗봇</p>
<p>최근 딥러닝을 활용한 자연어 처리 기술이 폭발적으로 발전하면서 괄목할만한 성과를 이루고 있다. 이 분야는 종종 ’텍스트 분석’이라고도 불리지만, ’자연어 처리’라고 하면 인공지능 기술을 활용한다는 의미가 더 강하게 내포된다.</p>
</section>
<section id="자연어-처리의-기회" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 자연어 처리의 기회</h1>
<p>자연어 처리는 현재 IT 업계에서 매우 유망한 분야다. 그 이유는 다음과 같다:</p>
<ol type="1">
<li><p><strong>산업 전반에 걸친 수요</strong>: 특정 도메인에 국한되지 않고 거의 모든 산업 분야에서 자연어 처리 기술에 대한 수요가 있다.</p></li>
<li><p><strong>인력 부족</strong>: 현재 실무에서 PLM(Pre-trained Language Model)을 활용할 수 있는 중급 이상의 인력이 부족해 기회가 많다.</p></li>
<li><p><strong>오픈소스의 발전</strong>: 성능 좋은 오픈소스 모델과 라이브러리가 지속적으로 공개되고 있어, 자연어 처리 기술을 익히면 손쉽게 높은 성능의 모델을 활용할 수 있다.</p></li>
</ol>
</section>
<section id="자연어-처리-학습-순서" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> 자연어 처리 학습 순서</h1>
<p>자연어 처리를 배우기 위한 일반적인 학습 경로는 다음과 같다:</p>
<ol type="1">
<li>자연어 처리의 기본 개념 이해</li>
<li>통계적 방식의 자연어 처리 학습</li>
<li>초기 딥러닝 기반 자연어 처리 방법론 (2010년대 초반~중반)</li>
<li>현대의 딥러닝 자연어 처리 - PLM(Pre-trained Language Models) 중심</li>
</ol>
<p>세부 학습 단계</p>
<ol type="1">
<li><strong>Stemming and Tokenization</strong> (어간 추출 및 토큰화)
<ul>
<li>Stemming: 단어의 어간을 추출하는 과정으로, 접미사 등을 제거하여 기본 형태로 변환</li>
<li>Tokenization: 텍스트를 개별 단위(토큰)로 분리하는 과정으로, 문장을 단어나 형태소 단위로 나눔</li>
</ul></li>
<li><strong>BoW/TF-IDF</strong> (Bag of Words/Term Frequency-Inverse Document Frequency)
<ul>
<li>BoW: 단어의 순서를 고려하지 않고 출현 빈도만 고려하는 텍스트 표현 방식</li>
<li>TF-IDF: 단어의 중요도를 문서 내 빈도와 전체 문서에서의 희소성을 기반으로 계산하는 통계적 방법</li>
</ul></li>
<li><strong>Basic Models</strong> (기본 모델)
<ul>
<li>자연어 처리에 사용되는 기본적인 머신러닝 모델들(나이브 베이즈, SVM, 결정 트리 등)을 의미</li>
<li>통계적 방법론을 기반으로 한 초기 NLP 접근법</li>
</ul></li>
<li><strong>Word Embedding</strong> (단어 임베딩)
<ul>
<li>단어를 밀집 벡터(dense vector) 공간에 매핑하는 기법</li>
<li>Word2Vec, GloVe, FastText 등의 방법론을 통해 단어의 의미적 관계를 수치화</li>
</ul></li>
<li><strong>LSTM/GRU/Attention Models</strong> (장단기 메모리/게이트 순환 유닛/어텐션 모델)
<ul>
<li>LSTM(Long Short-Term Memory): 장기 의존성 문제를 해결하기 위한 특수한 RNN 구조</li>
<li>GRU(Gated Recurrent Unit): LSTM을 단순화한 구조로, 계산 효율성이 높음</li>
<li>Attention: 시퀀스의 특정 부분에 집중하는 메커니즘으로, 번역 등의 작업에서 성능 향상</li>
</ul></li>
<li><strong>Transformer Models</strong> (트랜스포머 모델)
<ul>
<li>어텐션 메커니즘만을 사용하여 설계된 신경망 구조</li>
<li>병렬 처리가 가능하고 장거리 의존성을 효과적으로 포착하는 특징</li>
<li>BERT, GPT, T5 등 현대 NLP의 핵심 아키텍처</li>
</ul></li>
<li><strong>Deploying BERT on Cloud</strong> (클라우드에 BERT 배포)
<ul>
<li>BERT(Bidirectional Encoder Representations from Transformers): 양방향 트랜스포머 기반 언어 모델</li>
<li>클라우드 환경(AWS, GCP, Azure 등)에 BERT 모델을 배포하여 실제 서비스에 적용하는 과정</li>
<li>확장성, 가용성, 비용 효율성을 고려한 모델 서빙 방법론</li>
</ul></li>
</ol>
</section>
<section id="주요-도구와-프레임워크" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> 주요 도구와 프레임워크</h1>
<section id="pytorch" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="pytorch"><span class="header-section-number">4.1</span> PyTorch</h2>
<p>PyTorch는 Facebook AI Research(FAIR)에서 개발한 딥러닝 프레임워크다. 연구용 프로토타입부터 상용 제품까지 빠르게 개발할 수 있는 유연성을 제공하며, 현재 자연어 처리 분야에서 가장 보편적으로 사용되는 프레임워크 중 하나다.</p>
</section>
<section id="transformers" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="transformers"><span class="header-section-number">4.2</span> Transformers</h2>
<p>Hugging Face<a href="https://huggingface.co/docs/transformers/index">(https://huggingface.co/docs/transformers/index)</a> 에서 개발한 Transformers 라이브러리는 다양한 트랜스포머 계열의 모델과 관련 모듈을 제공하는 Data Science Hub 플랫폼이다. 현대 자연어 처리에서 PLM을 활용할 때 대부분 이 라이브러리를 사용한다. BERT, GPT, T5 등 최신 언어 모델을 쉽게 불러와 사용할 수 있게 해준다.</p>
</section>
</section>
<section id="한국어-자연어-처리의-난이도와-특성" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> 한국어 자연어 처리의 난이도와 특성</h1>
<p>한국어는 영어에 비해 자연어 처리가 더 어려운 특성을 가지고 있다. 이러한 특성들은 언어 모델의 성능에 직접적인 영향을 미친다.</p>
<section id="한국어의-언어적-특성" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="한국어의-언어적-특성"><span class="header-section-number">5.1</span> 한국어의 언어적 특성</h2>
<section id="교착어로서의-특성" class="level3" data-number="5.1.1">
<h3 data-number="5.1.1" class="anchored" data-anchor-id="교착어로서의-특성"><span class="header-section-number">5.1.1</span> 교착어로서의 특성</h3>
<ul>
<li><strong>정의</strong>: 실질적인 의미를 가진 어간에 조사나 어미와 같은 문법 형태소들이 결합하여 문법적 기능이 부여되는 언어</li>
<li><strong>예시</strong>: ‘사람은’, ‘사람이’, ‘사람을’, ‘사람에게’, ‘사람과’, ‘사람의’, ‘사람에’, ’사람으로부터’와 같이 같은 명사에 다양한 조사가 결합</li>
<li><strong>문제점</strong>: 띄어쓰기 단위로 토큰화할 경우 이들이 모두 다른 단어로 간주됨</li>
</ul>
</section>
<section id="어순의-유연성" class="level3" data-number="5.1.2">
<h3 data-number="5.1.2" class="anchored" data-anchor-id="어순의-유연성"><span class="header-section-number">5.1.2</span> 어순의 유연성</h3>
<ul>
<li>한국어는 정황어로서 조사나 토씨만으로도 문장의 의미를 파악할 수 있음</li>
<li>문장 성분의 위치가 바뀌어도 의미 전달에 큰 문제가 없음</li>
<li><strong>예시</strong>:
<ul>
<li>나는 오늘 저녁에 친구와 함께 영화를 보러 간다.</li>
<li>(나는) 친구와 함께 오늘 저녁에 영화를 보러 간다.</li>
<li>(나는) 영화를 보러 오늘 저녁에 친구와 함께 간다.</li>
<li>간다 (나는) 영화를 보러 오늘 저녁에 친구와 함께.</li>
</ul></li>
</ul>
</section>
<section id="주어-생략-현상" class="level3" data-number="5.1.3">
<h3 data-number="5.1.3" class="anchored" data-anchor-id="주어-생략-현상"><span class="header-section-number">5.1.3</span> 주어 생략 현상</h3>
<ul>
<li>한국어는 문맥상 이해 가능한 경우 주어를 자주 생략함</li>
<li>때로는 주어와 서술어가 모두 생략되는 경우도 있음</li>
<li><strong>예시</strong>: “(나는) 오늘 저녁에 친구와 함께 영화를 보러 (간다).”</li>
</ul>
</section>
<section id="띄어쓰기-규칙의-비일관성" class="level3" data-number="5.1.4">
<h3 data-number="5.1.4" class="anchored" data-anchor-id="띄어쓰기-규칙의-비일관성"><span class="header-section-number">5.1.4</span> 띄어쓰기 규칙의 비일관성</h3>
<ul>
<li>한국어는 띄어쓰기가 엄격하게 지켜지지 않는 경향이 있음</li>
<li>띄어쓰기를 하지 않더라도 문장 이해가 가능함</li>
<li><strong>예시</strong>: “동해물과백두산이마르고닳도록하느님이보우하사우리나라만세”</li>
<li>반면 영어는 띄어쓰기가 없으면 읽기 어려움: “tobeornottobethatisthequestion”</li>
</ul>
</section>
<section id="한자어의-특성" class="level3" data-number="5.1.5">
<h3 data-number="5.1.5" class="anchored" data-anchor-id="한자어의-특성"><span class="header-section-number">5.1.5</span> 한자어의 특성</h3>
<ul>
<li>하나의 음절이 다양한 의미를 가질 수 있음</li>
<li>동음이의어가 많아 문맥 파악이 중요함</li>
</ul>
</section>
</section>
<section id="한국어-자연어-처리의-어려움" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="한국어-자연어-처리의-어려움"><span class="header-section-number">5.2</span> 한국어 자연어 처리의 어려움</h2>
<section id="모델링-관점의-어려움" class="level3" data-number="5.2.1">
<h3 data-number="5.2.1" class="anchored" data-anchor-id="모델링-관점의-어려움"><span class="header-section-number">5.2.1</span> 모델링 관점의 어려움</h3>
<ul>
<li>주어 생략과 자유로운 어순으로 인해 언어 모델의 예측 성능이 저하됨</li>
<li>교착어 특성으로 인한 어휘 다양성 증가로 모델 복잡도 증가</li>
</ul>
</section>
<section id="리소스-부족" class="level3" data-number="5.2.2">
<h3 data-number="5.2.2" class="anchored" data-anchor-id="리소스-부족"><span class="header-section-number">5.2.2</span> 리소스 부족</h3>
<ul>
<li>영어에 비해 데이터와 언어에 특화된 모델이 상대적으로 부족함</li>
<li>한국어 특성을 고려한 전처리 도구와 평가 방법론 개발 필요</li>
</ul>
<p>이러한 한국어의 특성들은 자연어 처리 모델의 성능에 직접적인 영향을 미치며, 한국어 자연어 처리를 위해서는 이러한 특성을 고려한 접근 방식이 필요하다.</p>
</section>
</section>
<section id="영어의-언어적-특성" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="영어의-언어적-특성"><span class="header-section-number">5.3</span> 영어의 언어적 특성</h2>
<section id="고립어로서의-특성" class="level3" data-number="5.3.1">
<h3 data-number="5.3.1" class="anchored" data-anchor-id="고립어로서의-특성"><span class="header-section-number">5.3.1</span> 고립어로서의 특성</h3>
<ul>
<li><strong>정의</strong>: 단어의 형태가 거의 변하지 않고, 어순과 전치사 등을 통해 문법적 관계를 표현하는 언어</li>
<li><strong>예시</strong>: ‘person’, ‘the person’, ‘to the person’, ‘with the person’, ’of the person’과 같이 명사 자체는 변하지 않고 전치사나 관사가 추가됨</li>
<li><strong>특징</strong>: 단어 경계가 명확하여 토큰화가 상대적으로 용이함</li>
</ul>
</section>
<section id="엄격한-어순" class="level3" data-number="5.3.2">
<h3 data-number="5.3.2" class="anchored" data-anchor-id="엄격한-어순"><span class="header-section-number">5.3.2</span> 엄격한 어순</h3>
<ul>
<li>영어는 주어-동사-목적어(SVO) 구조를 기본으로 하는 엄격한 어순을 가짐</li>
<li>어순이 바뀌면 문장의 의미가 크게 달라지거나 비문법적이 됨</li>
<li><strong>예시</strong>:
<ul>
<li>“I love you” (나는 너를 사랑한다)</li>
<li>“You love I” (비문법적)</li>
<li>“Love I you” (비문법적)</li>
</ul></li>
</ul>
</section>
<section id="주어-필수-현상" class="level3" data-number="5.3.3">
<h3 data-number="5.3.3" class="anchored" data-anchor-id="주어-필수-현상"><span class="header-section-number">5.3.3</span> 주어 필수 현상</h3>
<ul>
<li>영어는 거의 모든 문장에서 주어가 필수적으로 요구됨</li>
<li>주어가 없는 문장은 명령문이나 특수한 경우를 제외하고는 비문법적임</li>
<li>의미상 주어가 없을 때도 형식적 주어(it, there)를 사용함</li>
<li><strong>예시</strong>: “It is raining.” (비인칭 주어 it 사용)</li>
</ul>
</section>
<section id="띄어쓰기의-중요성" class="level3" data-number="5.3.4">
<h3 data-number="5.3.4" class="anchored" data-anchor-id="띄어쓰기의-중요성"><span class="header-section-number">5.3.4</span> 띄어쓰기의 중요성</h3>
<ul>
<li>영어는 띄어쓰기가 의미 구분에 필수적인 역할을 함</li>
<li>띄어쓰기가 없으면 단어 경계 식별이 어려워 문장 이해가 불가능함</li>
<li><strong>예시</strong>: “Iloveyou” vs “I love you”</li>
</ul>
</section>
<section id="굴절-현상의-제한성" class="level3" data-number="5.3.5">
<h3 data-number="5.3.5" class="anchored" data-anchor-id="굴절-현상의-제한성"><span class="header-section-number">5.3.5</span> 굴절 현상의 제한성</h3>
<ul>
<li>영어는 한국어에 비해 굴절(inflection) 현상이 제한적임</li>
<li>명사는 복수형, 소유격 정도만 변화</li>
<li>동사는 시제, 인칭에 따라 제한적으로 변화</li>
<li><strong>예시</strong>:
<ul>
<li>명사: dog → dogs (복수형)</li>
<li>동사: walk → walks, walked, walking</li>
</ul></li>
</ul>
</section>
<section id="동음이의어와-다의어" class="level3" data-number="5.3.6">
<h3 data-number="5.3.6" class="anchored" data-anchor-id="동음이의어와-다의어"><span class="header-section-number">5.3.6</span> 동음이의어와 다의어</h3>
<ul>
<li>영어도 동음이의어와 다의어가 많아 문맥 파악이 중요함</li>
<li><strong>예시</strong>:
<ul>
<li>“bank”(은행 또는 강둑)</li>
<li>“light”(가벼운 또는 빛)</li>
</ul></li>
</ul>
</section>
</section>
<section id="영어-자연어-처리의-특징" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="영어-자연어-처리의-특징"><span class="header-section-number">5.4</span> 영어 자연어 처리의 특징</h2>
<section id="모델링-관점의-이점" class="level3" data-number="5.4.1">
<h3 data-number="5.4.1" class="anchored" data-anchor-id="모델링-관점의-이점"><span class="header-section-number">5.4.1</span> 모델링 관점의 이점</h3>
<ul>
<li>어순이 고정되어 있어 언어 모델의 예측 성능이 상대적으로 높음</li>
<li>단어 형태 변화가 적어 어휘 다양성이 한국어보다 낮음</li>
<li>띄어쓰기가 명확하여 토큰화가 용이함</li>
</ul>
</section>
<section id="풍부한-리소스" class="level3" data-number="5.4.2">
<h3 data-number="5.4.2" class="anchored" data-anchor-id="풍부한-리소스"><span class="header-section-number">5.4.2</span> 풍부한 리소스</h3>
<ul>
<li>방대한 양의 텍스트 데이터와 사전 학습된 모델이 존재함</li>
<li>다양한 자연어 처리 도구와 평가 데이터셋이 개발되어 있음</li>
<li>영어 기반 연구가 선행되어 참고할 수 있는 자료가 많음</li>
</ul>
<p>영어와 한국어의 이러한 언어적 차이는 자연어 처리 접근 방식에 직접적인 영향을 미치며, 각 언어의 특성에 맞는 전처리 방법과 모델링 전략이 필요하다.</p>
</section>
</section>
</section>
<section id="사전-학습-언어-모델plm의-발전과-다국어-처리" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> 사전 학습 언어 모델(PLM)의 발전과 다국어 처리</h1>
<section id="다국어-처리의-혁신" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="다국어-처리의-혁신"><span class="header-section-number">6.1</span> 다국어 처리의 혁신</h2>
<p>최근 자연어 처리 분야에서는 사전 학습 언어 모델(Pre-trained Language Models, PLM)의 급속한 발전으로 인해 언어 간 차이에 대한 우려가 크게 감소하고 있다. 이러한 모델들은 다양한 언어의 특성을 효과적으로 학습하여 언어 간 격차를 줄이고 있다.</p>
<section id="다국어-사전-학습-모델의-등장" class="level3" data-number="6.1.1">
<h3 data-number="6.1.1" class="anchored" data-anchor-id="다국어-사전-학습-모델의-등장"><span class="header-section-number">6.1.1</span> 다국어 사전 학습 모델의 등장</h3>
<ul>
<li><strong>다국어 BERT, XLM, mT5</strong> 등의 모델은 100개 이상의 언어를 동시에 처리할 수 있는 능력을 갖추고 있음</li>
<li>이러한 모델들은 각 언어의 고유한 특성(어순, 형태소, 문법 구조 등)을 대규모 말뭉치를 통해 자동으로 학습</li>
<li>한국어와 같은 교착어도 효과적으로 처리할 수 있는 능력을 보여줌</li>
</ul>
</section>
<section id="언어-간-전이-학습의-효과" class="level3" data-number="6.1.2">
<h3 data-number="6.1.2" class="anchored" data-anchor-id="언어-간-전이-학습의-효과"><span class="header-section-number">6.1.2</span> 언어 간 전이 학습의 효과</h3>
<ul>
<li>영어 등 리소스가 풍부한 언어에서 학습된 지식이 리소스가 적은 언어로 효과적으로 전이됨</li>
<li>적은 양의 한국어 데이터로도 영어 수준에 근접한 성능을 달성할 수 있게 됨</li>
<li>언어 간 공통된 의미적, 구문적 패턴을 모델이 포착하여 활용</li>
</ul>
</section>
</section>
<section id="한국어-자연어-처리의-현재" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="한국어-자연어-처리의-현재"><span class="header-section-number">6.2</span> 한국어 자연어 처리의 현재</h2>
<section id="한국어-특화-모델의-발전" class="level3" data-number="6.2.1">
<h3 data-number="6.2.1" class="anchored" data-anchor-id="한국어-특화-모델의-발전"><span class="header-section-number">6.2.1</span> 한국어 특화 모델의 발전</h3>
<ul>
<li><strong>KoBERT, KoGPT, KoELECTRA</strong> 등 한국어에 최적화된 사전 학습 모델들이 개발되어 공개됨</li>
<li>이러한 모델들은 한국어의 특성을 고려한 토큰화 방식과 학습 방법을 적용</li>
<li>한국어 위키피디아, 뉴스, 웹 문서 등 대규모 한국어 말뭉치로 학습되어 우수한 성능을 보임</li>
</ul>
</section>
<section id="실용적-관점에서의-변화" class="level3" data-number="6.2.2">
<h3 data-number="6.2.2" class="anchored" data-anchor-id="실용적-관점에서의-변화"><span class="header-section-number">6.2.2</span> 실용적 관점에서의 변화</h3>
<ul>
<li>과거에는 한국어 형태소 분석기 선택과 최적화가 핵심 과제였으나, 현재는 적절한 사전 학습 모델 선택이 더 중요해짐</li>
<li>토큰화, 형태소 분석 등의 전처리 작업이 모델 내부에서 자동으로 처리되어 개발자의 부담이 크게 감소</li>
<li>대부분의 NLP 태스크에서 언어 특성에 대한 깊은 이해 없이도 준수한 성능 달성 가능</li>
</ul>
</section>
</section>
<section id="실무적-시사점" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="실무적-시사점"><span class="header-section-number">6.3</span> 실무적 시사점</h2>
<section id="개발-효율성-향상" class="level3" data-number="6.3.1">
<h3 data-number="6.3.1" class="anchored" data-anchor-id="개발-효율성-향상"><span class="header-section-number">6.3.1</span> 개발 효율성 향상</h3>
<ul>
<li>언어별 특화된 전처리 파이프라인 구축 필요성이 감소</li>
<li>동일한 아키텍처와 접근 방식으로 다양한 언어 처리 가능</li>
<li>개발 및 유지보수 비용 절감</li>
</ul>
</section>
<section id="다국어-서비스-구현-용이성" class="level3" data-number="6.3.2">
<h3 data-number="6.3.2" class="anchored" data-anchor-id="다국어-서비스-구현-용이성"><span class="header-section-number">6.3.2</span> 다국어 서비스 구현 용이성</h3>
<ul>
<li>하나의 모델로 여러 언어를 지원하는 서비스 구현 가능</li>
<li>언어 간 일관된 성능으로 사용자 경험 향상</li>
<li>새로운 언어 추가가 상대적으로 용이해짐</li>
</ul>
<p>결론적으로, 현대 PLM의 발전으로 인해 한국어와 영어 간의 언어적 차이가 자연어 처리에 미치는 영향은 크게 감소했다. 물론 각 언어의 특성을 이해하는 것은 여전히 중요하지만, 기술적 장벽은 상당히 낮아졌으며, 이는 다양한 언어에 대한 NLP 응용 프로그램 개발을 크게 촉진하고 있다.</p>


</section>
</section>
</section>

 ]]></description>
  <category>NLP</category>
  <category>Deep Learning</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Deep_Learning/NLP/1.nlp_overview.html</guid>
  <pubDate>Tue, 31 Dec 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Data Governance Study - Data Standard Governance</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Governance/5-0-2.terminology_hierarchy copy.html</link>
  <description><![CDATA[ 




<section id="데이터-표준화-원칙-문서의-작성" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 데이터 표준화 원칙 문서의 작성</h1>
<p>데이터 거버넌스의 한 부분인 데이터 표준화는 여러 사람이 참여하는 대형 프로젝트인 만큼 실무자들이 따를 지침서를 작성하는 것이 중요하다. 이때 표준화 지침에 핵심적인 기능을 하는 것이 표준화 원칙 문서인데 표준화 원칙 문서는 다음 사항들을 고려하여 작성해야한다.</p>
<section id="데이터-표준화-원칙-문서의-작성-기본-원칙과-구조" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="데이터-표준화-원칙-문서의-작성-기본-원칙과-구조"><span class="header-section-number">1.1</span> 데이터 표준화 원칙 문서의 작성 기본 원칙과 구조</h2>
<section id="표준화-원칙-문서는-명확성과-일관성을-최우선으로-함" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="표준화-원칙-문서는-명확성과-일관성을-최우선으로-함"><span class="header-section-number">1.1.1</span> 표준화 원칙 문서는 명확성과 일관성을 최우선으로 함</h3>
<ul>
<li>표준화 원칙 문서는 객관적인 기준을 제시하며, 해석의 여지를 최소화하는 것이 목적임<br>
</li>
<li>표준을 정의하는 과정에서 주관적 해석이 개입될 경우, 적용 일관성이 저하될 수 있음<br>
</li>
<li>문장의 길이를 줄이고 간결한 조항 형식으로 표기하는 것이 원칙임<br>
</li>
<li>예시
<ul>
<li><em>“이 규칙은 데이터 정합성을 높이는 데 도움이 됩니다.”</em> (해석의 여지가 많음)<br>
</li>
<li><strong>“데이터 값은 지정된 형식과 명명 규칙을 따라야 한다.”</strong> (명확하고 일관됨)</li>
</ul></li>
</ul>
</section>
<section id="표준화-원칙은-해석-이-아니라-적용-이-목적" class="level3" data-number="1.1.2">
<h3 data-number="1.1.2" class="anchored" data-anchor-id="표준화-원칙은-해석-이-아니라-적용-이-목적"><span class="header-section-number">1.1.2</span> 표준화 원칙은 <strong>해석</strong> 이 아니라 <strong>적용</strong> 이 목적</h3>
<ul>
<li>표준화 원칙은 특정한 상황에 따라 해석하는 것이 아니라, <strong>일관된 적용</strong>을 목표로 함<br>
</li>
<li>해설이나 장점이 포함될 경우, 개별적인 해석 차이가 발생하여 표준의 목적이 훼손될 수 있음<br>
</li>
<li>따라서 원칙의 취지나 배경 설명은 별도의 가이드라인이나 해설서에서 제공하는 것이 적절함<br>
</li>
<li>예시
<ul>
<li>표준 문서에서는 <strong>“파일명은 {프로젝트명_날짜_버전} 형식을 따른다.”</strong> 와 같이 명확히 규정함<br>
</li>
<li>해설이 필요한 경우, <strong>“이 표준은 프로젝트별 관리 효율성을 높이기 위한 것”</strong> 등의 내용은 별도의 가이드라인에서 제공</li>
</ul></li>
</ul>
</section>
<section id="표준은-변화할-수-있지만-목적과-가치는-변하지-않음" class="level3" data-number="1.1.3">
<h3 data-number="1.1.3" class="anchored" data-anchor-id="표준은-변화할-수-있지만-목적과-가치는-변하지-않음"><span class="header-section-number">1.1.3</span> 표준은 변화할 수 있지만, <strong>목적과 가치</strong>는 변하지 않음</h3>
<ul>
<li>기술의 발전과 환경 변화에 따라 표준 자체는 개정될 수 있지만, <strong>일관성과 명확성을 유지하는 원칙은 변하지 않음</strong><br>
</li>
<li>표준의 적용 목적은 변하지 않으며, 단순히 특정 기술이나 방식이 아닌 <strong>보편적인 기준</strong>을 유지해야 함<br>
</li>
<li>해설이나 배경 설명이 포함될 경우, 표준 개정 시 불필요한 수정이 발생할 수 있어 배제하는 것이 원칙임<br>
</li>
<li>예시:
<ul>
<li>기존 표준: <strong>“데이터는 CSV 형식으로 저장한다.”</strong><br>
</li>
<li>개정 표준: <strong>“데이터는 JSON 형식으로 저장한다.”</strong><br>
</li>
<li>표준 변경이 가능하지만, <strong>“데이터 저장 형식을 명확하게 정의해야 한다.”</strong> 라는 원칙은 유지됨</li>
</ul></li>
</ul>
</section>
<section id="표준-문서와-해설-문서의-역할-분리" class="level3" data-number="1.1.4">
<h3 data-number="1.1.4" class="anchored" data-anchor-id="표준-문서와-해설-문서의-역할-분리"><span class="header-section-number">1.1.4</span> 표준 문서와 해설 문서의 역할 분리</h3>
<ul>
<li>표준 및 원칙 문서: “해야 한다” (일관된 적용을 위한 명확한 규정)<br>
</li>
<li>해설서/가이드라인: “이 표준의 목적은…” (표준이 존재하는 이유와 적용 가이드 제공)<br>
</li>
<li>정책 보고서: “이 표준이 도입되면 기대되는 효과는…” (표준화로 인한 개선점 분석)<br>
</li>
<li>예시:
<ul>
<li>표준 문서: <em>“모든 테이블명은 대문자 알파벳과 숫자로만 구성해야 한다.”</em><br>
</li>
<li>해설서: <em>“이 표준은 데이터베이스 간 일관성을 유지하고 검색 효율성을 높이기 위한 것이다.”</em><br>
</li>
<li>정책 보고서: <em>“이 표준을 적용하면 시스템 간 데이터 호환성이 향상될 것으로 예상된다.”</em></li>
</ul></li>
</ul>
</section>
<section id="결론-표준화-원칙-문서에는-해설을-포함하지-않는-것이-원칙" class="level3" data-number="1.1.5">
<h3 data-number="1.1.5" class="anchored" data-anchor-id="결론-표준화-원칙-문서에는-해설을-포함하지-않는-것이-원칙"><span class="header-section-number">1.1.5</span> 결론: 표준화 원칙 문서에는 해설을 포함하지 않는 것이 원칙</h3>
<ul>
<li><strong>명확성과 일관성 유지</strong> → 주관적 해석을 방지하고 적용 기준을 통일함<br>
</li>
<li><strong>적용 중심</strong> → 표준 및 원칙은 해석이 아니라 직접 적용하는 것이 목적임<br>
</li>
<li><strong>시대적 변화 고려</strong> → 표준 내용은 개정될 수 있지만, 표준화 원칙은 유지됨<br>
</li>
<li><strong>문서 역할 구분</strong> → 표준 문서(규정), 해설서(설명), 정책 보고서(효과 분석)</li>
</ul>
<p>따라서 표준화 원칙 문서에서는 해설, 이유, 장점, 원리 등의 내용을 배제하고, 명확한 기준을 제시하는 것이 원칙이다.</p>
</section>
</section>
<section id="버전-관리와-이력-추적" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="버전-관리와-이력-추적"><span class="header-section-number">1.2</span> 버전 관리와 이력 추적</h2>
<ul>
<li>표준 문서 자체의 버전 관리 방식을 명시해야 함</li>
<li>표준 개정 이력을 추적할 수 있는 체계 필요</li>
<li>각 표준 조항별 시행일자 명시 방법 정의</li>
<li>예시
<ul>
<li>표준 문서 버전 관리 체계
<ul>
<li>표준 문서의 버전은 ‘{주버전}.{부버전}.{수정버전}’ 형식으로 관리한다</li>
<li>주버전은 표준의 근본적 변경 시 증가한다</li>
<li>부버전은 기존 표준의 확장 시 증가한다</li>
<li>수정버전은 오류 수정이나 경미한 변경 시 증가한다</li>
</ul></li>
<li>표준 개정 이력 관리
<ul>
<li>모든 표준 문서는 개정 이력 테이블을 포함해야 한다</li>
<li>개정 이력에는 버전, 개정일자, 승인자, 주요 변경사항을 기록한다</li>
<li>개정된 조항은 해당 조항의 버전을 별도로 표기한다</li>
<li>개정 전 표준 문서는 별도 저장소에 보관한다</li>
</ul></li>
<li>표준 조항 시행일자 관리
<ul>
<li>각 표준 조항에는 시행일자를 명시한다</li>
<li>시행일자가 다른 조항은 별도로 구분하여 표기한다</li>
<li>시행 유예가 필요한 조항은 유예기간을 명확히 표기한다</li>
<li>폐기된 조항은 폐기일자와 대체 조항을 명시한다</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="예외-처리-기준" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="예외-처리-기준"><span class="header-section-number">1.3</span> 예외 처리 기준</h2>
<ul>
<li>표준을 적용할 수 없는 예외 상황에 대한 판단 기준 제시</li>
<li>예외 승인 절차와 권한에 대한 명확한 정의</li>
<li>예시: “예외 적용은 데이터 거버넌스 위원회의 승인을 필요로 한다.”
<ul>
<li>예외 상황 판단 기준
<ul>
<li>기술적 제약으로 인한 예외
<ul>
<li>레거시 시스템과의 호환성 문제</li>
<li>외부 시스템 연계로 인한 제약</li>
<li>특수 기술 환경으로 인한 제약</li>
</ul></li>
<li>업무적 예외
<ul>
<li>법적 요구사항과의 충돌</li>
<li>긴급 상황 대응을 위한 예외</li>
<li>임시 조치가 필요한 상황</li>
</ul></li>
</ul></li>
<li>예외 승인 절차
<ul>
<li>예외 신청서 제출
<ul>
<li>예외가 필요한 표준 조항 명시</li>
<li>예외 적용이 필요한 사유 기술</li>
<li>예외 적용 범위와 기간 명시</li>
<li>대안 또는 보완 방안 제시</li>
</ul></li>
<li>예외 심사
<ul>
<li>데이터 거버넌스 위원회의 정기 심사</li>
<li>긴급 건의 경우 수시 심사 가능</li>
<li>예외 승인 기준에 따른 평가</li>
</ul></li>
<li>승인 및 관리
<ul>
<li>승인된 예외는 관리대장에 등록</li>
<li>예외 적용 현황 정기 모니터링</li>
<li>예외 기간 만료 시 연장 또는 종료 심사</li>
</ul></li>
</ul></li>
<li>예외 승인 권한
<ul>
<li>일반적 예외: 데이터 거버넌스 위원회 승인 필요</li>
<li>긴급 예외: 데이터 관리자 승인 후 사후 위원회 보고</li>
<li>항구적 예외: 전체 위원회 2/3 이상 동의 필요</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="적용-범위의-명확화" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="적용-범위의-명확화"><span class="header-section-number">1.4</span> 적용 범위의 명확화</h2>
<ul>
<li>표준이 적용되는 대상 시스템/데이터의 범위</li>
<li>조직 내 적용 부서/팀의 범위</li>
<li>외부 협력사나 벤더와의 관계에서의 적용 범위</li>
<li>예시
<ul>
<li>대상 시스템/데이터 범위
<ul>
<li>적용 대상 시스템 분류
<ul>
<li>핵심 업무 시스템: 전체 표준 필수 적용</li>
<li>지원 시스템: 기본 표준 필수 적용</li>
<li>임시 시스템: 핵심 표준만 적용</li>
</ul></li>
<li>데이터 범위 정의
<ul>
<li>마스터 데이터: 전체 표준 적용</li>
<li>트랜잭션 데이터: 기본 표준 적용</li>
<li>외부 연계 데이터: 연계 표준 적용</li>
<li>임시 데이터: 제외 대상</li>
</ul></li>
</ul></li>
<li>조직 범위
<ul>
<li>필수 적용 조직
<ul>
<li>데이터 생성/관리 부서</li>
<li>시스템 운영 부서</li>
<li>데이터 분석 부서</li>
</ul></li>
<li>선택 적용 조직
<ul>
<li>비정기 데이터 활용 부서</li>
<li>임시 프로젝트 팀</li>
</ul></li>
<li>예외 조직
<ul>
<li>외부 감사 대응 부서</li>
<li>일회성 태스크포스</li>
</ul></li>
</ul></li>
<li>외부 협력 범위
<ul>
<li>협력사 적용 기준
<ul>
<li>데이터 직접 처리 벤더: 전체 표준 적용</li>
<li>시스템 개발 벤더: 개발 표준 적용</li>
<li>운영 대행 벤더: 운영 표준 적용</li>
</ul></li>
<li>계약 반영 사항
<ul>
<li>표준 준수 의무 명시</li>
<li>위반 시 제재 사항 포함</li>
<li>정기 점검 수용 의무</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="표준-준수-검증-기준" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="표준-준수-검증-기준"><span class="header-section-number">1.5</span> 표준 준수 검증 기준</h2>
<ul>
<li>표준 준수 여부를 확인할 수 있는 객관적 기준</li>
<li>검증 주기와 방법론</li>
<li>미준수 시의 조치 사항</li>
<li>예시
<ul>
<li>객관적 검증 기준
<ul>
<li>시스템 점검 항목
<ul>
<li>데이터 모델 준수율</li>
<li>명명 규칙 준수율</li>
<li>코드 표준 준수율</li>
<li>품질 규칙 준수율</li>
</ul></li>
<li>프로세스 점검 항목
<ul>
<li>데이터 생성 절차 준수</li>
<li>변경 관리 절차 준수</li>
<li>접근 통제 준수</li>
<li>백업 정책 준수</li>
</ul></li>
</ul></li>
<li>검증 방법
<ul>
<li>정기 검증
<ul>
<li>월간: 자동화 도구 검증</li>
<li>분기: 샘플링 검증</li>
<li>반기: 전수 검증</li>
</ul></li>
<li>특별 검증
<ul>
<li>중요 시스템 변경 시</li>
<li>대규모 데이터 이관 시</li>
<li>신규 시스템 도입 시</li>
</ul></li>
<li>검증 도구
<ul>
<li>자동화 검증 도구 활용</li>
<li>체크리스트 기반 점검</li>
<li>전문가 검토</li>
</ul></li>
</ul></li>
<li>미준수 시 조치
<ul>
<li>경미한 위반
<ul>
<li>시정 계획 제출</li>
<li>재검증 일정 지정</li>
<li>교육 이수 의무화</li>
</ul></li>
<li>중대한 위반
<ul>
<li>즉시 시정 조치</li>
<li>원인 분석 보고</li>
<li>책임자 경고</li>
<li>재발 방지 대책 수립</li>
</ul></li>
<li>상습적 위반
<ul>
<li>시스템 접근 제한</li>
<li>업무 배제 검토</li>
<li>성과 평가 반영</li>
<li>위원회 제재 심의</li>
</ul></li>
</ul></li>
</ul></li>
</ul>


</section>
</section>

 ]]></description>
  <category>Data Governance</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Governance/5-0-2.terminology_hierarchy copy.html</guid>
  <pubDate>Tue, 26 Nov 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Data Governance Study - Data Standard Governance</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Governance/5-0-2.terminology_hierarchy.html</link>
  <description><![CDATA[ 




<section id="용어-정리" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 용어 정리</h1>
<p>용어 (glossary, terms, terminology, etc.)와 관련된 단어들이 많아 혼동되어 사용될 때가 있다. 서로 연관성과 포괄 범위에 따라 <strong>계층적(hierarchy)</strong>으로 대략적으로 구분할 수 있다. 이 계층 구조는 일반적으로 구체성과 사용 범위를 기준으로 정리했다. 반드시 이런 계층 구조를 갖는 다는 것이 아닌 대략적인 생각의 정리를 한것이기 때문에 다른 참고 문헌과 다를 수 있다. 아래는 용어와 관련된 주요 단어들의 계층 구조와 그 관계를 설명한 것이다.</p>
<section id="hierarchy-of-terms-related-to-terminology" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="hierarchy-of-terms-related-to-terminology"><span class="header-section-number">1.1</span> Hierarchy of Terms Related to “Terminology”</h2>
<pre><code>Language (언어)
 ├─ Lexicon (어휘: 언어의 모든 단어 체계)
 │   ├─ Word (단어: 단어, 언어의 기본 단위)
 │   ├─ Vocabulary (어휘량: 특정 맥락에서 사용되는 단어들의 집합)
 │   │   ├─ Terms (용어: 특정 의미가 부여된 전문적 단어)
 │   │   │   ├─ Terminology (특정 분야의 용어 체계)
 │   │   │   │   ├─ Terminology의 산출물
 │   │   │   │   │  ├─ Glossary (용어집)
 │   │   │   │   │  ├─ Thesaurus (단어 관계 구조: 유의어, 반의어 등)   
 │   │   │   │   │  └─ Ontology (개념 구조)
 │   │   │   │   └─ Nomenclature-Based Terms (명명법: 이름 부여 규칙에 의거하여 만들어진 용어)
 │   │   │   └─ Jargon (비공식적 전문 용어)</code></pre>
<ol type="1">
<li>Language (언어)
<ul>
<li>가장 상위 개념.</li>
<li>모든 용어(term)는 특정 언어의 표현 방식을 통해 전달된다.</li>
<li>예: 영어(English), 한국어(Korean)</li>
</ul></li>
<li>Lexicon (어휘)
<ul>
<li>특정 언어에서 사용되는 단어들의 집합.</li>
<li>모든 단어가 용어(term)는 아니지만, 용어는 어휘의 하위 집합에 속함.</li>
<li>예: 영어의 어휘 중 “algorithm”이나 “regression” 같은 단어.</li>
</ul></li>
<li>Word (단어)
<ul>
<li>언어의 가장 기본적이고 일반적인 단위.</li>
<li>역할: 모든 용어(term), 어휘(vocabulary), 전문 용어(terminology), 또는 다른 언어적 표현의 기본 단위.</li>
<li>위치: 계층의 최하단 (어휘 이전 단계)</li>
<li>모든 “Terms(용어)”는 “Words(단어)”에서 출발하므로 계층의 가장 기본적 구성 요소.</li>
</ul></li>
<li>Vocabulary (어휘량, 단어집합)
<ul>
<li>개인이나 특정 그룹이 사용하는 단어나 표현의 집합.</li>
<li>일반적으로 넓은 범위의 단어를 포함하며, 특정 전문성을 요구하지 않음.</li>
<li>예: 초등학생의 어휘량, 일반적인 대화에서 쓰이는 단어들.</li>
</ul></li>
<li>Terms (용어)
<ul>
<li>특정 개념, 아이디어, 또는 사물에 대해 지칭하는 단어들.</li>
<li>일반 어휘(vocabulary) 중에서도 구체적이고 정의된 단어를 의미.</li>
<li>예: “data,” “model,” “learning rate” 등.</li>
</ul></li>
<li>Terminology (전문 용어 체계)
<ul>
<li>특정 분야에서 사용하는 용어(term)들의 집합.</li>
<li>용어의 정의, 사용 방법, 상호 연관성을 포함하며, 체계적으로 정리됨.</li>
<li>예: 의료 용어(medical terminology), 법률 용어(legal terminology), AI 용어(artificial intelligence terminology).</li>
</ul></li>
<li>Nomenclature-based Terms (명명법)
<ul>
<li>Nomenclature: 특정 분야에서 사물이나 개념을 체계적으로 명명하는 방식.</li>
<li>용어(terms)가 생성되고 정의되는 체계.</li>
<li>예: 화학의 분자 명명법(IUPAC nomenclature), 생물학의 학명 체계, 공식 명칭 (Official Names), 표준화된 용어 (Standardized Terms), 기술적 용어 (Technical Terms), 학명 (Scientific Names), 코드 또는 약어 (Codes/Acronyms)</li>
</ul></li>
<li>Jargon (전문 용어/은어):
<ul>
<li>전문 용어 체계(terminology)의 비공식적/비체계적 하위 집합.</li>
<li>특정 집단 내에서 자연스럽게 발생하여 특정 그룹에서만 사용되며, 외부인은 이해하기 어렵다.</li>
<li>때로는 비격식적이거나 약어로 사용됨 (반드시 체계적이지 않을 수 있음)</li>
<li>예: “push the envelope” (항공 공학), “debugging” (프로그래밍)</li>
</ul></li>
<li>Glossary (용어집)
<ul>
<li>특정 문서, 주제, 또는 책에서 사용된 용어(term)와 그 정의를 정리한 목록.</li>
<li>전문 분야 용어(term) 또는 terminology의 서브셋을 정리한 자료.</li>
<li>예: 교과서 뒤의 용어집, 연구 보고서의 부록.</li>
</ul></li>
<li>Thesaurus (유의어 사전)
<ul>
<li>단어들(terms) 간의 관계를 설명한 자료.<br>
</li>
<li>주로 유사어, 반의어, 상위어, 하위어를 포함함.</li>
<li>예: 단어 “big”의 유의어는 “large,” “huge.”</li>
</ul></li>
<li>Ontology (온톨로지, 개념 모델)
<ul>
<li>특정 도메인에서 사용되는 용어(term)와 그 관계를 구조화한 지식 체계.</li>
<li>Glossary나 terminology보다 복잡하며, 개념 간의 관계를 설명.</li>
<li>예: 생물학에서 유전자-단백질 간 관계를 나타내는 온톨로지.</li>
</ul></li>
</ol>
<section id="example-of-hierarchy-in-context" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="example-of-hierarchy-in-context"><span class="header-section-number">1.1.1</span> Example of Hierarchy in Context</h3>
<section id="computing-and-programming" class="level4" data-number="1.1.1.1">
<h4 data-number="1.1.1.1" class="anchored" data-anchor-id="computing-and-programming"><span class="header-section-number">1.1.1.1</span> Computing and Programming</h4>
<ul>
<li><strong>Language</strong>: Python (programming language)
<ul>
<li><strong>Lexicon</strong>: All valid identifiers, keywords, and syntax in Python.
<ul>
<li><strong>Word</strong>: “Function” (basic programming concept).</li>
<li><strong>Vocabulary</strong>: Words commonly used by data scientists using Python.
<ul>
<li><strong>Terms</strong>: Specialized terms in data science programming.
<ul>
<li><strong>Jargon</strong>: “ETL pipeline” (informal term understood by data engineers).</li>
<li><strong>Terminology</strong>: The standardized terminology in data science and programming.
<ul>
<li><strong>Terminology의 산출물</strong>:
<ul>
<li><strong>Glossary</strong>: A Python library documentation glossary defining “NumPy array” as a multi-dimensional array object.</li>
<li><strong>Thesaurus</strong>: Relationships between “NumPy array,” “Pandas DataFrame,” and “Python lists.”</li>
<li><strong>Ontology</strong>: A knowledge graph connecting “Data preprocessing,” “Feature engineering,” and “Machine learning pipelines.”</li>
</ul></li>
<li><strong>Nomenclature-Based Terms</strong>: “NaN” (Not a Number) in data handling, defined by IEEE 754 standard for floating-point arithmetic.</li>
</ul>
<pre><code>Language (Python)
 ├─ Lexicon (All valid identifiers, keywords, and syntax in Python)
 │   ├─ Word ("Function")
 │   ├─ Vocabulary (Words commonly used by data scientists using Python)
 │   │   ├─ Terms (Specialized terms in data science programming)
 │   │   │   ├─ Jargon ("ETL pipeline", "Model drift")
 │   │   │   ├─ Terminology (Standardized terminology in programming and data science)
 │   │   │   │   ├─ Glossary ("NumPy array": Multi-dimensional array object)
 │   │   │   │   ├─ Thesaurus (Relationships: "NumPy array" ↔ "Pandas DataFrame" ↔ "Python lists")
 │   │   │   │   ├─ Ontology (Knowledge graph: "Data preprocessing" ↔ "Feature engineering" ↔ "Machine learning pipelines")
 │   │   │   │   └─ Nomenclature-Based Terms ("NaN": Not a Number, defined by IEEE 754 standard)</code></pre></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="biology" class="level4" data-number="1.1.1.2">
<h4 data-number="1.1.1.2" class="anchored" data-anchor-id="biology"><span class="header-section-number">1.1.1.2</span> Biology</h4>
<ul>
<li><strong>Language</strong>: English
<ul>
<li><strong>Lexicon</strong>: All English words, including formal and informal usage.
<ul>
<li><strong>Word</strong>: “Gene,” “DNA,” “Mutation” (basic units of language with general meanings).</li>
<li><strong>Vocabulary</strong>: Words used by genomics researchers, including both common (“Genetic”) and specialized terms (“Polymorphism”).
<ul>
<li><strong>Terms</strong>: Specialized words in genomics with precise definitions. “Single Nucleotide Polymorphism (SNP): a single base change in a DNA sequence”
<ul>
<li><strong>Jargon</strong>: Informal terms or shorthand used by genomics professionals, often inaccessible to outsiders. “GWAS” (Genome-Wide Association Study)</li>
<li><strong>Terminology</strong>: Standardized terms used in genomics for precise communication. “Genotype” (the genetic makeup of an organism).
<ul>
<li><strong>Terminology의 산출물</strong>:
<ul>
<li><strong>Glossary</strong>: A genomics textbook glossary defining “Transcriptomics” as the study of RNA transcripts in a cell or organism</li>
<li><strong>Thesaurus</strong>: Showing relationships between “Genotype” (genetic composition), “Allele” (variant form of a gene), and “Haplotype” (group of alleles inherited together).</li>
<li><strong>Ontology</strong>: Gene Ontology (GO) mapping relationships between “Biological processes,” “Molecular functions,” and “Cellular components.”</li>
</ul></li>
<li><strong>Nomenclature-Based Terms</strong>: Terms created based on standard naming conventions in genomics.”BRCA1” (a gene associated with breast cancer susceptibility, named following gene nomenclature rules).</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<pre><code>Language (English)
 ├─ Lexicon (All genomics-related words)
 │   ├─ Word ("Gene," "DNA," "Mutation")
 │   ├─ Vocabulary (General and domain-specific words)
 │   │   ├─ Terms (Precise definitions: "SNP," "Epigenetics")
 │   │   │   ├─ Jargon (Shorthand: "GWAS," "NGS")
 │   │   │   ├─ Terminology (Standardized concepts: "Genotype," "Phenotype")
 │   │   │   │   ├─ Glossary (Definitions: "Transcriptomics")
 │   │   │   │   ├─ Thesaurus (Relationships: "Genotype" ↔ "Allele" ↔ "Haplotype")
 │   │   │   │   ├─ Ontology (Gene Ontology: "Biological process" ↔ "Molecular function")
 │   │   │   │   └─ Nomenclature-Based Terms ("BRCA1," "rs1234567")</code></pre>
</section>
<section id="medical-field" class="level4" data-number="1.1.1.3">
<h4 data-number="1.1.1.3" class="anchored" data-anchor-id="medical-field"><span class="header-section-number">1.1.1.3</span> Medical Field</h4>
<ul>
<li><strong>Language</strong>: Latin and English (used in medical communication)
<ul>
<li><strong>Lexicon</strong>: All terms used in medical practice.
<ul>
<li><strong>Word</strong>: “Heart” (common term in English).</li>
<li><strong>Vocabulary</strong>: Words used by cardiologists.
<ul>
<li><strong>Terms</strong>: Medical terms with precise definitions.
<ul>
<li><strong>Jargon</strong>: “Code blue” (hospital jargon for cardiac arrest emergency).</li>
<li><strong>Terminology</strong>: Standardized medical terms in cardiology.
<ul>
<li><strong>Terminology의 산출물</strong>:
<ul>
<li><strong>Glossary</strong>: A medical glossary defining “Myocardial infarction” as a heart attack.</li>
<li><strong>Thesaurus</strong>: Linking “Myocardial infarction” with “Cardiac ischemia” (related condition) and “Angina” (symptom).</li>
<li><strong>Ontology</strong>: A structured model showing how “Atherosclerosis” leads to “Coronary artery blockage,” resulting in “Myocardial infarction.”</li>
</ul></li>
<li><strong>Nomenclature-Based Terms</strong>: “ICD-10 I21.9” (International Classification of Diseases code for acute myocardial infarction, unspecified).</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<pre><code>Language (Latin and English)
 ├─ Lexicon (All terms used in medical practice)
 │   ├─ Word ("Heart", "Lung")
 │   ├─ Vocabulary (Words used by cardiologists and medical professionals)
 │   │   ├─ Terms (Medical terms with precise definitions)
 │   │   │   ├─ Jargon ("Code blue": Hospital slang for cardiac arrest emergency)
 │   │   │   ├─ Terminology (Standardized medical terms in cardiology)
 │   │   │   │   ├─ Glossary ("Myocardial infarction": Defined as a heart attack in a glossary)
 │   │   │   │   ├─ Thesaurus (Relationships: "Myocardial infarction" ↔ "Cardiac ischemia" ↔ "Angina")
 │   │   │   │   ├─ Ontology (Concept map: "Atherosclerosis" ↔ "Coronary artery blockage" ↔ "Myocardial infarction")
 │   │   │   │   └─ Nomenclature-Based Terms ("ICD-10 I21.9": Classification code for acute myocardial infarction)</code></pre>
</section>
</section>
</section>
<section id="정리-요약" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="정리-요약"><span class="header-section-number">1.2</span> 정리 요약</h2>
<ol type="1">
<li><strong>Lexicon</strong>: Comprehensive vocabulary encompassing all terms in medical practice, including both common and specialized words.</li>
<li><strong>Word</strong>: The basic building blocks of language, such as “Heart” or “Lung.”</li>
<li><strong>Vocabulary</strong>: Terms specific to medical practice or subfields (e.g., cardiology).</li>
<li><strong>Terms</strong>: Precise, specialized language used by medical professionals to ensure accuracy.
<ul>
<li><strong>Terminology</strong>: Formal, standardized terms (e.g., “Myocardial infarction”).
<ul>
<li><strong>Glossary</strong>: Definitions of terms for educational purposes.</li>
<li><strong>Thesaurus</strong>: Showing semantic relationships between terms.</li>
<li><strong>Ontology</strong>: Structural knowledge models explaining interdependencies.</li>
<li><strong>Nomenclature-Based Terms</strong>: Official codes or identifiers for conditions, such as ICD-10 classification.</li>
</ul></li>
<li><strong>Jargon</strong>: Informal shorthand (e.g., “Code blue”).</li>
</ul></li>
</ol>


</section>
</section>

 ]]></description>
  <category>Data Governance</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Governance/5-0-2.terminology_hierarchy.html</guid>
  <pubDate>Sun, 24 Nov 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Data Governance Study - Data Quality Management</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Governance/8-0.data_quality_measures.html</link>
  <description><![CDATA[ 




<section id="data-standard-governance-data-quality-management" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="data-standard-governance-data-quality-management"><span class="header-section-number">1</span> Data Standard Governance &gt; Data Quality Management</h2>
<section id="데이터-품질-진단-지표-측정-방법" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="데이터-품질-진단-지표-측정-방법"><span class="header-section-number">1.1</span> 데이터 품질 진단 지표 측정 방법</h3>
<section id="정확성-accuracy" class="level4" data-number="1.1.1">
<h4 data-number="1.1.1" class="anchored" data-anchor-id="정확성-accuracy"><span class="header-section-number">1.1.1</span> 정확성 (Accuracy)</h4>
<ul>
<li>데이터가 실제 값이나 참조 소스와 일치하는 정도</li>
<li>측정 방법
<ul>
<li>샘플링을 통한 수동 검증
<ul>
<li>(정확한 샘플 수 / 전체 샘플 수) * 100</li>
<li>방법: 무작위로 선택된 데이터 샘플을 실제 값과 비교</li>
</ul></li>
<li>참조 데이터와의 비교
<ul>
<li>예: (참조 데이터와 일치하는 레코드 수 / 전체 레코드 수) * 100</li>
<li>방법: 신뢰할 수 있는 외부 데이터 소스와 비교</li>
</ul></li>
<li>비즈니스 규칙 위반 검사
<ul>
<li>예: (비즈니스 규칙을 준수하는 레코드 수 / 전체 레코드 수) * 100</li>
<li>방법: 미리 정의된 비즈니스 규칙에 대한 준수 여부 확인</li>
</ul></li>
<li>데이터 검증 알고리즘 사용
<ul>
<li>예: (알고리즘 검증을 통과한 데이터 수 / 전체 데이터 수) * 100</li>
<li>방법: 체크섬, 유효성 검사 알고리즘 등을 사용</li>
</ul></li>
</ul></li>
<li>중요성
<ul>
<li>신뢰성 있는 의사결정: 정확한 데이터는 올바른 비즈니스 결정을 내리는 기반이 된다.</li>
<li>운영 효율성: 부정확한 데이터로 인한 오류와 재작업을 줄일 수 있다.</li>
<li>고객 만족: 정확한 고객 정보는 더 나은 서비스 제공으로 이어진다.</li>
<li>규제 준수: 많은 산업에서 데이터의 정확성은 법적 요구사항이다.</li>
<li>비용 절감: 정확한 데이터는 불필요한 비용 발생을 방지한다.</li>
</ul></li>
<li>예시
<ul>
<li>고객 주소 정확성
<ul>
<li>측정: 우편번호와 주소의 일치 여부</li>
<li>방법: 우편번호 데이터베이스와 비교</li>
<li>목표: 95% 이상의 주소가 정확해야 함</li>
</ul></li>
<li>제품 가격 정확성
<ul>
<li>측정: 시스템에 등록된 가격과 실제 판매 가격의 일치 여부</li>
<li>방법: POS 데이터와 제품 카탈로그 비교</li>
<li>목표: 99.9% 이상의 가격 정보가 정확해야 함</li>
</ul></li>
<li>재고 수량 정확성
<ul>
<li>측정: 시스템상 재고량과 실제 재고량의 일치 여부</li>
<li>방법: 정기적인 실사를 통한 비교</li>
<li>목표: 97% 이상의 재고 정보가 정확해야 함</li>
</ul></li>
<li>금융 거래 정확성
<ul>
<li>측정: 거래 기록의 정확성</li>
<li>방법: 더블 엔트리 회계 시스템을 통한 검증</li>
<li>목표: 100% 정확성 (모든 불일치는 조사 및 수정되어야 함)</li>
</ul></li>
<li>고객 연락처 정확성
<ul>
<li>측정: 이메일 주소와 전화번호의 유효성</li>
<li>방법: 이메일 발송 테스트, 전화번호 형식 검증</li>
<li>목표: 90% 이상의 연락처 정보가 유효해야 함</li>
</ul></li>
</ul></li>
<li>정확성 개선 전략
<ul>
<li>데이터 입력 시 자동 검증 시스템 구축</li>
<li>정기적인 데이터 클렌징 및 품질 검사 수행</li>
<li>데이터 소스의 신뢰성 평가 및 관리</li>
<li>직원 교육을 통한 데이터 입력 오류 최소화</li>
<li>데이터 품질 관리 도구 활용</li>
<li>데이터 정확성에 대한 책임자 지정</li>
<li>지속적인 모니터링 및 피드백 시스템 구축</li>
</ul></li>
</ul>
</section>
<section id="완전성-completeness" class="level4" data-number="1.1.2">
<h4 data-number="1.1.2" class="anchored" data-anchor-id="완전성-completeness"><span class="header-section-number">1.1.2</span> 완전성 (Completeness)</h4>
<ul>
<li>완전성은 필요한 모든 데이터가 존재하는 정도</li>
<li>즉, 데이터셋이 얼마나 빠짐없이 채워져 있는지, 그리고 필요한 모든 정보를 포함하고 있는지를 측정</li>
<li>측정 방법
<ul>
<li>널(Null) 값 또는 빈 값 검사
<ul>
<li>(채워진 필드 수 / 전체 필드 수) * 100</li>
</ul></li>
<li>필수 필드 존재 여부 확인
<ul>
<li>(모든 필수 필드가 채워진 레코드 수 / 전체 레코드 수) * 100</li>
</ul></li>
<li>데이터셋 완전성 검사
<ul>
<li>(실제 레코드 수 / 예상되는 총 레코드 수) * 100</li>
</ul></li>
<li>시계열 데이터 완전성 검사
<ul>
<li>(데이터가 있는 시간 단위 수 / 전체 시간 단위 수) * 100</li>
</ul></li>
</ul></li>
<li>중요성
<ul>
<li>정확한 분석: 완전한 데이터셋은 더 정확하고 신뢰할 수 있는 분석 결과 제공</li>
<li>의사결정 지원: 누락된 데이터 없이 전체 그림을 볼 수 있어 더 나은 의사결정 가능</li>
<li>프로세스 효율성: 필요한 모든 데이터가 있으면 업무 프로세스가 원활하게 진행</li>
<li>고객 만족: 완전한 고객 정보는 더 나은 서비스와 경험 제공 가능</li>
<li>규제 준수: 많은 산업에서 데이터의 완전성은 규제 요구사항의 일부</li>
</ul></li>
<li>구체적인 예시
<ul>
<li>고객 프로필 완전성
<ul>
<li>측정: 필수 고객 정보 필드의 완전성</li>
<li>방법: (모든 필수 필드가 채워진 고객 프로필 수 / 전체 고객 프로필 수) * 100</li>
<li>목표: 95% 이상의 고객 프로필이 모든 필수 정보를 포함해야 함</li>
<li>필수 필드 예: 이름, 연락처, 이메일, 주소</li>
</ul></li>
<li>주문 데이터 완전성
<ul>
<li>측정: 주문 관련 모든 필요 정보의 존재 여부</li>
<li>방법: (모든 필요 정보가 있는 주문 수 / 전체 주문 수) * 100</li>
<li>목표: 99% 이상의 주문이 모든 필요 정보를 포함해야 함</li>
<li>필요 정보: 주문 ID, 고객 ID, 주문 날짜, 제품 ID, 수량, 가격, 배송 주소</li>
</ul></li>
<li>재무 보고 데이터 완전성
<ul>
<li>측정: 월별 재무 보고서의 모든 필요 항목 존재 여부</li>
<li>방법: (모든 필요 항목이 보고된 월 수 / 전체 보고 월 수) * 100</li>
<li>목표: 100% (모든 월의 재무 보고서가 완전해야 함)</li>
<li>필요 항목: 매출, 비용, 순이익, 자산, 부채, 자본 등</li>
</ul></li>
<li>센서 데이터 완전성
<ul>
<li>측정: IoT 센서에서 수집된 데이터의 시간별 완전성</li>
<li>방법: (데이터가 수집된 시간 단위 수 / 24시간) * 100 (일일 기준)</li>
<li>목표: 99.9% 이상 (하루 중 대부분의 시간에 데이터가 수집되어야 함)</li>
</ul></li>
<li>제품 카탈로그 완전성
<ul>
<li>측정: 제품 정보의 완전성</li>
<li>방법: (모든 필요 정보가 있는 제품 수 / 전체 제품 수) * 100</li>
<li>목표: 98% 이상의 제품이 모든 필요 정보를 포함해야 함</li>
<li>필요 정보: 제품명, 설명, 가격, 카테고리, 이미지, 재고 상태 등</li>
</ul></li>
</ul></li>
<li>완전성 개선 전략
<ul>
<li>데이터 입력 시 필수 필드 설정 및 유효성 검사 구현</li>
<li>데이터 수집 프로세스 자동화</li>
<li>데이터 품질 모니터링 도구 사용</li>
<li>정기적인 데이터 감사 및 클렌징 작업 수행</li>
<li>사용자 교육 및 데이터 입력 가이드라인 제공</li>
<li>데이터 보완을 위한 외부 데이터 소스 활용</li>
<li>데이터 거버넌스 정책 수립 및 시행</li>
</ul></li>
</ul>
</section>
<section id="일관성-consistency" class="level4" data-number="1.1.3">
<h4 data-number="1.1.3" class="anchored" data-anchor-id="일관성-consistency"><span class="header-section-number">1.1.3</span> 일관성 (Consistency)</h4>
<ul>
<li>일관성은 데이터가 여러 위치, 시스템, 또는 표현 방식에서 서로 모순 없이 일치하는 정도</li>
<li>이는 데이터의 내부적 일관성(동일 데이터셋 내)과 외부적 일관성(여러 데이터셋 간)을 모두 포함</li>
<li>측정 방법
<ul>
<li>크로스 체크 (여러 테이블/시스템 간 데이터 비교)
<ul>
<li>(일치하는 데이터 항목 수 / 전체 비교 데이터 항목 수) * 100</li>
</ul></li>
<li>중복 데이터 검사
<ul>
<li>(고유한 데이터 항목 수 / 전체 데이터 항목 수) * 100</li>
</ul></li>
<li>데이터 형식의 일관성 검사
<ul>
<li>(표준 형식을 따르는 데이터 항목 수 / 전체 데이터 항목 수) * 100</li>
</ul></li>
<li>참조 무결성 검사
<ul>
<li>(유효한 참조를 가진 외래 키 수 / 전체 외래 키 수) * 100</li>
</ul></li>
</ul></li>
<li>중요성
<ul>
<li>데이터 신뢰성
<ul>
<li>일관된 데이터는 신뢰할 수 있는 정보 제공</li>
<li>여러 시스템이나 채널에서 일관된 정보를 제공함으로써 고객과 내부 사용자의 신뢰를 얻을 수 있다.</li>
</ul></li>
<li>효율적인 운영
<ul>
<li>일관된 데이터는 업무 프로세스의 효율성을 높이고, 데이터 불일치로 인한 추가 작업을 줄일 수 있다.<br>
</li>
</ul></li>
<li>의사결정 지원
<ul>
<li>모순 없는 데이터를 기반으로 한 일관된 의사결정 가능</li>
</ul></li>
<li>시스템 통합
<ul>
<li>여러 시스템 간 원활한 데이터 교환 및 통합 지원</li>
</ul></li>
<li>사용자 경험
<ul>
<li>일관된 데이터로 인한 사용자 혼란 방지</li>
</ul></li>
<li>정확한 보고 및 분석
<ul>
<li>여러 소스의 데이터가 일관될 때, 더 정확하고 신뢰할 수 있는 비즈니스 인텔리전스와 분석이 가능</li>
</ul></li>
<li>비용 절감
<ul>
<li>데이터 불일치로 인한 오류 수정 비용 감소</li>
</ul></li>
<li>규제 준수
<ul>
<li>많은 산업에서 데이터의 일관성은 규제 요구사항의 일부이다. 일관된 데이터 관리는 컴플라이언스를 지원.</li>
</ul></li>
<li>고객 경험 향상
<ul>
<li>고객이 모든 접점에서 일관된 정보를 받을 때, 더 나은 고객 경험을 제공</li>
</ul></li>
</ul></li>
<li>예시
<ul>
<li>고객 정보의 일관성
<ul>
<li>측정: CRM 시스템과 주문 시스템 간 고객 정보 일치 여부</li>
<li>방법: 두 시스템의 고객 데이터를 주기적으로 비교</li>
<li>목표: 95% 이상의 고객 정보가 두 시스템에서 일치해야 함</li>
</ul></li>
<li>제품 가격의 일관성
<ul>
<li>측정: 온라인 스토어와 POS 시스템 간 제품 가격 일치 여부</li>
<li>방법: 실시간 또는 일일 기준으로 두 시스템의 제품 가격 비교</li>
<li>목표: 99.9% 이상의 제품 가격이 모든 판매 채널에서 일치해야 함</li>
</ul></li>
<li>재무 데이터의 일관성
<ul>
<li>측정: 총계정원장과 보조원장 간 잔액 일치 여부</li>
<li>방법: 월말 결산 시 원장 간 잔액 비교</li>
<li>목표: 100% 일치 (모든 차이는 조정되고 설명되어야 함)</li>
</ul></li>
<li>주소 형식의 일관성
<ul>
<li>측정: 정의된 주소 형식 준수 여부</li>
<li>방법: 정규 표현식을 사용하여 주소 형식 검증</li>
<li>목표: 90% 이상의 주소가 표준 형식을 따라야 함</li>
</ul></li>
<li>제품 카테고리의 일관성
<ul>
<li>측정: 여러 시스템에서 동일한 제품에 대한 카테고리 분류 일치 여부</li>
<li>방법: 제품 마스터 데이터와 각 시스템의 카테고리 정보 비교</li>
<li>목표: 98% 이상의 제품이 모든 시스템에서 동일한 카테고리로 분류되어야 함</li>
</ul></li>
</ul></li>
<li>일관성 개선 전략
<ul>
<li>데이터 통합 솔루션 구현 (예: 마스터 데이터 관리 시스템)</li>
<li>데이터 동기화 메커니즘 개선</li>
<li>데이터 거버넌스 정책 수립 및 시행</li>
<li>데이터 입력 및 수정 프로세스 표준화</li>
<li>정기적인 데이터 감사 및 정화 작업 수행</li>
<li>시스템 간 실시간 데이터 교환 체계 구축</li>
<li>데이터 소유권 및 책임 명확화</li>
</ul></li>
</ul>
</section>
<section id="유효성-validity" class="level4" data-number="1.1.4">
<h4 data-number="1.1.4" class="anchored" data-anchor-id="유효성-validity"><span class="header-section-number">1.1.4</span> 유효성 (Validity)</h4>
<ul>
<li>유효성은 데이터가 정의된 비즈니스 규칙, 데이터 타입, 범위, 형식 등을 준수하는 정도</li>
<li>즉, 데이터가 논리적으로 타당하고 비즈니스 컨텍스트에서 의미 있는지를 측정하는 지표</li>
<li>중요성
<ul>
<li>데이터 무결성: 시스템의 전반적인 데이터 무결성 보장</li>
<li>오류 방지: 잘못된 데이터로 인한 비즈니스 프로세스 오류 예방</li>
<li>분석 신뢰성: 유효한 데이터를 기반으로 한 신뢰할 수 있는 분석 결과 도출</li>
<li>시스템 호환성: 다양한 시스템 간 데이터 교환 시 문제 방지</li>
</ul></li>
<li>측정 방법
<ul>
<li>데이터 타입 검사
<ul>
<li>(올바른 데이터 타입을 가진 필드 수 / 전체 필드 수) * 100</li>
</ul></li>
<li>값 범위 검사
<ul>
<li>(정의된 범위 내의 값을 가진 레코드 수 / 전체 레코드 수) * 100</li>
</ul></li>
<li>형식 검사
<ul>
<li>(올바른 형식을 가진 데이터 항목 수 / 전체 데이터 항목 수) * 100</li>
</ul></li>
<li>비즈니스 규칙 준수 검사
<ul>
<li>(비즈니스 규칙을 준수하는 레코드 수 / 전체 레코드 수) * 100</li>
</ul></li>
</ul></li>
<li>예시
<ul>
<li>이메일 주소 유효성
<ul>
<li>측정: 올바른 이메일 형식 준수 여부</li>
<li>방법: 정규 표현식을 사용하여 이메일 주소 형식 검증</li>
<li>예시 규칙: <sup>1</sup>+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}$</li>
<li>목표: 95% 이상의 이메일 주소가 올바른 형식을 가져야 함</li>
</ul></li>
<li>나이 데이터 유효성
<ul>
<li>측정: 나이 값의 논리적 범위 준수</li>
<li>방법: 0 &lt; 나이 &lt;= 120 범위 검사</li>
<li>목표: 100%의 나이 데이터가 유효한 범위 내에 있어야 함</li>
</ul></li>
<li>주문 데이터 유효성
<ul>
<li>측정: 주문 금액과 주문 항목 수량의 논리적 일관성</li>
<li>방법: 주문 총액 = Σ(항목 가격 * 수량) 검증</li>
<li>목표: 99.9% 이상의 주문 데이터가 이 규칙을 만족해야 함</li>
</ul></li>
<li>신용카드 번호 유효성
<ul>
<li>측정: Luhn 알고리즘을 사용한 신용카드 번호 유효성 검사</li>
<li>방법: Luhn 알고리즘 적용 후 유효성 확인</li>
<li>목표: 100%의 신용카드 번호가 Luhn 알고리즘을 통과해야 함</li>
</ul></li>
<li>날짜 데이터 유효성
<ul>
<li>측정: 날짜 형식 및 논리적 타당성 검사</li>
<li>방법: YYYY-MM-DD 형식 준수 및 존재하는 날짜인지 확인 (예: 2023-02-30은 유효하지 않음)</li>
<li>목표: 100%의 날짜 데이터가 올바른 형식과 유효한 날짜여야 함</li>
</ul></li>
</ul></li>
<li>유효성 개선 전략
<ul>
<li>데이터 입력 시점의 유효성 검사 구현</li>
<li>정기적인 데이터 클렌징 프로세스 수립</li>
<li>비즈니스 규칙 엔진 도입</li>
<li>데이터 품질 관리 도구 활용</li>
<li>사용자 교육 및 가이드라인 제공</li>
<li>데이터 모델링 및 스키마 설계 시 제약조건 적용</li>
</ul></li>
</ul>
</section>
<section id="적시성-timeliness" class="level4" data-number="1.1.5">
<h4 data-number="1.1.5" class="anchored" data-anchor-id="적시성-timeliness"><span class="header-section-number">1.1.5</span> 적시성 (Timeliness)</h4>
<ul>
<li>데이터가 필요한 시점에 이용 가능한 정도와 최신 상태인 정도를 나타냅
<ul>
<li>즉, 데이터가 현실 세계의 상태를 얼마나 잘 반영하고 있는지를 측정하는 지표</li>
</ul></li>
<li>중요성
<ul>
<li>의사결정: 최신 데이터를 기반으로 한 신속하고 정확한 의사결정 가능 중요성</li>
<li>운영 효율성: 실시간 또는 최신 데이터로 업무 프로세스 최적화 중요성</li>
<li>고객 만족: 최신 정보를 기반으로 한 서비스 제공으로 고객 경험 향상</li>
</ul></li>
<li>측정 방법
<ul>
<li>데이터 갱신 주기 확인
<ul>
<li>(정해진 주기 내 업데이트된 레코드 수 / 전체 레코드 수) * 100</li>
</ul></li>
<li>실시간 데이터와 저장된 데이터의 시간 차이 측정
<ul>
<li>평균 데이터 지연 시간 = Σ(현재 시간 - 데이터 최종 업데이트 시간) / 전체 레코드 수</li>
</ul></li>
<li>데이터 생성 시점과 사용 가능 시점의 차이 측정
<ul>
<li>평균 데이터 가용 지연 = Σ(데이터 사용 가능 시간 - 데이터 생성 시간) / 전체 데이터 수</li>
</ul></li>
</ul></li>
<li>예시
<ul>
<li>재고 관리 시스템
<ul>
<li>측정: 실제 재고량과 시스템상 재고량의 일치 비율</li>
<li>방법: (1시간 이내 업데이트된 재고 항목 수 / 전체 재고 항목 수) * 100</li>
<li>목표: 95% 이상의 재고 정보가 1시간 이내에 업데이트되어야 함</li>
</ul></li>
<li>금융 거래 시스템
<ul>
<li>측정: 거래 발생부터 시스템 반영까지의 평균 시간</li>
<li>방법: Σ(거래 반영 시간 - 거래 발생 시간) / 전체 거래 수</li>
<li>목표: 평균 지연 시간 5초 이내</li>
</ul></li>
<li>고객 정보 관리 시스템
<ul>
<li>측정: 고객 정보 변경사항의 반영 속도</li>
<li>방법: (24시간 이내 업데이트된 고객 정보 변경 건수 / 전체 고객 정보 변경 요청 건수) * 100</li>
<li>목표: 99% 이상의 고객 정보 변경사항이 24시간 이내에 반영되어야 함</li>
</ul></li>
<li>적시성 개선 전략
<ul>
<li>실시간 데이터 처리 시스템 구축</li>
<li>데이터 동기화 주기 최적화</li>
<li>데이터 파이프라인 효율성 향상</li>
<li>중요 데이터에 대한 우선순위 처리 체계 수립</li>
<li>데이터 갱신 알림 시스템 구축</li>
</ul></li>
</ul></li>
</ul>


</section>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>a-zA-Z0-9._%+-↩︎</p></li>
</ol>
</section></div> ]]></description>
  <category>Data Governance</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Governance/8-0.data_quality_measures.html</guid>
  <pubDate>Mon, 19 Aug 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Data Governance Study - Data Quality Management</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Governance/8.0nlp.html</link>
  <description><![CDATA[ 




<section id="data-standard-governance-data-quality-management" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="data-standard-governance-data-quality-management"><span class="header-section-number">1</span> Data Standard Governance &gt; Data Quality Management</h2>
<section id="데이터-품질-진단-지표-측정-방법" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="데이터-품질-진단-지표-측정-방법"><span class="header-section-number">1.1</span> 데이터 품질 진단 지표 측정 방법</h3>
<section id="정확성-accuracy" class="level4" data-number="1.1.1">
<h4 data-number="1.1.1" class="anchored" data-anchor-id="정확성-accuracy"><span class="header-section-number">1.1.1</span> 정확성 (Accuracy)</h4>
<ul>
<li>데이터가 실제 값이나 참조 소스와 일치하는 정도</li>
<li>측정 방법
<ul>
<li>샘플링을 통한 수동 검증
<ul>
<li>(정확한 샘플 수 / 전체 샘플 수) * 100</li>
<li>방법: 무작위로 선택된 데이터 샘플을 실제 값과 비교</li>
</ul></li>
<li>참조 데이터와의 비교
<ul>
<li>예: (참조 데이터와 일치하는 레코드 수 / 전체 레코드 수) * 100</li>
<li>방법: 신뢰할 수 있는 외부 데이터 소스와 비교</li>
</ul></li>
<li>비즈니스 규칙 위반 검사
<ul>
<li>예: (비즈니스 규칙을 준수하는 레코드 수 / 전체 레코드 수) * 100</li>
<li>방법: 미리 정의된 비즈니스 규칙에 대한 준수 여부 확인</li>
</ul></li>
<li>데이터 검증 알고리즘 사용
<ul>
<li>예: (알고리즘 검증을 통과한 데이터 수 / 전체 데이터 수) * 100</li>
<li>방법: 체크섬, 유효성 검사 알고리즘 등을 사용</li>
</ul></li>
</ul></li>
<li>중요성
<ul>
<li>신뢰성 있는 의사결정: 정확한 데이터는 올바른 비즈니스 결정을 내리는 기반이 된다.</li>
<li>운영 효율성: 부정확한 데이터로 인한 오류와 재작업을 줄일 수 있다.</li>
<li>고객 만족: 정확한 고객 정보는 더 나은 서비스 제공으로 이어진다.</li>
<li>규제 준수: 많은 산업에서 데이터의 정확성은 법적 요구사항이다.</li>
<li>비용 절감: 정확한 데이터는 불필요한 비용 발생을 방지한다.</li>
</ul></li>
<li>예시
<ul>
<li>고객 주소 정확성
<ul>
<li>측정: 우편번호와 주소의 일치 여부</li>
<li>방법: 우편번호 데이터베이스와 비교</li>
<li>목표: 95% 이상의 주소가 정확해야 함</li>
</ul></li>
<li>제품 가격 정확성
<ul>
<li>측정: 시스템에 등록된 가격과 실제 판매 가격의 일치 여부</li>
<li>방법: POS 데이터와 제품 카탈로그 비교</li>
<li>목표: 99.9% 이상의 가격 정보가 정확해야 함</li>
</ul></li>
<li>재고 수량 정확성
<ul>
<li>측정: 시스템상 재고량과 실제 재고량의 일치 여부</li>
<li>방법: 정기적인 실사를 통한 비교</li>
<li>목표: 97% 이상의 재고 정보가 정확해야 함</li>
</ul></li>
<li>금융 거래 정확성
<ul>
<li>측정: 거래 기록의 정확성</li>
<li>방법: 더블 엔트리 회계 시스템을 통한 검증</li>
<li>목표: 100% 정확성 (모든 불일치는 조사 및 수정되어야 함)</li>
</ul></li>
<li>고객 연락처 정확성
<ul>
<li>측정: 이메일 주소와 전화번호의 유효성</li>
<li>방법: 이메일 발송 테스트, 전화번호 형식 검증</li>
<li>목표: 90% 이상의 연락처 정보가 유효해야 함</li>
</ul></li>
</ul></li>
<li>정확성 개선 전략
<ul>
<li>데이터 입력 시 자동 검증 시스템 구축</li>
<li>정기적인 데이터 클렌징 및 품질 검사 수행</li>
<li>데이터 소스의 신뢰성 평가 및 관리</li>
<li>직원 교육을 통한 데이터 입력 오류 최소화</li>
<li>데이터 품질 관리 도구 활용</li>
<li>데이터 정확성에 대한 책임자 지정</li>
<li>지속적인 모니터링 및 피드백 시스템 구축</li>
</ul></li>
</ul>
</section>
<section id="완전성-completeness" class="level4" data-number="1.1.2">
<h4 data-number="1.1.2" class="anchored" data-anchor-id="완전성-completeness"><span class="header-section-number">1.1.2</span> 완전성 (Completeness)</h4>
<ul>
<li>완전성은 필요한 모든 데이터가 존재하는 정도</li>
<li>즉, 데이터셋이 얼마나 빠짐없이 채워져 있는지, 그리고 필요한 모든 정보를 포함하고 있는지를 측정</li>
<li>측정 방법
<ul>
<li>널(Null) 값 또는 빈 값 검사
<ul>
<li>(채워진 필드 수 / 전체 필드 수) * 100</li>
</ul></li>
<li>필수 필드 존재 여부 확인
<ul>
<li>(모든 필수 필드가 채워진 레코드 수 / 전체 레코드 수) * 100</li>
</ul></li>
<li>데이터셋 완전성 검사
<ul>
<li>(실제 레코드 수 / 예상되는 총 레코드 수) * 100</li>
</ul></li>
<li>시계열 데이터 완전성 검사
<ul>
<li>(데이터가 있는 시간 단위 수 / 전체 시간 단위 수) * 100</li>
</ul></li>
</ul></li>
<li>중요성
<ul>
<li>정확한 분석: 완전한 데이터셋은 더 정확하고 신뢰할 수 있는 분석 결과 제공</li>
<li>의사결정 지원: 누락된 데이터 없이 전체 그림을 볼 수 있어 더 나은 의사결정 가능</li>
<li>프로세스 효율성: 필요한 모든 데이터가 있으면 업무 프로세스가 원활하게 진행</li>
<li>고객 만족: 완전한 고객 정보는 더 나은 서비스와 경험 제공 가능</li>
<li>규제 준수: 많은 산업에서 데이터의 완전성은 규제 요구사항의 일부</li>
</ul></li>
<li>구체적인 예시
<ul>
<li>고객 프로필 완전성
<ul>
<li>측정: 필수 고객 정보 필드의 완전성</li>
<li>방법: (모든 필수 필드가 채워진 고객 프로필 수 / 전체 고객 프로필 수) * 100</li>
<li>목표: 95% 이상의 고객 프로필이 모든 필수 정보를 포함해야 함</li>
<li>필수 필드 예: 이름, 연락처, 이메일, 주소</li>
</ul></li>
<li>주문 데이터 완전성
<ul>
<li>측정: 주문 관련 모든 필요 정보의 존재 여부</li>
<li>방법: (모든 필요 정보가 있는 주문 수 / 전체 주문 수) * 100</li>
<li>목표: 99% 이상의 주문이 모든 필요 정보를 포함해야 함</li>
<li>필요 정보: 주문 ID, 고객 ID, 주문 날짜, 제품 ID, 수량, 가격, 배송 주소</li>
</ul></li>
<li>재무 보고 데이터 완전성
<ul>
<li>측정: 월별 재무 보고서의 모든 필요 항목 존재 여부</li>
<li>방법: (모든 필요 항목이 보고된 월 수 / 전체 보고 월 수) * 100</li>
<li>목표: 100% (모든 월의 재무 보고서가 완전해야 함)</li>
<li>필요 항목: 매출, 비용, 순이익, 자산, 부채, 자본 등</li>
</ul></li>
<li>센서 데이터 완전성
<ul>
<li>측정: IoT 센서에서 수집된 데이터의 시간별 완전성</li>
<li>방법: (데이터가 수집된 시간 단위 수 / 24시간) * 100 (일일 기준)</li>
<li>목표: 99.9% 이상 (하루 중 대부분의 시간에 데이터가 수집되어야 함)</li>
</ul></li>
<li>제품 카탈로그 완전성
<ul>
<li>측정: 제품 정보의 완전성</li>
<li>방법: (모든 필요 정보가 있는 제품 수 / 전체 제품 수) * 100</li>
<li>목표: 98% 이상의 제품이 모든 필요 정보를 포함해야 함</li>
<li>필요 정보: 제품명, 설명, 가격, 카테고리, 이미지, 재고 상태 등</li>
</ul></li>
</ul></li>
<li>완전성 개선 전략
<ul>
<li>데이터 입력 시 필수 필드 설정 및 유효성 검사 구현</li>
<li>데이터 수집 프로세스 자동화</li>
<li>데이터 품질 모니터링 도구 사용</li>
<li>정기적인 데이터 감사 및 클렌징 작업 수행</li>
<li>사용자 교육 및 데이터 입력 가이드라인 제공</li>
<li>데이터 보완을 위한 외부 데이터 소스 활용</li>
<li>데이터 거버넌스 정책 수립 및 시행</li>
</ul></li>
</ul>
</section>
<section id="일관성-consistency" class="level4" data-number="1.1.3">
<h4 data-number="1.1.3" class="anchored" data-anchor-id="일관성-consistency"><span class="header-section-number">1.1.3</span> 일관성 (Consistency)</h4>
<ul>
<li>일관성은 데이터가 여러 위치, 시스템, 또는 표현 방식에서 서로 모순 없이 일치하는 정도</li>
<li>이는 데이터의 내부적 일관성(동일 데이터셋 내)과 외부적 일관성(여러 데이터셋 간)을 모두 포함</li>
<li>측정 방법
<ul>
<li>크로스 체크 (여러 테이블/시스템 간 데이터 비교)
<ul>
<li>(일치하는 데이터 항목 수 / 전체 비교 데이터 항목 수) * 100</li>
</ul></li>
<li>중복 데이터 검사
<ul>
<li>(고유한 데이터 항목 수 / 전체 데이터 항목 수) * 100</li>
</ul></li>
<li>데이터 형식의 일관성 검사
<ul>
<li>(표준 형식을 따르는 데이터 항목 수 / 전체 데이터 항목 수) * 100</li>
</ul></li>
<li>참조 무결성 검사
<ul>
<li>(유효한 참조를 가진 외래 키 수 / 전체 외래 키 수) * 100</li>
</ul></li>
</ul></li>
<li>중요성
<ul>
<li>데이터 신뢰성
<ul>
<li>일관된 데이터는 신뢰할 수 있는 정보 제공</li>
<li>여러 시스템이나 채널에서 일관된 정보를 제공함으로써 고객과 내부 사용자의 신뢰를 얻을 수 있다.</li>
</ul></li>
<li>효율적인 운영
<ul>
<li>일관된 데이터는 업무 프로세스의 효율성을 높이고, 데이터 불일치로 인한 추가 작업을 줄일 수 있다.<br>
</li>
</ul></li>
<li>의사결정 지원
<ul>
<li>모순 없는 데이터를 기반으로 한 일관된 의사결정 가능</li>
</ul></li>
<li>시스템 통합
<ul>
<li>여러 시스템 간 원활한 데이터 교환 및 통합 지원</li>
</ul></li>
<li>사용자 경험
<ul>
<li>일관된 데이터로 인한 사용자 혼란 방지</li>
</ul></li>
<li>정확한 보고 및 분석
<ul>
<li>여러 소스의 데이터가 일관될 때, 더 정확하고 신뢰할 수 있는 비즈니스 인텔리전스와 분석이 가능</li>
</ul></li>
<li>비용 절감
<ul>
<li>데이터 불일치로 인한 오류 수정 비용 감소</li>
</ul></li>
<li>규제 준수
<ul>
<li>많은 산업에서 데이터의 일관성은 규제 요구사항의 일부이다. 일관된 데이터 관리는 컴플라이언스를 지원.</li>
</ul></li>
<li>고객 경험 향상
<ul>
<li>고객이 모든 접점에서 일관된 정보를 받을 때, 더 나은 고객 경험을 제공</li>
</ul></li>
</ul></li>
<li>예시
<ul>
<li>고객 정보의 일관성
<ul>
<li>측정: CRM 시스템과 주문 시스템 간 고객 정보 일치 여부</li>
<li>방법: 두 시스템의 고객 데이터를 주기적으로 비교</li>
<li>목표: 95% 이상의 고객 정보가 두 시스템에서 일치해야 함</li>
</ul></li>
<li>제품 가격의 일관성
<ul>
<li>측정: 온라인 스토어와 POS 시스템 간 제품 가격 일치 여부</li>
<li>방법: 실시간 또는 일일 기준으로 두 시스템의 제품 가격 비교</li>
<li>목표: 99.9% 이상의 제품 가격이 모든 판매 채널에서 일치해야 함</li>
</ul></li>
<li>재무 데이터의 일관성
<ul>
<li>측정: 총계정원장과 보조원장 간 잔액 일치 여부</li>
<li>방법: 월말 결산 시 원장 간 잔액 비교</li>
<li>목표: 100% 일치 (모든 차이는 조정되고 설명되어야 함)</li>
</ul></li>
<li>주소 형식의 일관성
<ul>
<li>측정: 정의된 주소 형식 준수 여부</li>
<li>방법: 정규 표현식을 사용하여 주소 형식 검증</li>
<li>목표: 90% 이상의 주소가 표준 형식을 따라야 함</li>
</ul></li>
<li>제품 카테고리의 일관성
<ul>
<li>측정: 여러 시스템에서 동일한 제품에 대한 카테고리 분류 일치 여부</li>
<li>방법: 제품 마스터 데이터와 각 시스템의 카테고리 정보 비교</li>
<li>목표: 98% 이상의 제품이 모든 시스템에서 동일한 카테고리로 분류되어야 함</li>
</ul></li>
</ul></li>
<li>일관성 개선 전략
<ul>
<li>데이터 통합 솔루션 구현 (예: 마스터 데이터 관리 시스템)</li>
<li>데이터 동기화 메커니즘 개선</li>
<li>데이터 거버넌스 정책 수립 및 시행</li>
<li>데이터 입력 및 수정 프로세스 표준화</li>
<li>정기적인 데이터 감사 및 정화 작업 수행</li>
<li>시스템 간 실시간 데이터 교환 체계 구축</li>
<li>데이터 소유권 및 책임 명확화</li>
</ul></li>
</ul>
</section>
<section id="유효성-validity" class="level4" data-number="1.1.4">
<h4 data-number="1.1.4" class="anchored" data-anchor-id="유효성-validity"><span class="header-section-number">1.1.4</span> 유효성 (Validity)</h4>
<ul>
<li>유효성은 데이터가 정의된 비즈니스 규칙, 데이터 타입, 범위, 형식 등을 준수하는 정도</li>
<li>즉, 데이터가 논리적으로 타당하고 비즈니스 컨텍스트에서 의미 있는지를 측정하는 지표</li>
<li>중요성
<ul>
<li>데이터 무결성: 시스템의 전반적인 데이터 무결성 보장</li>
<li>오류 방지: 잘못된 데이터로 인한 비즈니스 프로세스 오류 예방</li>
<li>분석 신뢰성: 유효한 데이터를 기반으로 한 신뢰할 수 있는 분석 결과 도출</li>
<li>시스템 호환성: 다양한 시스템 간 데이터 교환 시 문제 방지</li>
</ul></li>
<li>측정 방법
<ul>
<li>데이터 타입 검사
<ul>
<li>(올바른 데이터 타입을 가진 필드 수 / 전체 필드 수) * 100</li>
</ul></li>
<li>값 범위 검사
<ul>
<li>(정의된 범위 내의 값을 가진 레코드 수 / 전체 레코드 수) * 100</li>
</ul></li>
<li>형식 검사
<ul>
<li>(올바른 형식을 가진 데이터 항목 수 / 전체 데이터 항목 수) * 100</li>
</ul></li>
<li>비즈니스 규칙 준수 검사
<ul>
<li>(비즈니스 규칙을 준수하는 레코드 수 / 전체 레코드 수) * 100</li>
</ul></li>
</ul></li>
<li>예시
<ul>
<li>이메일 주소 유효성
<ul>
<li>측정: 올바른 이메일 형식 준수 여부</li>
<li>방법: 정규 표현식을 사용하여 이메일 주소 형식 검증</li>
<li>예시 규칙: <sup>1</sup>+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}$</li>
<li>목표: 95% 이상의 이메일 주소가 올바른 형식을 가져야 함</li>
</ul></li>
<li>나이 데이터 유효성
<ul>
<li>측정: 나이 값의 논리적 범위 준수</li>
<li>방법: 0 &lt; 나이 &lt;= 120 범위 검사</li>
<li>목표: 100%의 나이 데이터가 유효한 범위 내에 있어야 함</li>
</ul></li>
<li>주문 데이터 유효성
<ul>
<li>측정: 주문 금액과 주문 항목 수량의 논리적 일관성</li>
<li>방법: 주문 총액 = Σ(항목 가격 * 수량) 검증</li>
<li>목표: 99.9% 이상의 주문 데이터가 이 규칙을 만족해야 함</li>
</ul></li>
<li>신용카드 번호 유효성
<ul>
<li>측정: Luhn 알고리즘을 사용한 신용카드 번호 유효성 검사</li>
<li>방법: Luhn 알고리즘 적용 후 유효성 확인</li>
<li>목표: 100%의 신용카드 번호가 Luhn 알고리즘을 통과해야 함</li>
</ul></li>
<li>날짜 데이터 유효성
<ul>
<li>측정: 날짜 형식 및 논리적 타당성 검사</li>
<li>방법: YYYY-MM-DD 형식 준수 및 존재하는 날짜인지 확인 (예: 2023-02-30은 유효하지 않음)</li>
<li>목표: 100%의 날짜 데이터가 올바른 형식과 유효한 날짜여야 함</li>
</ul></li>
</ul></li>
<li>유효성 개선 전략
<ul>
<li>데이터 입력 시점의 유효성 검사 구현</li>
<li>정기적인 데이터 클렌징 프로세스 수립</li>
<li>비즈니스 규칙 엔진 도입</li>
<li>데이터 품질 관리 도구 활용</li>
<li>사용자 교육 및 가이드라인 제공</li>
<li>데이터 모델링 및 스키마 설계 시 제약조건 적용</li>
</ul></li>
</ul>
</section>
<section id="적시성-timeliness" class="level4" data-number="1.1.5">
<h4 data-number="1.1.5" class="anchored" data-anchor-id="적시성-timeliness"><span class="header-section-number">1.1.5</span> 적시성 (Timeliness)</h4>
<ul>
<li>데이터가 필요한 시점에 이용 가능한 정도와 최신 상태인 정도를 나타냅
<ul>
<li>즉, 데이터가 현실 세계의 상태를 얼마나 잘 반영하고 있는지를 측정하는 지표</li>
</ul></li>
<li>중요성
<ul>
<li>의사결정: 최신 데이터를 기반으로 한 신속하고 정확한 의사결정 가능 중요성</li>
<li>운영 효율성: 실시간 또는 최신 데이터로 업무 프로세스 최적화 중요성</li>
<li>고객 만족: 최신 정보를 기반으로 한 서비스 제공으로 고객 경험 향상</li>
</ul></li>
<li>측정 방법
<ul>
<li>데이터 갱신 주기 확인
<ul>
<li>(정해진 주기 내 업데이트된 레코드 수 / 전체 레코드 수) * 100</li>
</ul></li>
<li>실시간 데이터와 저장된 데이터의 시간 차이 측정
<ul>
<li>평균 데이터 지연 시간 = Σ(현재 시간 - 데이터 최종 업데이트 시간) / 전체 레코드 수</li>
</ul></li>
<li>데이터 생성 시점과 사용 가능 시점의 차이 측정
<ul>
<li>평균 데이터 가용 지연 = Σ(데이터 사용 가능 시간 - 데이터 생성 시간) / 전체 데이터 수</li>
</ul></li>
</ul></li>
<li>예시
<ul>
<li>재고 관리 시스템
<ul>
<li>측정: 실제 재고량과 시스템상 재고량의 일치 비율</li>
<li>방법: (1시간 이내 업데이트된 재고 항목 수 / 전체 재고 항목 수) * 100</li>
<li>목표: 95% 이상의 재고 정보가 1시간 이내에 업데이트되어야 함</li>
</ul></li>
<li>금융 거래 시스템
<ul>
<li>측정: 거래 발생부터 시스템 반영까지의 평균 시간</li>
<li>방법: Σ(거래 반영 시간 - 거래 발생 시간) / 전체 거래 수</li>
<li>목표: 평균 지연 시간 5초 이내</li>
</ul></li>
<li>고객 정보 관리 시스템
<ul>
<li>측정: 고객 정보 변경사항의 반영 속도</li>
<li>방법: (24시간 이내 업데이트된 고객 정보 변경 건수 / 전체 고객 정보 변경 요청 건수) * 100</li>
<li>목표: 99% 이상의 고객 정보 변경사항이 24시간 이내에 반영되어야 함</li>
</ul></li>
<li>적시성 개선 전략
<ul>
<li>실시간 데이터 처리 시스템 구축</li>
<li>데이터 동기화 주기 최적화</li>
<li>데이터 파이프라인 효율성 향상</li>
<li>중요 데이터에 대한 우선순위 처리 체계 수립</li>
<li>데이터 갱신 알림 시스템 구축</li>
</ul></li>
</ul></li>
</ul>


</section>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>a-zA-Z0-9._%+-↩︎</p></li>
</ol>
</section></div> ]]></description>
  <category>Data Governance</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Governance/8.0nlp.html</guid>
  <pubDate>Mon, 19 Aug 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Data Governance Study - Glossary Usage Rules</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Governance/7-0.data_glossary_rules.html</link>
  <description><![CDATA[ 




<section id="data-standard-governance-contents-agreement" class="level2" data-number="1">

<section id="데이터-contents-agreement" class="level3" data-number="1.1">

<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 40%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>번호</th>
<th>도메인</th>
<th>질의내용</th>
<th>확정</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>수</td>
<td>1,2,3,4, … , 01, 02, 03 등 숫자형 금칙어 등록<br>- 숫자는 문자와 함께 씀<br>- 운전자1 (Driver1)</td>
<td>숫자 단일 사용은 금지</td>
</tr>
<tr class="even">
<td>2</td>
<td>수</td>
<td>갯수 -&gt; 개수</td>
<td>개수로 사용</td>
</tr>
<tr class="odd">
<td>3</td>
<td>금액</td>
<td>금, 비, 액, 가격, 가액(공금가액, 증가액, 차량가액) -&gt; 금액으로 통일<br>- 금액으로 사용하지 못하는 단어일 경우 복합어 사용</td>
<td>fee : 요금<br>price : 가격<br>cost : 비용<br>amount : 금액</td>
</tr>
<tr class="even">
<td>4</td>
<td>금액</td>
<td>금액을 나타내는 ‘료’ 단어 단일어 인정 여부<br>- 렌탈료-&gt;렌탈요금, 휴차료, 담보료</td>
<td>요금으로 사용하며, 관용단어 -&gt; 료 복합어 생성</td>
</tr>
<tr class="odd">
<td>5</td>
<td>명</td>
<td>’명’을 단일어로 사용 여부(성명, 명 모두 명으로 사용)</td>
<td>사물 : 명<br>사람 : 성명</td>
</tr>
<tr class="even">
<td>6</td>
<td>일자</td>
<td>일 -&gt; 일자로 사용(취득일, 종료일, 승인일, 발행일 -&gt; 취득일자, 종료일자) 하고 DD의 형태는 ’일’로 사용</td>
<td>’일자’로 사용</td>
</tr>
<tr class="odd">
<td>7</td>
<td>-</td>
<td>차대 -&gt; 차대번호 고유단어로 등록<br>- CARBODYNO(차대번호), CAR_BODY_NO로 사용 중</td>
<td>차대번호 복합어 생성</td>
</tr>
<tr class="even">
<td>8</td>
<td>-</td>
<td>상품(상품코드, 주문상품) -&gt; 제품<br>- 별도로 사용하면 상품 영문명(Goods), 제품(Product)<br>- 상품은 Good과 Product를 사용중<br>- 제품은 Item을 사용중<br>- 상품을 Commondity로 등록</td>
<td>상품 : Product<br>자산 : Asset<br>제품 : Goods<br>부품 : Components<br>소모품 : Consumption Goods</td>
</tr>
<tr class="odd">
<td>9</td>
<td>-</td>
<td>회사(실사용자회사명, 사용회사, 소속회사) -&gt; 업체<br>- 회사 영문명(Corporation) 업체(Company)</td>
<td>회사 : 사용<br>업체 : 사용하지 않고 ’비즈니스파트너’로 대체</td>
</tr>
<tr class="even">
<td>10</td>
<td>일자</td>
<td>월 -&gt; 월단가, 월렌탈료, 월리스료 등으로 단어 생성<br>- 월(Month)은 1월~12월을 표현하는 용도로만 사용</td>
<td>필요시 복합어 생성<br>ex) 월별렌탈금액 단어 생성</td>
</tr>
<tr class="odd">
<td>11</td>
<td>수</td>
<td>수 -&gt; 단일어 허용할지 여부(고객수, 직원수, 회전수)</td>
<td>단일어 사용하지 않고 복합어 생성</td>
</tr>
<tr class="even">
<td>12</td>
<td>수</td>
<td>건수(Count/CNT, 처리건수, 발생건수)와 개수(Count/CO, 반품갯수, 쿠폰갯수)로 분리해서 사용</td>
<td>건수는 CNT약어로 생성</td>
</tr>
<tr class="odd">
<td>13</td>
<td>명</td>
<td>이름(금칙어 등록), 성명 -&gt; 명으로 사용</td>
<td>사물 : 명<br>사람 : 성명</td>
</tr>
<tr class="even">
<td>14</td>
<td>내용</td>
<td>사항(특기사항, 특약사항, 참고사항) -&gt; 내용으로 사용</td>
<td>내용으로 사용하며 명시적으로 사항을 사용하는 경우 복합어 생성</td>
</tr>
<tr class="odd">
<td>15</td>
<td>번호</td>
<td>사업자번호(인증서 사업자번호) -&gt; 사업자등록번호 : 사업자번호가 사업자등록번호와 다른 의미이면 단어 생성</td>
<td>사업자등록번호로 사용</td>
</tr>
<tr class="even">
<td>16</td>
<td>번호</td>
<td>연락처 -&gt; 전화번호로 사용 (ASIS 컬럼은 대부분 TEL로 전화번호 내용임)<br>- 연락을 취할수 있는 모든 내용의 의미로 사용예정이면 등록</td>
<td>연락처 단어 생성(연락처 Pool에서 사용)<br>ASIS에서 연락처는 전화번호의 의미이므로 ASIS의 연락처 용어는 전화번호로 대체</td>
</tr>
<tr class="odd">
<td>17</td>
<td>번호</td>
<td>핸드폰번호(가장많음), 휴대전화번호, 휴대폰 -&gt; 휴대전화번호(표준어)로 통일</td>
<td>휴대전화번호로 사용</td>
</tr>
<tr class="even">
<td>18</td>
<td>-</td>
<td>대여 (대여종료일자, 대여지점, 월간대여료)-&gt; 랜탈</td>
<td>렌탈로 사용하며 대여는 금칙어</td>
</tr>
<tr class="odd">
<td>19</td>
<td>-</td>
<td>제작사(MAKERCODE, CONFIRMDATE)와 제조사(Maker) 차이</td>
<td>제작사 : 사용<br>제조사 : 금칙어</td>
</tr>
<tr class="even">
<td>20</td>
<td>율</td>
<td>백분율을 나타내는 ‘율’ 단어 단일어 인정 여부<br>- 감가율, 공채율, 대비율</td>
<td>복합어 생성(사전 참조)<br>단일어 불허</td>
</tr>
<tr class="odd">
<td>21</td>
<td>세</td>
<td>세금을 나타내는 ‘세’ 단어 단일어 인정 여부<br>- 과세, 교육세</td>
<td>복합어 생성(사전 참조)<br>단일어 불허</td>
</tr>
<tr class="even">
<td>22</td>
<td>-</td>
<td>구입(구입가격, 차량구입비, 구입일자) -&gt; 구매<br>- 구입가격, 구입일</td>
<td>구매<br>구입 : 금칙어</td>
</tr>
<tr class="odd">
<td>23</td>
<td>명</td>
<td>이름을 나타내는 ‘명’ 단어 단일어 인정 여부<br>- 파일명, 차량명</td>
<td>사물 : 명<br>사람 : 성명</td>
</tr>
<tr class="even">
<td>24</td>
<td>-</td>
<td>구입(구입가격, 차량구입비, 구입일자) -&gt; 구매<br>- 구입가격, 구입일</td>
<td>구매<br>구입 : 금칙어</td>
</tr>
<tr class="odd">
<td>25</td>
<td>-</td>
<td>제원(specification) (제원), 스팩(SPEC) (제품스팩, 제품스팩아이디) -&gt; 스펙</td>
<td>스펙<br>제원 : 금칙어</td>
</tr>
<tr class="even">
<td>26</td>
<td>-</td>
<td>제휴협력사 vs 협력사 vs 파트너</td>
<td>비즈니스파트너</td>
</tr>
<tr class="odd">
<td>27</td>
<td>-</td>
<td>제휴사 -&gt; ex) 대한항공</td>
<td>-</td>
</tr>
<tr class="even">
<td>28</td>
<td>-</td>
<td>협력사 -&gt; 정비업체</td>
<td>-</td>
</tr>
<tr class="odd">
<td>29</td>
<td>-</td>
<td>이해당사자 vs 이해관계자</td>
<td>이해관계자</td>
</tr>
<tr class="even">
<td>30</td>
<td>량</td>
<td>양을 나타내는 의미로 ‘량’ 단어 단일어 인정 여부<br>- 월평균소요량, 연료량 등</td>
<td>’량’으로 복합어 생성(사전 참조)<br>단일어 불허</td>
</tr>
<tr class="odd">
<td>31</td>
<td>값</td>
<td>값을 나타내는 의미로 ‘값’ 단어 단일어 인정 여부<br>- 변경값, 관리키값, 상태값 등</td>
<td>복합어 생성(사전 참조)<br>단일어 불허</td>
</tr>
<tr class="even">
<td>32</td>
<td>번호</td>
<td>번호 그룹 도메인에 속하는 용어들의 데이터 타입 및 길이가 상이하므로, 용어별 도메인 별도 생성</td>
<td>번호용어 별 도메인 생성</td>
</tr>
<tr class="odd">
<td>33</td>
<td>-</td>
<td>매각제품 별 단가, 회차 별 산출금액에서 ‘별’ 단어 허용 여부</td>
<td>별, 및 : 금칙어<br>필요시 복합어 생성</td>
</tr>
<tr class="even">
<td>34</td>
<td>명</td>
<td>‘처’ (유지보수 처, 송금 처) 단어 허용 여부<br>- 처의 의미</td>
<td>처 : 금칙어<br>-&gt; 대상 등으로 사용</td>
</tr>
<tr class="odd">
<td>35</td>
<td>번호</td>
<td>순번과 일련번호 중 일련번호 사용 (순번 -&gt; 금칙어)<br>- 일련번호를 Serial Number로 사용하고 순번을 단순한 순차적인 번호(Sequence)로 사용할지 에 대한 의사결정 필요</td>
<td>순번 : 금칙어<br>일련번호 : 순차적인 번호 (KEY)<br>고유번호(시리얼번호) : 제품고유번호</td>
</tr>
</tbody>
</table>


</section>
</section>

 ]]></description>
  <category>Data Governance</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Governance/7-0.data_glossary_rules.html</guid>
  <pubDate>Sun, 18 Aug 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Data Governance Study - Data Code Registration Process</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Governance/6-2.data_code_registration.html</link>
  <description><![CDATA[ 




<section id="data-standard-governance-data-code-review-process" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="data-standard-governance-data-code-review-process"><span class="header-section-number">1</span> Data Standard Governance &gt; Data Code Review Process</h2>
<ul>
<li>애플리케이션 파트(개발)가 코드 정보 도출하여 신규 및 변경 신청하고 표준 담당자가 승인한다.</li>
</ul>
<section id="데이터-모델-표준-코드-등록-절차" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="데이터-모델-표준-코드-등록-절차"><span class="header-section-number">1.1</span> 데이터 모델 표준 코드 등록 절차</h3>
<ul>
<li>애플리케이션 파트(개발)가 코드 정보 도출하여 신규 및 변경 신청하고 표준 담당자가 승인한다.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="kk3225.netlify.app/images/governance/data_code_registration.PNG" class="img-fluid figure-img"></p>
<figcaption>데이터 모델 표준 코드 등록 절차</figcaption>
</figure>
</div>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>순번</th>
<th>TASK</th>
<th>설명</th>
<th>담당</th>
<th>비고</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>표준 코드 요건 발생</td>
<td>애플리케이션 개발 중 신규 코드 요건 발생</td>
<td>개발자</td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td>표준 코드 도출</td>
<td>신규 등록이 필요한 코드 명, 값 등을 도출</td>
<td>개발자</td>
<td>EXCEL</td>
</tr>
<tr class="odd">
<td>3</td>
<td>코드 검색</td>
<td>표준 코드 사전에서 해당 코드 검색</td>
<td>개발자</td>
<td>코드 사전</td>
</tr>
<tr class="even">
<td>4</td>
<td>표준 코드 신청</td>
<td>표준 코드 사전에 도출된 코드가 없을 경우 표준 담당자에게 신청</td>
<td>개발자</td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td>코드 신청 접수</td>
<td>표준 담당자는 개발자가 신청한 코드 표준 등록 요청 접수</td>
<td>표준담당</td>
<td></td>
</tr>
<tr class="even">
<td>6</td>
<td>타당성 검토</td>
<td>기존 코드 사전을 기준으로 신규 코드 타당성 검토</td>
<td>표준담당</td>
<td></td>
</tr>
<tr class="odd">
<td>7</td>
<td>표준 코드 등록</td>
<td>검토를 마친 신청 표준 코드를 표준 코드 사전에 등록 후 개발자에게 통보</td>
<td>표준담당</td>
<td>EXCEL</td>
</tr>
<tr class="even">
<td>8</td>
<td>표준 코드 반영</td>
<td>등록된 코드 반영</td>
<td>개발자</td>
<td></td>
</tr>
</tbody>
</table>


</section>
</section>

 ]]></description>
  <category>Data Governance</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Governance/6-2.data_code_registration.html</guid>
  <pubDate>Sat, 17 Aug 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Data Governance Study - Data Glossary Review Process</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Governance/6-1.data_review_process.html</link>
  <description><![CDATA[ 




<section id="data-standard-governance-data-glossary-review-process" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Data Standard Governance &gt; Data Glossary Review Process</h1>
<p>데이터 모델 수정 발생시 표준담당자가 표준 점검 후 신규 용어를 데이터 모델 담당자에게 전달하고 모델에 반영한다.</p>
<section id="데이터-모델-표준-용어-점검-절차" class="level3" data-number="1.0.1">
<h3 data-number="1.0.1" class="anchored" data-anchor-id="데이터-모델-표준-용어-점검-절차"><span class="header-section-number">1.0.1</span> 데이터 모델 표준 용어 점검 절차</h3>
<ul>
<li>데이터 모델 수정 발생시 표준담당자가 표준 점검 후 신규 용어를 데이터 모델 담당자에게 전달하고 모델에 반영한다.</li>
<li>표준담당자가 회사 표준담당자가 아닐 경우 표준단어/표준용어에 등록 시 회사 담당자 확인이 필요함</li>
<li>메타시스템 도입 전까지 회사 표준 담당자가 엑셀로 관리함</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="kk3225.netlify.app/images/governance/glossary_review_process.PNG" class="img-fluid figure-img"></p>
<figcaption>데이터 모델 표준 용어 점검 절차</figcaption>
</figure>
</div>
<ul>
<li>데이터 모델의 표준 용어 점검 절차를 TASK 별 상세 설명
<ul>
<li>모델 담당자와 표준 담당자 간의 명확한 역할 구분</li>
<li>단계별 검토 및 피드백 프로세스</li>
<li>비표준 용어 발견 시 신규 용어 생성 및 확인 절차</li>
<li>최종적으로 모델에 표준 용어 반영</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>순번</th>
<th>TASK</th>
<th>설명</th>
<th>담당</th>
<th>비고</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>데이터 모델 마트 적재</td>
<td>데이터 모델 담당자는 설계한 데이터 모델을 회사 데이터 마트에 적재하여 공유함</td>
<td>모델담당</td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td>데이터 표준 준수 여부 점검 요청</td>
<td>신규 또는 변경된 데이터 모델에 대하여 표준 담당자에게 표준 준수 여부 점검을 요청함</td>
<td>모델담당</td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td>표준 준수 점검 신청 접수</td>
<td>표준 담당자는 데이터 모델 담당자의 데이터 모델 표준 준수 여부 요청을 접수함</td>
<td>표준담당</td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td>데이터 모델 마트 접속</td>
<td>데이터 모델 마트에 접속하여 모델의 속성명 정보를 내려받아 점검 대상을 추출함</td>
<td>표준담당</td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td>용어 및 단어 표준 준수 여부 점검</td>
<td>점검 대상을 표준 단어 및 용어 기준으로 표준 준수 여부를 점검함</td>
<td>표준담당</td>
<td></td>
</tr>
<tr class="even">
<td>6</td>
<td>비표준 용어 발생 여부 확인</td>
<td>추출한 데이터 모델의 용어 중 비표준 용어 발생 여부를 확인함</td>
<td>표준담당</td>
<td></td>
</tr>
<tr class="odd">
<td>7</td>
<td>신규 단어/용어 생성 및 모델 담당자 전달</td>
<td>비표준 용어에 대한 용어 및 단어 생성 후 모델러에게 전달</td>
<td>표준담당</td>
<td>EXCEL</td>
</tr>
<tr class="even">
<td>8</td>
<td>신규 용어 확인</td>
<td>표준 담당자에게 전달받은 신규 용어가 적정한지 확인</td>
<td>모델담당</td>
<td></td>
</tr>
<tr class="odd">
<td>9</td>
<td>데이터 표준 점검 확인 통보</td>
<td>데이터 모델에 비표준 용어가 없을 경우 점검 확인을 데이터 모델 담당자에게 통보함</td>
<td>표준담당</td>
<td></td>
</tr>
<tr class="even">
<td>10</td>
<td>표준 점검 완료</td>
<td>데이터 모델 담당자는 신규 용어를 데이터 모델에 반영함</td>
<td>모델담당</td>
<td></td>
</tr>
</tbody>
</table></li>
</ul>


</section>
</section>

 ]]></description>
  <category>Data Governance</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Governance/6-1.data_review_process.html</guid>
  <pubDate>Fri, 16 Aug 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Data Governance Study - Data Registration Process</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Governance/6-0.data_registration_process.html</link>
  <description><![CDATA[ 




<section id="data-standard-governance-data-registration-process" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Data Standard Governance &gt; Data Registration Process</h1>
<section id="표준-단어-용어-및-도메인-신청-절차" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="표준-단어-용어-및-도메인-신청-절차"><span class="header-section-number">1.1</span> 표준 단어, 용어 및 도메인 신청 절차</h2>
<ul>
<li>DB 스키마 (물리적 데이터 모델)에 포함된 단어들만 신청 가능하도록 한다.</li>
<li>데이터 모델 담당자가 단어(분류어일 경우 도메인 포함) 및 용어와 도메인을 신청하고 표준 담당자가 승인한다.</li>
<li>표준담당자가 회사 표준담당자가 아닐 경우 표준단어/표준용어에 등록 시 회사 담당자 확인이 필요함</li>
<li>메타시스템 도입 전까지 회사 렌터카 표준 담당자가 엑셀로 관리함</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="kk3225.netlify.app/images/governance/data_registration_process.PNG" class="img-fluid figure-img"></p>
<figcaption>단어 신청 절차 순서도</figcaption>
</figure>
</div>
<ol type="1">
<li>신청 단계 (데이터 모델 담당자):
<ul>
<li>새로운 단어, 용어, 도메인의 필요성 확인</li>
<li>기존 표준 목록 검토 (중복 여부 확인)</li>
<li>신청 양식 작성
<ul>
<li>단어의 경우: 단어명, 정의, 영문명, 약어 등</li>
<li>분류어일 경우: 위 내용 + 도메인 정보 (데이터 타입, 길이 등)</li>
<li>용어의 경우: 용어명, 정의, 구성 단어, 도메인 등</li>
</ul></li>
<li>신청 시스템이나 지정된 채널을 통해 제출</li>
</ul></li>
<li>검토 단계 (표준 담당자):
<ul>
<li>신청 내용의 완전성 확인</li>
<li>기존 표준과의 일관성 검토</li>
<li>명명 규칙 준수 여부 확인</li>
<li>정의의 명확성과 적절성 검토</li>
<li>도메인 정보의 적절성 확인 (해당되는 경우)</li>
</ul></li>
<li>피드백 및 수정 단계:
<ul>
<li>필요시 데이터 모델 담당자에게 추가 정보 요청 또는 수정 제안</li>
<li>데이터 모델 담당자는 요청받은 사항에 대해 보완하여 재제출</li>
</ul></li>
<li>승인 단계 (표준 담당자):
<ul>
<li>최종 검토 후 승인 결정</li>
<li>승인된 내용을 표준 사전에 등록</li>
<li>필요시 관련 시스템 업데이트 (예: 데이터 모델링 도구, 메타데이터 저장소 등)</li>
</ul></li>
<li>결과 통보:
<ul>
<li>데이터 모델 담당자에게 승인 결과 통보</li>
<li>승인된 경우 적용 방법 및 시기 안내</li>
<li>반려된 경우 사유 설명 및 대안 제시</li>
</ul></li>
<li>적용 및 모니터링:
<ul>
<li>데이터 모델 담당자는 승인된 표준을 모델에 적용</li>
<li>표준 담당자는 적용 현황을 모니터링하고 필요시 지원 제공</li>
</ul></li>
<li>피드백 및 개선:
<ul>
<li>사용 과정에서 발생하는 이슈나 개선사항 수집</li>
<li>필요시 표준 개정 절차 진행</li>
</ul></li>
</ol>
<section id="소프트웨어-개발-및-관리-프로세스" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="소프트웨어-개발-및-관리-프로세스"><span class="header-section-number">1.1.1</span> 소프트웨어 개발 및 관리 프로세스</h3>
<p>개발 과정의 유연성과 표준화 사이의 균형을 잡는 것은 중요하다.</p>
<ul>
<li>개발 단계 구분:
<ol type="1">
<li>PoC / 프로토타입 단계
<ul>
<li>개발자들에게 최대한의 자유도 부여</li>
<li>임시 명명 규칙 사용 (예: tmp_, poc_, dev_ 접두어)</li>
<li>표준화 절차 적용하지 않음</li>
</ul></li>
<li>알파 / 베타 단계
<ul>
<li>느슨한 명명 규칙 적용</li>
<li>주요 변수, 속성에 대해서만 표준화 검토</li>
<li>간소화된 승인 프로세스 사용</li>
</ul></li>
<li>프로덕션 준비 단계
<ul>
<li>엄격한 표준화 적용</li>
<li>모든 주요 변수, 속성, 코드에 대한 표준화 검토</li>
<li>정식 승인 프로세스 적용</li>
</ul></li>
</ol></li>
<li>명명 규칙 계층화
<ol type="1">
<li>개인 / 팀 레벨
<ul>
<li>개발자 또는 팀 내에서 사용하는 임시 명명 규칙</li>
<li>문서화는 하되, 공식 승인 불필요</li>
</ul></li>
<li>프로젝트 레벨
<ul>
<li>프로젝트 내에서 합의된 명명 규칙</li>
<li>프로젝트 매니저 또는 기술 리더의 승인</li>
</ul></li>
<li>부서 / 도메인 레벨
<ul>
<li>특정 비즈니스 도메인이나 부서에서 사용하는 표준</li>
<li>도메인 전문가의 검토 필요</li>
</ul></li>
<li>전사 레벨
<ul>
<li>조직 전체에서 사용되는 공식 표준</li>
<li>데이터 거버넌스 위원회의 승인 필요</li>
</ul></li>
</ol></li>
<li>자동화 도구 활용
<ul>
<li>코드 분석 도구를 사용하여 명명 규칙 준수 여부 자동 검사</li>
<li>CI/CD 파이프라인에 표준화 검사 단계 추가</li>
<li>데이터 모델링 도구와 연동하여 표준 용어 자동 적용</li>
</ul></li>
<li>점진적 표준화
<ul>
<li>개발 초기에는 핵심 개념에 대해서만 표준화 적용</li>
<li>프로젝트 진행에 따라 점진적으로 표준화 범위 확대</li>
<li>리팩토링 과정에서 비표준 명칭을 표준화된 명칭으로 대체</li>
</ul></li>
<li>예외 관리 프로세스
<ul>
<li>표준을 적용하기 어려운 특수 상황에 대한 예외 처리 절차 마련</li>
<li>예외 사유 문서화 및 승인 프로세스 간소화</li>
</ul></li>
<li>교육 및 가이드라인
<ul>
<li>개발자들에게 표준화의 중요성과 이점에 대한 교육 제공</li>
<li>쉽게 참조할 수 있는 명명 규칙 가이드라인 제공</li>
<li>자주 사용되는 표준 용어 목록 공유</li>
</ul></li>
<li>정기적인 리뷰 및 정리
<ul>
<li>주기적으로 사용 중인 변수명, 코드명 등을 검토</li>
<li>프로젝트 마일스톤마다 표준화 작업 수행</li>
</ul></li>
</ul>
</section>
<section id="표준-단어-용어-및-도메인-신청-절차-task-별-상세-설명" class="level3" data-number="1.1.2">
<h3 data-number="1.1.2" class="anchored" data-anchor-id="표준-단어-용어-및-도메인-신청-절차-task-별-상세-설명"><span class="header-section-number">1.1.2</span> 표준 단어, 용어 및 도메인 신청 절차 TASK 별 상세 설명</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 4%">
<col style="width: 17%">
<col style="width: 65%">
<col style="width: 7%">
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th>순번</th>
<th>TASK</th>
<th>설명</th>
<th>담당</th>
<th>비고</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>데이터 모델 신규 용어 발생</td>
<td>데이터 모델 담당자가 속성 추가 등으로 신규 용어를 추가요건 발생</td>
<td>모델담당</td>
<td></td>
</tr>
<tr class="even">
<td>2</td>
<td>표준 용어 검색</td>
<td>데이터 모델 담당자가 추가한 속성에 해당하는 용어를 데이터 사전에서 검색</td>
<td>모델담당</td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td>표준 도메인 검색</td>
<td>신청하는 용어의 도메인이 존재하는지 데이터 사전에서 검색</td>
<td>모델담당</td>
<td></td>
</tr>
<tr class="even">
<td>4</td>
<td>표준 단어 검색</td>
<td>데이터 모델 담당자는 표준데이터 사전에서 신규 속성 구성 단어를 검색 함</td>
<td>모델담당</td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td>표준 단어 신청</td>
<td>표준데이터 사전에 구성 단어가 없을 경우 DA는 표준담당자에게 단어신청 함</td>
<td>모델담당</td>
<td></td>
</tr>
<tr class="even">
<td>6</td>
<td>단어 신청 접수</td>
<td>표준담당자는 신규 단어 신청을 접수 함</td>
<td>표준담당</td>
<td>EXCEL</td>
</tr>
<tr class="odd">
<td>7</td>
<td>타당성 검토</td>
<td>기존 표준단어 및 지침을 참고로 신규 신청 단어의 표준 등록 가능 여부를 판단하고 결과를 데이터 모델 담당자에 통보 함</td>
<td>표준담당</td>
<td></td>
</tr>
<tr class="even">
<td>8</td>
<td>표준 단어 등록</td>
<td>신규 신청 단어가 표준 단어로 적정할 경우 표준담당자는 표준 사전에 등록 함</td>
<td>표준담당</td>
<td></td>
</tr>
<tr class="odd">
<td>9</td>
<td>표준 용어/도메인 신청</td>
<td>신규 속성 용어/도메인이 없을 경우 데이터 모델 담당자는 표준담당자에게 용어신청 함</td>
<td>모델담당</td>
<td></td>
</tr>
<tr class="even">
<td>10</td>
<td>타당성 검토</td>
<td>신청 된 용어/도메인이 표준 지침에 맞게 구성 되었는지 검토 후 표준 등록 여부 DA 통보</td>
<td>표준담당</td>
<td></td>
</tr>
<tr class="odd">
<td>11</td>
<td>표준 용어/도메인 등록</td>
<td>신규 신청 용어/도메인를 표준 사전에 등록</td>
<td>표준담당</td>
<td>EXCEL</td>
</tr>
<tr class="even">
<td>12</td>
<td>데이터 모델 반영</td>
<td>변경 된 표준 용어 및 도메인을 데이터 모델에 반영</td>
<td>모델담당</td>
<td></td>
</tr>
</tbody>
</table>


</section>
</section>
</section>

 ]]></description>
  <category>Data Governance</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Governance/6-0.data_registration_process.html</guid>
  <pubDate>Thu, 15 Aug 2024 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Data Governance Study - Data Standard Code</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Governance/5-4.data_code.html</link>
  <description><![CDATA[ 




<section id="data-standard-governance-data-standard-code" class="level1" data-number="1">

<section id="데이터-표준-코드-사전이란" class="level2" data-number="1.1">

<ul>
<li>데이터 표준 코드는 특정 개념이나 항목을 나타내기 위해 일관되게 사용되는 약속된 값의 집합이다.
<ul>
<li>즉, 코드란 활용하고자 하는 데이터를 약어 혹은 기호로 함축하여 사용하는 데이터를 말한다.</li>
</ul></li>
<li>도메인의 한 유형으로서, 속성(컬럼)에 허용된 데이터 값을 제한된 범위 내에서 구체적으로 열거하여 정의한 것을 지칭한다</li>
<li>이 데이터 값을 코드값 또는 코드 유효값이라 하며 각각의 코드값에는 의미를 부여한다. 이 의미를 ‘코드값명’ 또는 ’코드유효값정의’라 한다</li>
<li>예시
<ul>
<li>성별 코드: M (남성), F (여성)</li>
<li>은행 코드: 004 (국민은행), 020 (우리은행)</li>
<li>국가 코드: KR (대한민국), US (미국)
<ul>
<li>코드명은 “국가코드”이다.</li>
<li>코드값(코드 유효값)은 ISO 3166-1 alpha-2 표준을 따르는 2자리 국가 코드이다.</li>
<li>코드값 명은 해당 국가의 한글 명칭이다.</li>
<li>코드 유효값 정의(설명)는 모든 코드가 ISO 3166-1 alpha-2 기준을 따르며, 영문 대문자 2자리로 구성됨을 명시한다..</li>
</ul></li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 17%">
<col style="width: 23%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>코드명</th>
<th>코드값</th>
<th>코드값 명</th>
<th>코드 유효값 정의</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>국가코드</td>
<td>KR</td>
<td>대한민국</td>
<td>ISO 3166-1 alpha-2 기준, 영문 대문자 2자리</td>
</tr>
<tr class="even">
<td>국가코드</td>
<td>US</td>
<td>미국</td>
<td>ISO 3166-1 alpha-2 기준, 영문 대문자 2자리</td>
</tr>
<tr class="odd">
<td>국가코드</td>
<td>JP</td>
<td>일본</td>
<td>ISO 3166-1 alpha-2 기준, 영문 대문자 2자리</td>
</tr>
<tr class="even">
<td>국가코드</td>
<td>CN</td>
<td>중국</td>
<td>ISO 3166-1 alpha-2 기준, 영문 대문자 2자리</td>
</tr>
<tr class="odd">
<td>국가코드</td>
<td>GB</td>
<td>영국</td>
<td>ISO 3166-1 alpha-2 기준, 영문 대문자 2자리</td>
</tr>
<tr class="even">
<td>국가코드</td>
<td>DE</td>
<td>독일</td>
<td>ISO 3166-1 alpha-2 기준, 영문 대문자 2자리</td>
</tr>
<tr class="odd">
<td>국가코드</td>
<td>FR</td>
<td>프랑스</td>
<td>ISO 3166-1 alpha-2 기준, 영문 대문자 2자리</td>
</tr>
</tbody>
</table></li>
</ul>
<section id="목적" class="level3" data-number="1.1.1">

<ul>
<li>데이터의 일관성 유지</li>
<li>시스템 간 데이터 교환 용이</li>
<li>데이터 해석의 명확성 제공
<ul>
<li>전사적으로 표준코드를 사용하도록 함으로써 업무영역간 운영데이터의 불일치를 방지하고 데이터의 정합성을 향상 시킨다.</li>
</ul></li>
<li>데이터 입력 오류 감소</li>
</ul>
</section>
<section id="특징" class="level3" data-number="1.1.2">

<ul>
<li>고유성: 각 코드는 유일한 의미를 가짐
<ul>
<li>코드의 중복방지(유사한 코드 검토 포함) 통해 효율적 운영이 가능해야 한다</li>
</ul></li>
<li>간결성: 일반적으로 짧고 간단한 형태</li>
<li>체계성: 논리적인 구조를 가짐</li>
<li>확장성: 새로운 항목 추가가 가능한 구조</li>
</ul>
</section>
<section id="구성-요소" class="level3" data-number="1.1.3">

<ul>
<li>코드 값: 실제 사용되는 코드</li>
<li>코드 명: 코드가 나타내는 항목의 이름</li>
<li>설명: 코드의 의미나 사용 목적</li>
<li>유효 기간: 코드의 사용 가능 기간</li>
</ul>
</section>
<section id="관리-방법" class="level3" data-number="1.1.4">

<ul>
<li>코드 관리 시스템 구축</li>
<li>정기적인 검토 및 업데이트</li>
<li>코드 변경 이력 관리</li>
</ul>
</section>
<section id="주의사항" class="level3" data-number="1.1.5">

<ul>
<li>업계 표준이나 국제 표준 고려</li>
<li>코드의 의미가 시간이 지나도 변하지 않도록 설계</li>
<li>코드 체계의 일관성 유지</li>
</ul>
</section>
<section id="코드-표준화-대상-및-원칙" class="level3" data-number="1.1.6">

<ul>
<li>표준코드 작성 시 의미를 충분히 파악할 수 있도록 작성을 하며 구성은 표준용어 작성 기준 및 관리원칙을 따른다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 72%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th>순번</th>
<th>코드 표준화 대상 및 관리 원칙</th>
<th>비고</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>• 코드 정보가 저장되며 코드 테이블에 그 내용이 존재하는 경우</td>
<td>표준화 대상</td>
</tr>
<tr class="even">
<td>2</td>
<td>• 애플리케이션 내부에 코드의 실제 내용이 존재하는 경우</td>
<td>표준화 대상</td>
</tr>
<tr class="odd">
<td>3</td>
<td>• 사용 가능한 데이터의 종류가 2개 이상인 경우</td>
<td>표준화 대상</td>
</tr>
<tr class="even">
<td>4</td>
<td>• Yes or No 값 외에 미확정 값(Null)을 가질 수 있는 경우</td>
<td>표준화 대상</td>
</tr>
<tr class="odd">
<td>5</td>
<td>• 현재는 Yes or No 처럼 Boolean값을 갖지만 추후 그 이외의 데이터가 추가 될 가능성이 있는 경우</td>
<td>표준화 대상</td>
</tr>
<tr class="even">
<td>6</td>
<td>• Yes or No 처럼 Boolean 값만을 데이터로 가질 경우 ‘Y’/’N’으로 통일 함</td>
<td>관리원칙</td>
</tr>
<tr class="odd">
<td>7</td>
<td>• 표준코드도메인은 관용적으로 사용하는 용어를 우선적으로 사용한다</td>
<td>관리원칙</td>
</tr>
<tr class="even">
<td>8</td>
<td>• 표준코드를 구성할 때에는 가독성을 높이고, 의미를 명확히 전달하기 위해 수식어를 사용하여 구성하도록 한다.</td>
<td>관리원칙</td>
</tr>
<tr class="odd">
<td>9</td>
<td>• 단일 코드는 하나의 공통 엔티티로 관리한다.</td>
<td>관리원칙</td>
</tr>
<tr class="even">
<td>10</td>
<td>• 계층코드는 내용을 분석하여 단일코드 형태로 변경 조정 할 수 있다.</td>
<td>관리원칙</td>
</tr>
<tr class="odd">
<td>11</td>
<td>• 목록성 코드의 인스턴스 값은 각각 별도의 엔티티로 관리하며 공통코드 엔티티에서는 해당 코드값을 관리하는 테이블 정보를 관리한다.</td>
<td>관리원칙</td>
</tr>
</tbody>
</table>
</section>
<section id="표준-코드-관리" class="level3" data-number="1.1.7">

<ul>
<li>표준코드는 신규 모델링 시 데이터 모델 관리자 또는 응용팀에서 도출 신청 후 데이터 표준 담당자가 최종 관리한다. 죄송합니다. 제가 이해를 돕기 위해 추가 설명을 드리겠습니다. 귀하께서 언급하신 내용은 코드 관리 프로세스의 중요한 부분을 강조하고 있습니다. 이를 반영하여 테이블을 수정해 보겠습니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 62%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th>순번</th>
<th>담당</th>
<th>코드 표준 관리 담당 별 역할</th>
<th>비고</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>응용팀</td>
<td>• 기능 정의시 데이터 항목에 코드가 필요한 경우 모델러와 협의<br>• 목록성 코드에 대한 요건 제시<br>• 각 업무영역별로 생성된 목록성 코드에 대한 코드값 관리</td>
<td>운영시 코드 신청은 업무담당자(현업)가 수행함<br>현업: 코드 신청, 활용</td>
</tr>
<tr class="even">
<td>2</td>
<td>데이터 모델<br>관리자</td>
<td>• 단일코드, 계층코드 등 공통코드를 관리하기 위한 테이블 설계<br>• 업무영역별 목록성 코드 테이블 설계</td>
<td></td>
</tr>
<tr class="odd">
<td>3</td>
<td>표준담당자</td>
<td>• 단일코드/계층코드 신청을 위한 템플릿 제공<br>• 코드명에 대한 표준 준수 검증<br>• 코드 취합/조정 및 공통코드 확정<br>• 코드 중복 조정 작업 수행(인스턴스명 간 유사성 검증)<br>• 데이터 타입 검증(코드 도메인화)<br>• AS-IS 코드와 매핑 정보 관리<br>• 코드 등록, 공통 코드 및 코드 도메인 관리(메타시스템 or Excel)<br>• 신규 코드 생성 및 AS-IS 코드의 코드 값에 대한 재정비 수행<br>• 코드에 대한 Ownership 관리 및 승인</td>
<td>표준담당자: 코드 등록 및 관리</td>
</tr>
</tbody>
</table>
<ul>
<li>응용팀(현업)은 업무 수행 중 필요한 코드를 식별하고 신청
<ul>
<li>응용팀(현업)의 비고 항목에 “현업: 코드 신청, 활용”은 실제 업무를 수행하는 현업 담당자가 코드를 신청하고 사용한다</li>
</ul></li>
<li>표준담당자는 이 신청을 검토하고, 적절한 경우 코드를 등록하며, 전체적인 코드 체계를 관리한다.
<ul>
<li>표준담당자의 비고 항목에 “표준담당자: 코드 등록 및 관리”는 표준담당자가 신청된 코드를 검토하고, 실제로 시스템에 등록하며, 지속적으로 관리한다는 점을 명확히 한다.</li>
</ul></li>
</ul>
</section>
<section id="표준-코드-유형" class="level3" data-number="1.1.8">

<ul>
<li>코드의 구성에 따른 유형으로는 단일, 계층, 목록, 복합코드가 있으며, 내용은 다음과 같다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>유형</th>
<th>설명</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>단일코드(S)</td>
<td>• [코드값] + [코드내용]의 형태를 갖추는 가장 일반적인 형태의 코드로서 한 개의 코드로 Key가 구성됨<br>• 단일코드의 코드값은 시스템에 등록/관리하며, 등록된 단일코드(코드명, 코드값, 코드값 한글정의)는 프로젝트 내 공통코드 테이블의 형태로 만들어져 전사공통으로 활용됨</td>
<td></td>
</tr>
<tr class="even">
<td>계층코드(C)</td>
<td>• 하나 이상의 코드를 상속받거나 계층 구조를 통해 생성되어진 코드로 Key 가 구성된 경우<br>• 대분류 / 중분류 / 소분류 와 같은 분류체계를 가짐</td>
<td></td>
</tr>
<tr class="odd">
<td>목록코드(L)</td>
<td>• 목록성코드는 코드명, 코드값, 코드한글정의 외에 부가적인 정보를 관리해야 하는 코드를 의미하며, 해당 업무팀에서 테이블의 형태로 관리한다</td>
<td></td>
</tr>
<tr class="even">
<td>복합코드(M)</td>
<td>• 두개이상의 코드도메인을 하나의 코드도메인에서 활용하기 위하여 구성.<br>• 복합코드는 단일코드의 코드도메인을 관리함.</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>각 코드 유형(단일코드, 계층코드, 목록코드, 복합코드)의 특성과 용도를 명확히 구분하고 있다.</li>
<li>예시
<ul>
<li>단일코드(S)
<ul>
<li>단일코드(S) 유형: 각 코드가 하나의 고유한 의미를 가진다.</li>
<li>코드값(고객 구분 코드)은 숫자로 구성되어 있으며, 일반적으로 2자리 숫자를 사용한다.</li>
<li>코드명(고객 구분 명)은 해당 코드의 의미를 명확하게 설명한다.</li>
<li>사용 조건
<ul>
<li>간단하고 평면적인 분류가 필요할 때</li>
<li>코드 값과 의미가 1:1로 대응될 때</li>
<li>코드의 수가 제한적이고 변경이 적을 때</li>
</ul></li>
<li>예시: 고객 구분 코드, 성별코드, 결혼여부코드, 직급코드</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th>고객 구분 코드</th>
<th>고객 구분 명</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>개인</td>
</tr>
<tr class="even">
<td>02</td>
<td>법인</td>
</tr>
<tr class="odd">
<td>03</td>
<td>개인사업자</td>
</tr>
<tr class="even">
<td>04</td>
<td>외국인</td>
</tr>
<tr class="odd">
<td>05</td>
<td>공공기관</td>
</tr>
<tr class="even">
<td>06</td>
<td>비영리단체</td>
</tr>
<tr class="odd">
<td>07</td>
<td>VIP</td>
</tr>
<tr class="even">
<td>08</td>
<td>임직원</td>
</tr>
<tr class="odd">
<td>09</td>
<td>제휴사</td>
</tr>
<tr class="even">
<td>10</td>
<td>기타</td>
</tr>
</tbody>
</table></li>
<li>계층코드(C)
<ul>
<li>하나 이상의 코드를 상속받거나 계층 구조를 통해 생성되어진 코드로 Key 가 구성된 경우</li>
<li>대분류 / 중분류 / 소분류 와 같은 분류체계를 가짐
<ul>
<li>정규화: 각 분류 수준이 별도의 테이블로 분리되어 있어 데이터 중복이 최소화된다.</li>
<li>참조 무결성: 외래 키 관계를 통해 데이터의 일관성이 유지된다.</li>
<li>유연성: 각 분류 수준에서 독립적으로 항목을 추가, 수정, 삭제할 수 있다.</li>
<li>확장성: 새로운 분류 항목을 쉽게 추가할 수 있다.
<ul>
<li>각 분류 수준에 대한 추가 정보(예: 생성일, 수정일, 설명 등)를 쉽게 추가할 수 있는 장점이 있다.</li>
</ul></li>
<li>쿼리 효율성: 필요에 따라 조인을 통해 전체 계층 구조를 조회하거나, 특정 수준만 조회할 수 있다.</li>
</ul></li>
<li>사용 조건
<ul>
<li>데이터가 계층적 구조를 가질 때</li>
<li>상위 개념과 하위 개념의 관계를 표현해야 할 때</li>
<li>drill-down 분석이 필요한 경우</li>
<li>예시: 조직코드, 상품분류코드, 지역코드</li>
</ul>
<ol type="1">
<li>대분류 코드 테이블:</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>대분류 코드</th>
<th>대분류명</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>전자제품</td>
</tr>
<tr class="even">
<td>B</td>
<td>가전제품</td>
</tr>
<tr class="odd">
<td>C</td>
<td>의류</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>중분류 코드 테이블:</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>중분류 코드</th>
<th>중분류명</th>
<th>대분류 코드 (FK)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A1</td>
<td>컴퓨터</td>
<td>A</td>
</tr>
<tr class="even">
<td>A2</td>
<td>휴대폰</td>
<td>A</td>
</tr>
<tr class="odd">
<td>B1</td>
<td>주방가전</td>
<td>B</td>
</tr>
<tr class="even">
<td>B2</td>
<td>생활가전</td>
<td>B</td>
</tr>
<tr class="odd">
<td>C1</td>
<td>남성복</td>
<td>C</td>
</tr>
<tr class="even">
<td>C2</td>
<td>여성복</td>
<td>C</td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li>소분류 코드 테이블:</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>소분류 코드</th>
<th>소분류명</th>
<th>대분류 코드 (FK)</th>
<th>중분류 코드 (FK)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A11</td>
<td>데스크톱</td>
<td>A</td>
<td>A1</td>
</tr>
<tr class="even">
<td>A12</td>
<td>노트북</td>
<td>A</td>
<td>A1</td>
</tr>
<tr class="odd">
<td>A13</td>
<td>태블릿</td>
<td>A</td>
<td>A1</td>
</tr>
<tr class="even">
<td>A21</td>
<td>스마트폰</td>
<td>A</td>
<td>A2</td>
</tr>
<tr class="odd">
<td>A22</td>
<td>피처폰</td>
<td>A</td>
<td>A2</td>
</tr>
<tr class="even">
<td>B11</td>
<td>냉장고</td>
<td>B</td>
<td>B1</td>
</tr>
<tr class="odd">
<td>B12</td>
<td>전자레인지</td>
<td>B</td>
<td>B1</td>
</tr>
<tr class="even">
<td>B21</td>
<td>청소기</td>
<td>B</td>
<td>B2</td>
</tr>
<tr class="odd">
<td>B22</td>
<td>세탁기</td>
<td>B</td>
<td>B2</td>
</tr>
<tr class="even">
<td>C11</td>
<td>셔츠</td>
<td>C</td>
<td>C1</td>
</tr>
<tr class="odd">
<td>C12</td>
<td>바지</td>
<td>C</td>
<td>C1</td>
</tr>
<tr class="even">
<td>C21</td>
<td>원피스</td>
<td>C</td>
<td>C2</td>
</tr>
<tr class="odd">
<td>C22</td>
<td>스커트</td>
<td>C</td>
<td>C2</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li>목록코드(L)
<ul>
<li>코드값(은행코드)과 코드명(은행명) 외에 여러 부가 정보를 포함한다.</li>
<li>약칭, 영문명, 주소, 전화번호 등 해당 코드와 관련된 상세 정보를 관리한다.</li>
<li>설립일과 같은 날짜 정보도 포함될 수 있다.</li>
<li>사용여부와 같은 관리 정보도 포함될 수 있다.</li>
<li>목록코드는 일반적으로 해당 업무팀에서 직접 관리하며, 시스템 전반에서 참조되어 사용됨
<ul>
<li>목록코드의 장점
<ul>
<li>상세 정보 관리: 코드와 관련된 다양한 부가 정보를 함께 관리할 수 있다.</li>
<li>업무 특성 반영: 특정 업무 영역의 특성을 반영한 정보를 포함할 수 있다.</li>
<li>데이터 일관성: 코드와 관련된 정보를 중앙에서 관리함으로써 데이터의 일관성을 유지할 수 있다.</li>
<li>확장성: 필요에 따라 새로운 정보 항목을 쉽게 추가할 수 있다.</li>
</ul></li>
</ul></li>
<li>사용 조건
<ul>
<li>코드와 함께 추가적인 속성 정보가 필요할 때
<ul>
<li>업무 요구사항 분석
<ul>
<li>사용자나 부서가 코드 외에 추가 정보를 자주 요청하는 경우</li>
<li>코드만으로는 업무 처리에 충분한 정보를 제공하지 못하는 경우</li>
</ul></li>
<li>데이터 활용도 검토
<ul>
<li>보고서나 분석에서 코드 관련 부가 정보가 자주 필요한 경우</li>
<li>데이터 조인이나 lookup 작업이 빈번하게 발생하는 경우</li>
</ul></li>
<li>시스템 통합 요구사항
<ul>
<li>다른 시스템과 데이터를 교환할 때 코드 외 추가 정보가 필요한 경우</li>
<li>외부 시스템이나 API가 코드와 관련된 부가 정보를 요구하는 경우</li>
</ul></li>
<li>변경 관리 필요성
<ul>
<li>코드 값이 시간에 따라 변경되거나 이력 관리가 필요한 경우</li>
<li>코드의 유효 기간이나 사용 상태를 관리해야 하는 경우</li>
</ul></li>
<li>복잡한 비즈니스 로직
<ul>
<li>코드를 기반으로 복잡한 비즈니스 규칙이나 계산이 필요한 경우</li>
<li>코드에 따라 다른 처리 로직이 적용되어야 하는 경우<br>
</li>
</ul></li>
<li>사용자 인터페이스 요구사항
<ul>
<li>코드 선택 시 사용자에게 추가 정보를 제공해야 하는 경우</li>
<li>코드 검색이나 필터링 시 다양한 기준이 필요한 경우</li>
</ul></li>
<li>감사 및 규제 요구사항
<ul>
<li>코드 사용에 대한 상세한 이력이나 근거를 유지해야 하는 경우</li>
<li>규제 준수를 위해 코드와 관련된 부가 정보를 관리해야 하는 경우</li>
</ul></li>
</ul></li>
<li>코드 정보가 자주 변경되거나 확장될 가능성이 있을 때</li>
<li>코드 정보가 특정 업무 영역에 국한되어 관리될 때</li>
</ul></li>
<li>예시: 은행코드, 국가코드, 통화코드</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 11%">
<col style="width: 8%">
<col style="width: 11%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 11%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th>은행코드</th>
<th>은행명</th>
<th>약칭</th>
<th>영문명</th>
<th>본점주소</th>
<th>대표전화</th>
<th>설립일</th>
<th>사용여부</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>001</td>
<td>한국은행</td>
<td>한은</td>
<td>Bank of Korea</td>
<td>서울특별시 중구 남대문로 39</td>
<td>02-759-4114</td>
<td>1950-06-12</td>
<td>Y</td>
</tr>
<tr class="even">
<td>002</td>
<td>산업은행</td>
<td>산은</td>
<td>Korea Development Bank</td>
<td>서울특별시 영등포구 은행로 14</td>
<td>1588-1500</td>
<td>1954-04-01</td>
<td>Y</td>
</tr>
<tr class="odd">
<td>003</td>
<td>기업은행</td>
<td>IBK</td>
<td>Industrial Bank of Korea</td>
<td>서울특별시 중구 을지로 79</td>
<td>1566-2566</td>
<td>1961-08-01</td>
<td>Y</td>
</tr>
<tr class="even">
<td>004</td>
<td>KB국민은행</td>
<td>국민</td>
<td>KB Kookmin Bank</td>
<td>서울특별시 영등포구 국제금융로8길 26</td>
<td>1588-9999</td>
<td>2001-11-01</td>
<td>Y</td>
</tr>
<tr class="odd">
<td>005</td>
<td>하나은행</td>
<td>하나</td>
<td>KEB Hana Bank</td>
<td>서울특별시 중구 을지로 35</td>
<td>1599-1111</td>
<td>1967-01-30</td>
<td>Y</td>
</tr>
<tr class="even">
<td>007</td>
<td>수협은행</td>
<td>수협</td>
<td>Suhyup Bank</td>
<td>서울특별시 송파구 오금로 62</td>
<td>1588-1515</td>
<td>1962-04-01</td>
<td>Y</td>
</tr>
</tbody>
</table></li>
<li>복합코드 (M)
<ul>
<li>코드 구성: 복합코드는 ’상품카테고리코드’와 ’지역코드’를 조합하여 만들어진다.</li>
<li>의미 결합: 두 개의 단일 코드의 의미를 결합하여 새로운 의미를 만든다.</li>
<li>추가 정보: 복합코드에는 단순히 두 코드를 붙인 것 외에도 추가적인 정보(설명, 담당부서, 적용일자 등)를 포함할 수 있다.</li>
<li>유연성: 새로운 상품 카테고리나 지역이 추가될 때 쉽게 확장할 수 있다.</li>
<li>복합코드의 장점
<ul>
<li>데이터 압축: 여러 정보를 하나의 코드로 표현할 수 있다.</li>
<li>의미 전달: 코드만으로도 여러 차원의 정보를 전달할 수 있다.</li>
<li>유연한 확장: 기존 단일 코드 체계를 유지하면서 새로운 의미를 부여할 수 있다.
<ul>
<li>데이터 분석: 복합코드를 분해하여 다양한 관점에서 데이터를 분석할 수 있다.</li>
</ul></li>
<li>이러한 복합코드는 조직의 복잡한 구조나 다차원적인 정보를 효율적으로 표현하고 관리하는 데 유용하다.</li>
</ul></li>
<li>이러한 목록코드는 일반적으로 해당 업무팀에서 직접 관리하며, 시스템 전반에서 참조되어 사용된다.</li>
<li>사용 조건
<ul>
<li>두 개 이상의 독립적인 코드 체계를 조합해야 할 때</li>
<li>다차원적인 정보를 하나의 코드로 표현해야 할 때</li>
<li>기존 코드 체계를 유지하면서 새로운 의미를 부여해야 할 때</li>
</ul></li>
<li>먼저, 각 단일 코드 도메인을 정의한다.</li>
<li>예시: 지역별 상품코드, 부서별 프로젝트코드
<ol type="1">
<li>상품 카테고리 코드 (단일코드)</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>코드</th>
<th>카테고리명</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>전자제품</td>
</tr>
<tr class="even">
<td>B</td>
<td>의류</td>
</tr>
<tr class="odd">
<td>C</td>
<td>식품</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>지역 코드 (단일코드)</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>코드</th>
<th>지역명</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>01</td>
<td>서울</td>
</tr>
<tr class="even">
<td>02</td>
<td>부산</td>
</tr>
<tr class="odd">
<td>03</td>
<td>대구</td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li>지역별 상품 코드 (복합코드)</li>
</ol>
<table class="caption-top table">
<thead>
<tr class="header">
<th>복합코드</th>
<th>상품카테고리코드</th>
<th>지역코드</th>
<th>설명</th>
<th>담당부서</th>
<th>적용일자</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A01</td>
<td>A</td>
<td>01</td>
<td>서울 전자제품</td>
<td>서울영업1팀</td>
<td>2023-01-01</td>
</tr>
<tr class="even">
<td>A02</td>
<td>A</td>
<td>02</td>
<td>부산 전자제품</td>
<td>부산영업팀</td>
<td>2023-01-01</td>
</tr>
<tr class="odd">
<td>A03</td>
<td>A</td>
<td>03</td>
<td>대구 전자제품</td>
<td>대구영업팀</td>
<td>2023-01-01</td>
</tr>
<tr class="even">
<td>B01</td>
<td>B</td>
<td>01</td>
<td>서울 의류</td>
<td>서울영업2팀</td>
<td>2023-01-01</td>
</tr>
<tr class="odd">
<td>B02</td>
<td>B</td>
<td>02</td>
<td>부산 의류</td>
<td>부산영업팀</td>
<td>2023-01-01</td>
</tr>
<tr class="even">
<td>B03</td>
<td>B</td>
<td>03</td>
<td>대구 의류</td>
<td>대구영업팀</td>
<td>2023-01-01</td>
</tr>
<tr class="odd">
<td>C01</td>
<td>C</td>
<td>01</td>
<td>서울 식품</td>
<td>서울영업3팀</td>
<td>2023-01-01</td>
</tr>
<tr class="even">
<td>C02</td>
<td>C</td>
<td>02</td>
<td>부산 식품</td>
<td>부산영업팀</td>
<td>2023-01-01</td>
</tr>
<tr class="odd">
<td>C03</td>
<td>C</td>
<td>03</td>
<td>대구 식품</td>
<td>대구영업팀</td>
<td>2023-01-01</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul></li>
<li>선택 시 고려사항
<ul>
<li>데이터의 구조: 데이터가 계층적인지, 평면적인지 파악</li>
<li>확장성: 향후 코드 추가나 변경 가능성 고려</li>
<li>사용 목적: 데이터 분석, 보고, 시스템 통합 등의 용도 파악</li>
<li>관리 용이성: 코드 관리의 복잡성과 유지보수 고려</li>
<li>업무 특성: 특정 업무 도메인의 요구사항 반영</li>
</ul></li>
</ul>
</section>
<section id="표준-코드-관리항목" class="level3" data-number="1.1.9">

<ul>
<li>회사에서 사용하는 표준 코드의 기준 관리항목은 아래와 같다</li>
<li>표준코드 관리항목 구성
<ul>
<li>신규 모델링 단계에서 코드 값에 대한 신청은 오프라인으로 수행된다.</li>
<li>변경 모델링 단계에서 코드 값에 대한 신청은 표준화 담당자를 통해 이루어진다.</li>
<li>모든 코드는 코드 도메인과 매핑 관계를 가지며 ERP 공통 코드 테이블에 대한 데이터 SYNC 작업이 수행된다</li>
</ul></li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th>유형</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>코드구분값</td>
<td>• 코드목록값 혹은 계층코드일 경우 최상위 코드 목록값</td>
</tr>
<tr class="even">
<td>코드값</td>
<td>• 코드 목록에 따른 코드 Value값</td>
</tr>
<tr class="odd">
<td>코드명</td>
<td>• 코드 도메인명과 동일함</td>
</tr>
<tr class="even">
<td>코드설명</td>
<td>• 코드명 설명</td>
</tr>
<tr class="odd">
<td>코드영문명</td>
<td>• 코드 도메인 영문명과 동일함</td>
</tr>
<tr class="even">
<td>코드길이</td>
<td>• 실제 코드 값의 길이</td>
</tr>
<tr class="odd">
<td>코드구분</td>
<td>• 단일코드/계층코드/목록성코드로 구분함</td>
</tr>
<tr class="even">
<td>업무구분</td>
<td>• 코드에 대한 ownership을 가진 담당 업무영역</td>
</tr>
<tr class="odd">
<td>상위코드값</td>
<td>• 상위 코드 Value값</td>
</tr>
<tr class="even">
<td>상위코드구분값</td>
<td>• 상위코드 목록값</td>
</tr>
<tr class="odd">
<td>엔티티명</td>
<td>• 목록성 코드인 경우 대상 엔티티명</td>
</tr>
<tr class="even">
<td>테이블명</td>
<td>• 목록성 코드인 경우 대상 테이블명</td>
</tr>
</tbody>
</table>
</section>
<section id="표준코드-수식어-유형" class="level3" data-number="1.1.10">

<ul>
<li>[주제어] + [코드 수식어 유형] + 코드 형태로 정의하여 사용한다.</li>
<li>표준코드 구성 체계
<ul>
<li>수식어 없이 코드용어 생성 가능</li>
</ul></li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>분류</th>
<th>유형</th>
<th>설명</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>기본</td>
<td>유형</td>
<td>어떤 비슷한 것들의 본질을 개체로서 나타낸 것, 또는 그것들의 공통되는 성질이나 모양을 정의할 때 사용되는 코드 유형</td>
<td>거래 유형 코드</td>
</tr>
<tr class="even">
<td>기본</td>
<td>분류</td>
<td>코드 값을 체계화 하여 관리하는 경우 사용하며, 주로 대 / 중 / 소 / 세 등의 분류 체계를 갖는 코드에 대해서 ’분류’를 사용</td>
<td>제품 소분류 코드</td>
</tr>
<tr class="odd">
<td>기본</td>
<td>종류</td>
<td>가급적 사용을 제한하되 ’유형’이나 ’분류’의 사용 시 의미 전달이 모호해질 경우 혹은 통상적으로 사용되는 경우에 한해서 사용</td>
<td>거래 종류 코드</td>
</tr>
<tr class="even">
<td>기본</td>
<td>구분</td>
<td>따로따로 갈라서 나누는 것으로 ’유형’보다는 단순하고 값의 종류가 10개 이내로 제한적이고 값의 범위가 명확한 경우 사용</td>
<td>상품항목 구분 코드</td>
</tr>
<tr class="odd">
<td>기본</td>
<td>항목</td>
<td>목록을 나열한 경우에 한해 사용</td>
<td>점검 항목 코드</td>
</tr>
<tr class="even">
<td>확장</td>
<td>사유</td>
<td>인식 작용, 분석, 종합, 추리, 판단 등의 정신 작용에 대한 근거 및 동기</td>
<td>취소 사유 코드</td>
</tr>
<tr class="odd">
<td>확장</td>
<td>상태</td>
<td>사물이나 현상이 처해 있는 현재의 모양 또는 형편</td>
<td>계약 상태 코드</td>
</tr>
<tr class="even">
<td>확장</td>
<td>관계</td>
<td>둘 이상의 사람, 사물, 현상 따위가 서로 관련을 맺거나 관련이 있음</td>
<td>계약자 관계 코드</td>
</tr>
<tr class="odd">
<td>확장</td>
<td>용도</td>
<td>사용되는 곳 혹은 사용되는 목적을 정의</td>
<td>자금 용도 코드</td>
</tr>
<tr class="even">
<td>확장</td>
<td>등급</td>
<td>높고 낮음이나 좋고 나쁨 따위의 차이를 여러 층으로 구분한 단계</td>
<td>차량 등급 코드</td>
</tr>
<tr class="odd">
<td>확장</td>
<td>지역</td>
<td>전체 영역을 어떤 특징으로 나눈 일정한 공간 영역</td>
<td>등록 지역 코드</td>
</tr>
<tr class="even">
<td>확장</td>
<td>단위</td>
<td>어떤 물리량(物理量)의 크기를 나타낼 때 비교의 기준 되는 크기</td>
<td>회계 단위 코드</td>
</tr>
</tbody>
</table>
</section>
<section id="코드값-부여-원칙" class="level3" data-number="1.1.11">

<ul>
<li>코드값(인스턴스)을 부여하는 방식에 대한 4가지 분류가 있으며 코드의 형식을 결정할 수 있다</li>
<li>계층 분류형(H)은 조직 구조와 같이 계층적인 관계를 표현하는 데 적합합니다.</li>
<li>순차 채번형(S)은 순서가 있는 항목들을 나열할 때 유용합니다.</li>
<li>표준약어 부여형(A)은 국제적으로 통용되는 표준 코드를 사용할 때 적합합니다.</li>
<li>복합 분류형(C)은 계층 구조와 순차적 번호 부여가 동시에 필요한 경우에 사용됩니다.</li>
<li>표준코드 구성 체계
<ul>
<li>[A : Alphabet N : Numeric S : Sequence Number]</li>
</ul></li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>유형</th>
<th>설명</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>계층 분류형(H)</td>
<td>• 대/중/소 등의 분류에 의한 구분이 필요한 경우 적용<br>• 일반적으로 10진 분류 체계로 구성<br>• 코드형식: N + N + N<br> - NN(대분류) + NN(중분류) + NN(소분류)<br> - NN(본/지점 분류) + NN(실/부 분류) + NN(팀 분류)</td>
<td>[조직구분코드]<br>100000: 본사총괄<br>101000: 기획실<br>101010: 회계팀<br>101020: 자금팀</td>
</tr>
<tr class="even">
<td>순차 채번형(S)</td>
<td>• 일련번호와 같이 순차적으로 번호를 부여하며 부여된 자리를 넘지 않도록 구성<br>• 가능한 결번이 없도록 정의함. 코드 길이 만큼을 앞에 0을 채워서 번호 부여(숫자형 문자)<br>• 코드 형식: SS</td>
<td>[가족구분코드]<br>01: 부<br>02: 모<br>03: 배우자<br>99: 기타</td>
</tr>
<tr class="odd">
<td>표준약어 부여형(A)</td>
<td>• 대부분 국제 표준 코드 및 국가표준코드, 업종표준코드 등이 이에 속함.<br>• 코드 형식: AAA</td>
<td>[국가구분코드]<br>CAN: 캐나다<br>CHN: 중국</td>
</tr>
<tr class="even">
<td>복합 분류형(C)</td>
<td>• 계층분류와 순차채번이 결합된 형태의 분류<br>• 코드 형식: ASSSSS</td>
<td>[담보구분코드]<br>A00001: 건물<br>A00002: 토지<br>B00001: 예금</td>
</tr>
</tbody>
</table>
</section>
<section id="코드-표준화-원칙" class="level3" data-number="1.1.12">

<ul>
<li>표준코드 구성 체계</li>
<li>기본 원칙
<ul>
<li>원칙적으로 회사 렌터카 시스템 구축에서 사용하는 모든 코드는 통합 관리한다</li>
<li>업무적으로 동일한 의미의 코드나 유사한 코드를 통합 후 표준화된 코드값과 코드내용을 부여한다</li>
<li>목록성 코드의 경우 참조정보(DB명, 테이블명, 컬럼명) 만 관리하며 별도 코드값, 코드내용을 관리하지 않는다. 코드값과 코드내용 이외에 부가적인 정보가 존재하고, 코드에 따라 부가적인 정보의 개수가 다르기 때문에 표준 코드 테이블에서 관리하기 어렵기 때문이다</li>
</ul></li>
<li>코드값(인스턴스) 부여 원칙
<ul>
<li>코드값의 부여는 원칙적으로 숫자형 문자 형태의 일련번호(01,02..)를 부여한다</li>
<li>특별한 사유가 없는 한 현업에서 부여한 코드값을 최우선 사용함을 원칙으로 한다</li>
<li>코드값 부여는 가능한 연속적으로 부여한다</li>
<li>코드값 길이는 향후 확장성을 고려해서 부여한다</li>
<li>숫자로만 이루어진 코드는 원칙적으로 허용하지 않으며 코드 길이만큼 숫자형 문자를 이용해서 ’0’을 채워서 코드를 부여한다</li>
<li>‘기타’, ‘해당없음’ 등의 내용을 갖는 코드는 가급적 사용하지 않는 것을 원칙으로 하되, 반드시 사용해야 할 경우 해당 자리의 ‘00’, ‘99’ 등의 최대값을 이용한다</li>
<li>’ 여부’, ’유무’의 모든 코드값은 ’Y＇과 ’N＇로 사용된다.</li>
</ul></li>
<li>코드값(인스턴스) 부여 원칙 예외
<ul>
<li>기존 As-Is에서 특별한 의미를 가지는 코드 값으로 사용되었을 경우 그대로 채택한다</li>
<li>외부에서 정의되어서 표준 약어로 널리 사용되는 있는 코드들은 표준화 대상에서 제외하며, 그대로 사용하도록 한다.
<ul>
<li>국가구분코드 등</li>
</ul></li>
</ul></li>
</ul>


</section>
</section>
</section>

 ]]></description>
  <category>Data Governance</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Governance/5-4.data_code.html</guid>
  <pubDate>Wed, 14 Aug 2024 15:00:00 GMT</pubDate>
</item>
</channel>
</rss>
