<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Kwangmin Kim</title>
<link>kk3225.netlify.app/docs/blog/</link>
<atom:link href="kk3225.netlify.app/docs/blog/index.xml" rel="self" type="application/rss+xml"/>
<description>blog</description>
<generator>quarto-1.4.543</generator>
<lastBuildDate>Wed, 10 Sep 2025 15:00:00 GMT</lastBuildDate>
<item>
  <title>Programmers Code Problem Study</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Code_Test/algorithm/hash_level1_pocketmon.html</link>
  <description><![CDATA[ 




<section id="문제-정보" class="level1">
<h1>문제 정보</h1>
<ul>
<li>제목: 폰켓몬</li>
<li>링크: https://school.programmers.co.kr/learn/courses/30/lessons/1845</li>
<li><strong>난이도</strong>: 1</li>
<li><strong>유형</strong>: Hash</li>
<li>풀이 시간: 10분</li>
</ul>
</section>
<section id="문제-설명" class="level1">
<h1>문제 설명</h1>
<p>당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다. 홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.</p>
<p>첫 번째(3번), 두 번째(1번) 폰켓몬을 선택 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택 두 번째(1번), 세 번째(2번) 폰켓몬을 선택 두 번째(1번), 네 번째(3번) 폰켓몬을 선택 세 번째(2번), 네 번째(3번) 폰켓몬을 선택</p>
<p>이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다. 당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.</p>
<section id="제한사항" class="level2">
<h2 class="anchored" data-anchor-id="제한사항">제한사항</h2>
<p>nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다. nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다. 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다. 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.</p>
</section>
<section id="입출력-예" class="level2">
<h2 class="anchored" data-anchor-id="입출력-예">입출력 예</h2>
<table class="table">
<thead>
<tr class="header">
<th>nums</th>
<th>result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[3,1,2,3]</td>
<td>2</td>
</tr>
<tr class="even">
<td>[3,3,3,2,2,4]</td>
<td>3</td>
</tr>
<tr class="odd">
<td>[3,3,3,2,2,2]</td>
<td>2</td>
</tr>
</tbody>
</table>
</section>
<section id="입출력-예-설명" class="level2">
<h2 class="anchored" data-anchor-id="입출력-예-설명">입출력 예 설명</h2>
<section id="입출력-예-1" class="level3">
<h3 class="anchored" data-anchor-id="입출력-예-1">입출력 예 #1</h3>
<p>문제의 예시와 같습니다.</p>
</section>
<section id="입출력-예-2" class="level3">
<h3 class="anchored" data-anchor-id="입출력-예-2">입출력 예 #2</h3>
<p>6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다. 가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다.</p>
</section>
<section id="입출력-예-3" class="level3">
<h3 class="anchored" data-anchor-id="입출력-예-3">입출력 예 #3</h3>
<p>6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다. 가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.</p>
</section>
</section>
</section>
<section id="문제-해설" class="level1">
<h1>문제 해설</h1>
<section id="문제-핵심-이해" class="level2">
<h2 class="anchored" data-anchor-id="문제-핵심-이해">문제 핵심 이해</h2>
<p>이 문제의 핵심은 <strong>가장 다양한 종류의 폰켓몬을 선택하는 것</strong></p>
<ul>
<li>전체 폰켓몬: N마리</li>
<li>선택 가능: N/2마리<br>
</li>
<li>목표: 최대한 많은 종류 선택</li>
</ul>
</section>
<section id="중요한-조건들" class="level2">
<h2 class="anchored" data-anchor-id="중요한-조건들">중요한 조건들</h2>
<ol type="1">
<li><strong>중복 제거</strong>: 같은 종류는 하나만 선택해도 충분</li>
<li><strong>선택 제한</strong>: N/2마리만 선택할 수 있다.</li>
<li><strong>최적 전략</strong>: min(고유 종류 수, N/2)가 정답</li>
</ol>
</section>
<section id="해결-방법별-분석" class="level2">
<h2 class="anchored" data-anchor-id="해결-방법별-분석">해결 방법별 분석</h2>
<section id="알고리즘-요약" class="level3">
<h3 class="anchored" data-anchor-id="알고리즘-요약">알고리즘 요약</h3>
<section id="핵심-아이디어" class="level4">
<h4 class="anchored" data-anchor-id="핵심-아이디어">핵심 아이디어</h4>
<p><strong>최대한 다양한 종류를 선택하되, N/2개 선택 제한을 넘지 않는</strong> 그리디 전략을 해시셋으로 구현</p>
</section>
<section id="알고리즘-동작" class="level4">
<h4 class="anchored" data-anchor-id="알고리즘-동작">알고리즘 동작</h4>
<ol type="1">
<li><strong>고유 종류 계산</strong>: <code>set()</code>을 사용해 중복을 제거하고 고유한 폰켓몬 종류 개수를 구함</li>
<li><strong>선택 제한 계산</strong>: 전체 개수를 2로 나누어 선택 가능한 최대 개수를 구함</li>
<li><strong>최적값 선택</strong>: 두 값 중 작은 값이 선택할 수 있는 최대 종류 수</li>
</ol>
</section>
<section id="왜-효율적인가" class="level4">
<h4 class="anchored" data-anchor-id="왜-효율적인가">왜 효율적인가?</h4>
<p>해시셋의 자동 중복 제거 기능을 활용하여 O(n) 시간에 간단하고 직관적으로 해결할 수 있음</p>
</section>
<section id="핵심-포인트" class="level4">
<h4 class="anchored" data-anchor-id="핵심-포인트">핵심 포인트</h4>
<p>다양성을 최대화하려면 <strong>“각 종류마다 최대 1마리씩만 선택”</strong>하는 것이 최적이므로, 고유 종류 수와 선택 가능 수 중 작은 값이 정답</p>
</section>
</section>
<section id="해시셋set-방법-권장" class="level3">
<h3 class="anchored" data-anchor-id="해시셋set-방법-권장">해시셋(Set) 방법 (권장)</h3>
<p><strong>시간복잡도</strong>: O(n)<br>
<strong>공간복잡도</strong>: O(n)</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(nums):</span>
<span id="cb1-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 고유한 종류의 개수 구하기</span></span>
<span id="cb1-3">    unique_types <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">set</span>(nums))  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(n) 시간, O(n) 공간</span></span>
<span id="cb1-4">    max_selection <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">//</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># N/2 계산</span></span>
<span id="cb1-5">    </span>
<span id="cb1-6">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 최대한 다양하게 선택할 수 있는 종류 수</span></span>
<span id="cb1-7">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(unique_types, max_selection)</span></code></pre></div>
<p><strong>동작 원리</strong>: - <code>set()</code>을 사용해 중복 제거하여 고유 종류 개수 계산 - <code>N/2</code>개만 선택 가능하므로 둘 중 작은 값이 정답</p>
</section>
<section id="해시맵dictionary-방법" class="level3">
<h3 class="anchored" data-anchor-id="해시맵dictionary-방법">해시맵(Dictionary) 방법</h3>
<p><strong>시간복잡도</strong>: O(n)<br>
<strong>공간복잡도</strong>: O(n)</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(nums):</span>
<span id="cb2-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 각 종류별 개수 카운트</span></span>
<span id="cb2-3">    pokemon_count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {}</span>
<span id="cb2-4">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> pokemon <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> nums:</span>
<span id="cb2-5">        pokemon_count[pokemon] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> pokemon_count.get(pokemon, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb2-6">    </span>
<span id="cb2-7">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 고유 종류 수와 선택 가능 수 비교</span></span>
<span id="cb2-8">    unique_types <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(pokemon_count)</span>
<span id="cb2-9">    max_selection <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">//</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span></span>
<span id="cb2-10">    </span>
<span id="cb2-11">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(unique_types, max_selection)</span></code></pre></div>
<p><strong>동작 원리</strong>: - 각 폰켓몬 종류별로 개수를 딕셔너리에 저장 - 딕셔너리의 키 개수 = 고유 종류 수 - min(고유 종류 수, N/2) 반환</p>
</section>
<section id="정렬-중복-제거-방법" class="level3">
<h3 class="anchored" data-anchor-id="정렬-중복-제거-방법">정렬 + 중복 제거 방법</h3>
<p><strong>시간복잡도</strong>: O(n log n)<br>
<strong>공간복잡도</strong>: O(1)</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(nums):</span>
<span id="cb3-2">    nums.sort()  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 정렬 O(n log n)</span></span>
<span id="cb3-3">    </span>
<span id="cb3-4">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 인접한 요소 비교로 고유 종류 개수 계산</span></span>
<span id="cb3-5">    unique_count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 첫 번째 요소는 항상 고유</span></span>
<span id="cb3-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums)):</span>
<span id="cb3-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> nums[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!=</span> nums[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]:  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 이전 요소와 다르면 새로운 종류</span></span>
<span id="cb3-8">            unique_count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb3-9">    </span>
<span id="cb3-10">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(unique_count, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">//</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span></code></pre></div>
<p><strong>특징</strong>: - 메모리 효율적이지만 정렬로 인한 시간 오버헤드 존재 - 메모리 제약이 있는 환경에서 고려</p>
</section>
</section>
<section id="정답-코드" class="level2">
<h2 class="anchored" data-anchor-id="정답-코드">정답 코드</h2>
<section id="최적-해답-해시셋-사용" class="level3">
<h3 class="anchored" data-anchor-id="최적-해답-해시셋-사용">최적 해답 (해시셋 사용)</h3>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(nums):</span>
<span id="cb4-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 가장 간단하고 직관적</span></span>
<span id="cb4-3">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">set</span>(nums)), <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">//</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span></code></pre></div>
</section>
<section id="해시맵-사용-해답" class="level3">
<h3 class="anchored" data-anchor-id="해시맵-사용-해답">해시맵 사용 해답</h3>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(nums):</span>
<span id="cb5-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 종류별 개수까지 알고 싶을 때</span></span>
<span id="cb5-3">    pokemon_types <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {}</span>
<span id="cb5-4">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> pokemon <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> nums:</span>
<span id="cb5-5">        pokemon_types[pokemon] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> pokemon_types.get(pokemon, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb5-6">    </span>
<span id="cb5-7">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(pokemon_types), <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">//</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span></code></pre></div>
</section>
<section id="한-줄-해답-고급" class="level3">
<h3 class="anchored" data-anchor-id="한-줄-해답-고급">한 줄 해답 (고급)</h3>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(nums):</span>
<span id="cb6-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">set</span>(nums)), <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">//</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span></code></pre></div>
</section>
</section>
<section id="복잡도-비교표" class="level2">
<h2 class="anchored" data-anchor-id="복잡도-비교표">복잡도 비교표</h2>
<table class="table">
<thead>
<tr class="header">
<th>방법</th>
<th>시간복잡도</th>
<th>공간복잡도</th>
<th>특징</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>해시셋</td>
<td>O(n)</td>
<td>O(n)</td>
<td><strong>최적 성능, 가장 간단</strong></td>
</tr>
<tr class="even">
<td>해시맵</td>
<td>O(n)</td>
<td>O(n)</td>
<td>종류별 개수 정보 추가 제공</td>
</tr>
<tr class="odd">
<td>정렬</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>메모리 효율적</td>
</tr>
</tbody>
</table>
</section>
<section id="왜-해시셋이-최적인가" class="level2">
<h2 class="anchored" data-anchor-id="왜-해시셋이-최적인가">왜 해시셋이 최적인가?</h2>
<ol type="1">
<li><strong>단순함</strong>: <code>min(len(set(nums)), len(nums) // 2)</code> 한 줄로 해결</li>
<li><strong>시간 효율성</strong>: O(n) - 배열을 한 번만 순회</li>
<li><strong>직관성</strong>: “고유한 종류 수”라는 개념과 정확히 일치</li>
<li><strong>자동 중복 제거</strong>: set 자료구조가 자동으로 중복을 제거</li>
</ol>
</section>
<section id="핵심-포인트-1" class="level2">
<h2 class="anchored" data-anchor-id="핵심-포인트-1">핵심 포인트</h2>
<ul>
<li><strong>중복 제거</strong>: set을 사용해 고유 종류만 추출</li>
<li><strong>그리디 전략</strong>: 최대한 다양한 종류를 선택하는 것이 최적</li>
<li><strong>제한 조건</strong>: N/2개만 선택할 수 있으므로 min() 함수 사용</li>
</ul>
<p>이 문제의 핵심은 <strong>“가능한 많은 종류를 선택하되, N/2개 제한을 넘지 않는 것”</strong>입니다.</p>
</section>
<section id="예제별-동작-과정" class="level2">
<h2 class="anchored" data-anchor-id="예제별-동작-과정">예제별 동작 과정</h2>
<section id="예제-1-3123-결과-2" class="level3">
<h3 class="anchored" data-anchor-id="예제-1-3123-결과-2">예제 1: <code>[3,1,2,3]</code> → 결과: 2</h3>
<p><strong>해시셋 방법</strong>: 1. <code>set([3,1,2,3])</code> = <code>{1, 2, 3}</code> → 고유 종류: 3개 2. <code>len([3,1,2,3]) // 2</code> = <code>4 // 2</code> = 2 → 선택 가능: 2개 3. <code>min(3, 2)</code> = 2 → <strong>답: 2</strong></p>
</section>
<section id="예제-2-333224-결과-3" class="level3">
<h3 class="anchored" data-anchor-id="예제-2-333224-결과-3">예제 2: <code>[3,3,3,2,2,4]</code> → 결과: 3</h3>
<p><strong>해시셋 방법</strong>: 1. <code>set([3,3,3,2,2,4])</code> = <code>{2, 3, 4}</code> → 고유 종류: 3개 2. <code>len([3,3,3,2,2,4]) // 2</code> = <code>6 // 2</code> = 3 → 선택 가능: 3개 3. <code>min(3, 3)</code> = 3 → <strong>답: 3</strong></p>
</section>
<section id="예제-3-333222-결과-2" class="level3">
<h3 class="anchored" data-anchor-id="예제-3-333222-결과-2">예제 3: <code>[3,3,3,2,2,2]</code> → 결과: 2</h3>
<p><strong>해시셋 방법</strong>: 1. <code>set([3,3,3,2,2,2])</code> = <code>{2, 3}</code> → 고유 종류: 2개 2. <code>len([3,3,3,2,2,2]) // 2</code> = <code>6 // 2</code> = 3 → 선택 가능: 3개 3. <code>min(2, 3)</code> = 2 → <strong>답: 2</strong> (종류가 부족해서 제한됨)</p>


</section>
</section>
</section>

 ]]></description>
  <category>Algorithm Test</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Code_Test/algorithm/hash_level1_pocketmon.html</guid>
  <pubDate>Wed, 10 Sep 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Programmers Code Problem Study</title>
  <dc:creator>Your Name</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Code_Test/algorithm/hash_level1_runner.html</link>
  <description><![CDATA[ 




<section id="문제-정보" class="level1">
<h1>문제 정보</h1>
<ul>
<li>제목: 완주하지 못한 선수</li>
<li>링크: https://school.programmers.co.kr/learn/courses/30/lessons/42576</li>
<li><strong>난이도</strong>: 1</li>
<li><strong>유형</strong>: Hash</li>
<li>풀이 시간: 10분</li>
</ul>
</section>
<section id="문제-설명" class="level1">
<h1>문제 설명</h1>
<p>수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.</p>
<p>마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.</p>
<section id="제한사항" class="level2">
<h2 class="anchored" data-anchor-id="제한사항">제한사항</h2>
<ul>
<li>마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.</li>
<li>completion의 길이는 participant의 길이보다 1 작습니다.</li>
<li>참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.</li>
<li>참가자 중에는 동명이인이 있을 수 있습니다.</li>
</ul>
</section>
<section id="입출력-예" class="level2">
<h2 class="anchored" data-anchor-id="입출력-예">입출력 예</h2>
<table class="table">
<colgroup>
<col style="width: 38%">
<col style="width: 35%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th>participant</th>
<th>completion</th>
<th>return</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[“leo”, “kiki”, “eden”]</td>
<td>[“eden”, “kiki”]</td>
<td>“leo”</td>
</tr>
<tr class="even">
<td>[“marina”, “josipa”, “nikola”, “vinko”, “filipa”]</td>
<td>[“josipa”, “filipa”, “marina”, “nikola”]</td>
<td>“vinko”</td>
</tr>
<tr class="odd">
<td>[“mislav”, “stanko”, “mislav”, “ana”]</td>
<td>[“stanko”, “ana”, “mislav”]</td>
<td>“mislav”</td>
</tr>
</tbody>
</table>
</section>
<section id="입출력-예-설명" class="level2">
<h2 class="anchored" data-anchor-id="입출력-예-설명">입출력 예 설명</h2>
<section id="예제-1" class="level3">
<h3 class="anchored" data-anchor-id="예제-1">예제 #1</h3>
<p>“leo”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.</p>
</section>
<section id="예제-2" class="level3">
<h3 class="anchored" data-anchor-id="예제-2">예제 #2</h3>
<p>“vinko”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.</p>
</section>
<section id="예제-3" class="level3">
<h3 class="anchored" data-anchor-id="예제-3">예제 #3</h3>
<p>“mislav”는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.</p>
<p>※ 공지 - 2023년 01월 25일 테스트케이스가 추가되었습니다.</p>
</section>
</section>
</section>
<section id="문제-해설" class="level1">
<h1>문제 해설</h1>
<section id="문제-핵심-이해" class="level2">
<h2 class="anchored" data-anchor-id="문제-핵심-이해">문제 핵심 이해</h2>
<p>이 문제의 핵심은 <strong>두 개의 배열에서 빠진 요소 하나를 찾는 것</strong></p>
<ul>
<li>참가자 배열: <code>participant</code> (n명)</li>
<li>완주자 배열: <code>completion</code> (n-1명)</li>
<li>목표: 완주하지 못한 1명 찾기</li>
</ul>
</section>
<section id="중요한-조건들" class="level2">
<h2 class="anchored" data-anchor-id="중요한-조건들">중요한 조건들</h2>
<ol type="1">
<li><strong>동명이인 존재 가능</strong>: 단순히 이름만 비교하면 안 되고, 개수까지 고려해야 한다.</li>
<li><strong>대용량 데이터</strong>: 최대 100,000명까지 가능하므로 효율적인 알고리즘이 필요하다.</li>
<li><strong>정확히 1명 차이</strong>: completion 길이 = participant 길이 - 1</li>
</ol>
</section>
<section id="해결-방법별-분석" class="level2">
<h2 class="anchored" data-anchor-id="해결-방법별-분석">해결 방법별 분석</h2>
<section id="해시맵dictionary-방법-권장" class="level3">
<h3 class="anchored" data-anchor-id="해시맵dictionary-방법-권장">해시맵(Dictionary) 방법 (권장)</h3>
<p><strong>시간복잡도</strong>: O(n) + O(n) + O(n) = O(n) <strong>공간복잡도</strong>: O(n) (최악의 경우 모든 참가자가 서로 다른 이름)</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">'''</span></span>
<span id="cb1-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">핵심 아이디어</span></span>
<span id="cb1-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  - 해설: 완주하지 못한 선수는 참가했지만 완주 명단에서 차감되지 않은 유일한 사람이므로, 카운팅 차집합으로 정확히 찾을 수 있음 </span></span>
<span id="cb1-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  - 전략: 참가자 카운트 - 완주자 카운트 = 미완주자의 차집합 원리를 해시맵으로 구현 </span></span>
<span id="cb1-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">알고리즘 동작</span></span>
<span id="cb1-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  - 참가자 딕셔너리 생성: 각 참가자 이름별 개수를 해시맵에 저장</span></span>
<span id="cb1-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  - 완주자 카운트 차감: 완주자 리스트를 순회하며 해당 이름의 카운트를 1씩 차감</span></span>
<span id="cb1-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  - 미완주자 탐색: 카운트 값이 0보다 큰 이름을 찾아 반환</span></span>
<span id="cb1-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">왜 효율적인가?</span></span>
<span id="cb1-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  - 해시맵의 O(1) 접근 시간을 활용하여 전체 O(n) 시간에 동명이인까지 정확히 처리할 수 있음</span></span>
<span id="cb1-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">'''</span></span>
<span id="cb1-12"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(participant, completion):</span>
<span id="cb1-13">    participant_dict <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {} <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 최대 n개의 서로 다른 이름 저장 → O(n) 공간</span></span>
<span id="cb1-14">    </span>
<span id="cb1-15">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1단계: 참가자 카운트 - O(n)</span></span>
<span id="cb1-16">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> name <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> participant:  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># n번 반복</span></span>
<span id="cb1-17">        participant_dict[name] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> participant_dict.get(name, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb1-18">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 잘못된 방법 - participant_dict[name] = participant_dict[name] + 1</span></span>
<span id="cb1-19">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># → KeyError: 'leo' (처음 등장하는 이름은 키가 없음)</span></span>
<span id="cb1-20">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># dict.get(key, default_value): 값을 가져오는 역할</span></span>
<span id="cb1-21">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># name이라는 키가 딕셔너리에 있으면 → 그 값을 반환</span></span>
<span id="cb1-22">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># name이라는 키가 딕셔너리에 없으면 → 0을 반환 (default 값)</span></span>
<span id="cb1-23">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># + 1 → 참가자 개수 증가 (동명이인 방지)</span></span>
<span id="cb1-24">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 두 번째 "leo" (만약 동명이인이 있다면) → 1 + 1 = 2</span></span>
<span id="cb1-25">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># dict.get() = O(1), dict 할당 = O(1)</span></span>
<span id="cb1-26">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 예시: ["mislav", "stanko", "mislav", "ana"] → {"mislav": 2, "stanko": 1, "ana": 1}</span></span>
<span id="cb1-27">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 1. name = "mislav" (첫 번째)</span></span>
<span id="cb1-28">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict.get("mislav", 0) + 1</span></span>
<span id="cb1-29">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # → 0 + 1 = 1</span></span>
<span id="cb1-30">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict["mislav"] = 1</span></span>
<span id="cb1-31">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 현재 상태: {"mislav": 1}</span></span>
<span id="cb1-32"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># </span></span>
<span id="cb1-33">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 2. name = "stanko"</span></span>
<span id="cb1-34">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict.get("stanko", 0) + 1  </span></span>
<span id="cb1-35">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # → 0 + 1 = 1</span></span>
<span id="cb1-36">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict["stanko"] = 1</span></span>
<span id="cb1-37">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 현재 상태: {"mislav": 1, "stanko": 1}</span></span>
<span id="cb1-38"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># </span></span>
<span id="cb1-39">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 3. name = "mislav" (두 번째, 동명이인!)</span></span>
<span id="cb1-40">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict.get("mislav", 0) + 1</span></span>
<span id="cb1-41">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # → 1 + 1 = 2  (이미 "mislav"가 있어서 1을 반환)</span></span>
<span id="cb1-42">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict["mislav"] = 2</span></span>
<span id="cb1-43">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 현재 상태: {"mislav": 2, "stanko": 1}</span></span>
<span id="cb1-44"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># </span></span>
<span id="cb1-45">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 4. name = "ana"</span></span>
<span id="cb1-46">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict.get("ana", 0) + 1</span></span>
<span id="cb1-47">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # → 0 + 1 = 1</span></span>
<span id="cb1-48">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict["ana"] = 1</span></span>
<span id="cb1-49">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 최종 상태: {"mislav": 2, "stanko": 1, "ana": 1}</span></span>
<span id="cb1-50">    </span>
<span id="cb1-51">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2단계: 완주자 차감 - O(n-1) = O(n)</span></span>
<span id="cb1-52">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> name <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> completion:  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># n-1번 반복</span></span>
<span id="cb1-53">        participant_dict[name] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb1-54">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># dict 접근 및 수정 = O(1)</span></span>
<span id="cb1-55">    </span>
<span id="cb1-56">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3단계: 결과 찾기 - O(n)</span></span>
<span id="cb1-57">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> name, count <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> participant_dict.items():  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 최대 n번 반복</span></span>
<span id="cb1-58">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:</span>
<span id="cb1-59">            <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> name</span></code></pre></div>
<p><strong>동작 원리</strong>: - 참가자 이름별 개수를 카운트 - 완주자 이름별로 개수를 차감 - 남은 개수가 1인 사람이 미완주자</p>
</section>
<section id="정렬-방법" class="level3">
<h3 class="anchored" data-anchor-id="정렬-방법">정렬 방법</h3>
<p><strong>시간복잡도</strong>: O(n log n) + O(n log n) + O(n) = O(n log n)</p>
<ul>
<li>분할 정복(Divide and Conquer) 원리
<ul>
<li>분할: 배열을 절반씩 나누기 → log n 단계 → n개의 요소를 계속 반으로 나누면서 1개가 남을 때까지의 분할 횟수가 log n</li>
<li>n개의 요소를 계속 반으로 나누면서 1개가 남을 때까지의 분할 횟수가 log n</li>
<li>n → n/2 → n/4 → n/8 → … → n/2^k → … → 1 - n/2^k = 1 → 2^k = n → k = log₂n → O(log n)</li>
<li>예시: 8개 요소 정렬 - [8, 3, 1, 7, 0, 10, 2, 5]
<ul>
<li>1단계: [8,3,1,7] | [0,10,2,5] ← 8 → 4, 4</li>
<li>2단계: [8,3|1,7] | [0,10|2,5] ← 4 → 2, 2</li>
<li>3단계: [8|3|1|7] | [0|10|2|5] ← 2 → 1, 1</li>
</ul></li>
<li>총 단계 수: log₂(8) = 3단계 = log n</li>
<li>각 단계마다: 8개 요소 처리 = n개</li>
<li>반으로 나누는 것만으로도 문제 크기를 지수적으로 줄일 수 있어서 O(n) 보다 O(log n)이 더 효율적</li>
<li>정복: 각 단계에서 모든 요소를 비교/병합 → n 개 요소</li>
<li>결과: log n 단계 × n개 처리 = O(n log n)</li>
</ul></li>
</ul>
<p><strong>공간복잡도</strong>: O(1) (입력 배열 자체를 정렬) - O(1) = 상수 시간 (Constant Time)</p>
<ul>
<li>입력 크기에 상관없이 항상 일정한 시간이 걸리는 연산</li>
<li>즉, 추가 메모리를 거의 사용하지 않는다는 뜻 - 모두 O(1) 연산들</li>
</ul>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1">arr[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]           <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 배열 인덱스 접근 = O(1)</span></span>
<span id="cb2-2"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">dict</span>[key]        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 해시맵 접근 = O(1)</span></span>
<span id="cb2-3">x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 변수 할당</span></span>
<span id="cb2-4"><span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 단순 비교</span></span>
<span id="cb2-5">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> x     <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 반환</span></span></code></pre></div>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(participant, completion):</span>
<span id="cb3-2">    participant.sort() <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 시간: O(n log n), 공간: O(1)</span></span>
<span id="cb3-3">    completion.sort() <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 시간: O(n log n), 공간: O(1)</span></span>
<span id="cb3-4">    </span>
<span id="cb3-5">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 순서대로 비교하다가 다른 부분 발견 → 시간: O(n), 공간: O(1)</span></span>
<span id="cb3-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(completion)):  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># n-1번 반복</span></span>
<span id="cb3-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> participant[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!=</span> completion[i]: <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1)</span></span>
<span id="cb3-8">            <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> participant[i]</span>
<span id="cb3-9">    </span>
<span id="cb3-10">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 모두 같다면 마지막 사람이 미완주자</span></span>
<span id="cb3-11">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> participant[<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1)</span></span></code></pre></div>
<p>따라서, 정렬 방법의 시간복잡도는 O(n log n)이고, 공간복잡도는 O(1)</p>
<ul>
<li>시간복잡도: O(n log n) + O(n log n) + O(n) = O(n log n)</li>
<li>공간복잡도: O(1) + O(1) + O(1) = O(1)</li>
<li>메모리 vs 속도 트레이드오프</li>
<li>결론: 대부분 상황에서는 해시맵이 좋지만, 메모리가 부족한 환경에서는 정렬 방법을 고려할 수 있다</li>
</ul>
<table class="table">
<thead>
<tr class="header">
<th>방법</th>
<th>속도</th>
<th>메모리</th>
<th>상황</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>해시맵</td>
<td>빠름 O(n)</td>
<td>많이 씀 O(n)</td>
<td><strong>일반적으로 권장</strong></td>
</tr>
<tr class="even">
<td>정렬</td>
<td>보통 O(n log n)</td>
<td>적게 씀 O(1)</td>
<td>메모리 제약이 있을 때</td>
</tr>
</tbody>
</table>
</section>
<section id="최적-해답-해시맵-사용" class="level3">
<h3 class="anchored" data-anchor-id="최적-해답-해시맵-사용">최적 해답 (해시맵 사용)</h3>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(participant, completion):</span>
<span id="cb4-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 방법 1: Counter 사용 (가장 간단)</span></span>
<span id="cb4-3">    <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> collections <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Counter</span>
<span id="cb4-4">    </span>
<span id="cb4-5">    participant_counter <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Counter(participant) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(n)</span></span>
<span id="cb4-6">    completion_counter <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Counter(completion) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(n)</span></span>
<span id="cb4-7">    </span>
<span id="cb4-8">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 차집합으로 미완주자 찾기</span></span>
<span id="cb4-9">    result <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> participant_counter <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> completion_counter <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(n)</span></span>
<span id="cb4-10">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">list</span>(result.keys())[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>] <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1)</span></span></code></pre></div>
</section>
<section id="한-줄-해답-고급" class="level3">
<h3 class="anchored" data-anchor-id="한-줄-해답-고급">한 줄 해답 (고급)</h3>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(participant, completion):</span>
<span id="cb5-2">    <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> collections <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Counter</span>
<span id="cb5-3">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">list</span>((Counter(participant) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> Counter(completion)).keys())[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span></code></pre></div>
</section>
<section id="브루트-포스-방법-비권장" class="level3">
<h3 class="anchored" data-anchor-id="브루트-포스-방법-비권장">브루트 포스 방법 (비권장)</h3>
<p><strong>시간복잡도</strong>: O(n²)<br>
<strong>공간복잡도</strong>: O(1)</p>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(participant, completion):</span>
<span id="cb6-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> p <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> participant:</span>
<span id="cb6-3">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> p <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">not</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> completion:</span>
<span id="cb6-4">            <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> p</span>
<span id="cb6-5">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">else</span>:</span>
<span id="cb6-6">            completion.remove(p)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 동명이인 처리</span></span></code></pre></div>
</section>
</section>
<section id="복잡도-비교표" class="level2">
<h2 class="anchored" data-anchor-id="복잡도-비교표">복잡도 비교표</h2>
<table class="table">
<thead>
<tr class="header">
<th>방법</th>
<th>시간복잡도</th>
<th>공간복잡도</th>
<th>특징</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>해시맵</td>
<td>O(n)</td>
<td>O(n)</td>
<td><strong>최적 성능, 가독성 좋음</strong></td>
</tr>
<tr class="even">
<td>Counter</td>
<td>O(n)</td>
<td>O(n)</td>
<td><strong>가장 간결, 최적 성능</strong></td>
</tr>
<tr class="odd">
<td>정렬</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>메모리 효율적</td>
</tr>
<tr class="even">
<td>브루트포스</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>비효율적, 비권장</td>
</tr>
</tbody>
</table>
</section>
<section id="왜-해시맵이-최적인가" class="level2">
<h2 class="anchored" data-anchor-id="왜-해시맵이-최적인가">왜 해시맵이 최적인가?</h2>
<ol type="1">
<li><strong>해시 테이블의 특성</strong>: 삽입, 조회, 수정이 모두 O(1)</li>
<li><strong>선형 탐색</strong>: 각 배열을 한 번씩만 순회 → O(n)</li>
<li><strong>공간-시간 트레이드오프</strong>: 메모리를 조금 더 사용해서 시간을 크게 단축</li>
<li><strong>시간 효율성</strong>: O(n) - 각 배열을 한 번씩만 순회</li>
<li><strong>동명이인 처리</strong>: 이름별 개수를 정확히 관리</li>
<li><strong>구현 단순성</strong>: 직관적이고 이해하기 쉬운 로직</li>
<li><strong>확장성</strong>: 미완주자가 여러 명이어도 쉽게 확장 가능</li>
</ol>
</section>
<section id="핵심-포인트" class="level2">
<h2 class="anchored" data-anchor-id="핵심-포인트">핵심 포인트</h2>
<ul>
<li><strong>Hash 자료구조의 특성 활용</strong>: O(1) 삽입/조회로 효율성 극대화</li>
<li><strong>카운팅 기법</strong>: 단순 존재 여부가 아닌 개수 비교로 동명이인 문제 해결</li>
<li><strong>차집합 개념</strong>: 전체에서 일부를 빼는 방식으로 누락된 요소 찾기</li>
</ul>
<p>대용량 데이터(최대 100,000명)에서는 <strong>O(n)</strong>과 <strong>O(n²)</strong>의 차이가 매우 크기 때문에 해시맵 방식이 필수적이다</p>
</section>
<section id="예제별-동작-과정" class="level2">
<h2 class="anchored" data-anchor-id="예제별-동작-과정">예제별 동작 과정</h2>
<section id="예제-1-leo-kiki-eden-eden-kiki" class="level3">
<h3 class="anchored" data-anchor-id="예제-1-leo-kiki-eden-eden-kiki">예제 1: <code>["leo", "kiki", "eden"]</code>, <code>["eden", "kiki"]</code></h3>
<p><strong>해시맵 방법</strong>: 1. participant_dict = {“leo”: 1, “kiki”: 1, “eden”: 1} 2. “eden” 차감 → {“leo”: 1, “kiki”: 1, “eden”: 0} 3. “kiki” 차감 → {“leo”: 1, “kiki”: 0, “eden”: 0} 4. count가 1인 “leo” 반환</p>
</section>
<section id="예제-3-mislav-stanko-mislav-ana-stanko-ana-mislav" class="level3">
<h3 class="anchored" data-anchor-id="예제-3-mislav-stanko-mislav-ana-stanko-ana-mislav">예제 3: <code>["mislav", "stanko", "mislav", "ana"]</code>, <code>["stanko", "ana", "mislav"]</code></h3>
<p><strong>해시맵 방법</strong>: 1. participant_dict = {“mislav”: 2, “stanko”: 1, “ana”: 1} 2. 완주자들 차감 후 → {“mislav”: 1, “stanko”: 0, “ana”: 0} 3. count가 1인 “mislav” 반환</p>
</section>
</section>
</section>
<section id="해시맵-기초" class="level1">
<h1>해시맵 기초</h1>
<ul>
<li>해시맵(해시테이블): 컴퓨터 과학 이론에서 사용하는 표준 학술 용어</li>
<li>Python 딕셔너리 = 해시맵(해시테이블) = 해시 기반 키-값 저장소</li>
<li>딕셔너리의 Key → 해시함수 → 인덱스 → 메모리 위치 → Value 할당</li>
</ul>
<section id="딕셔너리의-내부-구현" class="level2">
<h2 class="anchored" data-anchor-id="딕셔너리의-내부-구현">딕셔너리의 내부 구현</h2>
<p><strong>Python의 <code>dict</code>는 실제로 해시테이블(Hash Table)로 구현</strong>되어 있음 - 즉, 해시맵과 동일한 자료구조 - <code>my_dict = {"key": "value"}</code> - 내부적으로는 해시테이블이 동작 - 1. “key”를 해시함수에 통과 → hash(“key”) = 12345 - 2. 12345 % 배열크기 = 인덱스 계산 - 3. 해당 인덱스에 (“key”, “value”) 저장</p>
</section>
<section id="언어별-용어-차이" class="level2">
<h2 class="anchored" data-anchor-id="언어별-용어-차이">언어별 용어 차이</h2>
<table class="table">
<thead>
<tr class="header">
<th>언어</th>
<th>이름</th>
<th>실제로는</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Python</strong></td>
<td>dict</td>
<td>Hash Table</td>
</tr>
<tr class="even">
<td><strong>Java</strong></td>
<td>HashMap</td>
<td>Hash Table</td>
</tr>
<tr class="odd">
<td><strong>C++</strong></td>
<td>unordered_map</td>
<td>Hash Table</td>
</tr>
<tr class="even">
<td><strong>JavaScript</strong></td>
<td>Object, Map</td>
<td>Hash Table</td>
</tr>
<tr class="odd">
<td><strong>C#</strong></td>
<td>Dictionary</td>
<td>Hash Table</td>
</tr>
</tbody>
</table>
</section>
<section id="왜-해시맵이라고-부르는가" class="level2">
<h2 class="anchored" data-anchor-id="왜-해시맵이라고-부르는가">왜 “해시맵”이라고 부르는가?</h2>
<section id="해시-함수-사용" class="level3">
<h3 class="anchored" data-anchor-id="해시-함수-사용">해시 함수 사용</h3>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 내부 동작 과정</span></span>
<span id="cb7-2">key <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"leo"</span></span>
<span id="cb7-3">hash_value <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">hash</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"leo"</span>)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 예: 2578946130</span></span>
<span id="cb7-4">index <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> hash_value <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span>    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 배열 크기가 8이면 → 인덱스 2</span></span>
<span id="cb7-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># dict_array[2] 위치에 ("leo", 1) 저장</span></span></code></pre></div>
</section>
<section id="키-값-매핑mapping" class="level3">
<h3 class="anchored" data-anchor-id="키-값-매핑mapping">키-값 매핑(Mapping)</h3>
<div class="sourceCode" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 키를 값으로 "매핑(mapping)"</span></span>
<span id="cb8-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"leo"</span> → <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb8-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"kiki"</span> → <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>  </span>
<span id="cb8-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"eden"</span> → <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span></code></pre></div>
</section>
</section>
<section id="해시맵의-핵심-특성" class="level2">
<h2 class="anchored" data-anchor-id="해시맵의-핵심-특성">해시맵의 핵심 특성</h2>
<section id="o1-평균-시간복잡도" class="level3">
<h3 class="anchored" data-anchor-id="o1-평균-시간복잡도">O(1) 평균 시간복잡도</h3>
<div class="sourceCode" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 모두 O(1) 평균 시간</span></span>
<span id="cb9-2"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">dict</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"key"</span>]           <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 조회</span></span>
<span id="cb9-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">dict</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"key"</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> value   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 삽입  </span></span>
<span id="cb9-4"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">dict</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"key"</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>      <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 수정</span></span></code></pre></div>
</section>
<section id="해시-충돌-처리" class="level3">
<h3 class="anchored" data-anchor-id="해시-충돌-처리">해시 충돌 처리</h3>
<div class="sourceCode" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 서로 다른 키가 같은 해시값을 가질 때</span></span>
<span id="cb10-2"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">hash</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"leo"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span></span>
<span id="cb10-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">hash</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ana"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 충돌!</span></span>
<span id="cb10-4"></span>
<span id="cb10-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Python은 Open Addressing으로 해결</span></span>
<span id="cb10-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Open Addressing: 다음 빈 슬롯을 찾아 저장</span></span></code></pre></div>


</section>
</section>
</section>

 ]]></description>
  <category>Algorithm Test</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Code_Test/algorithm/hash_level1_runner.html</guid>
  <pubDate>Invalid Date</pubDate>
</item>
<item>
  <title>Programmers Code Problem: Phone Number List</title>
  <dc:creator>kkm </dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Code_Test/algorithm/hash_level2_phone_number.html</link>
  <description><![CDATA[ 




<section id="문제-정보" class="level1">
<h1>문제 정보</h1>
<ul>
<li>제목: 전화번호 목록</li>
<li>링크: https://school.programmers.co.kr/learn/courses/30/lessons/42577</li>
<li><strong>난이도</strong>: 2</li>
<li><strong>유형</strong>: Hash</li>
<li>풀이 시간: 10분</li>
</ul>
</section>
<section id="문제-설명" class="level1">
<h1>문제 설명</h1>
<p>전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다. 전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.</p>
<ul>
<li>구조대 : 119</li>
<li>박준영 : 97 674 223</li>
<li>지영석 : 11 9552 4421</li>
</ul>
<p>전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를, 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.</p>
<section id="제한-사항" class="level2">
<h2 class="anchored" data-anchor-id="제한-사항">제한 사항</h2>
<p>phone_book의 길이는 1 이상 1,000,000 이하입니다. 각 전화번호의 길이는 1 이상 20 이하입니다. 같은 전화번호가 중복해서 들어있지 않습니다.</p>
</section>
<section id="입출력-예제" class="level2">
<h2 class="anchored" data-anchor-id="입출력-예제">입출력 예제</h2>
<table class="table">
<thead>
<tr class="header">
<th>예시</th>
<th>phone_book</th>
<th>return</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>예시 1</td>
<td>[“119”, “97674223”, “1195524421”]</td>
<td>false</td>
</tr>
<tr class="even">
<td>예시 2</td>
<td>[“123”,“456”,“789”]</td>
<td>true</td>
</tr>
<tr class="odd">
<td>예시 3</td>
<td>[“12”,“123”,“1235”,“567”,“88”]</td>
<td>false</td>
</tr>
</tbody>
</table>
</section>
<section id="입출력-예-설명" class="level2">
<h2 class="anchored" data-anchor-id="입출력-예-설명">입출력 예 설명</h2>
<p>입출력 예 #1 앞에서 설명한 예와 같습니다.</p>
<p>입출력 예 #2 한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.</p>
<p>입출력 예 #3 첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.</p>
</section>
<section id="알림" class="level2">
<h2 class="anchored" data-anchor-id="알림">알림</h2>
<p>2021년 3월 4일, 테스트 케이스가 변경되었습니다. 이로 인해 이전에 통과하던 코드가 더 이상 통과하지 않을 수 있습니다.</p>
</section>
</section>
<section id="문제-해설" class="level1">
<h1>문제 해설</h1>
<section id="문제-핵심-이해" class="level2">
<h2 class="anchored" data-anchor-id="문제-핵심-이해">문제 핵심 이해</h2>
<p>이 문제의 핵심은 <strong>한 전화번호가 다른 전화번호의 접두어인지 확인하는 것</strong></p>
<ul>
<li>입력: 전화번호 목록 배열</li>
<li>출력: 접두어 관계가 있으면 false, 없으면 true</li>
<li>목표: 효율적으로 접두어 관계 탐지</li>
</ul>
</section>
<section id="중요한-조건들" class="level2">
<h2 class="anchored" data-anchor-id="중요한-조건들">중요한 조건들</h2>
<ol type="1">
<li><strong>접두어 정의</strong>: 한 번호가 다른 번호의 시작 부분과 완전히 일치</li>
<li><strong>대용량 데이터</strong>: 최대 1,000,000개의 전화번호 처리 필요</li>
<li><strong>효율성 요구</strong>: O(n²) 방식으로는 시간 초과 발생 가능</li>
</ol>
</section>
<section id="해결-방법별-분석" class="level2">
<h2 class="anchored" data-anchor-id="해결-방법별-분석">해결 방법별 분석</h2>
<section id="알고리즘-요약" class="level3">
<h3 class="anchored" data-anchor-id="알고리즘-요약">알고리즘 요약</h3>
<section id="핵심-아이디어" class="level4">
<h4 class="anchored" data-anchor-id="핵심-아이디어">핵심 아이디어</h4>
<p><strong>사전순 정렬 후 인접한 번호끼리만 비교</strong>하여 O(n log n) 시간에 모든 접두어 관계를 효율적으로 탐지</p>
</section>
<section id="알고리즘-동작" class="level4">
<h4 class="anchored" data-anchor-id="알고리즘-동작">알고리즘 동작</h4>
<ol type="1">
<li><strong>사전순 정렬</strong>: 전화번호를 문자열 기준으로 정렬</li>
<li><strong>인접 비교</strong>: 정렬된 배열에서 인접한 두 번호만 접두어 관계를 확인</li>
<li><strong>조기 종료</strong>: 접두어 관계를 발견하면 즉시 false를 반환</li>
</ol>
</section>
<section id="왜-효율적인가" class="level4">
<h4 class="anchored" data-anchor-id="왜-효율적인가">왜 효율적인가?</h4>
<p>정렬의 특성상 접두어 관계가 있다면 반드시 인접한 위치에 배치되므로, 모든 쌍을 비교할 필요가 없음</p>
</section>
<section id="핵심-포인트" class="level4">
<h4 class="anchored" data-anchor-id="핵심-포인트">핵심 포인트</h4>
<p><strong>“정렬된 상태에서 접두어는 반드시 인접하다”</strong>는 특성을 활용하여 O(n²) → O(n log n)로 시간복잡도를 획기적으로 개선</p>
</section>
</section>
<section id="정렬-방법-권장" class="level3">
<h3 class="anchored" data-anchor-id="정렬-방법-권장">정렬 방법 (권장)</h3>
<p><strong>시간복잡도</strong>: O(n log n)<br>
<strong>공간복잡도</strong>: O(log n)</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(phone_book):</span>
<span id="cb1-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 사전순 정렬 - O(n log n) 시간, O(log n) 공간(정렬 알고리즘 스택)</span></span>
<span id="cb1-3">    phone_book.sort()</span>
<span id="cb1-4">    </span>
<span id="cb1-5">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 인접한 번호끼리만 접두어 관계 확인 - O(n) 시간, O(1) 공간</span></span>
<span id="cb1-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(phone_book) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(n) 반복</span></span>
<span id="cb1-7">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># startswith 비교 - O(m) 시간 (m: 짧은 번호의 길이)</span></span>
<span id="cb1-8">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> phone_book[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>].startswith(phone_book[i]):</span>
<span id="cb1-9">            <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1) 시간, O(1) 공간</span></span>
<span id="cb1-10">    </span>
<span id="cb1-11">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1) 시간, O(1) 공간</span></span>
<span id="cb1-12"></span>
<span id="cb1-13"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전체 시간복잡도: O(n log n) + O(n * m) = O(n log n) (m &lt;&lt; log n 일반적)</span></span>
<span id="cb1-14"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전체 공간복잡도: O(log n) (정렬 알고리즘의 스택 공간)</span></span></code></pre></div>
<p><strong>동작 원리</strong>: - 사전순 정렬 후 인접한 번호끼리만 비교 - 정렬되어 있으면 접두어 관계는 반드시 인접한 위치에 존재 - 예: [“119”, “1195524421”, “97674223”] 정렬 시 “119”와 “1195524421”이 인접</p>
</section>
<section id="해시셋set-방법" class="level3">
<h3 class="anchored" data-anchor-id="해시셋set-방법">해시셋(Set) 방법</h3>
<p><strong>시간복잡도</strong>: O(n×m²) (n: 번호 개수, m: 평균 번호 길이)<br>
<strong>공간복잡도</strong>: O(n×m)</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(phone_book):</span>
<span id="cb2-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 모든 번호를 해시셋에 저장 - O(n) 시간, O(n * m) 공간</span></span>
<span id="cb2-3">    phone_set <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">set</span>(phone_book)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># n개 번호, 각 번호 평균 m자리</span></span>
<span id="cb2-4">    </span>
<span id="cb2-5">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 각 번호의 모든 접두어가 해시셋에 있는지 확인 - O(n * m) 시간</span></span>
<span id="cb2-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> phone <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> phone_book:  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(n) 반복</span></span>
<span id="cb2-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(phone)):  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(m) 반복 (m: 전화번호 길이)</span></span>
<span id="cb2-8">            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 슬라이싱 O(i), 해시셋 검색 O(1) 평균 → O(m) 최대</span></span>
<span id="cb2-9">            <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> phone[:i] <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> phone_set:</span>
<span id="cb2-10">                <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1) 시간, O(1) 공간</span></span>
<span id="cb2-11">    </span>
<span id="cb2-12">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1) 시간, O(1) 공간</span></span>
<span id="cb2-13"></span>
<span id="cb2-14"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전체 시간복잡도: O(n) + O(n * m^2) = O(n * m^2)</span></span>
<span id="cb2-15"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전체 공간복잡도: O(n * m) (해시셋 저장)</span></span></code></pre></div>
<p><strong>동작 원리</strong>: - 모든 전화번호를 해시셋에 저장 - 각 번호의 모든 가능한 접두어를 생성하여 해시셋에서 검색</p>
</section>
<section id="한-줄-해답-정렬-any-함수" class="level3">
<h3 class="anchored" data-anchor-id="한-줄-해답-정렬-any-함수">한 줄 해답 (정렬 + any 함수)</h3>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(phone_book):</span>
<span id="cb3-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 사전순 정렬 - O(n log n) 시간, O(log n) 공간</span></span>
<span id="cb3-3">    phone_book.sort()</span>
<span id="cb3-4">    </span>
<span id="cb3-5">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># any() 함수로 접두어 관계 확인 - O(n * m) 시간, O(1) 공간</span></span>
<span id="cb3-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">not</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">any</span>(  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># any(): 최악의 경우 O(n) 반복</span></span>
<span id="cb3-7">        phone_book[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>].startswith(phone_book[i])  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># startswith: O(m) 시간</span></span>
<span id="cb3-8">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(phone_book) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 제너레이터: O(1) 공간</span></span>
<span id="cb3-9">    )</span>
<span id="cb3-10"></span>
<span id="cb3-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전체 시간복잡도: O(n log n) + O(n * m) = O(n log n) (m &lt;&lt; log n 일반적)</span></span>
<span id="cb3-12"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전체 공간복잡도: O(log n) (정렬 알고리즘 스택) + O(1) (제너레이터) = O(log n)</span></span></code></pre></div>
</section>
</section>
<section id="복잡도-비교표" class="level2">
<h2 class="anchored" data-anchor-id="복잡도-비교표">복잡도 비교표</h2>
<table class="table">
<thead>
<tr class="header">
<th>방법</th>
<th>시간복잡도</th>
<th>공간복잡도</th>
<th>특징</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>정렬</td>
<td>O(n log n)</td>
<td>O(log n)</td>
<td><strong>가장 효율적, 메모리 절약</strong></td>
</tr>
<tr class="even">
<td>해시셋</td>
<td>O(n×m²)</td>
<td>O(n×m)</td>
<td>구현이 직관적</td>
</tr>
<tr class="odd">
<td>한 줄 해답</td>
<td>O(n log n)</td>
<td>O(log n)</td>
<td>코드가 간결</td>
</tr>
</tbody>
</table>
</section>
<section id="왜-정렬-방법이-최적인가" class="level2">
<h2 class="anchored" data-anchor-id="왜-정렬-방법이-최적인가">왜 정렬 방법이 최적인가?</h2>
<ol type="1">
<li><strong>핵심 아이디어</strong>: 사전순 정렬 시 접두어 관계는 반드시 인접한 위치에 존재</li>
<li><strong>시간 효율성</strong>: O(n log n) - 정렬 후 한 번의 순회만 필요</li>
<li><strong>공간 효율성</strong>: O(log n) - 정렬 알고리즘의 스택 공간만 사용</li>
<li><strong>단순함</strong>: 구현이 직관적이고 이해하기 쉬움</li>
</ol>
</section>
<section id="핵심-포인트-1" class="level2">
<h2 class="anchored" data-anchor-id="핵심-포인트-1">핵심 포인트</h2>
<ul>
<li><strong>정렬의 활용</strong>: 사전순 정렬로 비교 대상을 대폭 축소</li>
<li><strong>접두어 특성</strong>: A가 B의 접두어라면, 정렬 후 A는 B보다 앞에 위치</li>
<li><strong>최적화</strong>: 모든 쌍 비교(O(n²)) → 인접 비교(O(n))</li>
</ul>
<p>이 문제의 핵심은 <strong>“정렬을 통한 비교 대상 축소로 효율성을 극대화하는 것”</strong>입니다.</p>
</section>
<section id="예제별-동작-과정" class="level2">
<h2 class="anchored" data-anchor-id="예제별-동작-과정">예제별 동작 과정</h2>
<section id="예제-1-119-97674223-1195524421-결과-false" class="level3">
<h3 class="anchored" data-anchor-id="예제-1-119-97674223-1195524421-결과-false">예제 1: <code>["119", "97674223", "1195524421"]</code> → 결과: false</h3>
<p><strong>정렬 방법</strong>: 1. 사전순 정렬: <code>["119", "1195524421", "97674223"]</code> 2. 인접 비교: - “119”와 “1195524421”: <code>"1195524421".startswith("119")</code> → True - 접두어 관계 발견! → <strong>답: false</strong></p>
</section>
<section id="예제-2-123-456-789-결과-true" class="level3">
<h3 class="anchored" data-anchor-id="예제-2-123-456-789-결과-true">예제 2: <code>["123", "456", "789"]</code> → 결과: true</h3>
<p><strong>정렬 방법</strong>: 1. 사전순 정렬: <code>["123", "456", "789"]</code> (이미 정렬됨) 2. 인접 비교: - “123”과 “456”: <code>"456".startswith("123")</code> → False - “456”과 “789”: <code>"789".startswith("456")</code> → False - 접두어 관계 없음 → <strong>답: true</strong></p>
</section>
<section id="예제-3-12-123-1235-567-88-결과-false" class="level3">
<h3 class="anchored" data-anchor-id="예제-3-12-123-1235-567-88-결과-false">예제 3: <code>["12", "123", "1235", "567", "88"]</code> → 결과: false</h3>
<p><strong>정렬 방법</strong>: 1. 사전순 정렬: <code>["12", "123", "1235", "567", "88"]</code> 2. 인접 비교: - “12”와 “123”: <code>"123".startswith("12")</code> → True - 접두어 관계 발견! → <strong>답: false</strong></p>


</section>
</section>
</section>

 ]]></description>
  <category>Algorithm Test</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Code_Test/algorithm/hash_level2_phone_number.html</guid>
  <pubDate>Invalid Date</pubDate>
</item>
<item>
  <title>Data Science Content List</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Data_Science/content.list.html</link>
  <description><![CDATA[ 




<section id="문제-정의-모델-선택-역량" class="level2" data-number="1">

<section id="비즈니스-문제-분석" class="level3" data-number="1.1">

<ul>
<li>문제 유형 분류 (분류/회귀/생성/검색/최적화)</li>
<li>ROI 계산 및 성공 지표 정의</li>
<li>데이터 가용성 vs 모델 요구사항 분석</li>
<li>기술적 제약사항 파악 (지연시간, 정확도, 비용)</li>
</ul>
</section>
<section id="모델-생태계-이해" class="level3" data-number="1.2">

<ul>
<li>Hugging Face Hub 활용: 모델 탐색, 벤치마크 해석</li>
<li>Foundation Models 맵핑: GPT-4, Claude, Llama, Mistral 등 특성</li>
<li>Computer Vision: CLIP, SAM, YOLO, ViT 계열</li>
<li>테이블형 데이터: AutoML vs 전통 ML 판단 기준</li>
</ul>
</section>
<section id="모델-성능-평가" class="level3" data-number="1.3">

<ul>
<li>벤치마크 해석 (BLEU, ROUGE, MMLU, HellaSwag 등)</li>
<li>도메인별 평가 지표 설계</li>
<li>A/B 테스트 설계 원칙</li>
<li>비용-성능 트레이드오프 분석</li>
</ul>
</section>
</section>
<section id="fine-tuning-api-활용---langchain" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="fine-tuning-api-활용---langchain"><span class="header-section-number">2</span> Fine-tuning &amp; API 활용 - LangChain</h2>
<section id="llm-fine-tuning-전략" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="llm-fine-tuning-전략"><span class="header-section-number">2.1</span> LLM Fine-tuning 전략</h3>
<ul>
<li>Parameter-Efficient Fine-tuning: LoRA, QLoRA, Adapter</li>
<li>Instruction Tuning: 태스크별 프롬프트 데이터셋 구축</li>
<li>RLHF 개념: 인간 피드백 활용 방법론</li>
<li>도메인 적응: 의료, 법률, 금융 등 특화 모델 구축</li>
</ul>
</section>
<section id="api-활용-및-최적화" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="api-활용-및-최적화"><span class="header-section-number">2.2</span> API 활용 및 최적화</h3>
<ul>
<li>OpenAI API: GPT-4, Fine-tuning, Assistants API</li>
<li>Anthropic Claude: Constitutional AI, Function Calling</li>
<li>오픈소스 API: Ollama, vLLM, Text Generation Inference</li>
<li>멀티모달 API: GPT-4V, Claude-3, Gemini 활용</li>
</ul>
</section>
<section id="프롬프트-엔지니어링" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="프롬프트-엔지니어링"><span class="header-section-number">2.3</span> 프롬프트 엔지니어링</h3>
<ul>
<li>Few-shot Learning 전략</li>
<li>Chain-of-Thought, Tree-of-Thought</li>
<li>프롬프트 최적화 도구 (DSPy, Guidance)</li>
<li>프롬프트 보안 (Jailbreaking 방지)</li>
</ul>
</section>
</section>
<section id="시스템-통합-아키텍처---langchain" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="시스템-통합-아키텍처---langchain"><span class="header-section-number">3</span> 시스템 통합 &amp; 아키텍처 - LangChain</h2>
<section id="ai-애플리케이션-아키텍처" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="ai-애플리케이션-아키텍처"><span class="header-section-number">3.1</span> AI 애플리케이션 아키텍처</h3>
<ul>
<li>RAG 시스템 설계: Vector DB, Embedding, Retrieval 전략</li>
<li>Agent Framework: LangChain, CrewAI, AutoGen</li>
<li>워크플로우 엔진: 복잡한 AI 태스크 체이닝</li>
<li>멀티모달 파이프라인: 텍스트+이미지+음성 통합</li>
</ul>
</section>
<section id="벡터-데이터베이스-검색" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="벡터-데이터베이스-검색"><span class="header-section-number">3.2</span> 벡터 데이터베이스 &amp; 검색</h3>
<ul>
<li>Vector DB: Pinecone, Weaviate, Chroma, FAISS</li>
<li>Embedding 전략: 텍스트, 이미지, 코드 임베딩</li>
<li>하이브리드 검색: 키워드 + 시맨틱 검색 결합</li>
<li>검색 성능 최적화: 인덱싱, 캐싱 전략</li>
</ul>
</section>
<section id="모델-서빙-인프라" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="모델-서빙-인프라"><span class="header-section-number">3.3</span> 모델 서빙 &amp; 인프라</h3>
<ul>
<li>모델 서빙: TorchServe, TensorFlow Serving, vLLM</li>
<li>로드 밸런싱: 모델별 트래픽 분산</li>
<li>캐싱 전략: 응답 캐시, 임베딩 캐시</li>
<li>비용 최적화: GPU 사용량, API 호출 최적화</li>
</ul>
</section>
</section>
<section id="운영-mlops---langchain" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="운영-mlops---langchain"><span class="header-section-number">4</span> 운영 &amp; MLOps - LangChain</h2>
<section id="모델-모니터링" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="모델-모니터링"><span class="header-section-number">4.1</span> 모델 모니터링</h3>
<ul>
<li>성능 드리프트: 입력 분포 변화 감지</li>
<li>출력 품질 모니터링: 응답 길이, 독성 탐지, 할루시네이션</li>
<li>사용자 피드백: 만족도, 정확도 추적</li>
<li>비용 모니터링: 토큰 사용량, API 비용 추적</li>
</ul>
</section>
<section id="ab-테스트-실험" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="ab-테스트-실험"><span class="header-section-number">4.2</span> A/B 테스트 &amp; 실험</h3>
<ul>
<li>모델 비교: 다양한 모델/프롬프트 성능 비교</li>
<li>점진적 롤아웃: Canary 배포, Blue-Green 배포</li>
<li>실험 설계: 통계적 유의성, 표본 크기 계산</li>
<li>결과 분석: 비즈니스 메트릭 vs 기술 메트릭</li>
</ul>
</section>
<section id="거버넌스-윤리" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="거버넌스-윤리"><span class="header-section-number">4.3</span> 거버넌스 &amp; 윤리</h3>
<ul>
<li>AI 안전성: Content Filtering, Bias 탐지</li>
<li>데이터 프라이버시: PII 마스킹, GDPR 준수</li>
<li>모델 해석성: LIME, SHAP 등 설명 가능 AI</li>
<li>규제 준수: AI Act, 금융/의료 규제 대응</li>
</ul>
</section>
</section>
<section id="고급-통합-자동화---langchain-일부-커버" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="고급-통합-자동화---langchain-일부-커버"><span class="header-section-number">5</span> 고급 통합 &amp; 자동화 - LangChain 일부 커버</h2>
<section id="automl-모델-자동화" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="automl-모델-자동화"><span class="header-section-number">5.1</span> AutoML &amp; 모델 자동화</h3>
<ul>
<li>AutoML 플랫폼: H2O.ai, DataRobot, AutoGluon</li>
<li>하이퍼파라미터 최적화: Optuna, Ray Tune</li>
<li>뉴럴 아키텍처 서치: 모델 구조 자동 탐색</li>
<li>모델 압축: Pruning, Quantization, Distillation</li>
</ul>
</section>
<section id="고급-ai-패턴" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="고급-ai-패턴"><span class="header-section-number">5.2</span> 고급 AI 패턴</h3>
<ul>
<li>Multi-Agent Systems: 협업하는 AI 에이전트</li>
<li>Tool-Using AI: 외부 도구/API 활용하는 AI</li>
<li>Self-Improving Systems: 피드백 기반 자동 개선</li>
<li>Federated Learning: 분산 학습 시스템</li>
</ul>
</section>
</section>
<section id="실습-프로젝트-로드맵" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="실습-프로젝트-로드맵"><span class="header-section-number">6</span> 실습 프로젝트 로드맵</h2>
<section id="초급" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="초급"><span class="header-section-number">6.1</span> 초급</h3>
<ol type="1">
<li><strong>문서 QA 시스템</strong>: RAG + OpenAI API</li>
<li><strong>이미지 분류 API</strong>: Pre-trained Vision 모델 + FastAPI</li>
</ol>
</section>
<section id="중급" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="중급"><span class="header-section-number">6.2</span> 중급</h3>
<ol start="3" type="1">
<li><strong>커스텀 챗봇</strong>: Fine-tuned LLM + 벡터DB</li>
<li><strong>멀티모달 검색</strong>: 텍스트+이미지 통합 검색</li>
</ol>
</section>
<section id="고급" class="level3" data-number="6.3">
<h3 data-number="6.3" class="anchored" data-anchor-id="고급"><span class="header-section-number">6.3</span> 고급</h3>
<ol start="5" type="1">
<li><strong>AI 에이전트 시스템</strong>: 복잡한 태스크 자동화</li>
<li><strong>A/B 테스트 플랫폼</strong>: 모델 성능 비교 시스템</li>
</ol>


</section>
</section>

 ]]></description>
  <category>Data Science</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Data_Science/content.list.html</guid>
  <pubDate>Sat, 31 May 2025 15:00:00 GMT</pubDate>
</item>
</channel>
</rss>
