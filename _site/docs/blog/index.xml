<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Kwangmin Kim</title>
<link>kk3225.netlify.app/docs/blog/</link>
<atom:link href="kk3225.netlify.app/docs/blog/index.xml" rel="self" type="application/rss+xml"/>
<description>blog</description>
<generator>quarto-1.4.543</generator>
<lastBuildDate>Tue, 31 Dec 2109 15:00:00 GMT</lastBuildDate>
<item>
  <title>Data Governance</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Governance/</link>
  <description><![CDATA[ 





<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="kk3225.netlify.app/images/governance/data_governance.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Governance</figcaption>
</figure>
</div>
<section id="data-governance" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Data Governance</h1>
<section id="data-governance-basic-concept" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="data-governance-basic-concept"><span class="header-section-number">1.1</span> Data Governance Basic Concept</h2>
<ul>
<li>2024-08-01, <a href="../../../../docs/blog/posts/Governance/1.basis.html">Data Governance Basic Concepts, 거버넌스 기본 개념</a></li>
<li>2024-08-02, <a href="../../../../docs/blog/posts/Governance/2.task_process.html">Task Process, 업무 절차</a></li>
<li>2024-08-03, <a href="../../../../docs/blog/posts/Governance/3.architetucre.html">Data Architecture, 구조관리</a></li>
<li>0000-00-00, [Data Pipeline Design, 파이프라인 설계]</li>
<li>0000-00-00, [Data Storage, 저장소 관리]</li>
<li>0000-00-00, [Data Management Policy, 데이터 관리 정책]</li>
<li>0000-00-00, [Data Stewardship Model, 데이터 관리 모델]</li>
</ul>
</section>
<section id="data-modeling" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="data-modeling"><span class="header-section-number">1.2</span> Data Modeling</h2>
<ul>
<li>2024-08-04, <a href="../../../../docs/blog/posts/Governance/4-0.data_model.html">Data Model (1) - Basic Concept</a></li>
<li>2024-08-05, <a href="../../../../docs/blog/posts/Governance/4-1.data_model_database.html">Data Model (2) - Database Basis</a></li>
<li>2024-08-06, <a href="../../../../docs/blog/posts/Governance/4-2.data_model_sql.html">Data Model (3) - SQL Concept</a></li>
<li>2024-08-07, <a href="../../../../docs/blog/posts/Governance/4-3.data_model_schema.html">Data Model (4) - DB Design</a></li>
<li>2024-08-08, <a href="../../../../docs/blog/posts/Governance/4-4.data_model_requirements.html">Data Model (5) - Requirement Collection</a></li>
<li>2024-08-09, <a href="../../../../docs/blog/posts/Governance/4-5-0.data_model_conceptual.html">Data Model (6) - Conceptual Design</a></li>
<li>2024-08-10, <a href="../../../../docs/blog/posts/Governance/4-5-1.data_model_conceptual_ER_model.html">Data Model (7) - ER Modeling</a></li>
</ul>
<section id="data-standardization" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="data-standardization"><span class="header-section-number">1.2.1</span> Data Standardization</h3>
<ul>
<li>2024-08-11, <a href="../../../../docs/blog/posts/Governance/5-0-0.data_standard.html">Data Standardization - Basic Concept</a></li>
<li>2024-08-12, <a href="../../../../docs/blog/posts/Governance/5-0-1.stndrdztn_rule.ver1.0.0.html">Data Standardization - Standard Rules</a></li>
<li>2024-11-25, <a href="../../../../docs/blog/posts/Governance/5-0-2.terminology_hierarchy.html">Data Standardization - 용어 정리</a></li>
<li>2024-08-12, <a href="../../../../docs/blog/posts/Governance/5-1.data_word_dictionary.html">Data Standardization - 표준 단어 사전</a></li>
<li>2024-08-13, <a href="../../../../docs/blog/posts/Governance/5-2.data_word_domain.html">Data Standardization - 표준 도메인 사전</a></li>
<li>2024-08-14, <a href="../../../../docs/blog/posts/Governance/5-3.data_word_glossary.html">Data Standardization - 표준 용어 사전</a></li>
<li>2024-08-15, <a href="../../../../docs/blog/posts/Governance/5-4.data_code.html">Data Standardization - 표준 코드</a></li>
<li>2024-08-16, <a href="../../../../docs/blog/posts/Governance/6-0.data_registration_process.html">Data Standardization - 등록 프로세스</a></li>
<li>2024-08-17, <a href="../../../../docs/blog/posts/Governance/6-1.data_review_process.html">Data Standardization - 용어 검토 프로세스</a></li>
<li>2024-08-18, <a href="../../../../docs/blog/posts/Governance/6-2.data_code_registration.html">Data Standardization - 코드 등록 프로세스</a></li>
<li>2024-08-19, <a href="../../../../docs/blog/posts/Governance/8-0.data_quality_measures.html">Data Standardization - 데이터 품질 측정</a></li>
</ul>
</section>
<section id="data-quality" class="level3" data-number="1.2.2">
<h3 data-number="1.2.2" class="anchored" data-anchor-id="data-quality"><span class="header-section-number">1.2.2</span> Data Quality</h3>
<ul>
<li>0000-00-00, [Data Quality Control Process, 데이터 품질 절차]</li>
<li>0000-00-00, [Data Quality Measurement, 데이터 품질 측정]</li>
<li>0000-00-00, [Data Validation, 데이터 품질 검증]</li>
</ul>
</section>
<section id="etc." class="level3" data-number="1.2.3">
<h3 data-number="1.2.3" class="anchored" data-anchor-id="etc."><span class="header-section-number">1.2.3</span> etc.</h3>
<ul>
<li>0000-00-00, [Data Governance Solutions, 데이터 관리 솔루션]</li>
<li>0000-00-00, [Metadata Management, 메타데이터 관리]</li>
<li>0000-00-00, [Data Integration, 데이터 통합]</li>
<li>0000-00-00, [Data Security, 데이터 보안]</li>
</ul>


</section>
</section>
</section>

 ]]></description>
  <category>Data Governance</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Governance/</guid>
  <pubDate>Tue, 31 Dec 2109 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Epidemiology</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Experimentation/Epidemiology/</link>
  <description><![CDATA[ 





<section id="contents" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Contents</h1>
<section id="learning-path-for-experimentation" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="learning-path-for-experimentation"><span class="header-section-number">1.1</span> Learning Path for Experimentation</h2>
<p><strong>Priority Topics for Experimentation:</strong> 1. <strong>Experimental Studies → RCT</strong> (A/B Testing 직접 원형) 2. <strong>Causal Inference</strong> (전체 섹션 - 실험의 이론적 기초) 3. <strong>Effect Modification</strong> (Heterogeneous Treatment Effects) 4. <strong>Sample Size and Power</strong> (실험 설계 필수) 5. <strong>Propensity Score Methods</strong> (Observational causal inference)</p>
<p><strong>Recommended Study Order:</strong></p>
<p>Phase 1 (1-2주): Foundations + Study Designs → Focus on RCT and experimental principles</p>
<p>Phase 2 (1주): Measures of Association and Impact → Effect measures calculation practice</p>
<p>Phase 3 (2주): Causal Inference ⭐ → DAG practice, Counterfactual framework → Most critical for experimentation</p>
<p>Phase 4 (1주): Bias and Confounding + Study Fundamentals → Sample size calculations → Validity considerations</p>
<p>Phase 5 (선택): Advanced Topics → As needed for specific applications</p>
</section>
<section id="foundations" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="foundations"><span class="header-section-number">1.2</span> Foundations</h2>
<ul>
<li>1111-11-11, <a href="./foundations/concepts.qmd">Epidemiologic Concepts</a>
<ul>
<li>1111-11-11, <a href="./foundations/incidence_prevalence.qmd">Incidence vs.&nbsp;Prevalence (발생률 vs.&nbsp;유병률)</a></li>
<li>1111-11-11, <a href="./foundations/population_at_risk.qmd">Population at Risk (위험인구)</a></li>
<li>1111-11-11, <a href="./foundations/exposure_outcome.qmd">Exposure and Outcome (노출과 결과)</a></li>
</ul></li>
<li>1111-11-11, <a href="./foundations/framework.qmd">Study Design Framework (연구설계 프레임워크)</a>
<ul>
<li>1111-11-11, <a href="./foundations/descriptive_analytical.qmd">Descriptive vs.&nbsp;Analytical Studies (기술 vs.&nbsp;분석 연구)</a></li>
<li>1111-11-11, <a href="./foundations/observational_experimental.qmd">Observational vs.&nbsp;Experimental Studies (관찰 vs.&nbsp;실험 연구)</a></li>
<li>1111-11-11, <a href="./foundations/time_relationship.qmd">Time Relationship (시간적 관계)</a></li>
</ul></li>
</ul>
</section>
<section id="study-designs" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="study-designs"><span class="header-section-number">1.3</span> Study Designs</h2>
<ul>
<li>2023-02-27, Types of Study Designs in Epidemiology
<ul>
<li>1111-11-11, Descriptive Studies (기술연구)
<ul>
<li>1111-11-11, <a href="./descriptive/case_reports.qmd">Case Reports and Case Series (증례보고 및 증례군)</a></li>
<li>1111-11-11, <a href="./descriptive/ecological.qmd">Ecological Studies (생태학적 연구)</a></li>
</ul></li>
<li>1111-11-11, Observational Analytical Studies (관찰 분석연구)
<ul>
<li>1111-11-11, <a href="./observational/cross_sectional.qmd">Cross-sectional Studies (단면연구)</a></li>
<li>1111-11-11, <a href="./observational/case_control.qmd">Case-control Studies (환자-대조군 연구)</a></li>
<li>1111-11-11, <a href="./observational/cohort.qmd">Cohort Studies (코호트 연구)</a>
<ul>
<li>1111-11-11, <a href="./observational/cohort_prospective.qmd">Prospective Cohort (전향적 코호트)</a></li>
<li>1111-11-11, <a href="./observational/cohort_retrospective.qmd">Retrospective Cohort (후향적 코호트)</a></li>
</ul></li>
</ul></li>
<li>1111-11-11, Experimental Studies (실험연구) ⭐
<ul>
<li>1111-11-11, <a href="./experimental/rct.qmd">Randomized Controlled Trial (무작위 대조 시험)</a> ⭐</li>
<li>1111-11-11, <a href="./experimental/quasi_experimental.qmd">Quasi-experimental Studies (준실험 연구)</a></li>
<li>1111-11-11, <a href="./experimental/before_after.qmd">Before-after Studies (전후 연구)</a></li>
<li>1111-11-11, <a href="./experimental/factorial_design.qmd">Factorial Design (요인 설계)</a></li>
</ul></li>
<li>1111-11-11, Evidence Synthesis (근거 통합)
<ul>
<li>1111-11-11, <a href="./synthesis/systematic_review.qmd">Systematic Reviews (체계적 문헌고찰)</a></li>
<li>1111-11-11, <a href="./synthesis/meta_analysis.qmd">Meta-analyses (메타분석)</a></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="measures-of-association-and-impact" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="measures-of-association-and-impact"><span class="header-section-number">1.4</span> Measures of Association and Impact</h2>
<ul>
<li>2023-05-23, <a href="./measures_overview.qmd">Measures in Epidemiology</a>
<ul>
<li>1111-11-11, Contingency Tables and Basic Measures (분할표와 기본 측정)
<ul>
<li>1111-11-11, <a href="./measures/contingency_table.qmd">2x2 Contingency Tables (2x2 분할표)</a></li>
<li>1111-11-11, <a href="./measures/risk_rate_odds.qmd">Risk, Rate, and Odds (위험, 비율, 오즈)</a></li>
</ul></li>
<li>1111-11-11, Measures of Association (연관성 지표)
<ul>
<li>1111-11-11, <a href="./measures/relative_risk.qmd">Relative Risk (상대위험도)</a></li>
<li>1111-11-11, <a href="./measures/odds_ratio.qmd">Odds Ratio (오즈비)</a></li>
<li>1111-11-11, <a href="./measures/rate_ratio.qmd">Rate Ratio (비율비)</a></li>
</ul></li>
<li>1111-11-11, Measures of Effect (효과 지표)
<ul>
<li>1111-11-11, <a href="./measures/risk_difference.qmd">Risk Difference (위험차이)</a></li>
<li>1111-11-11, <a href="./measures/rrr.qmd">Relative Risk Reduction (상대위험감소)</a></li>
<li>1111-11-11, <a href="./measures/arr.qmd">Absolute Risk Reduction (절대위험감소)</a></li>
<li>1111-11-11, <a href="./measures/nnt.qmd">Number Needed to Treat (치료필요수)</a></li>
</ul></li>
<li>1111-11-11, Measures of Impact (영향 지표)
<ul>
<li>1111-11-11, <a href="./measures/attributable_risk.qmd">Attributable Risk (기여위험도)</a></li>
<li>1111-11-11, <a href="./measures/ar_percent.qmd">Attributable Risk Percent (기여위험분율)</a></li>
<li>1111-11-11, <a href="./measures/population_attributable_risk.qmd">Population Attributable Risk (인구기여위험도)</a></li>
<li>1111-11-11, <a href="./measures/par_percent.qmd">Population Attributable Risk Percent (인구기여위험분율)</a></li>
</ul></li>
<li>1111-11-11, Statistical Inference (통계적 추론)
<ul>
<li>1111-11-11, <a href="./measures/confidence_intervals.qmd">Confidence Intervals (신뢰구간)</a></li>
<li>1111-11-11, <a href="./measures/hypothesis_testing.qmd">Hypothesis Testing (가설 검정)</a></li>
<li>1111-11-11, <a href="./measures/p_values.qmd">p-values and Interpretation (p-값과 해석)</a></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="causal-inference" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="causal-inference"><span class="header-section-number">1.5</span> Causal Inference ⭐</h2>
<ul>
<li>1111-11-11, <a href="./causation/index.qmd">Causation in Epidemiology (역학에서의 인과관계)</a>
<ul>
<li>1111-11-11, Causation Concepts (인과관계 개념)
<ul>
<li>1111-11-11, <a href="./causation/necessary_sufficient.qmd">Necessary vs.&nbsp;Sufficient Causes (필요조건 vs.&nbsp;충분조건)</a></li>
<li>1111-11-11, <a href="./causation/component_causes.qmd">Component Causes (구성요인)</a></li>
<li>1111-11-11, <a href="./causation/induction_period.qmd">Induction Period (유도기간)</a></li>
</ul></li>
<li>1111-11-11, <a href="./causation/bradford_hill.qmd">Bradford Hill Criteria (Bradford Hill 기준)</a>
<ul>
<li>1111-11-11, <a href="./causation/strength.qmd">Strength of Association (연관성의 강도)</a></li>
<li>1111-11-11, <a href="./causation/consistency.qmd">Consistency and Replication (일관성과 재현성)</a></li>
<li>1111-11-11, <a href="./causation/specificity.qmd">Specificity (특이성)</a></li>
<li>1111-11-11, <a href="./causation/temporality.qmd">Temporality (시간적 선후관계)</a></li>
<li>1111-11-11, <a href="./causation/dose_response.qmd">Biological Gradient (생물학적 기울기)</a></li>
<li>1111-11-11, <a href="./causation/plausibility.qmd">Plausibility and Coherence (개연성과 일관성)</a></li>
<li>1111-11-11, <a href="./causation/experiment_analogy.qmd">Experiment and Analogy (실험과 유추)</a></li>
</ul></li>
<li>1111-11-11, <a href="./causation/counterfactual.qmd">Counterfactual Framework (반사실적 프레임워크)</a> ⭐
<ul>
<li>1111-11-11, <a href="./causation/potential_outcomes.qmd">Potential Outcomes (잠재결과)</a></li>
<li>1111-11-11, <a href="./causation/ate.qmd">Average Treatment Effect (평균 처치효과)</a></li>
<li>1111-11-11, <a href="./causation/sutva.qmd">SUTVA (안정단위처치값 가정)</a></li>
</ul></li>
<li>1111-11-11, <a href="./causation/dag.qmd">Directed Acyclic Graphs (방향성 비순환 그래프)</a> ⭐
<ul>
<li>1111-11-11, <a href="./causation/causal_pathways.qmd">Causal Pathways (인과 경로)</a></li>
<li>1111-11-11, <a href="./causation/confounding_paths.qmd">Confounding Paths (교란 경로)</a></li>
<li>1111-11-11, <a href="./causation/colliders.qmd">Colliders and Selection Bias (충돌자와 선택 편향)</a></li>
<li>1111-11-11, <a href="./causation/d_separation.qmd">d-separation (d-분리)</a></li>
</ul></li>
<li>1111-11-11, <a href="./causation/propensity_score.qmd">Propensity Score Methods (성향점수 방법)</a>
<ul>
<li>1111-11-11, <a href="./causation/ps_matching.qmd">Propensity Score Matching (성향점수 매칭)</a></li>
<li>1111-11-11, <a href="./causation/iptw.qmd">Inverse Probability Weighting (역확률 가중)</a></li>
<li>1111-11-11, <a href="./causation/ps_stratification.qmd">Propensity Score Stratification (성향점수 층화)</a></li>
<li>1111-11-11, <a href="./causation/ps_adjustment.qmd">Covariate Adjustment (공변량 조정)</a></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="bias-and-confounding" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="bias-and-confounding"><span class="header-section-number">1.6</span> Bias and Confounding</h2>
<ul>
<li>1111-11-11, <a href="./bias/index.qmd">Bias in Epidemiologic Studies (역학 연구의 편향)</a>
<ul>
<li>1111-11-11, Types of Bias (편향의 종류)
<ul>
<li>1111-11-11, <a href="./bias/selection_bias.qmd">Selection Bias (선택 편향)</a></li>
<li>1111-11-11, <a href="./bias/information_bias.qmd">Information Bias (정보 편향)</a></li>
<li>1111-11-11, <a href="./bias/misclassification.qmd">Misclassification Bias (오분류 편향)</a>
<ul>
<li>1111-11-11, <a href="./bias/nondifferential.qmd">Non-differential Misclassification (비차별적 오분류)</a></li>
<li>1111-11-11, <a href="./bias/differential.qmd">Differential Misclassification (차별적 오분류)</a></li>
</ul></li>
</ul></li>
</ul></li>
<li>1111-11-11, <a href="./confounding/index.qmd">Confounding (교란)</a>
<ul>
<li>1111-11-11, <a href="./confounding/definition.qmd">Definition and Criteria (정의와 기준)</a></li>
<li>1111-11-11, <a href="./confounding/positive_negative.qmd">Positive vs.&nbsp;Negative Confounding (양성 vs.&nbsp;음성 교란)</a></li>
<li>1111-11-11, <a href="./confounding/residual.qmd">Residual Confounding (잔여 교란)</a></li>
</ul></li>
<li>1111-11-11, <a href="./effect_modification/index.qmd">Effect Modification (효과 수정)</a> ⭐
<ul>
<li>1111-11-11, <a href="./effect_modification/vs_confounding.qmd">vs.&nbsp;Confounding (교란과의 구분)</a></li>
<li>1111-11-11, <a href="./effect_modification/statistical_interaction.qmd">Statistical Interaction (통계적 상호작용)</a></li>
<li>1111-11-11, <a href="./effect_modification/biological_interaction.qmd">Biological Interaction (생물학적 상호작용)</a></li>
</ul></li>
<li>1111-11-11, <a href="./control/index.qmd">Control Methods (통제 방법)</a>
<ul>
<li>1111-11-11, Design Stage Methods (설계 단계 방법)
<ul>
<li>1111-11-11, <a href="./control/restriction.qmd">Restriction (제한)</a></li>
<li>1111-11-11, <a href="./control/matching.qmd">Matching (매칭)</a></li>
</ul></li>
<li>1111-11-11, Analysis Stage Methods (분석 단계 방법)
<ul>
<li>1111-11-11, <a href="./control/stratification.qmd">Stratification Analysis (층화 분석)</a></li>
<li>1111-11-11, <a href="./control/standardization.qmd">Standardization (표준화)</a></li>
<li>1111-11-11, <a href="./control/regression_adjustment.qmd">Regression Adjustment (회귀 조정)</a></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="study-design-fundamentals" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="study-design-fundamentals"><span class="header-section-number">1.7</span> Study Design Fundamentals</h2>
<ul>
<li>1111-11-11, <a href="./fundamentals/sample_size_power.qmd">Sample Size and Power (표본 크기와 검정력)</a> ⭐
<ul>
<li>1111-11-11, <a href="./fundamentals/type1_error.qmd">Type I Error (1종 오류, α)</a></li>
<li>1111-11-11, <a href="./fundamentals/type2_error.qmd">Type II Error (2종 오류, β)</a></li>
<li>1111-11-11, <a href="./fundamentals/power.qmd">Statistical Power (통계적 검정력, 1-β)</a></li>
<li>1111-11-11, <a href="./fundamentals/effect_size.qmd">Effect Size (효과 크기)</a></li>
<li>1111-11-11, <a href="./fundamentals/sample_size_calc.qmd">Sample Size Calculation (표본 크기 계산)</a></li>
</ul></li>
<li>1111-11-11, <a href="./fundamentals/randomization.qmd">Randomization Methods (무작위 배정 방법)</a>
<ul>
<li>1111-11-11, <a href="./fundamentals/simple_random.qmd">Simple Randomization (단순 무작위배정)</a></li>
<li>1111-11-11, <a href="./fundamentals/block_random.qmd">Block Randomization (블록 무작위배정)</a></li>
<li>1111-11-11, <a href="./fundamentals/stratified_random.qmd">Stratified Randomization (층화 무작위배정)</a></li>
</ul></li>
<li>1111-11-11, <a href="./fundamentals/validity.qmd">Validity in Epidemiologic Studies (역학 연구의 타당도)</a>
<ul>
<li>1111-11-11, <a href="./fundamentals/internal_validity.qmd">Internal Validity (내적 타당도)</a></li>
<li>1111-11-11, <a href="./fundamentals/external_validity.qmd">External Validity (외적 타당도)</a></li>
<li>1111-11-11, <a href="./fundamentals/construct_validity.qmd">Construct Validity (구성 타당도)</a></li>
</ul></li>
</ul>
</section>
<section id="screening-and-diagnostic-tests" class="level2" data-number="1.8">
<h2 data-number="1.8" class="anchored" data-anchor-id="screening-and-diagnostic-tests"><span class="header-section-number">1.8</span> Screening and Diagnostic Tests</h2>
<ul>
<li>1111-11-11, <a href="./screening/index.qmd">Evaluation of Diagnostic Tests (진단검사 평가)</a>
<ul>
<li>1111-11-11, Test Performance Measures (검사 성능 지표)
<ul>
<li>1111-11-11, <a href="./screening/sensitivity.qmd">Sensitivity (민감도, True Positive Rate)</a></li>
<li>1111-11-11, <a href="./screening/specificity.qmd">Specificity (특이도, True Negative Rate)</a></li>
<li>1111-11-11, <a href="./screening/ppv.qmd">Positive Predictive Value (양성 예측도, PPV)</a></li>
<li>1111-11-11, <a href="./screening/npv.qmd">Negative Predictive Value (음성 예측도, NPV)</a></li>
</ul></li>
<li>1111-11-11, <a href="./screening/likelihood_ratios.qmd">Likelihood Ratios (우도비)</a>
<ul>
<li>1111-11-11, <a href="./screening/lr_positive.qmd">Positive Likelihood Ratio (양성 우도비, LR+)</a></li>
<li>1111-11-11, <a href="./screening/lr_negative.qmd">Negative Likelihood Ratio (음성 우도비, LR-)</a></li>
<li>1111-11-11, <a href="./screening/pretest_posttest.qmd">Pre-test to Post-test Probability (사전-사후 확률)</a></li>
</ul></li>
<li>1111-11-11, Trade-offs and Optimization (상충관계와 최적화)
<ul>
<li>1111-11-11, <a href="./screening/roc_curve.qmd">ROC Curve (ROC 곡선)</a></li>
<li>1111-11-11, <a href="./screening/auc.qmd">Area Under Curve (곡선하면적, AUC)</a></li>
<li>1111-11-11, <a href="./screening/cutpoint.qmd">Optimal Cut-point Selection (최적 절단값 선택)</a></li>
</ul></li>
<li>1111-11-11, <a href="./screening/bayesian.qmd">Bayesian Interpretation (베이지안 해석)</a>
<ul>
<li>1111-11-11, <a href="./screening/bayes_theorem.qmd">Bayes’ Theorem Connection (베이즈 정리와의 연결)</a></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="survival-analysis" class="level2" data-number="1.9">
<h2 data-number="1.9" class="anchored" data-anchor-id="survival-analysis"><span class="header-section-number">1.9</span> Survival Analysis</h2>
<ul>
<li>1111-11-11, <a href="./survival/index.qmd">Time-to-Event Analysis (시간-사건 분석)</a>
<ul>
<li>1111-11-11, Basic Concepts (기본 개념)
<ul>
<li>1111-11-11, <a href="./survival/censoring.qmd">Censoring (중도절단)</a></li>
<li>1111-11-11, <a href="./survival/survival_function.qmd">Survival Function (생존함수)</a></li>
<li>1111-11-11, <a href="./survival/hazard_function.qmd">Hazard Function (위험함수)</a></li>
</ul></li>
<li>1111-11-11, <a href="./survival/kaplan_meier.qmd">Kaplan-Meier Method (Kaplan-Meier 방법)</a>
<ul>
<li>1111-11-11, <a href="./survival/nonparametric.qmd">Non-parametric Estimation (비모수 추정)</a></li>
<li>1111-11-11, <a href="./survival/logrank_test.qmd">Log-rank Test (로그순위 검정)</a></li>
</ul></li>
<li>1111-11-11, <a href="./survival/cox_model.qmd">Cox Proportional Hazards Model (Cox 비례위험모형)</a>
<ul>
<li>1111-11-11, <a href="./survival/semiparametric.qmd">Semi-parametric Model (준모수 모형)</a></li>
<li>1111-11-11, <a href="./survival/hazard_ratio.qmd">Hazard Ratio (위험비)</a></li>
<li>1111-11-11, <a href="./survival/ph_assumption.qmd">Proportional Hazards Assumption (비례위험 가정)</a></li>
</ul></li>
<li>1111-11-11, Advanced Survival Topics (고급 생존분석 주제)
<ul>
<li>1111-11-11, <a href="./survival/competing_risks.qmd">Competing Risks (경쟁위험)</a></li>
<li>1111-11-11, <a href="./survival/recurrent_events.qmd">Recurrent Events (반복사건)</a></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="advanced-topics" class="level2" data-number="1.10">
<h2 data-number="1.10" class="anchored" data-anchor-id="advanced-topics"><span class="header-section-number">1.10</span> Advanced Topics</h2>
<ul>
<li>1111-11-11, <a href="./advanced/designs/index.qmd">Advanced Study Designs (고급 연구설계)</a>
<ul>
<li>1111-11-11, <a href="./advanced/designs/cluster_rct.qmd">Cluster Randomized Trials (군집 무작위 시험)</a></li>
<li>1111-11-11, <a href="./advanced/designs/stepped_wedge.qmd">Stepped Wedge Designs (단계적 쐐기 설계)</a></li>
<li>1111-11-11, <a href="./advanced/designs/adaptive.qmd">Adaptive Designs (적응형 설계)</a></li>
<li>1111-11-11, <a href="./advanced/designs/platform_trials.qmd">Platform Trials (플랫폼 시험)</a></li>
</ul></li>
<li>1111-11-11, <a href="./advanced/causal/index.qmd">Advanced Causal Methods (고급 인과추론 방법)</a>
<ul>
<li>1111-11-11, <a href="./advanced/causal/instrumental_variables.qmd">Instrumental Variables (도구변수)</a></li>
<li>1111-11-11, <a href="./advanced/causal/rdd.qmd">Regression Discontinuity Design (회귀불연속 설계)</a></li>
<li>1111-11-11, <a href="./advanced/causal/did.qmd">Difference-in-Differences (이중차분법)</a></li>
<li>1111-11-11, <a href="./advanced/causal/synthetic_control.qmd">Synthetic Control Methods (합성 통제 방법)</a></li>
</ul></li>
<li>1111-11-11, <a href="./advanced/stats/index.qmd">Advanced Statistical Methods (고급 통계 방법)</a>
<ul>
<li>1111-11-11, <a href="./advanced/stats/multilevel_modeling.qmd">Multilevel/Hierarchical Modeling (다층/계층 모델링)</a></li>
<li>1111-11-11, <a href="./advanced/stats/meta_analysis.qmd">Meta-analysis (메타분석)</a>
<ul>
<li>1111-11-11, <a href="./advanced/stats/fixed_effects.qmd">Fixed Effects Model (고정효과 모형)</a></li>
<li>1111-11-11, <a href="./advanced/stats/random_effects.qmd">Random Effects Model (무선효과 모형)</a></li>
<li>1111-11-11, <a href="./advanced/stats/meta_regression.qmd">Meta-regression (메타회귀분석)</a></li>
</ul></li>
<li>1111-11-11, <a href="./advanced/stats/missing_data.qmd">Missing Data Methods (결측치 처리 방법)</a>
<ul>
<li>1111-11-11, <a href="./advanced/stats/missing_mechanisms.qmd">MCAR, MAR, MNAR (결측 메커니즘)</a></li>
<li>1111-11-11, <a href="./advanced/stats/multiple_imputation.qmd">Multiple Imputation (다중대체)</a></li>
</ul></li>
<li>1111-11-11, <a href="./advanced/stats/measurement_error.qmd">Measurement Error Models (측정 오차 모형)</a></li>
</ul></li>
<li>1111-11-11, <a href="./advanced/special/index.qmd">Special Topics (특수 주제)</a>
<ul>
<li>1111-11-11, <a href="./advanced/special/time_varying_confounding.qmd">Time-varying Confounding (시간가변 교란)</a></li>
<li>1111-11-11, <a href="./advanced/special/mediation.qmd">Mediation Analysis (매개분석)</a></li>
<li>1111-11-11, <a href="./advanced/special/g_methods.qmd">G-methods (G-방법)</a>
<ul>
<li>1111-11-11, <a href="./advanced/special/g_computation.qmd">G-computation (G-계산)</a></li>
<li>1111-11-11, <a href="./advanced/special/ipw.qmd">Inverse Probability Weighting (역확률 가중)</a></li>
<li>1111-11-11, <a href="./advanced/special/g_estimation.qmd">G-estimation (G-추정)</a></li>
</ul></li>
<li>1111-11-11, <a href="./advanced/special/sensitivity_analysis.qmd">Sensitivity Analysis (민감도 분석)</a></li>
</ul></li>
</ul>


</section>
</section>

 ]]></description>
  <category>Epidemiology</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Experimentation/Epidemiology/</guid>
  <pubDate>Sun, 28 Feb 2100 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Mathematics</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Math/</link>
  <description><![CDATA[ 





<section id="contents" class="level1" data-number="1">

<section id="basic" class="level2" data-number="1.1">

<ul>
<li>2023-03-24, <a href="./variables/index.qmd">Variable types</a></li>
<li>1111-11-11, <a href="./function/index.qmd">Function</a>
<ul>
<li>2023-01-31, <a href="../../../../docs/blog/posts/Math/function/univariable_scalar_function.html">Function (1) - Univariable Scalar Function (One to One)</a></li>
<li>2023-01-31, <a href="../../../../docs/blog/posts/Math/function/multivariable_scalar_function.html">Function (2) - Multi-variable Scalar Function (Many to One)</a></li>
<li>2023-01-31, <a href="../../../../docs/blog/posts/Math/function/univariable_vector_function.html">Function (3) - Univariable Vector Function (One to Many)</a></li>
<li>2023-01-31, <a href="../../../../docs/blog/posts/Math/function/mutivariable_vector_function.html">Function (4) - Multi-variable Vector Function (Many to Many)</a></li>
<li>2023-02-18, <a href="../../../../docs/blog/posts/Math/function/composite_function.html">Function (5) - Composite Function</a></li>
</ul></li>
<li>2023-02-18, <a href="./transformation/index.qmd">Transformations of Functions</a></li>
<li>1111-11-11, Vector &amp; Matrix</li>
<li>2023-03-15, <a href="./epsilon_delta/">Limit, <img src="https://latex.codecogs.com/png.latex?%5Cepsilon-%5Cdelta"> Method</a></li>
<li>Differentiation
<ul>
<li>2023-02-04, <a href="./differentiation/2023-02-04_uni_derivative.qmd">Derivative (1) - Univariable Scalar Funtion</a></li>
<li>1111-11-11, <a href="./differentiation/2023-02-10_composite_partial_derivative.qmd">Derivative (2) - Chain Rule &amp; Partial Derivative</a></li>
<li>1111-11-11, Derivative (3) - Higher Order Derivative</li>
<li>1111-11-11, Derivative (4) - Mean Value Theorem</li>
<li>1111-11-11, Derivative (5) - Gradient</li>
</ul></li>
<li>2023-03-15, <a href="./taylor_series/index.qmd">Talyer’s Series</a></li>
<li>1111-11-11, Gradient Direction</li>
<li>1111-11-11, Random Variable</li>
<li>1111-11-11, Probability Distribution</li>
<li>1111-11-11, Information Theory - Entropy</li>
<li>1111-11-11,</li>
<li>1111-11-11,</li>
<li>1111-11-11,</li>
<li>1111-11-11,</li>
</ul>
</section>
<section id="linear-algebra" class="level2" data-number="1.2">

<ul>
<li>2023-03-30, <a href="../../../../docs/blog/posts/Math/linear_algebra/01.basic_vector.html">Basic Vector(1) - Vector Operations</a></li>
<li>2023-03-30, <a href="../../../../docs/blog/posts/Math/linear_algebra/02.norm_dot-product.html">Basic Vector(2) - Vector Norm and Dot Product”</a></li>
<li>2023-03-30, <a href="../../../../docs/blog/posts/Math/linear_algebra/03.vector_equation.html">Basic Vector(3) - Vector Equation</a></li>
<li>2023-03-30, Basic Matrix(1) - Matrix Operation</li>
<li>2023-03-30, Basic Matrix(2) - Matrix Multiplication</li>
<li>2023-03-30, <a href="../../../../docs/blog/posts/Math/linear_algebra/06.system_of_lineqr_equations.html">Basic Matrix(3) - System of Linear Equations</a></li>
<li>2023-03-30, <a href="../../../../docs/blog/posts/Math/linear_algebra/09.special_matrix.html">Basic Matrix(4) - Special Matrix</a></li>
<li>2023-04-14, [Lineqr Equations]</li>
<li>2023-04-14, [Vector Space and Subspaces]</li>
<li>2023-04-21, [Orthogonality]</li>
<li>1111-11-11, [Determinants]</li>
<li>1111-11-11, [Eigen Value &amp; Eigen Vector]</li>
<li>1111-11-11, [Linear Transformations]</li>
<li>1111-11-11, Basis, Dimension, &amp; Rank</li>
<li>1111-11-11,</li>
<li>1111-11-11, Eigen Decomposition</li>
<li>1111-11-11, Singular Value Decomposition (SVD)</li>
<li>1111-11-11, Group</li>
<li>1111-11-11, Rotation &amp; Group</li>
<li>2023-04-02, <a href="./linear_algebra/quadratic_form.qmd">Matrix Transformation (5) - Quadratic Form</a></li>
<li>2023-04-02, <a href="../../../../docs/blog/posts/Math/linear_algebra/derivative_matrix_vector.html">Matrix Calculus (1) - Quadratic Form</a></li>
<li>1111-11-11,</li>
<li>1111-11-11,</li>
<li>1111-11-11,</li>
</ul>
</section>
<section id="optimization" class="level2" data-number="1.3">

<ul>
<li>2023-03-23, <a href="./optimization/minimizer.qmd">Minimizer &amp; Minimum</a></li>
<li>1111-11-11, Convex Set</li>
<li>1111-11-11, Convex Function</li>
<li>1111-11-11, Unconstrained Optimization</li>
<li>1111-11-11, Non-linear Least Square</li>
<li>1111-11-11, Largrange Multiplier Method
<ul>
<li>1111-11-11, Largrange Primal Function</li>
<li>1111-11-11, Largrange Dual Function</li>
<li>1111-11-11, KKT conditions</li>
</ul></li>
<li>1111-11-11, Gradient Descent Optimizers</li>
<li>1111-11-11,</li>
<li>1111-11-11,</li>
<li>1111-11-11,</li>
<li>1111-11-11,</li>
<li>1111-11-11,</li>
<li>1111-11-11,</li>
</ul>


</section>
</section>

 ]]></description>
  <category>Mathematics</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Math/</guid>
  <pubDate>Sun, 28 Feb 2100 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Experimentation</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Experimentation/</link>
  <description><![CDATA[ 





<section id="experimentation" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Experimentation</h1>
<ul>
<li>실험 설계와 인과추론의 체계적 이해를 위한 구조화된 학습 경로를 제시</li>
<li>Epidemiology 기반 지식을 활용하여 A/B Testing과 Multi-Armed Bandit을 포함한 Experimentation 전반을 학습할 수 있도록 구성</li>
</ul>
<section id="experimentation-하위구조" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="experimentation-하위구조"><span class="header-section-number">1.1</span> Experimentation 하위구조</h2>
<ul>
<li>Experimentation
<ul>
<li>Epidemiolog</li>
<li>AB_test</li>
<li>Fundamentals</li>
<li>MAB (Multi-Armed Badit)</li>
<li>Causal_inference</li>
<li>Advanced</li>
<li>Platform</li>
</ul></li>
</ul>
</section>
<section id="learning-path" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="learning-path"><span class="header-section-number">1.2</span> Learning Path</h2>
<p>이 학습 경로는 <strong>Epidemiology → Classical A/B Testing → Multi-Armed Bandits → Advanced Methods</strong> 순서로 실험 설계와 인과추론을 체계적으로 학습하도록 설계</p>
<section id="core-concepts-connection-map" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="core-concepts-connection-map"><span class="header-section-number">1.2.1</span> Core Concepts Connection Map</h3>
<pre><code>Epidemiology RCT → A/B Testing → Sequential Testing → Adaptive Testing → MAB
       ↓              ↓                                        ↓
Causal Inference → DAG/SUTVA ────────────────────→ Interference Handling
       ↓              ↓                                        ↓
Effect Measures → Lift/Uplift ──────────────────→ Heterogeneous TE
       ↓
Sample Size → Power Analysis → Sequential Monitoring → Variance Reduction</code></pre>
</section>
<section id="key-mathematical-connections" class="level3" data-number="1.2.2">
<h3 data-number="1.2.2" class="anchored" data-anchor-id="key-mathematical-connections"><span class="header-section-number">1.2.2</span> Key Mathematical Connections</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Epidemiology</th>
<th>Experimentation</th>
<th>수식</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Relative Risk</td>
<td>Lift</td>
<td><img src="https://latex.codecogs.com/png.latex?%5Cfrac%7BP(Y=1%7CT=1)%7D%7BP(Y=1%7CT=0)%7D"></td>
</tr>
<tr class="even">
<td>Risk Difference</td>
<td>Absolute Uplift</td>
<td><img src="https://latex.codecogs.com/png.latex?P(Y=1%7CT=1)%20-%20P(Y=1%7CT=0)"></td>
</tr>
<tr class="odd">
<td>NNT</td>
<td>Number to Convert</td>
<td><img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7BRD%7D"></td>
</tr>
<tr class="even">
<td>Effect Modification</td>
<td>HTE</td>
<td><img src="https://latex.codecogs.com/png.latex?E%5BY(1)-Y(0)%7CX%5D"></td>
</tr>
</tbody>
</table>
</section>
<section id="recommended-study-time" class="level3" data-number="1.2.3">
<h3 data-number="1.2.3" class="anchored" data-anchor-id="recommended-study-time"><span class="header-section-number">1.2.3</span> Recommended Study Time</h3>
<pre><code>Phase 1: 1-2개월 (주 10-15시간)
  - Epidemiology: 2-3주
  - Statistics: 1주
  - Classical A/B: 2-3주

Phase 2: 2-3개월 (주 10-15시간)
  - Advanced A/B: 2-3주
  - Causal Inference: 3-4주 ⭐ (가장 중요)
  - MAB Fundamentals: 2주
  - Classical Algorithms: 2-3주

Phase 3: 2-3개월 (주 8-12시간)
  - HTE: 2-3주
  - Variance Reduction: 2주
  - Advanced Bandits: 3-4주
  - Practical Challenges: 2-3주

Phase 4: 지속적 (프로젝트 기반)
  - Platform: 필요시
  - Applications: 도메인별
  - Research: 관심분야별</code></pre>
</section>
</section>
<section id="foundations-1-2개월" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="foundations-1-2개월"><span class="header-section-number">1.3</span> Foundations (1-2개월)</h2>
<section id="epidemiology-foundations" class="level3" data-number="1.3.1">
<h3 data-number="1.3.1" class="anchored" data-anchor-id="epidemiology-foundations"><span class="header-section-number">1.3.1</span> Epidemiology Foundations</h3>
<p>RCT(무작위 대조 시험)는 A/B Testing의 직접적 원형이며, 인과추론의 수학적 프레임워크(Potential Outcomes, SUTVA)가 실험 설계의 이론적 기초를 제공한다. 역학의 effect measures(RR, RD, NNT)는 디지털 실험의 lift와 uplift 지표로 직접 대응되며, bias와 confounding 개념은 실험의 타당도를 판단하는 핵심 도구다. Sample size와 power 계산은 모든 실험 설계의 출발점이다.</p>
<ul>
<li><a href="../../../../docs/blog/posts/Experimentation/Epidemiology/index.html">Epidemiology Overview</a> ⭐
<ul>
<li>Study Design Framework
<ul>
<li>1111-11-11, <a href="./Epidemiology/experimental/rct.qmd">Randomized Controlled Trial (무작위 대조 시험)</a> ⭐</li>
<li>1111-11-11, <a href="./Epidemiology/experimental/quasi_experimental.qmd">Quasi-experimental Studies (준실험 연구)</a></li>
<li>1111-11-11, <a href="./Epidemiology/experimental/factorial_design.qmd">Factorial Design (요인 설계)</a></li>
</ul></li>
<li>Measures of Association and Impact
<ul>
<li>1111-11-11, <a href="./Epidemiology/measures/relative_risk.qmd">Relative Risk and Risk Difference</a></li>
<li>1111-11-11, <a href="./Epidemiology/measures/effect_size.qmd">Effect Size Measures</a></li>
<li>1111-11-11, <a href="./Epidemiology/measures/nnt.qmd">Number Needed to Treat</a></li>
</ul></li>
<li>Bias and Confounding
<ul>
<li>1111-11-11, <a href="./Epidemiology/bias/selection_bias.qmd">Selection Bias</a></li>
<li>1111-11-11, <a href="./Epidemiology/bias/information_bias.qmd">Information Bias</a></li>
<li>1111-11-11, <a href="./Epidemiology/confounding/index.qmd">Confounding and Control</a></li>
</ul></li>
<li>Study Design Fundamentals
<ul>
<li>1111-11-11, <a href="./Epidemiology/fundamentals/sample_size_power.qmd">Sample Size and Power</a> ⭐</li>
<li>1111-11-11, <a href="./Epidemiology/fundamentals/randomization.qmd">Randomization Methods</a> ⭐</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="statistical-foundations" class="level3" data-number="1.3.2">
<h3 data-number="1.3.2" class="anchored" data-anchor-id="statistical-foundations"><span class="header-section-number">1.3.2</span> Statistical Foundations</h3>
<p>가설 검정의 Type I/II 오류와 statistical power 개념은 실험 결과 해석의 필수 요소다. Multiple testing problem은 여러 지표를 동시에 평가하거나 중간 결과를 확인할 때 발생하는 false positive를 통제하는 방법을 제공한다. Effect size와 MDE(최소감지효과) 이해 없이는 실무적으로 의미 있는 실험 설계가 불가능하다.</p>
<ul>
<li><a href="./Fundamentals/statistics.qmd">Statistical Foundations for Experimentation</a>
<ul>
<li>1111-11-11, <a href="./Fundamentals/hypothesis_testing.qmd">Hypothesis Testing Framework</a>
<ul>
<li>1111-11-11, Type I and Type II Errors (1종·2종 오류)</li>
<li>1111-11-11, Statistical Power (검정력)</li>
<li>1111-11-11, p-values and Significance (p-값과 유의성)</li>
</ul></li>
<li>1111-11-11, <a href="./Fundamentals/effect_size.qmd">Effect Size and Practical Significance</a>
<ul>
<li>1111-11-11, Minimum Detectable Effect (MDE, 최소감지효과)</li>
<li>1111-11-11, Cohen’s d and Standardized Effect Sizes</li>
</ul></li>
<li>1111-11-11, <a href="./Fundamentals/multiple_testing.qmd">Multiple Testing Problem</a>
<ul>
<li>1111-11-11, Family-wise Error Rate (FWER)</li>
<li>1111-11-11, False Discovery Rate (FDR)</li>
<li>1111-11-11, Bonferroni and Holm Corrections</li>
</ul></li>
<li>1111-11-11, <a href="./Fundamentals/confidence_intervals.qmd">Confidence Intervals</a>
<ul>
<li>1111-11-11, Interpretation and Common Mistakes</li>
<li>1111-11-11, Bootstrap Methods</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="classical-ab-testing-fundamentals" class="level3" data-number="1.3.3">
<h3 data-number="1.3.3" class="anchored" data-anchor-id="classical-ab-testing-fundamentals"><span class="header-section-number">1.3.3</span> Classical A/B Testing Fundamentals</h3>
<p>디지털 제품에서 RCT 원리를 적용하는 구체적 방법론이다. Randomization unit 선택, traffic allocation, metric selection 등 실무적 의사결정 프레임워크를 제공한다. Fixed-horizon testing의 원칙과 “peeking problem”을 이해해야 sequential testing과 MAB의 필요성을 정확히 파악할 수 있다. 대부분의 실무 실험이 이 방법으로 진행되므로 가장 실용적이다.</p>
<ul>
<li><a href="./AB_test/index.qmd">Classical A/B Testing</a> ⭐
<ul>
<li>1111-11-11, <a href="./AB_test/design_principles.qmd">A/B Test Design Principles</a>
<ul>
<li>1111-11-11, Hypothesis Formulation (가설 수립)</li>
<li>1111-11-11, Metric Selection (지표 선택)</li>
<li>1111-11-11, Randomization Unit (무작위 배정 단위)</li>
<li>1111-11-11, Traffic Allocation (트래픽 할당)</li>
</ul></li>
<li>1111-11-11, <a href="./AB_test/sample_size.qmd">Sample Size Calculation</a> ⭐
<ul>
<li>1111-11-11, Power Analysis for A/B Tests</li>
<li>1111-11-11, Continuous vs.&nbsp;Binary Metrics</li>
<li>1111-11-11, Unequal Allocation</li>
</ul></li>
<li>1111-11-11, <a href="./AB_test/randomization.qmd">Randomization Strategies</a>
<ul>
<li>1111-11-11, Simple Randomization</li>
<li>1111-11-11, Stratified Randomization</li>
<li>1111-11-11, Consistent Hashing</li>
</ul></li>
<li>1111-11-11, <a href="./AB_test/analysis.qmd">Analysis Methods</a>
<ul>
<li>1111-11-11, t-tests and z-tests</li>
<li>1111-11-11, Chi-square Tests</li>
<li>1111-11-11, Non-parametric Tests (Mann-Whitney)</li>
</ul></li>
<li>1111-11-11, <a href="./AB_test/duration.qmd">Duration and Stopping Rules</a>
<ul>
<li>1111-11-11, Fixed Horizon Testing</li>
<li>1111-11-11, When to Stop (언제 중단할 것인가)</li>
<li>1111-11-11, Peeking Problem (중간확인 문제)</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section id="core-methods-2-3개월" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="core-methods-2-3개월"><span class="header-section-number">1.4</span> Core Methods (2-3개월)</h2>
<section id="advanced-ab-testing" class="level3" data-number="1.4.1">
<h3 data-number="1.4.1" class="anchored" data-anchor-id="advanced-ab-testing"><span class="header-section-number">1.4.1</span> Advanced A/B Testing</h3>
<p>Sequential testing은 실험 진행 중 중간 결과를 확인하면서도 Type I 오류를 통제하는 방법으로, 실무에서 가장 많이 요구되는 기술이다. Bayesian A/B testing은 “승률 확률” 같은 비즈니스 친화적 해석을 제공한다. Multi-variate testing은 여러 요소의 상호작용 효과를 동시에 평가할 수 있어 복잡한 제품 최적화에 필수적이다.</p>
<ul>
<li><a href="./AB_test/advanced/index.qmd">Advanced A/B Testing Techniques</a>
<ul>
<li>1111-11-11, <a href="./AB_test/advanced/sequential.qmd">Sequential Testing</a> ⭐
<ul>
<li>1111-11-11, Group Sequential Designs (그룹순차설계)</li>
<li>1111-11-11, Sequential Probability Ratio Test (SPRT)</li>
<li>1111-11-11, Alpha Spending Functions</li>
<li>1111-11-11, Always-Valid Inference</li>
</ul></li>
<li>1111-11-11, <a href="./AB_test/advanced/bayesian.qmd">Bayesian A/B Testing</a>
<ul>
<li>1111-11-11, Prior Distribution Selection (사전분포 선택)</li>
<li>1111-11-11, Posterior Probability (사후확률)</li>
<li>1111-11-11, Credible Intervals (신용구간)</li>
<li>1111-11-11, Probability of Being Best</li>
</ul></li>
<li>1111-11-11, <a href="./AB_test/advanced/multivariate.qmd">Multi-variate Testing</a>
<ul>
<li>1111-11-11, Full Factorial Designs (완전요인설계)</li>
<li>1111-11-11, Fractional Factorial Designs (부분요인설계)</li>
<li>1111-11-11, Interaction Effects (상호작용효과)</li>
</ul></li>
<li>1111-11-11, <a href="./AB_test/advanced/aa_testing.qmd">A/A Testing</a>
<ul>
<li>1111-11-11, Platform Validation</li>
<li>1111-11-11, Sample Ratio Mismatch (SRM) Detection</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="causal-inference-framework" class="level3" data-number="1.4.2">
<h3 data-number="1.4.2" class="anchored" data-anchor-id="causal-inference-framework"><span class="header-section-number">1.4.2</span> Causal Inference Framework</h3>
<p>Potential outcomes와 DAG는 “왜 무작위 배정이 중요한가”, “어떤 변수를 통제해야 하는가”에 대한 수학적으로 엄밀한 답을 제공한다. SUTVA 위반(network effects, spillover)은 디지털 실험에서 흔히 발생하며, 이를 감지하고 처리하는 방법이 필요하다. HTE(heterogeneous treatment effects) 분석의 이론적 기초가 되어 “어떤 사용자에게 효과적인가”를 과학적으로 답할 수 있게 한다.</p>
<ul>
<li><a href="./Causal_inference/index.qmd">Causal Inference for Experimentation</a> ⭐
<ul>
<li>1111-11-11, <a href="./Causal_inference/potential_outcomes.qmd">Potential Outcomes Framework</a> ⭐
<ul>
<li>1111-11-11, Rubin Causal Model (루빈 인과 모형)</li>
<li>1111-11-11, Average Treatment Effect (ATE, 평균처치효과)</li>
<li>1111-11-11, CATE and ITE (조건부·개별 처치효과)</li>
<li>1111-11-11, SUTVA (안정단위처치값 가정)</li>
</ul></li>
<li>1111-11-11, <a href="./Causal_inference/dag.qmd">Directed Acyclic Graphs</a> ⭐
<ul>
<li>1111-11-11, Causal Pathways (인과경로)</li>
<li>1111-11-11, Confounding Paths (교란경로)</li>
<li>1111-11-11, Colliders and Selection Bias (충돌자와 선택편향)</li>
<li>1111-11-11, d-separation (d-분리)</li>
<li>1111-11-11, Backdoor and Frontdoor Criteria</li>
</ul></li>
<li>1111-11-11, <a href="./Causal_inference/assignment.qmd">Assignment Mechanisms</a>
<ul>
<li>1111-11-11, Intent-to-Treat (ITT) Analysis</li>
<li>1111-11-11, Per-Protocol Analysis</li>
<li>1111-11-11, As-Treated Analysis</li>
<li>1111-11-11, Complier Average Causal Effect (CACE)</li>
</ul></li>
<li>1111-11-11, <a href="./Causal_inference/interference.qmd">Interference and Spillover</a>
<ul>
<li>1111-11-11, Network Effects (네트워크 효과)</li>
<li>1111-11-11, Cluster Randomization (군집 무작위배정)</li>
<li>1111-11-11, Switchback Experiments</li>
<li>1111-11-11, Geo-experiments</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="multi-armed-bandit-fundamentals" class="level3" data-number="1.4.3">
<h3 data-number="1.4.3" class="anchored" data-anchor-id="multi-armed-bandit-fundamentals"><span class="header-section-number">1.4.3</span> Multi-Armed Bandit Fundamentals</h3>
<p>A/B Testing이 “학습 후 의사결정”이라면, MAB는 “학습과 최적화를 동시에” 수행한다. Exploration-exploitation trade-off는 제한된 자원(트래픽)으로 최대 성과를 내는 전략의 핵심이다. Regret 개념은 “실험 비용”을 수학적으로 정량화하여 알고리즘 간 비교를 가능하게 한다.</p>
<ul>
<li><a href="./MAB/index.qmd">Multi-Armed Bandits Overview</a> ⭐
<ul>
<li>1111-11-11, <a href="./MAB/formulation.qmd">MAB Problem Formulation</a>
<ul>
<li>1111-11-11, Exploration vs.&nbsp;Exploitation Trade-off</li>
<li>1111-11-11, Regret Definition (후회 정의)
<ul>
<li>Cumulative Regret (누적 후회)</li>
<li>Simple Regret (단순 후회)</li>
</ul></li>
<li>1111-11-11, Reward Distributions (보상 분포)</li>
<li>1111-11-11, Stationarity Assumptions (정상성 가정)</li>
</ul></li>
<li>1111-11-11, <a href="./MAB/metrics.qmd">Performance Metrics</a>
<ul>
<li>1111-11-11, Expected Cumulative Regret</li>
<li>1111-11-11, Best Arm Identification</li>
<li>1111-11-11, Sample Complexity</li>
<li>1111-11-11, Convergence Rates</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="classical-mab-algorithms" class="level3" data-number="1.4.4">
<h3 data-number="1.4.4" class="anchored" data-anchor-id="classical-mab-algorithms"><span class="header-section-number">1.4.4</span> Classical MAB Algorithms</h3>
<p>Epsilon-greedy는 가장 단순하지만 exploration 비율을 수동으로 조정해야 하는 한계가 있다. UCB는 불확실성을 자동으로 정량화하여 exploration을 관리하며, 이론적 regret bound가 증명되었다. Thompson Sampling은 1933년 의학 실험을 위해 개발된 알고리즘으로, 실무에서 가장 성능이 좋고 구현이 간단하여 광범위하게 사용된다.</p>
<ul>
<li><a href="./MAB/classical/index.qmd">Classical Bandit Algorithms</a>
<ul>
<li>1111-11-11, <a href="./MAB/classical/epsilon_greedy.qmd">Epsilon-Greedy Methods</a>
<ul>
<li>1111-11-11, Fixed Epsilon Strategy</li>
<li>1111-11-11, Decaying Epsilon Strategy</li>
<li>1111-11-11, Theoretical Regret Bounds</li>
</ul></li>
<li>1111-11-11, <a href="./MAB/classical/ucb.qmd">Upper Confidence Bound (UCB)</a>
<ul>
<li>1111-11-11, UCB1 Algorithm</li>
<li>1111-11-11, UCB-Tuned</li>
<li>1111-11-11, Bayesian UCB</li>
<li>1111-11-11, KL-UCB</li>
</ul></li>
<li>1111-11-11, <a href="./MAB/classical/thompson_sampling.qmd">Thompson Sampling</a> ⭐
<ul>
<li>1111-11-11, Beta-Bernoulli Thompson Sampling</li>
<li>1111-11-11, Gaussian Thompson Sampling</li>
<li>1111-11-11, Theoretical Properties</li>
<li>1111-11-11, Historical Context (의학 실험 기원)</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="mab-vs.-ab-testing" class="level3" data-number="1.4.5">
<h3 data-number="1.4.5" class="anchored" data-anchor-id="mab-vs.-ab-testing"><span class="header-section-number">1.4.5</span> MAB vs.&nbsp;A/B Testing</h3>
<p>두 방법의 trade-off를 이해해야 상황에 맞는 선택이 가능하다. A/B Testing은 statistical validity가 명확하고 효과 크기를 정확히 추정하지만, MAB는 실험 중 기회비용을 최소화한다. 비즈니스 목표(정확한 측정 vs.&nbsp;빠른 최적화), 트래픽 규모, 의사결정 맥락에 따라 최적 방법이 달라진다.</p>
</section>
</section>
<section id="advanced-applications-2-3개월" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="advanced-applications-2-3개월"><span class="header-section-number">1.5</span> Advanced Applications (2-3개월)</h2>
<section id="heterogeneous-treatment-effects" class="level3" data-number="1.5.1">
<h3 data-number="1.5.1" class="anchored" data-anchor-id="heterogeneous-treatment-effects"><span class="header-section-number">1.5.1</span> Heterogeneous Treatment Effects</h3>
<p>“평균적으로 효과가 있다”는 것과 “모든 사용자에게 효과가 있다”는 것은 다르다. HTE 분석을 통해 어떤 사용자 세그먼트에서 효과가 크고 작은지 파악할 수 있다. Causal forests와 meta-learners 같은 ML 방법은 수백 개의 특성 조합에서 효과 패턴을 자동으로 발견한다. 개인화 전략 수립의 과학적 기반이 된다.</p>
<ul>
<li>1111-11-11, <a href="./MAB/comparison.qmd">When to Use MAB vs.&nbsp;A/B Testing</a> ⭐
<ul>
<li>1111-11-11, Trade-offs and Decision Framework</li>
<li>1111-11-11, Statistical Validity Considerations</li>
<li>1111-11-11, Business Context and Goals</li>
<li>1111-11-11, Hybrid Approaches</li>
</ul></li>
<li><a href="./Causal_inference/hte/index.qmd">Heterogeneous Treatment Effects</a> ⭐
<ul>
<li>1111-11-11, <a href="./Causal_inference/hte/subgroup.qmd">Subgroup Analysis</a>
<ul>
<li>1111-11-11, Pre-specified Subgroups</li>
<li>1111-11-11, Multiple Comparison Corrections</li>
<li>1111-11-11, Statistical vs.&nbsp;Practical Significance</li>
</ul></li>
<li>1111-11-11, <a href="./Causal_inference/hte/effect_modification.qmd">Effect Modification Analysis</a>
<ul>
<li>1111-11-11, Interaction Terms (상호작용항)</li>
<li>1111-11-11, Stratified Analysis (층화분석)</li>
</ul></li>
<li>1111-11-11, <a href="./Causal_inference/hte/ml_methods.qmd">Machine Learning Methods</a>
<ul>
<li>1111-11-11, Causal Forests</li>
<li>1111-11-11, Meta-learners (S-, T-, X-learner)</li>
<li>1111-11-11, Double Machine Learning (DML)</li>
<li>1111-11-11, BART (Bayesian Additive Regression Trees)</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="variance-reduction-techniques" class="level3" data-number="1.5.2">
<h3 data-number="1.5.2" class="anchored" data-anchor-id="variance-reduction-techniques"><span class="header-section-number">1.5.2</span> Variance Reduction Techniques</h3>
<p>동일한 sample size로 더 정확한 추정이 가능하면, 실험 기간을 단축하거나 더 작은 효과를 감지할 수 있다. CUPED는 실험 전 데이터(baseline)를 활용해 분산을 최대 50% 이상 줄일 수 있어 실무에서 표준 기법이 되었다. Stratification과 regression adjustment는 역학에서 검증된 방법으로, 디지털 실험에 직접 적용 가능하다.</p>
<ul>
<li><a href="./Advanced/variance_reduction/index.qmd">Variance Reduction Methods</a> ⭐
<ul>
<li>1111-11-11, <a href="./Advanced/variance_reduction/pre_experiment.qmd">Pre-experiment Methods</a>
<ul>
<li>1111-11-11, Stratification (층화)</li>
<li>1111-11-11, Matched Pair Design (대응설계)</li>
<li>1111-11-11, Blocking (블록화)</li>
</ul></li>
<li>1111-11-11, <a href="./Advanced/variance_reduction/post_experiment.qmd">Post-experiment Methods</a>
<ul>
<li>1111-11-11, CUPED (Controlled-experiment Using Pre-Experiment Data) ⭐</li>
<li>1111-11-11, CUPAC (CUPED with Asymptotic Confidence)</li>
<li>1111-11-11, Regression Adjustment (회귀조정)</li>
<li>1111-11-11, Difference-in-Differences (이중차분법)</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="contextual-and-advanced-bandits" class="level3" data-number="1.5.3">
<h3 data-number="1.5.3" class="anchored" data-anchor-id="contextual-and-advanced-bandits"><span class="header-section-number">1.5.3</span> Contextual and Advanced Bandits</h3>
<p>Contextual bandits는 사용자 특성(context)을 고려해 개인화된 의사결정을 내린다. Non-stationary bandits는 시간에 따라 최적 선택지가 변하는 현실을 반영한다. 추천 시스템, 동적 가격 책정, 개인화 마케팅 등 복잡한 실무 문제에 적용된다.</p>
<ul>
<li><a href="./MAB/advanced/index.qmd">Advanced Bandit Methods</a>
<ul>
<li>1111-11-11, <a href="./MAB/advanced/contextual.qmd">Contextual Bandits</a>
<ul>
<li>1111-11-11, Linear Contextual Bandits</li>
<li>1111-11-11, LinUCB Algorithm</li>
<li>1111-11-11, Neural Bandits</li>
<li>1111-11-11, Policy Gradient Methods</li>
</ul></li>
<li>1111-11-11, <a href="./MAB/advanced/non_stationary.qmd">Non-stationary Bandits</a>
<ul>
<li>1111-11-11, Sliding Window Approaches</li>
<li>1111-11-11, Discounted Rewards</li>
<li>1111-11-11, Change Detection Methods</li>
<li>1111-11-11, Switching Bandits</li>
</ul></li>
<li>1111-11-11, <a href="./MAB/advanced/structured.qmd">Structured Bandits</a>
<ul>
<li>1111-11-11, Combinatorial Bandits</li>
<li>1111-11-11, Dueling Bandits</li>
<li>1111-11-11, Ranking Bandits</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="practical-implementation-challenges" class="level3" data-number="1.5.4">
<h3 data-number="1.5.4" class="anchored" data-anchor-id="practical-implementation-challenges"><span class="header-section-number">1.5.4</span> Practical Implementation Challenges</h3>
<p>이론적으로 완벽한 실험도 실무에서는 metric 정의, novelty effects, network interference, SRM 등 다양한 문제에 직면한다. 이러한 문제들을 감지하고 완화하는 방법을 모르면 잘못된 의사결정으로 이어진다. North star metric과 guardrail metric 설정은 실험 프로그램의 성공을 좌우한다.</p>
<ul>
<li><a href="./Advanced/practical/index.qmd">Practical Experimentation Challenges</a>
<ul>
<li>1111-11-11, <a href="./Advanced/practical/metrics.qmd">Metric Design</a>
<ul>
<li>1111-11-11, North Star Metrics (핵심지표)</li>
<li>1111-11-11, Proxy Metrics (대리지표)</li>
<li>1111-11-11, Guardrail Metrics (가드레일지표)</li>
<li>1111-11-11, Long-term vs.&nbsp;Short-term Metrics</li>
</ul></li>
<li>1111-11-11, <a href="./Advanced/practical/novelty_effects.qmd">Novelty and Primacy Effects</a>
<ul>
<li>1111-11-11, Detection Methods</li>
<li>1111-11-11, Mitigation Strategies</li>
</ul></li>
<li>1111-11-11, <a href="./Advanced/practical/interference.qmd">Network Effects and Interference</a>
<ul>
<li>1111-11-11, Detection of SUTVA Violations</li>
<li>1111-11-11, Cluster-based Approaches</li>
<li>1111-11-11, Graph Cluster Randomization</li>
</ul></li>
<li>1111-11-11, <a href="./Advanced/practical/srm.qmd">Sample Ratio Mismatch</a>
<ul>
<li>1111-11-11, Detection Methods</li>
<li>1111-11-11, Root Cause Analysis</li>
<li>1111-11-11, Prevention Strategies</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section id="platform-and-specialization-지속적" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="platform-and-specialization-지속적"><span class="header-section-number">1.6</span> Platform and Specialization (지속적)</h2>
<section id="experimentation-platform-architecture" class="level4" data-number="1.6.0.1">
<h4 data-number="1.6.0.1" class="anchored" data-anchor-id="experimentation-platform-architecture"><span class="header-section-number">1.6.0.1</span> Experimentation Platform Architecture</h4>
<p>실험이 일회성이 아닌 조직의 표준 프로세스가 되려면 확장 가능한 인프라가 필요하다. Assignment service, logging, analysis engine의 설계는 실험의 신뢰성과 효율성을 결정한다. Feature flag integration과 auto-stopping 같은 자동화는 실험 운영 비용을 획기적으로 줄인다.</p>
<ul>
<li><a href="./Platform/index.qmd">Platform Design and Infrastructure</a>
<ul>
<li>1111-11-11, <a href="./Platform/components.qmd">Core Components</a>
<ul>
<li>1111-11-11, Assignment Service (배정 서비스)</li>
<li>1111-11-11, Logging and Tracking (로깅과 추적)</li>
<li>1111-11-11, Analysis Engine (분석 엔진)</li>
<li>1111-11-11, Reporting Dashboard (보고 대시보드)</li>
</ul></li>
<li>1111-11-11, <a href="./Platform/technical.qmd">Technical Considerations</a>
<ul>
<li>1111-11-11, Consistent Hashing for Assignment</li>
<li>1111-11-11, Experiment Overlap and Orthogonality</li>
<li>1111-11-11, Feature Flag Integration</li>
<li>1111-11-11, A/A Testing for Validation</li>
</ul></li>
<li>1111-11-11, <a href="./Platform/automation.qmd">Scale and Automation</a>
<ul>
<li>1111-11-11, Auto-stopping Rules (자동중단규칙)</li>
<li>1111-11-11, Winner Selection Algorithms</li>
<li>1111-11-11, Multi-objective Optimization</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="domain-specific-applications" class="level3" data-number="1.6.1">
<h3 data-number="1.6.1" class="anchored" data-anchor-id="domain-specific-applications"><span class="header-section-number">1.6.1</span> Domain-Specific Applications</h3>
<p>제품 최적화, 마케팅, 의료 등 도메인마다 고유한 제약과 요구사항이 있다. Healthcare의 경우 FDA guidance를 따라야 하며, marketplace 실험은 양면 시장의 특성을 고려해야 한다. 도메인 특화 지식이 실험 설계의 성공 여부를 결정한다.</p>
<ul>
<li><a href="./Advanced/applications/index.qmd">Industry Applications</a>
<ul>
<li>1111-11-11, <a href="./Advanced/applications/product.qmd">Product Optimization</a>
<ul>
<li>1111-11-11, UI/UX Experiments</li>
<li>1111-11-11, Recommendation System Testing</li>
<li>1111-11-11, Search Ranking Experiments</li>
</ul></li>
<li>1111-11-11, <a href="./Advanced/applications/growth.qmd">Growth and Marketing</a>
<ul>
<li>1111-11-11, Conversion Funnel Optimization</li>
<li>1111-11-11, Pricing Experiments</li>
<li>1111-11-11, Email and Notification Testing</li>
</ul></li>
<li>1111-11-11, <a href="./Advanced/applications/healthcare.qmd">Healthcare Applications</a>
<ul>
<li>1111-11-11, Adaptive Clinical Trials</li>
<li>1111-11-11, Response-Adaptive Randomization</li>
<li>1111-11-11, Platform Trials</li>
<li>1111-11-11, Regulatory Considerations (FDA Guidance)</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="research-frontiers" class="level3" data-number="1.6.2">
<h3 data-number="1.6.2" class="anchored" data-anchor-id="research-frontiers"><span class="header-section-number">1.6.2</span> Research Frontiers</h3>
<p>RL과의 통합, differential privacy, causal discovery 등은 차세대 실험 방법론이다. Off-policy evaluation은 과거 실험 데이터로 새로운 정책을 평가할 수 있게 하여 실험 비용을 줄인다. 이 분야의 최신 연구를 추적하면 경쟁 우위를 확보할 수 있다.</p>
<ul>
<li><a href="./Advanced/research/index.qmd">Emerging Topics and Research</a>
<ul>
<li>1111-11-11, <a href="./Advanced/research/rl.qmd">Reinforcement Learning Integration</a>
<ul>
<li>1111-11-11, Bandits as RL Problems</li>
<li>1111-11-11, Deep RL for Experimentation</li>
<li>1111-11-11, Off-policy Evaluation</li>
</ul></li>
<li>1111-11-11, <a href="./Advanced/research/privacy.qmd">Privacy-Preserving Experiments</a>
<ul>
<li>1111-11-11, Differential Privacy in Experiments</li>
<li>1111-11-11, Federated A/B Testing</li>
</ul></li>
<li>1111-11-11, <a href="./Advanced/research/causal_discovery.qmd">Causal Discovery</a>
<ul>
<li>1111-11-11, Constraint-based Methods</li>
<li>1111-11-11, Score-based Methods</li>
<li>1111-11-11, Experimentation for Graph Learning</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section id="references" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="references"><span class="header-section-number">1.7</span> References</h2>
<p><strong>Books:</strong> - Kohavi, Tang, and Xu (2020). “Trustworthy Online Controlled Experiments” - Lattimore and Szepesvári (2020). “Bandit Algorithms” - Imbens and Rubin (2015). “Causal Inference for Statistics, Social, and Biomedical Sciences” - Pearl and Mackenzie (2018). “The Book of Why”</p>
<p><strong>Papers:</strong> - Thompson (1933). “On the likelihood that one unknown probability exceeds another” - Auer et al.&nbsp;(2002). “Finite-time analysis of the multiarmed bandit problem” - Deng et al.&nbsp;(2013). “Improving the Sensitivity of Online Controlled Experiments by Utilizing Pre-Experiment Data” (CUPED)</p>
<p><strong>Online Courses:</strong> - Stanford CS234: Reinforcement Learning - MIT 6.S897: Machine Learning for Healthcare</p>


</section>
</section>

 ]]></description>
  <category>Experimentation</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Experimentation/</guid>
  <pubDate>Sun, 09 Nov 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>비동기 프로그래밍 (Asynchronous Programming)</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Engineering/async.html</link>
  <description><![CDATA[ 





<section id="비동기-프로그래밍-asynchronous-programming-개요" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="비동기-프로그래밍-asynchronous-programming-개요"><span class="header-section-number">1</span> 비동기 프로그래밍 (Asynchronous Programming) 개요</h2>
<ul>
<li>비동기 프로그래밍은 <strong>단일 스레드(Single Thread)</strong> 환경에서 I/O 작업으로 인한 대기 시간(Latency)을 효율적으로 활용하여 <strong>동시성(Concurrency)</strong>을 달성하고 시스템의 <strong>처리량(Throughput)</strong>을 극대화하는 프로그래밍 패러다임</li>
<li>동시에 여러 이벤트를 효율적으로 처리할 수 있지만 병렬작업과는 완전히 다른 개념</li>
</ul>
<section id="비동기란" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="비동기란"><span class="header-section-number">1.1</span> 비동기란?</h3>
<p>비동기 방식의 핵심은 <strong>“빠른 주체(CPU)를 느린 주체(I/O 장치)가 멈추게 하지 않도록 보호”</strong>하는 것</p>
<ul>
<li><strong>배경:</strong> 프로그램 실행 주체인 <strong>CPU</strong>는 초고속이지만, <strong>I/O 작업</strong> (네트워크 통신, 파일 접근, 데이터베이스 조회 등)은 수백~수천 배 느림</li>
<li><strong>동기(Synchronous) 방식의 문제:</strong> CPU가 느린 I/O 작업이 끝날 때까지 멈춰서 <strong>강제로 대기(Blocking)</strong>하며 에너지를 낭비</li>
<li><strong>비동기 방식으로 해결:</strong> CPU는 느린 I/O 작업을 <strong>OS 커널에 위임</strong>하고, 완료를 기다리지 않고 <strong>그 시간 동안 다른 요청을 처리</strong></li>
</ul>
<p><strong>결론:</strong> 비동기는 물리적인 동시 실행(병렬)보다는 <strong>CPU의 유휴(노는) 시간을 제거</strong>하여 프로그램의 반응성과 효율을 높이는 데 초점</p>
</section>
<section id="핵심-작동-원리-이벤트-루프와-협력" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="핵심-작동-원리-이벤트-루프와-협력"><span class="header-section-number">1.2</span> 핵심 작동 원리: 이벤트 루프와 협력</h3>
<p>비동기 프로그래밍이 순서가 꼬이지 않고 안정적으로 작동할 수 있는 핵심은 <strong>이벤트 루프(Event Loop)</strong>와 <strong>협력적 멀티태스킹</strong></p>
<ul>
<li><strong>이벤트 루프 (Event Loop):</strong>
<ul>
<li>비동기 작업의 <strong>교통 정리 관제탑</strong></li>
<li>CPU(메인 스레드)의 상태와 I/O 작업의 완료 여부를 끊임없이 감시하며, CPU가 비어 있을 때 처리할 다음 작업을 스케줄링</li>
</ul></li>
<li><strong>코루틴 (Coroutine):</strong> <code>async def</code>로 정의된 함수로, 실행을 <strong>일시 중지</strong>했다가 나중에 <strong>재개</strong>할 수 있는 특별한 실행 단위</li>
<li><strong><code>await</code> 키워드:</strong>
<ul>
<li>코루틴 내에서 <strong>I/O 대기</strong>가 필요한 지점을 <strong>명시적으로 표시</strong></li>
<li>CPU가 <code>await</code>을 만나면 <strong>스스로 제어권을 이벤트 루프에게 반납</strong>하고, 이벤트 루프는 그 시간에 다른 준비된 코루틴을 실행</li>
<li>주의) CPU가 <code>await</code>을 만나면 <strong>무조건 제어권을 이벤트 루프에게 반납하진 않음</strong></li>
</ul></li>
</ul>
</section>
<section id="비동기-프로그래밍-설계-시-유의사항-cpu-작업의-함정" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="비동기-프로그래밍-설계-시-유의사항-cpu-작업의-함정"><span class="header-section-number">1.3</span> 비동기 프로그래밍 설계 시 유의사항 (CPU 작업의 함정)</h3>
<p>비동기 환경에서 가장 중요한 원칙은 <strong>CPU의 블로킹을 절대 허용하지 않는 것</strong></p>
<ul>
<li><strong>CPU 집약적 연산의 위험:</strong> <code>await</code>이 없는 <strong>오래 걸리는 순수 CPU 연산</strong> (예: 복잡한 계산, 머신러닝 최적화)은 CPU가 제어권을 이벤트 루프에게 반납할 수 있는 <strong>논리적인 틈이 없기 때문</strong>에, <strong>메인 스레드를 블로킹</strong>하여 비동기 시스템 전체를 마비시킴</li>
<li><strong>올바른 설계:</strong>
<ul>
<li>코루틴 내부에는 <strong>I/O 작업(<code>await</code>)</strong>과 <strong>매우 짧은 CPU 연산</strong>만 배치하는 것이 원칙</li>
<li>오래 걸리는 CPU 작업은 <code>asyncio.to_thread()</code> 등을 사용하여 <strong>별도의 스레드에 위임(병렬 처리)</strong>해야함</li>
</ul></li>
</ul>
</section>
</section>
<section id="세부-설명" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="세부-설명"><span class="header-section-number">2</span> 세부 설명</h2>
<section id="비동기-프로그래밍의-등장-배경-속도의-불균형" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="비동기-프로그래밍의-등장-배경-속도의-불균형"><span class="header-section-number">2.1</span> 비동기 프로그래밍의 등장 배경: 속도의 불균형</h3>
<p>앞서 배경에서 언급했듯이, 하나의 프로그램을 실행하는 데 관여하는 <strong>주체들(Components)의 연산 속도 차이가 매우 심하다</strong>는 것이라는 것을 명심.</p>
<ul>
<li><strong>CPU (중앙 처리 장치):</strong> 초당 수십억 번의 연산을 수행하는 ‘매우 빠른 주체’.</li>
<li><strong>I/O (입출력 장치):</strong> 네트워크 통신, 디스크 파일 읽기/쓰기, 데이터베이스 조회 등 ‘매우 느린 주체’.</li>
</ul>
<p>전통적인 <strong>동기(Synchronous) 방식</strong>에서는 CPU가 코드를 순서대로 실행하다가 I/O 작업을 만나면, 그 느린 작업이 완료될 때까지 <strong>CPU는 아무 일도 하지 않고 멈춰서 대기(Blocking)</strong> 하는 것은 엄청난 자원 낭비로 이어짐.</p>
</section>
<section id="비동기asynchronous-방식의-핵심-목표-효율성" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="비동기asynchronous-방식의-핵심-목표-효율성"><span class="header-section-number">2.2</span> 비동기(Asynchronous) 방식의 핵심 목표: 효율성</h3>
<p>비동기 프로그래밍은 이 낭비를 막기 위해 등장</p>
<blockquote class="blockquote">
<p><strong>“빠른 주체(CPU)가 느린 주체(I/O)를 기다리며 쉴 틈을 주지 않고, 그 시간에 다른 일을 하게 만드는 것.”</strong></p>
</blockquote>
<ul>
<li>이것이 궁극적으로 도출된 비동기 프로그래밍의 핵심 목표.</li>
<li>즉, 비동기는 <strong>CPU의 유휴 시간(Idle Time)을 최소화</strong>하여 시스템 전체의 효율(처리량)을 극대화하는 방식</li>
</ul>
</section>
<section id="비동기-vs.-병렬-중요한-구분" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="비동기-vs.-병렬-중요한-구분"><span class="header-section-number">2.3</span> 비동기 vs.&nbsp;병렬: 중요한 구분</h3>
<p>우리는 이것이 <strong>병렬 작업(Parallelism)</strong>과 다르다는 점을 명확히 해야함</p>
<ul>
<li><strong>병렬 작업:</strong> 여러 개의 CPU 코어를 동원해 <strong>하나의 무거운 계산(CPU 작업)</strong>을 동시에 처리하여 ’총 작업 시간’을 줄이는 것. (예: 머신러닝 학습)</li>
<li><strong>비동기 작업 (동시성):</strong> <strong>하나의 CPU 코어</strong>가 여러 개의 <strong>느린 I/O 작업</strong> 사이를 효율적으로 오가며 ’대기 시간’을 활용하는 것</li>
</ul>
</section>
<section id="어떻게-비동기-프로그래밍을-구현하나-await-태깅과-이벤트-루프" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="어떻게-비동기-프로그래밍을-구현하나-await-태깅과-이벤트-루프"><span class="header-section-number">2.4</span> ‘어떻게’ 비동기 프로그래밍을 구현하나? (Await 태깅과 이벤트 루프)</h3>
<ul>
<li>그렇다면 CPU가 어떻게 I/O 작업을 기다리지 않고 다른 일을 할 수 있을까?</li>
<li>여기서 <code>async</code>와 <code>await</code>의 진짜 의미가 등장</li>
</ul>
<section id="프로그래머의-약속-async와-await-태깅" class="level4" data-number="2.4.1">
<h4 data-number="2.4.1" class="anchored" data-anchor-id="프로그래머의-약속-async와-await-태깅"><span class="header-section-number">2.4.1</span> 프로그래머의 약속: <code>async</code>와 <code>await</code> 태깅</h4>
<p>프로그래머가 CPU와 I/O가 할 일을 <strong>구분해서 코딩</strong>해야함</p>
<ul>
<li><strong><code>async def</code> (태깅):</strong>
<ul>
<li>함수를 일반 함수가 아닌 <strong>‘코루틴(Coroutine)’</strong> 객체로 선언</li>
<li>“이 함수는 내부에 I/O 대기(<code>await</code>)가 있을 수 있으니, 비동기적으로 관리되어야 합니다”라는 <strong>태그</strong>를 붙이는 행위</li>
</ul></li>
<li><strong><code>await</code> (마킹):</strong>
<ul>
<li>코루틴 내부에서 <strong>실제로 느린 I/O 작업</strong>이 발생하는 지점을 <strong>마킹</strong></li>
<li>즉, <code>await</code>은 프로그래머가 CPU에게 보내는 신호</li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p><strong>“이 명령어(<code>await</code>)는 외부 I/O 작업이라 오래 걸릴 거야. 그러니 이 작업은 OS 커널 같은 다른 주체에게 맡기고, 너(CPU)는 멈춰서 기다리지 말고 다른 일 하러 가.”</strong></p>
</blockquote>
</section>
<section id="교통-정리의-핵심-이벤트-루프-event-loop" class="level4" data-number="2.4.2">
<h4 data-number="2.4.2" class="anchored" data-anchor-id="교통-정리의-핵심-이벤트-루프-event-loop"><span class="header-section-number">2.4.2</span> 교통 정리의 핵심: 이벤트 루프 (Event Loop)</h4>
<ul>
<li><code>await</code>을 만난 CPU는 <code>await</code> 명령문의 연산 제어권을 포기하고 이 제어권은 <strong>이벤트 루프</strong>로 이동.</li>
<li>즉, 이벤트 루프는 <strong>“비동기 이벤트의 교통 정리 관제탑”</strong></li>
<li><strong>역할:</strong>
<ul>
<li>이벤트 루프는 <strong>단일 스레드</strong> 내에서 수많은 코루틴(Task)들의 상태를 관리</li>
<li>CPU가 놀지 않도록 다음에 실행할 작업을 <strong>스케줄링</strong></li>
</ul></li>
<li><strong>작동 방식 (교통 정리):</strong>
<ol type="1">
<li>CPU가 <strong>Task A</strong>를 실행하다가 <code>await</code> (I/O 작업 1)을 만난다.</li>
<li>CPU는 I/O 작업 1을 OS 커널에 위임하고 <strong>제어권을 이벤트 루프에게 반납</strong>.</li>
<li>이벤트 루프는 CPU가 비었으니, 대기 중인 <strong>Task B</strong>를 CPU에게 넘긴다.</li>
<li>CPU가 Task B를 실행하다가 <code>await</code> (I/O 작업 2)을 만난다.</li>
<li>CPU는 I/O 작업 2를 위임하고 <strong>제어권을 다시 반납</strong>한다.</li>
<li>이벤트 루프는 CPU가 비었지만, 만약 다른 Task가 없다면 대기</li>
<li>이때, OS 커널로부터 “I/O 작업 1이 완료되었습니다!”라는 <strong>알림(콜백)</strong>이 도착</li>
<li>이벤트 루프는 이 알림을 받고, “Task A의 다음 작업을 실행할 차례”라고 판단하여 <strong>Task A</strong>를 다시 CPU에게 넘긴다.</li>
<li>CPU는 Task A의 <code>await</code> 다음 줄부터 연산을 재개</li>
</ol></li>
</ul>
<p>이 모든 과정이 <strong>큐(Queue)</strong>와 <strong>콜백(Callback)</strong>이라는 알고리즘을 기반으로 순서가 뒤죽박죽되지 않고 안정적으로 처리</p>
</section>
<section id="예시" class="level4" data-number="2.4.3">
<h4 data-number="2.4.3" class="anchored" data-anchor-id="예시"><span class="header-section-number">2.4.3</span> 예시</h4>
<p>이 예시는 <strong>단일 스레드</strong> 내에서 여러 개의 코루틴(메서드)이 어떻게 CPU와 I/O 작업을 <strong>협력적으로</strong> 처리하며 전체 시간을 단축하는지를 보여줌</p>
</section>
</section>
</section>
<section id="복합-비동기-시나리오-예시-orderprocessor" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="복합-비동기-시나리오-예시-orderprocessor"><span class="header-section-number">3</span> 복합 비동기 시나리오 예시: <code>OrderProcessor</code></h2>
<ul>
<li>온라인 쇼핑몰의 주문을 처리하는 <code>OrderProcessor</code> 클래스를 가정</li>
<li>주문 처리 과정은 여러 단계를 거치며, 각 단계에는 CPU 연산과 I/O 대기(DB 조회, 결제)가 혼합되어 있다.</li>
</ul>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> asyncio</span>
<span id="cb1-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> time</span>
<span id="cb1-3"></span>
<span id="cb1-4"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">class</span> OrderProcessor:</span>
<span id="cb1-5">    <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">__init__</span>(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>, order_id):</span>
<span id="cb1-6">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.order_id <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> order_id</span>
<span id="cb1-7">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.data <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {}</span>
<span id="cb1-8">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"[</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>order_id<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">] 주문 프로세서 초기화 시작."</span>) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># &lt;--- CPU 작업</span></span>
<span id="cb1-9"></span>
<span id="cb1-10">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1. 코루틴: 사용자 정보를 비동기적으로 조회</span></span>
<span id="cb1-11">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">async</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> fetch_user_info(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>):</span>
<span id="cb1-12">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [CPU 작업] 현재 시각 기록 및 로그 메시지 출력</span></span>
<span id="cb1-13">        start <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> time.time()</span>
<span id="cb1-14">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"[</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>order_id<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">] 1. 사용자 정보 조회 요청..."</span>)</span>
<span id="cb1-15"></span>
<span id="cb1-16">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [I/O 위임 (await)] 1초간 네트워크 대기 시뮬레이션</span></span>
<span id="cb1-17">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># &lt;--- 제어권 반납 (이벤트 루프가 다른 Task로 전환)</span></span>
<span id="cb1-18">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">await</span> asyncio.sleep(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>) </span>
<span id="cb1-19">        </span>
<span id="cb1-20">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [CPU 작업] I/O 완료 후 데이터 처리</span></span>
<span id="cb1-21">        user_info <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"User-</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>order_id<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">-Data"</span></span>
<span id="cb1-22">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.data[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'user'</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> user_info</span>
<span id="cb1-23">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"[</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>order_id<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">] 1. 사용자 정보 조회 완료. (</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>time<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>time() <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> start<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.2f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">초 소요)"</span>)</span>
<span id="cb1-24">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> user_info</span>
<span id="cb1-25"></span>
<span id="cb1-26">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2. 코루틴: 재고 확인 (CPU 집약적인 로직 가정)</span></span>
<span id="cb1-27">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 일반 CPU 연산이므로 await을 사용하지 않아야 하지만, 시간이 너무 길면 블로킹 위험.</span></span>
<span id="cb1-28">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 여기서는 비동기 흐름을 깨지 않는 짧은 CPU 연산으로 가정.</span></span>
<span id="cb1-29">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">async</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> check_inventory(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>):</span>
<span id="cb1-30">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [CPU 작업] 시작 시간 기록</span></span>
<span id="cb1-31">        start <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> time.time()</span>
<span id="cb1-32">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"[</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>order_id<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">] 2. 재고 복잡 연산 시작..."</span>)</span>
<span id="cb1-33"></span>
<span id="cb1-34">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [CPU 작업] 복잡한 재고 연산을 시뮬레이션 (블로킹이 없다고 가정)</span></span>
<span id="cb1-35">        inventory_status <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Available"</span></span>
<span id="cb1-36">        </span>
<span id="cb1-37">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [CPU 작업] 결과 저장 및 출력</span></span>
<span id="cb1-38">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.data[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'inventory'</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> inventory_status</span>
<span id="cb1-39">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"[</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>order_id<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">] 2. 재고 연산 완료. (</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>time<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>time() <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> start<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.2f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">초 소요)"</span>)</span>
<span id="cb1-40">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> inventory_status</span>
<span id="cb1-41"></span>
<span id="cb1-42">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3. 코루틴: 결제 요청 (가장 오래 걸리는 I/O)</span></span>
<span id="cb1-43">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">async</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> process_payment(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>):</span>
<span id="cb1-44">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [CPU 작업] 시작 시간 기록</span></span>
<span id="cb1-45">        start <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> time.time()</span>
<span id="cb1-46">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"[</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>order_id<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">] 3. 결제 요청 시작..."</span>)</span>
<span id="cb1-47"></span>
<span id="cb1-48">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [I/O 위임 (await)] 4초간 외부 결제 API 대기 시뮬레이션</span></span>
<span id="cb1-49">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># &lt;--- 제어권 반납 (이벤트 루프가 다른 Task로 전환)</span></span>
<span id="cb1-50">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">await</span> asyncio.sleep(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">4</span>) </span>
<span id="cb1-51">        </span>
<span id="cb1-52">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># [CPU 작업] I/O 완료 후 결과 처리</span></span>
<span id="cb1-53">        payment_result <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Success"</span></span>
<span id="cb1-54">        <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.data[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'payment'</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> payment_result</span>
<span id="cb1-55">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"[</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>order_id<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">] 3. 결제 완료. (</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>time<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>time() <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> start<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.2f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">초 소요)"</span>)</span>
<span id="cb1-56">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> payment_result</span>
<span id="cb1-57">    </span>
<span id="cb1-58">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 4. 코루틴: 모든 단계를 비동기적으로 실행하고 결과를 취합</span></span>
<span id="cb1-59">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 이 메서드 자체가 여러 코루틴을 묶는 상위 코루틴입니다.</span></span>
<span id="cb1-60">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">async</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> run_full_process(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>):</span>
<span id="cb1-61">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"[</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>order_id<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">] &gt;&gt;&gt; 전체 주문 처리 파이프라인 시작 &lt;&lt;&lt;"</span>)</span>
<span id="cb1-62"></span>
<span id="cb1-63">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 4-1. [CPU/I/O] 사용자 정보 조회</span></span>
<span id="cb1-64">        user_info <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">await</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.fetch_user_info() </span>
<span id="cb1-65">        </span>
<span id="cb1-66">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 4-2. [CPU] 재고 확인</span></span>
<span id="cb1-67">        inventory <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">await</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.check_inventory()</span>
<span id="cb1-68">        </span>
<span id="cb1-69">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 4-3. [CPU/I/O] 결제 처리</span></span>
<span id="cb1-70">        payment <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">await</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span>.process_payment()</span>
<span id="cb1-71">        </span>
<span id="cb1-72">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 4-4. [CPU] 최종 결과 조합 및 출력</span></span>
<span id="cb1-73">        final_status <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"Order </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>order_id<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>user_info<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">, </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>inventory<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">, </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>payment<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span></span>
<span id="cb1-74">        <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"[</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">self</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>order_id<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">] &gt;&gt;&gt; 최종 결과: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>final_status<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;"> &lt;&lt;&lt;"</span>)</span>
<span id="cb1-75">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> final_status</span>
<span id="cb1-76"></span>
<span id="cb1-77"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># -------------------------------------------------------------</span></span>
<span id="cb1-78"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 메인 실행 로직</span></span>
<span id="cb1-79"><span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">async</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> main():</span>
<span id="cb1-80">    start_time <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> time.time()</span>
<span id="cb1-81">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"--- 2개의 주문을 비동기적으로 처리 시작 ---"</span>)</span>
<span id="cb1-82"></span>
<span id="cb1-83">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 두 개의 독립적인 주문 프로세스를 생성 (서로 다른 Task)</span></span>
<span id="cb1-84">    order_a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> OrderProcessor(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Order-A"</span>)</span>
<span id="cb1-85">    order_b <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> OrderProcessor(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Order-B"</span>)</span>
<span id="cb1-86"></span>
<span id="cb1-87">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 두 개의 run_full_process 코루틴을 Task로 만들고 동시에 실행</span></span>
<span id="cb1-88">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 여기서 비동기 동시성(Concurrency)이 발생합니다.</span></span>
<span id="cb1-89">    task_a <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> asyncio.create_task(order_a.run_full_process())</span>
<span id="cb1-90">    task_b <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> asyncio.create_task(order_b.run_full_process())</span>
<span id="cb1-91"></span>
<span id="cb1-92">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 두 Task가 모두 완료될 때까지 기다림</span></span>
<span id="cb1-93">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">await</span> asyncio.gather(task_a, task_b)</span>
<span id="cb1-94">    </span>
<span id="cb1-95">    end_time <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> time.time()</span>
<span id="cb1-96">    <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">--- 최종 소요 시간: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>end_time <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> start_time<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:.2f}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">초 ---"</span>)</span>
<span id="cb1-97"></span>
<span id="cb1-98"><span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">__name__</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"__main__"</span>:</span>
<span id="cb1-99">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 동기적으로 실행했다면: (1+4)초 + (1+4)초 = 약 10초 소요</span></span>
<span id="cb1-100">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 비동기적으로 실행하면: 가장 긴 I/O 시간인 4초에 가까워야 함</span></span>
<span id="cb1-101">    asyncio.run(main())</span></code></pre></div>
<p><strong>연산 처리 순서 및 흐름 설명</strong></p>
<p>총 소요 시간은 <img src="https://latex.codecogs.com/png.latex?4%5Ctext%7B%EC%B4%88%7D%20+%20%5Ctext%7B%EC%95%BD%EA%B0%84%EC%9D%98%20CPU%20%EC%8B%9C%EA%B0%84%7D">에 가깝게 나와야함.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">시간대 (대략)</th>
<th style="text-align: left;">CPU(메인 스레드) 역할</th>
<th style="text-align: left;">Order-A (Task A)</th>
<th style="text-align: left;">Order-B (Task B)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>0.0초</strong></td>
<td style="text-align: left;"><strong>Task A 시작</strong></td>
<td style="text-align: left;"><code>run_full_process</code> 실행</td>
<td style="text-align: left;">대기</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>0.0초</strong></td>
<td style="text-align: left;"><strong>Task B 시작</strong></td>
<td style="text-align: left;"><code>fetch_user_info</code> 실행 (CPU)</td>
<td style="text-align: left;">대기</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>0.0초</strong></td>
<td style="text-align: left;"><strong>제어권 반납</strong></td>
<td style="text-align: left;"><strong>await 1초 대기 (I/O 위임)</strong></td>
<td style="text-align: left;">대기</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>0.0초</strong></td>
<td style="text-align: left;"><strong>Task B 전환</strong></td>
<td style="text-align: left;">대기 (I/O 진행 중)</td>
<td style="text-align: left;"><code>run_full_process</code> 실행</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>0.0초</strong></td>
<td style="text-align: left;"><strong>제어권 반납</strong></td>
<td style="text-align: left;">대기 (I/O 진행 중)</td>
<td style="text-align: left;"><strong>await 1초 대기 (I/O 위임)</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>0.0초</strong></td>
<td style="text-align: left;"><strong>이벤트 루프 유휴</strong></td>
<td style="text-align: left;">I/O 진행 중</td>
<td style="text-align: left;">I/O 진행 중</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>1.0초</strong></td>
<td style="text-align: left;"><strong>Task A 재개</strong></td>
<td style="text-align: left;">I/O 완료, 재고 연산 (CPU)</td>
<td style="text-align: left;">대기</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>1.0초</strong></td>
<td style="text-align: left;"><strong>제어권 반납</strong></td>
<td style="text-align: left;"><code>process_payment</code> 실행 (CPU)</td>
<td style="text-align: left;">I/O 완료, 재고 연산 (CPU)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>1.0초</strong></td>
<td style="text-align: left;"><strong>Task B 재개</strong></td>
<td style="text-align: left;">대기</td>
<td style="text-align: left;"><code>process_payment</code> 실행 (CPU)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>1.0초</strong></td>
<td style="text-align: left;"><strong>제어권 반납</strong></td>
<td style="text-align: left;"><strong>await 4초 대기 (I/O 위임)</strong></td>
<td style="text-align: left;"><strong>await 4초 대기 (I/O 위임)</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>1.0 ~ 5.0초</strong></td>
<td style="text-align: left;"><strong>I/O 진행 중</strong></td>
<td style="text-align: left;">결제 I/O 진행 중</td>
<td style="text-align: left;">결제 I/O 진행 중</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>5.0초</strong></td>
<td style="text-align: left;"><strong>Task A 재개</strong></td>
<td style="text-align: left;">결제 완료, 최종 출력 (CPU)</td>
<td style="text-align: left;">대기</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>5.0초</strong></td>
<td style="text-align: left;"><strong>Task B 재개</strong></td>
<td style="text-align: left;">완료</td>
<td style="text-align: left;">결제 완료, 최종 출력 (CPU)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>5.0초</strong></td>
<td style="text-align: left;"><strong>모든 Task 완료</strong></td>
<td style="text-align: left;">완료</td>
<td style="text-align: left;">완료</td>
</tr>
</tbody>
</table>
<p><strong>결론: 동시성 달성</strong></p>
<ul>
<li>CPU는 <strong>Order-A의 1초 I/O 대기 시간</strong>이 발생했을 때 <strong>Order-B의 1초 I/O 요청</strong>을 처리하는 데 활용</li>
<li><strong>Order-A와 Order-B의 4초 결제 대기 시간</strong> 동안 CPU는 <strong>아무 작업도 하지 않고 대기</strong>하는 대신, <strong>두 결제 요청을 동시에 진행</strong></li>
<li>결과적으로 두 주문의 총 I/O 대기 시간(4초)에 가까운 시간 안에 모든 작업이 완료되어 <strong>효율적인 동시 처리</strong>가 이루어진다.</li>
</ul>
<section id="무엇을-조심해야-하는가-cpu-연산의-함정" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="무엇을-조심해야-하는가-cpu-연산의-함정"><span class="header-section-number">3.1</span> ‘무엇을’ 조심해야 하는가? (CPU 연산의 함정)</h3>
<ul>
<li>이 논리대로라면, 프로그래머가 <code>async def</code>와 <code>await</code>을 잘 설계하는 것이 핵심</li>
<li>프로그래머는 모든 명령문에 대해서 CPU작업과 I/O작업을 구분짓기 힘들 수 있음</li>
</ul>
<section id="코루틴의-구성-cpu-작업과-io-작업의-혼재" class="level4" data-number="3.1.1">
<h4 data-number="3.1.1" class="anchored" data-anchor-id="코루틴의-구성-cpu-작업과-io-작업의-혼재"><span class="header-section-number">3.1.1</span> 코루틴의 구성: CPU 작업과 I/O 작업의 혼재</h4>
<p>우리는 코루틴 내부가 <strong>“CPU가 할 일과 OS(I/O)가 할 일이 섞여 있을 수밖에 없다”</strong>는 것을 확인</p>
<ul>
<li><strong>CPU가 할 일 (Await이 없는 코드):</strong> 변수 할당, 간단한 연산, 로그 찍기.</li>
<li><strong>OS가 할 일 (Await이 있는 코드):</strong> <code>await asyncio.sleep(1)</code>, <code>await client.get(url)</code>.</li>
</ul>
<p>비동기 함수는 이 두 가지가 번갈아 나타나는 <strong>“얇은 껍질(Thin Wrapper)”</strong>처럼 설계되어, CPU가 간단한 연산을 빠르게 처리하고 즉시 <code>await</code>에서 제어권을 반납하도록 유도해야 바람직하다.</p>
</section>
<section id="치명적인-실수-cpu-집약적-작업에-await을-붙인다면" class="level4" data-number="3.1.2">
<h4 data-number="3.1.2" class="anchored" data-anchor-id="치명적인-실수-cpu-집약적-작업에-await을-붙인다면"><span class="header-section-number">3.1.2</span> 치명적인 실수: CPU 집약적 작업에 <code>await</code>을 붙인다면?</h4>
<p>만약 머신러닝의 ‘가중치 최적화’ 같은 <strong>무거운 CPU 연산</strong>에 <code>await</code>을 붙이면 어떻게 될까?</p>
<ul>
<li><strong>잘못된 가정:</strong> <code>await</code>을 붙였으니 CPU가 이 작업을 I/O처럼 다른 곳에 위임하고 다른 일을 할 것이다.</li>
<li><strong>현실:</strong>
<ul>
<li>CPU 연산은 OS 커널에 <strong>위임할 수 없다.</strong></li>
<li>CPU 자신이 <strong>직접</strong> 처리해야 하는 일이다.</li>
<li>즉, CPU 연산에 <code>await</code>을 마킹해도 CPU연산이 일어남</li>
<li>즉, <code>await</code>을 붙이더라도, CPU는 “이건 내가 해야 하는 계산이네”라고 판단하고, 그 <strong>계산이 끝날 때까지 제어권을 이벤트 루프에게 반납하지 않는다.</strong></li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p><strong>결과: 이벤트 루프가 멈춘다 (Blocking).</strong></p>
</blockquote>
<ul>
<li>CPU가 무거운 계산을 하는 동안 이벤트 루프는 스케줄링을 할 수 없게 되고,</li>
<li>다른 모든 비동기 작업(네트워크 요청, 다른 사용자의 응답)이 <strong>완전히 정지</strong></li>
<li>이는 <code>async</code>를 쓰지 않고 동기 코드를 실행한 것과 똑같거나 오히려 더 나쁜 결과를 초래</li>
</ul>
</section>
<section id="최종-결론-올바른-비동기-설계" class="level4" data-number="3.1.3">
<h4 data-number="3.1.3" class="anchored" data-anchor-id="최종-결론-올바른-비동기-설계"><span class="header-section-number">3.1.3</span> 최종 결론: 올바른 비동기 설계</h4>
<ul>
<li>비동기 프로그램은 <strong>I/O 대기 시간</strong>이 긴 작업(네트워크, DB)에 압도적으로 유리</li>
<li>비동기 코루틴(<code>async def</code>) 안에는 <strong>무거운 CPU 연산</strong>을 절대로 배치해서는 안 된다.</li>
<li>만약 무거운 CPU 연산이 필요하다면, <code>asyncio.to_thread()</code> 등을 사용해 <strong>별도의 스레드(병렬 처리)</strong>로 분리하여 이벤트 루프를 막지 않도록 설계해야 한다.</li>
</ul>


</section>
</section>
</section>

 ]]></description>
  <category>Engineering</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Engineering/async.html</guid>
  <pubDate>Wed, 29 Oct 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Programmers Code Problem: Phone Number List</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Code_Test/algorithm/hash_level2_phone_number.html</link>
  <description><![CDATA[ 





<section id="문제-정보" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 문제 정보</h1>
<ul>
<li>제목: 전화번호 목록</li>
<li>링크: https://school.programmers.co.kr/learn/courses/30/lessons/42577</li>
<li><strong>난이도</strong>: 2</li>
<li><strong>유형</strong>: Hash</li>
<li>풀이 시간: 10분</li>
</ul>
</section>
<section id="문제-설명" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 문제 설명</h1>
<p>전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다. 전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.</p>
<ul>
<li>구조대 : 119</li>
<li>박준영 : 97 674 223</li>
<li>지영석 : 11 9552 4421</li>
</ul>
<p>전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를, 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.</p>
<section id="제한-사항" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="제한-사항"><span class="header-section-number">2.1</span> 제한 사항</h2>
<p>phone_book의 길이는 1 이상 1,000,000 이하입니다. 각 전화번호의 길이는 1 이상 20 이하입니다. 같은 전화번호가 중복해서 들어있지 않습니다.</p>
</section>
<section id="입출력-예제" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="입출력-예제"><span class="header-section-number">2.2</span> 입출력 예제</h2>
<table class="caption-top table">
<thead>
<tr class="header">
<th>예시</th>
<th>phone_book</th>
<th>return</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>예시 1</td>
<td>[“119”, “97674223”, “1195524421”]</td>
<td>false</td>
</tr>
<tr class="even">
<td>예시 2</td>
<td>[“123”,“456”,“789”]</td>
<td>true</td>
</tr>
<tr class="odd">
<td>예시 3</td>
<td>[“12”,“123”,“1235”,“567”,“88”]</td>
<td>false</td>
</tr>
</tbody>
</table>
</section>
<section id="입출력-예-설명" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="입출력-예-설명"><span class="header-section-number">2.3</span> 입출력 예 설명</h2>
<p>입출력 예 #1 앞에서 설명한 예와 같습니다.</p>
<p>입출력 예 #2 한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.</p>
<p>입출력 예 #3 첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.</p>
</section>
<section id="알림" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="알림"><span class="header-section-number">2.4</span> 알림</h2>
<p>2021년 3월 4일, 테스트 케이스가 변경되었습니다. 이로 인해 이전에 통과하던 코드가 더 이상 통과하지 않을 수 있습니다.</p>
</section>
</section>
<section id="문제-해설" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> 문제 해설</h1>
<section id="문제-핵심-이해" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="문제-핵심-이해"><span class="header-section-number">3.1</span> 문제 핵심 이해</h2>
<p>이 문제의 핵심은 <strong>한 전화번호가 다른 전화번호의 접두어인지 확인하는 것</strong></p>
<ul>
<li>입력: 전화번호 목록 배열</li>
<li>출력: 접두어 관계가 있으면 false, 없으면 true</li>
<li>목표: 효율적으로 접두어 관계 탐지</li>
</ul>
</section>
<section id="중요한-조건들" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="중요한-조건들"><span class="header-section-number">3.2</span> 중요한 조건들</h2>
<ol type="1">
<li><strong>접두어 정의</strong>: 한 번호가 다른 번호의 시작 부분과 완전히 일치</li>
<li><strong>대용량 데이터</strong>: 최대 1,000,000개의 전화번호 처리 필요</li>
<li><strong>효율성 요구</strong>: O(n²) 방식으로는 시간 초과 발생 가능</li>
</ol>
</section>
<section id="해결-방법별-분석" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="해결-방법별-분석"><span class="header-section-number">3.3</span> 해결 방법별 분석</h2>
<section id="알고리즘-요약" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="알고리즘-요약"><span class="header-section-number">3.3.1</span> 알고리즘 요약</h3>
<section id="핵심-아이디어" class="level4" data-number="3.3.1.1">
<h4 data-number="3.3.1.1" class="anchored" data-anchor-id="핵심-아이디어"><span class="header-section-number">3.3.1.1</span> 핵심 아이디어</h4>
<p><strong>사전순 정렬 후 인접한 번호끼리만 비교</strong>하여 O(n log n) 시간에 모든 접두어 관계를 효율적으로 탐지</p>
</section>
<section id="알고리즘-동작" class="level4" data-number="3.3.1.2">
<h4 data-number="3.3.1.2" class="anchored" data-anchor-id="알고리즘-동작"><span class="header-section-number">3.3.1.2</span> 알고리즘 동작</h4>
<ol type="1">
<li><strong>사전순 정렬</strong>: 전화번호를 문자열 기준으로 정렬</li>
<li><strong>인접 비교</strong>: 정렬된 배열에서 인접한 두 번호만 접두어 관계를 확인</li>
<li><strong>조기 종료</strong>: 접두어 관계를 발견하면 즉시 false를 반환</li>
</ol>
</section>
<section id="왜-효율적인가" class="level4" data-number="3.3.1.3">
<h4 data-number="3.3.1.3" class="anchored" data-anchor-id="왜-효율적인가"><span class="header-section-number">3.3.1.3</span> 왜 효율적인가?</h4>
<p>정렬의 특성상 접두어 관계가 있다면 반드시 인접한 위치에 배치되므로, 모든 쌍을 비교할 필요가 없음</p>
</section>
<section id="핵심-포인트" class="level4" data-number="3.3.1.4">
<h4 data-number="3.3.1.4" class="anchored" data-anchor-id="핵심-포인트"><span class="header-section-number">3.3.1.4</span> 핵심 포인트</h4>
<p><strong>“정렬된 상태에서 접두어는 반드시 인접하다”</strong>는 특성을 활용하여 O(n²) → O(n log n)로 시간복잡도를 획기적으로 개선</p>
</section>
</section>
<section id="정렬-방법-권장" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="정렬-방법-권장"><span class="header-section-number">3.3.2</span> 정렬 방법 (권장)</h3>
<p><strong>시간복잡도</strong>: O(n log n)<br>
<strong>공간복잡도</strong>: O(log n)</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(phone_book):</span>
<span id="cb1-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 사전순 정렬 - O(n log n) 시간, O(log n) 공간(정렬 알고리즘 스택)</span></span>
<span id="cb1-3">    phone_book.sort()</span>
<span id="cb1-4">    </span>
<span id="cb1-5">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 인접한 번호끼리만 접두어 관계 확인 - O(n) 시간, O(1) 공간</span></span>
<span id="cb1-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(phone_book) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(n) 반복</span></span>
<span id="cb1-7">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># startswith 비교 - O(m) 시간 (m: 짧은 번호의 길이)</span></span>
<span id="cb1-8">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> phone_book[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>].startswith(phone_book[i]):</span>
<span id="cb1-9">            <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1) 시간, O(1) 공간</span></span>
<span id="cb1-10">    </span>
<span id="cb1-11">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1) 시간, O(1) 공간</span></span>
<span id="cb1-12"></span>
<span id="cb1-13"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전체 시간복잡도: O(n log n) + O(n * m) = O(n log n) (m &lt;&lt; log n 일반적)</span></span>
<span id="cb1-14"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전체 공간복잡도: O(log n) (정렬 알고리즘의 스택 공간)</span></span></code></pre></div>
<p><strong>동작 원리</strong>: - 사전순 정렬 후 인접한 번호끼리만 비교 - 정렬되어 있으면 접두어 관계는 반드시 인접한 위치에 존재 - 예: [“119”, “1195524421”, “97674223”] 정렬 시 “119”와 “1195524421”이 인접</p>
</section>
<section id="해시셋set-방법" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="해시셋set-방법"><span class="header-section-number">3.3.3</span> 해시셋(Set) 방법</h3>
<p><strong>시간복잡도</strong>: O(n×m²) (n: 번호 개수, m: 평균 번호 길이)<br>
<strong>공간복잡도</strong>: O(n×m)</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(phone_book):</span>
<span id="cb2-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 모든 번호를 해시셋에 저장 - O(n) 시간, O(n * m) 공간</span></span>
<span id="cb2-3">    phone_set <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">set</span>(phone_book)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># n개 번호, 각 번호 평균 m자리</span></span>
<span id="cb2-4">    </span>
<span id="cb2-5">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 각 번호의 모든 접두어가 해시셋에 있는지 확인 - O(n * m) 시간</span></span>
<span id="cb2-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> phone <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> phone_book:  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(n) 반복</span></span>
<span id="cb2-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(phone)):  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(m) 반복 (m: 전화번호 길이)</span></span>
<span id="cb2-8">            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 슬라이싱 O(i), 해시셋 검색 O(1) 평균 → O(m) 최대</span></span>
<span id="cb2-9">            <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> phone[:i] <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> phone_set:</span>
<span id="cb2-10">                <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1) 시간, O(1) 공간</span></span>
<span id="cb2-11">    </span>
<span id="cb2-12">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1) 시간, O(1) 공간</span></span>
<span id="cb2-13"></span>
<span id="cb2-14"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전체 시간복잡도: O(n) + O(n * m^2) = O(n * m^2)</span></span>
<span id="cb2-15"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전체 공간복잡도: O(n * m) (해시셋 저장)</span></span></code></pre></div>
<p><strong>동작 원리</strong>: - 모든 전화번호를 해시셋에 저장 - 각 번호의 모든 가능한 접두어를 생성하여 해시셋에서 검색</p>
</section>
<section id="한-줄-해답-정렬-any-함수" class="level3" data-number="3.3.4">
<h3 data-number="3.3.4" class="anchored" data-anchor-id="한-줄-해답-정렬-any-함수"><span class="header-section-number">3.3.4</span> 한 줄 해답 (정렬 + any 함수)</h3>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(phone_book):</span>
<span id="cb3-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 사전순 정렬 - O(n log n) 시간, O(log n) 공간</span></span>
<span id="cb3-3">    phone_book.sort()</span>
<span id="cb3-4">    </span>
<span id="cb3-5">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># any() 함수로 접두어 관계 확인 - O(n * m) 시간, O(1) 공간</span></span>
<span id="cb3-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">not</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">any</span>(  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># any(): 최악의 경우 O(n) 반복</span></span>
<span id="cb3-7">        phone_book[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>].startswith(phone_book[i])  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># startswith: O(m) 시간</span></span>
<span id="cb3-8">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(phone_book) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 제너레이터: O(1) 공간</span></span>
<span id="cb3-9">    )</span>
<span id="cb3-10"></span>
<span id="cb3-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전체 시간복잡도: O(n log n) + O(n * m) = O(n log n) (m &lt;&lt; log n 일반적)</span></span>
<span id="cb3-12"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 전체 공간복잡도: O(log n) (정렬 알고리즘 스택) + O(1) (제너레이터) = O(log n)</span></span></code></pre></div>
</section>
</section>
<section id="복잡도-비교표" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="복잡도-비교표"><span class="header-section-number">3.4</span> 복잡도 비교표</h2>
<table class="caption-top table">
<thead>
<tr class="header">
<th>방법</th>
<th>시간복잡도</th>
<th>공간복잡도</th>
<th>특징</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>정렬</td>
<td>O(n log n)</td>
<td>O(log n)</td>
<td><strong>가장 효율적, 메모리 절약</strong></td>
</tr>
<tr class="even">
<td>해시셋</td>
<td>O(n×m²)</td>
<td>O(n×m)</td>
<td>구현이 직관적</td>
</tr>
<tr class="odd">
<td>한 줄 해답</td>
<td>O(n log n)</td>
<td>O(log n)</td>
<td>코드가 간결</td>
</tr>
</tbody>
</table>
</section>
<section id="왜-정렬-방법이-최적인가" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="왜-정렬-방법이-최적인가"><span class="header-section-number">3.5</span> 왜 정렬 방법이 최적인가?</h2>
<ol type="1">
<li><strong>핵심 아이디어</strong>: 사전순 정렬 시 접두어 관계는 반드시 인접한 위치에 존재</li>
<li><strong>시간 효율성</strong>: O(n log n) - 정렬 후 한 번의 순회만 필요</li>
<li><strong>공간 효율성</strong>: O(log n) - 정렬 알고리즘의 스택 공간만 사용</li>
<li><strong>단순함</strong>: 구현이 직관적이고 이해하기 쉬움</li>
</ol>
</section>
<section id="핵심-포인트-1" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="핵심-포인트-1"><span class="header-section-number">3.6</span> 핵심 포인트</h2>
<ul>
<li><strong>정렬의 활용</strong>: 사전순 정렬로 비교 대상을 대폭 축소</li>
<li><strong>접두어 특성</strong>: A가 B의 접두어라면, 정렬 후 A는 B보다 앞에 위치</li>
<li><strong>최적화</strong>: 모든 쌍 비교(O(n²)) → 인접 비교(O(n))</li>
</ul>
<p>이 문제의 핵심은 <strong>“정렬을 통한 비교 대상 축소로 효율성을 극대화하는 것”</strong>입니다.</p>
</section>
<section id="예제별-동작-과정" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="예제별-동작-과정"><span class="header-section-number">3.7</span> 예제별 동작 과정</h2>
<section id="예제-1-119-97674223-1195524421-결과-false" class="level3" data-number="3.7.1">
<h3 data-number="3.7.1" class="anchored" data-anchor-id="예제-1-119-97674223-1195524421-결과-false"><span class="header-section-number">3.7.1</span> 예제 1: <code>["119", "97674223", "1195524421"]</code> → 결과: false</h3>
<p><strong>정렬 방법</strong>: 1. 사전순 정렬: <code>["119", "1195524421", "97674223"]</code> 2. 인접 비교: - “119”와 “1195524421”: <code>"1195524421".startswith("119")</code> → True - 접두어 관계 발견! → <strong>답: false</strong></p>
</section>
<section id="예제-2-123-456-789-결과-true" class="level3" data-number="3.7.2">
<h3 data-number="3.7.2" class="anchored" data-anchor-id="예제-2-123-456-789-결과-true"><span class="header-section-number">3.7.2</span> 예제 2: <code>["123", "456", "789"]</code> → 결과: true</h3>
<p><strong>정렬 방법</strong>: 1. 사전순 정렬: <code>["123", "456", "789"]</code> (이미 정렬됨) 2. 인접 비교: - “123”과 “456”: <code>"456".startswith("123")</code> → False - “456”과 “789”: <code>"789".startswith("456")</code> → False - 접두어 관계 없음 → <strong>답: true</strong></p>
</section>
<section id="예제-3-12-123-1235-567-88-결과-false" class="level3" data-number="3.7.3">
<h3 data-number="3.7.3" class="anchored" data-anchor-id="예제-3-12-123-1235-567-88-결과-false"><span class="header-section-number">3.7.3</span> 예제 3: <code>["12", "123", "1235", "567", "88"]</code> → 결과: false</h3>
<p><strong>정렬 방법</strong>: 1. 사전순 정렬: <code>["12", "123", "1235", "567", "88"]</code> 2. 인접 비교: - “12”와 “123”: <code>"123".startswith("12")</code> → True - 접두어 관계 발견! → <strong>답: false</strong></p>


</section>
</section>
</section>

 ]]></description>
  <category>Code Test</category>
  <category>Algorithm Test</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Code_Test/algorithm/hash_level2_phone_number.html</guid>
  <pubDate>Fri, 12 Sep 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Programmers Code Problem Study</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Code_Test/algorithm/hash_level1_runner.html</link>
  <description><![CDATA[ 





<section id="문제-정보" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 문제 정보</h1>
<ul>
<li>제목: 완주하지 못한 선수</li>
<li>링크: https://school.programmers.co.kr/learn/courses/30/lessons/42576</li>
<li><strong>난이도</strong>: 1</li>
<li><strong>유형</strong>: Hash</li>
<li>풀이 시간: 10분</li>
</ul>
</section>
<section id="문제-설명" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 문제 설명</h1>
<p>수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.</p>
<p>마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.</p>
<section id="제한사항" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="제한사항"><span class="header-section-number">2.1</span> 제한사항</h2>
<ul>
<li>마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.</li>
<li>completion의 길이는 participant의 길이보다 1 작습니다.</li>
<li>참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.</li>
<li>참가자 중에는 동명이인이 있을 수 있습니다.</li>
</ul>
</section>
<section id="입출력-예" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="입출력-예"><span class="header-section-number">2.2</span> 입출력 예</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 38%">
<col style="width: 35%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th>participant</th>
<th>completion</th>
<th>return</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[“leo”, “kiki”, “eden”]</td>
<td>[“eden”, “kiki”]</td>
<td>“leo”</td>
</tr>
<tr class="even">
<td>[“marina”, “josipa”, “nikola”, “vinko”, “filipa”]</td>
<td>[“josipa”, “filipa”, “marina”, “nikola”]</td>
<td>“vinko”</td>
</tr>
<tr class="odd">
<td>[“mislav”, “stanko”, “mislav”, “ana”]</td>
<td>[“stanko”, “ana”, “mislav”]</td>
<td>“mislav”</td>
</tr>
</tbody>
</table>
</section>
<section id="입출력-예-설명" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="입출력-예-설명"><span class="header-section-number">2.3</span> 입출력 예 설명</h2>
<section id="예제-1" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="예제-1"><span class="header-section-number">2.3.1</span> 예제 #1</h3>
<p>“leo”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.</p>
</section>
<section id="예제-2" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="예제-2"><span class="header-section-number">2.3.2</span> 예제 #2</h3>
<p>“vinko”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.</p>
</section>
<section id="예제-3" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="예제-3"><span class="header-section-number">2.3.3</span> 예제 #3</h3>
<p>“mislav”는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.</p>
<p>※ 공지 - 2023년 01월 25일 테스트케이스가 추가되었습니다.</p>
</section>
</section>
</section>
<section id="문제-해설" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> 문제 해설</h1>
<section id="문제-핵심-이해" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="문제-핵심-이해"><span class="header-section-number">3.1</span> 문제 핵심 이해</h2>
<p>이 문제의 핵심은 <strong>두 개의 배열에서 빠진 요소 하나를 찾는 것</strong></p>
<ul>
<li>참가자 배열: <code>participant</code> (n명)</li>
<li>완주자 배열: <code>completion</code> (n-1명)</li>
<li>목표: 완주하지 못한 1명 찾기</li>
</ul>
</section>
<section id="중요한-조건들" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="중요한-조건들"><span class="header-section-number">3.2</span> 중요한 조건들</h2>
<ol type="1">
<li><strong>동명이인 존재 가능</strong>: 단순히 이름만 비교하면 안 되고, 개수까지 고려해야 한다.</li>
<li><strong>대용량 데이터</strong>: 최대 100,000명까지 가능하므로 효율적인 알고리즘이 필요하다.</li>
<li><strong>정확히 1명 차이</strong>: completion 길이 = participant 길이 - 1</li>
</ol>
</section>
<section id="해결-방법별-분석" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="해결-방법별-분석"><span class="header-section-number">3.3</span> 해결 방법별 분석</h2>
<section id="해시맵dictionary-방법-권장" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="해시맵dictionary-방법-권장"><span class="header-section-number">3.3.1</span> 해시맵(Dictionary) 방법 (권장)</h3>
<p><strong>시간복잡도</strong>: O(n) + O(n) + O(n) = O(n) <strong>공간복잡도</strong>: O(n) (최악의 경우 모든 참가자가 서로 다른 이름)</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">'''</span></span>
<span id="cb1-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">핵심 아이디어</span></span>
<span id="cb1-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  - 해설: 완주하지 못한 선수는 참가했지만 완주 명단에서 차감되지 않은 유일한 사람이므로, 카운팅 차집합으로 정확히 찾을 수 있음 </span></span>
<span id="cb1-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  - 전략: 참가자 카운트 - 완주자 카운트 = 미완주자의 차집합 원리를 해시맵으로 구현 </span></span>
<span id="cb1-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">알고리즘 동작</span></span>
<span id="cb1-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  - 참가자 딕셔너리 생성: 각 참가자 이름별 개수를 해시맵에 저장</span></span>
<span id="cb1-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  - 완주자 카운트 차감: 완주자 리스트를 순회하며 해당 이름의 카운트를 1씩 차감</span></span>
<span id="cb1-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  - 미완주자 탐색: 카운트 값이 0보다 큰 이름을 찾아 반환</span></span>
<span id="cb1-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">왜 효율적인가?</span></span>
<span id="cb1-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  - 해시맵의 O(1) 접근 시간을 활용하여 전체 O(n) 시간에 동명이인까지 정확히 처리할 수 있음</span></span>
<span id="cb1-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">'''</span></span>
<span id="cb1-12"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(participant, completion):</span>
<span id="cb1-13">    participant_dict <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {} <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 최대 n개의 서로 다른 이름 저장 → O(n) 공간</span></span>
<span id="cb1-14">    </span>
<span id="cb1-15">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 1단계: 참가자 카운트 - O(n)</span></span>
<span id="cb1-16">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> name <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> participant:  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># n번 반복</span></span>
<span id="cb1-17">        participant_dict[name] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> participant_dict.get(name, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb1-18">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 잘못된 방법 - participant_dict[name] = participant_dict[name] + 1</span></span>
<span id="cb1-19">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># → KeyError: 'leo' (처음 등장하는 이름은 키가 없음)</span></span>
<span id="cb1-20">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># dict.get(key, default_value): 값을 가져오는 역할</span></span>
<span id="cb1-21">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># name이라는 키가 딕셔너리에 있으면 → 그 값을 반환</span></span>
<span id="cb1-22">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># name이라는 키가 딕셔너리에 없으면 → 0을 반환 (default 값)</span></span>
<span id="cb1-23">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># + 1 → 참가자 개수 증가 (동명이인 방지)</span></span>
<span id="cb1-24">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 두 번째 "leo" (만약 동명이인이 있다면) → 1 + 1 = 2</span></span>
<span id="cb1-25">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># dict.get() = O(1), dict 할당 = O(1)</span></span>
<span id="cb1-26">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 예시: ["mislav", "stanko", "mislav", "ana"] → {"mislav": 2, "stanko": 1, "ana": 1}</span></span>
<span id="cb1-27">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 1. name = "mislav" (첫 번째)</span></span>
<span id="cb1-28">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict.get("mislav", 0) + 1</span></span>
<span id="cb1-29">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # → 0 + 1 = 1</span></span>
<span id="cb1-30">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict["mislav"] = 1</span></span>
<span id="cb1-31">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 현재 상태: {"mislav": 1}</span></span>
<span id="cb1-32"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># </span></span>
<span id="cb1-33">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 2. name = "stanko"</span></span>
<span id="cb1-34">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict.get("stanko", 0) + 1  </span></span>
<span id="cb1-35">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # → 0 + 1 = 1</span></span>
<span id="cb1-36">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict["stanko"] = 1</span></span>
<span id="cb1-37">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 현재 상태: {"mislav": 1, "stanko": 1}</span></span>
<span id="cb1-38"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># </span></span>
<span id="cb1-39">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 3. name = "mislav" (두 번째, 동명이인!)</span></span>
<span id="cb1-40">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict.get("mislav", 0) + 1</span></span>
<span id="cb1-41">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # → 1 + 1 = 2  (이미 "mislav"가 있어서 1을 반환)</span></span>
<span id="cb1-42">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict["mislav"] = 2</span></span>
<span id="cb1-43">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 현재 상태: {"mislav": 2, "stanko": 1}</span></span>
<span id="cb1-44"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># </span></span>
<span id="cb1-45">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 4. name = "ana"</span></span>
<span id="cb1-46">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict.get("ana", 0) + 1</span></span>
<span id="cb1-47">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # → 0 + 1 = 1</span></span>
<span id="cb1-48">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># participant_dict["ana"] = 1</span></span>
<span id="cb1-49">          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># # 최종 상태: {"mislav": 2, "stanko": 1, "ana": 1}</span></span>
<span id="cb1-50">    </span>
<span id="cb1-51">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 2단계: 완주자 차감 - O(n-1) = O(n)</span></span>
<span id="cb1-52">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> name <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> completion:  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># n-1번 반복</span></span>
<span id="cb1-53">        participant_dict[name] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb1-54">        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># dict 접근 및 수정 = O(1)</span></span>
<span id="cb1-55">    </span>
<span id="cb1-56">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 3단계: 결과 찾기 - O(n)</span></span>
<span id="cb1-57">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> name, count <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> participant_dict.items():  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 최대 n번 반복</span></span>
<span id="cb1-58">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">==</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:</span>
<span id="cb1-59">            <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> name</span></code></pre></div>
<p><strong>동작 원리</strong>: - 참가자 이름별 개수를 카운트 - 완주자 이름별로 개수를 차감 - 남은 개수가 1인 사람이 미완주자</p>
</section>
<section id="정렬-방법" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="정렬-방법"><span class="header-section-number">3.3.2</span> 정렬 방법</h3>
<p><strong>시간복잡도</strong>: O(n log n) + O(n log n) + O(n) = O(n log n)</p>
<ul>
<li>분할 정복(Divide and Conquer) 원리
<ul>
<li>분할: 배열을 절반씩 나누기 → log n 단계 → n개의 요소를 계속 반으로 나누면서 1개가 남을 때까지의 분할 횟수가 log n</li>
<li>n개의 요소를 계속 반으로 나누면서 1개가 남을 때까지의 분할 횟수가 log n</li>
<li>n → n/2 → n/4 → n/8 → … → n/2^k → … → 1 - n/2^k = 1 → 2^k = n → k = log₂n → O(log n)</li>
<li>예시: 8개 요소 정렬 - [8, 3, 1, 7, 0, 10, 2, 5]
<ul>
<li>1단계: [8,3,1,7] | [0,10,2,5] ← 8 → 4, 4</li>
<li>2단계: [8,3|1,7] | [0,10|2,5] ← 4 → 2, 2</li>
<li>3단계: [8|3|1|7] | [0|10|2|5] ← 2 → 1, 1</li>
</ul></li>
<li>총 단계 수: log₂(8) = 3단계 = log n</li>
<li>각 단계마다: 8개 요소 처리 = n개</li>
<li>반으로 나누는 것만으로도 문제 크기를 지수적으로 줄일 수 있어서 O(n) 보다 O(log n)이 더 효율적</li>
<li>정복: 각 단계에서 모든 요소를 비교/병합 → n 개 요소</li>
<li>결과: log n 단계 × n개 처리 = O(n log n)</li>
</ul></li>
</ul>
<p><strong>공간복잡도</strong>: O(1) (입력 배열 자체를 정렬) - O(1) = 상수 시간 (Constant Time)</p>
<ul>
<li>입력 크기에 상관없이 항상 일정한 시간이 걸리는 연산</li>
<li>즉, 추가 메모리를 거의 사용하지 않는다는 뜻 - 모두 O(1) 연산들</li>
</ul>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1">arr[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]           <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 배열 인덱스 접근 = O(1)</span></span>
<span id="cb2-2"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">dict</span>[key]        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 해시맵 접근 = O(1)</span></span>
<span id="cb2-3">x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 변수 할당</span></span>
<span id="cb2-4"><span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 단순 비교</span></span>
<span id="cb2-5">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> x     <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 반환</span></span></code></pre></div>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(participant, completion):</span>
<span id="cb3-2">    participant.sort() <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 시간: O(n log n), 공간: O(1)</span></span>
<span id="cb3-3">    completion.sort() <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 시간: O(n log n), 공간: O(1)</span></span>
<span id="cb3-4">    </span>
<span id="cb3-5">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 순서대로 비교하다가 다른 부분 발견 → 시간: O(n), 공간: O(1)</span></span>
<span id="cb3-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(completion)):  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># n-1번 반복</span></span>
<span id="cb3-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> participant[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!=</span> completion[i]: <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1)</span></span>
<span id="cb3-8">            <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> participant[i]</span>
<span id="cb3-9">    </span>
<span id="cb3-10">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 모두 같다면 마지막 사람이 미완주자</span></span>
<span id="cb3-11">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> participant[<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>] <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1)</span></span></code></pre></div>
<p>따라서, 정렬 방법의 시간복잡도는 O(n log n)이고, 공간복잡도는 O(1)</p>
<ul>
<li>시간복잡도: O(n log n) + O(n log n) + O(n) = O(n log n)</li>
<li>공간복잡도: O(1) + O(1) + O(1) = O(1)</li>
<li>메모리 vs 속도 트레이드오프</li>
<li>결론: 대부분 상황에서는 해시맵이 좋지만, 메모리가 부족한 환경에서는 정렬 방법을 고려할 수 있다</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th>방법</th>
<th>속도</th>
<th>메모리</th>
<th>상황</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>해시맵</td>
<td>빠름 O(n)</td>
<td>많이 씀 O(n)</td>
<td><strong>일반적으로 권장</strong></td>
</tr>
<tr class="even">
<td>정렬</td>
<td>보통 O(n log n)</td>
<td>적게 씀 O(1)</td>
<td>메모리 제약이 있을 때</td>
</tr>
</tbody>
</table>
</section>
<section id="최적-해답-해시맵-사용" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="최적-해답-해시맵-사용"><span class="header-section-number">3.3.3</span> 최적 해답 (해시맵 사용)</h3>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(participant, completion):</span>
<span id="cb4-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 방법 1: Counter 사용 (가장 간단)</span></span>
<span id="cb4-3">    <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> collections <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Counter</span>
<span id="cb4-4">    </span>
<span id="cb4-5">    participant_counter <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Counter(participant) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(n)</span></span>
<span id="cb4-6">    completion_counter <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> Counter(completion) <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(n)</span></span>
<span id="cb4-7">    </span>
<span id="cb4-8">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 차집합으로 미완주자 찾기</span></span>
<span id="cb4-9">    result <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> participant_counter <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> completion_counter <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(n)</span></span>
<span id="cb4-10">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">list</span>(result.keys())[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>] <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(1)</span></span></code></pre></div>
</section>
<section id="한-줄-해답-고급" class="level3" data-number="3.3.4">
<h3 data-number="3.3.4" class="anchored" data-anchor-id="한-줄-해답-고급"><span class="header-section-number">3.3.4</span> 한 줄 해답 (고급)</h3>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(participant, completion):</span>
<span id="cb5-2">    <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> collections <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> Counter</span>
<span id="cb5-3">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">list</span>((Counter(participant) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> Counter(completion)).keys())[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span></code></pre></div>
</section>
<section id="브루트-포스-방법-비권장" class="level3" data-number="3.3.5">
<h3 data-number="3.3.5" class="anchored" data-anchor-id="브루트-포스-방법-비권장"><span class="header-section-number">3.3.5</span> 브루트 포스 방법 (비권장)</h3>
<p><strong>시간복잡도</strong>: O(n²)<br>
<strong>공간복잡도</strong>: O(1)</p>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(participant, completion):</span>
<span id="cb6-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> p <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> participant:</span>
<span id="cb6-3">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> p <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">not</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> completion:</span>
<span id="cb6-4">            <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> p</span>
<span id="cb6-5">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">else</span>:</span>
<span id="cb6-6">            completion.remove(p)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 동명이인 처리</span></span></code></pre></div>
</section>
</section>
<section id="복잡도-비교표" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="복잡도-비교표"><span class="header-section-number">3.4</span> 복잡도 비교표</h2>
<table class="caption-top table">
<thead>
<tr class="header">
<th>방법</th>
<th>시간복잡도</th>
<th>공간복잡도</th>
<th>특징</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>해시맵</td>
<td>O(n)</td>
<td>O(n)</td>
<td><strong>최적 성능, 가독성 좋음</strong></td>
</tr>
<tr class="even">
<td>Counter</td>
<td>O(n)</td>
<td>O(n)</td>
<td><strong>가장 간결, 최적 성능</strong></td>
</tr>
<tr class="odd">
<td>정렬</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>메모리 효율적</td>
</tr>
<tr class="even">
<td>브루트포스</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>비효율적, 비권장</td>
</tr>
</tbody>
</table>
</section>
<section id="왜-해시맵이-최적인가" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="왜-해시맵이-최적인가"><span class="header-section-number">3.5</span> 왜 해시맵이 최적인가?</h2>
<ol type="1">
<li><strong>해시 테이블의 특성</strong>: 삽입, 조회, 수정이 모두 O(1)</li>
<li><strong>선형 탐색</strong>: 각 배열을 한 번씩만 순회 → O(n)</li>
<li><strong>공간-시간 트레이드오프</strong>: 메모리를 조금 더 사용해서 시간을 크게 단축</li>
<li><strong>시간 효율성</strong>: O(n) - 각 배열을 한 번씩만 순회</li>
<li><strong>동명이인 처리</strong>: 이름별 개수를 정확히 관리</li>
<li><strong>구현 단순성</strong>: 직관적이고 이해하기 쉬운 로직</li>
<li><strong>확장성</strong>: 미완주자가 여러 명이어도 쉽게 확장 가능</li>
</ol>
</section>
<section id="핵심-포인트" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="핵심-포인트"><span class="header-section-number">3.6</span> 핵심 포인트</h2>
<ul>
<li><strong>Hash 자료구조의 특성 활용</strong>: O(1) 삽입/조회로 효율성 극대화</li>
<li><strong>카운팅 기법</strong>: 단순 존재 여부가 아닌 개수 비교로 동명이인 문제 해결</li>
<li><strong>차집합 개념</strong>: 전체에서 일부를 빼는 방식으로 누락된 요소 찾기</li>
</ul>
<p>대용량 데이터(최대 100,000명)에서는 <strong>O(n)</strong>과 <strong>O(n²)</strong>의 차이가 매우 크기 때문에 해시맵 방식이 필수적이다</p>
</section>
<section id="예제별-동작-과정" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="예제별-동작-과정"><span class="header-section-number">3.7</span> 예제별 동작 과정</h2>
<section id="예제-1-leo-kiki-eden-eden-kiki" class="level3" data-number="3.7.1">
<h3 data-number="3.7.1" class="anchored" data-anchor-id="예제-1-leo-kiki-eden-eden-kiki"><span class="header-section-number">3.7.1</span> 예제 1: <code>["leo", "kiki", "eden"]</code>, <code>["eden", "kiki"]</code></h3>
<p><strong>해시맵 방법</strong>: 1. participant_dict = {“leo”: 1, “kiki”: 1, “eden”: 1} 2. “eden” 차감 → {“leo”: 1, “kiki”: 1, “eden”: 0} 3. “kiki” 차감 → {“leo”: 1, “kiki”: 0, “eden”: 0} 4. count가 1인 “leo” 반환</p>
</section>
<section id="예제-3-mislav-stanko-mislav-ana-stanko-ana-mislav" class="level3" data-number="3.7.2">
<h3 data-number="3.7.2" class="anchored" data-anchor-id="예제-3-mislav-stanko-mislav-ana-stanko-ana-mislav"><span class="header-section-number">3.7.2</span> 예제 3: <code>["mislav", "stanko", "mislav", "ana"]</code>, <code>["stanko", "ana", "mislav"]</code></h3>
<p><strong>해시맵 방법</strong>: 1. participant_dict = {“mislav”: 2, “stanko”: 1, “ana”: 1} 2. 완주자들 차감 후 → {“mislav”: 1, “stanko”: 0, “ana”: 0} 3. count가 1인 “mislav” 반환</p>
</section>
</section>
</section>
<section id="해시맵-기초" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> 해시맵 기초</h1>
<ul>
<li>해시맵(해시테이블): 컴퓨터 과학 이론에서 사용하는 표준 학술 용어</li>
<li>Python 딕셔너리 = 해시맵(해시테이블) = 해시 기반 키-값 저장소</li>
<li>딕셔너리의 Key → 해시함수 → 인덱스 → 메모리 위치 → Value 할당</li>
</ul>
<section id="딕셔너리의-내부-구현" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="딕셔너리의-내부-구현"><span class="header-section-number">4.1</span> 딕셔너리의 내부 구현</h2>
<p><strong>Python의 <code>dict</code>는 실제로 해시테이블(Hash Table)로 구현</strong>되어 있음 - 즉, 해시맵과 동일한 자료구조 - <code>my_dict = {"key": "value"}</code> - 내부적으로는 해시테이블이 동작 - 1. “key”를 해시함수에 통과 → hash(“key”) = 12345 - 2. 12345 % 배열크기 = 인덱스 계산 - 3. 해당 인덱스에 (“key”, “value”) 저장</p>
</section>
<section id="언어별-용어-차이" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="언어별-용어-차이"><span class="header-section-number">4.2</span> 언어별 용어 차이</h2>
<table class="caption-top table">
<thead>
<tr class="header">
<th>언어</th>
<th>이름</th>
<th>실제로는</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Python</strong></td>
<td>dict</td>
<td>Hash Table</td>
</tr>
<tr class="even">
<td><strong>Java</strong></td>
<td>HashMap</td>
<td>Hash Table</td>
</tr>
<tr class="odd">
<td><strong>C++</strong></td>
<td>unordered_map</td>
<td>Hash Table</td>
</tr>
<tr class="even">
<td><strong>JavaScript</strong></td>
<td>Object, Map</td>
<td>Hash Table</td>
</tr>
<tr class="odd">
<td><strong>C#</strong></td>
<td>Dictionary</td>
<td>Hash Table</td>
</tr>
</tbody>
</table>
</section>
<section id="왜-해시맵이라고-부르는가" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="왜-해시맵이라고-부르는가"><span class="header-section-number">4.3</span> 왜 “해시맵”이라고 부르는가?</h2>
<section id="해시-함수-사용" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="해시-함수-사용"><span class="header-section-number">4.3.1</span> 해시 함수 사용</h3>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 내부 동작 과정</span></span>
<span id="cb7-2">key <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"leo"</span></span>
<span id="cb7-3">hash_value <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">hash</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"leo"</span>)  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 예: 2578946130</span></span>
<span id="cb7-4">index <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> hash_value <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span>    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 배열 크기가 8이면 → 인덱스 2</span></span>
<span id="cb7-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># dict_array[2] 위치에 ("leo", 1) 저장</span></span></code></pre></div>
</section>
<section id="키-값-매핑mapping" class="level3" data-number="4.3.2">
<h3 data-number="4.3.2" class="anchored" data-anchor-id="키-값-매핑mapping"><span class="header-section-number">4.3.2</span> 키-값 매핑(Mapping)</h3>
<div class="sourceCode" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 키를 값으로 "매핑(mapping)"</span></span>
<span id="cb8-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"leo"</span> → <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb8-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"kiki"</span> → <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>  </span>
<span id="cb8-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">"eden"</span> → <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span></code></pre></div>
</section>
</section>
<section id="해시맵의-핵심-특성" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="해시맵의-핵심-특성"><span class="header-section-number">4.4</span> 해시맵의 핵심 특성</h2>
<section id="o1-평균-시간복잡도" class="level3" data-number="4.4.1">
<h3 data-number="4.4.1" class="anchored" data-anchor-id="o1-평균-시간복잡도"><span class="header-section-number">4.4.1</span> O(1) 평균 시간복잡도</h3>
<div class="sourceCode" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 모두 O(1) 평균 시간</span></span>
<span id="cb9-2"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">dict</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"key"</span>]           <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 조회</span></span>
<span id="cb9-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">dict</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"key"</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> value   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 삽입  </span></span>
<span id="cb9-4"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">dict</span>[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"key"</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>      <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 수정</span></span></code></pre></div>
</section>
<section id="해시-충돌-처리" class="level3" data-number="4.4.2">
<h3 data-number="4.4.2" class="anchored" data-anchor-id="해시-충돌-처리"><span class="header-section-number">4.4.2</span> 해시 충돌 처리</h3>
<div class="sourceCode" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 서로 다른 키가 같은 해시값을 가질 때</span></span>
<span id="cb10-2"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">hash</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"leo"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span></span>
<span id="cb10-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">hash</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ana"</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">%</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 충돌!</span></span>
<span id="cb10-4"></span>
<span id="cb10-5"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Python은 Open Addressing으로 해결</span></span>
<span id="cb10-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Open Addressing: 다음 빈 슬롯을 찾아 저장</span></span></code></pre></div>


</section>
</section>
</section>

 ]]></description>
  <category>Code Test</category>
  <category>Algorithm Test</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Code_Test/algorithm/hash_level1_runner.html</guid>
  <pubDate>Thu, 11 Sep 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Programmers Code Problem Study</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Code_Test/algorithm/hash_level1_pocketmon.html</link>
  <description><![CDATA[ 





<section id="문제-정보" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 문제 정보</h1>
<ul>
<li>제목: 폰켓몬</li>
<li>링크: https://school.programmers.co.kr/learn/courses/30/lessons/1845</li>
<li><strong>난이도</strong>: 1</li>
<li><strong>유형</strong>: Hash</li>
<li>풀이 시간: 10분</li>
</ul>
</section>
<section id="문제-설명" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 문제 설명</h1>
<p>당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다. 홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.</p>
<p>첫 번째(3번), 두 번째(1번) 폰켓몬을 선택 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택 두 번째(1번), 세 번째(2번) 폰켓몬을 선택 두 번째(1번), 네 번째(3번) 폰켓몬을 선택 세 번째(2번), 네 번째(3번) 폰켓몬을 선택</p>
<p>이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다. 당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.</p>
<section id="제한사항" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="제한사항"><span class="header-section-number">2.1</span> 제한사항</h2>
<p>nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다. nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다. 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다. 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.</p>
</section>
<section id="입출력-예" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="입출력-예"><span class="header-section-number">2.2</span> 입출력 예</h2>
<table class="caption-top table">
<thead>
<tr class="header">
<th>nums</th>
<th>result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[3,1,2,3]</td>
<td>2</td>
</tr>
<tr class="even">
<td>[3,3,3,2,2,4]</td>
<td>3</td>
</tr>
<tr class="odd">
<td>[3,3,3,2,2,2]</td>
<td>2</td>
</tr>
</tbody>
</table>
</section>
<section id="입출력-예-설명" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="입출력-예-설명"><span class="header-section-number">2.3</span> 입출력 예 설명</h2>
<section id="입출력-예-1" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="입출력-예-1"><span class="header-section-number">2.3.1</span> 입출력 예 #1</h3>
<p>문제의 예시와 같습니다.</p>
</section>
<section id="입출력-예-2" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="입출력-예-2"><span class="header-section-number">2.3.2</span> 입출력 예 #2</h3>
<p>6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다. 가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다.</p>
</section>
<section id="입출력-예-3" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="입출력-예-3"><span class="header-section-number">2.3.3</span> 입출력 예 #3</h3>
<p>6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다. 가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.</p>
</section>
</section>
</section>
<section id="문제-해설" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> 문제 해설</h1>
<section id="문제-핵심-이해" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="문제-핵심-이해"><span class="header-section-number">3.1</span> 문제 핵심 이해</h2>
<p>이 문제의 핵심은 <strong>가장 다양한 종류의 폰켓몬을 선택하는 것</strong></p>
<ul>
<li>전체 폰켓몬: N마리</li>
<li>선택 가능: N/2마리<br>
</li>
<li>목표: 최대한 많은 종류 선택</li>
</ul>
</section>
<section id="중요한-조건들" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="중요한-조건들"><span class="header-section-number">3.2</span> 중요한 조건들</h2>
<ol type="1">
<li><strong>중복 제거</strong>: 같은 종류는 하나만 선택해도 충분</li>
<li><strong>선택 제한</strong>: N/2마리만 선택할 수 있다.</li>
<li><strong>최적 전략</strong>: min(고유 종류 수, N/2)가 정답</li>
</ol>
</section>
<section id="해결-방법별-분석" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="해결-방법별-분석"><span class="header-section-number">3.3</span> 해결 방법별 분석</h2>
<section id="알고리즘-요약" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="알고리즘-요약"><span class="header-section-number">3.3.1</span> 알고리즘 요약</h3>
<section id="핵심-아이디어" class="level4" data-number="3.3.1.1">
<h4 data-number="3.3.1.1" class="anchored" data-anchor-id="핵심-아이디어"><span class="header-section-number">3.3.1.1</span> 핵심 아이디어</h4>
<p><strong>최대한 다양한 종류를 선택하되, N/2개 선택 제한을 넘지 않는</strong> 그리디 전략을 해시셋으로 구현</p>
</section>
<section id="알고리즘-동작" class="level4" data-number="3.3.1.2">
<h4 data-number="3.3.1.2" class="anchored" data-anchor-id="알고리즘-동작"><span class="header-section-number">3.3.1.2</span> 알고리즘 동작</h4>
<ol type="1">
<li><strong>고유 종류 계산</strong>: <code>set()</code>을 사용해 중복을 제거하고 고유한 폰켓몬 종류 개수를 구함</li>
<li><strong>선택 제한 계산</strong>: 전체 개수를 2로 나누어 선택 가능한 최대 개수를 구함</li>
<li><strong>최적값 선택</strong>: 두 값 중 작은 값이 선택할 수 있는 최대 종류 수</li>
</ol>
</section>
<section id="왜-효율적인가" class="level4" data-number="3.3.1.3">
<h4 data-number="3.3.1.3" class="anchored" data-anchor-id="왜-효율적인가"><span class="header-section-number">3.3.1.3</span> 왜 효율적인가?</h4>
<p>해시셋의 자동 중복 제거 기능을 활용하여 O(n) 시간에 간단하고 직관적으로 해결할 수 있음</p>
</section>
<section id="핵심-포인트" class="level4" data-number="3.3.1.4">
<h4 data-number="3.3.1.4" class="anchored" data-anchor-id="핵심-포인트"><span class="header-section-number">3.3.1.4</span> 핵심 포인트</h4>
<p>다양성을 최대화하려면 <strong>“각 종류마다 최대 1마리씩만 선택”</strong>하는 것이 최적이므로, 고유 종류 수와 선택 가능 수 중 작은 값이 정답</p>
</section>
</section>
<section id="해시셋set-방법-권장" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="해시셋set-방법-권장"><span class="header-section-number">3.3.2</span> 해시셋(Set) 방법 (권장)</h3>
<p><strong>시간복잡도</strong>: O(n)<br>
<strong>공간복잡도</strong>: O(n)</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(nums):</span>
<span id="cb1-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 고유한 종류의 개수 구하기</span></span>
<span id="cb1-3">    unique_types <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">set</span>(nums))  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># O(n) 시간, O(n) 공간</span></span>
<span id="cb1-4">    max_selection <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">//</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># N/2 계산</span></span>
<span id="cb1-5">    </span>
<span id="cb1-6">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 최대한 다양하게 선택할 수 있는 종류 수</span></span>
<span id="cb1-7">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(unique_types, max_selection)</span></code></pre></div>
<p><strong>동작 원리</strong>: - <code>set()</code>을 사용해 중복 제거하여 고유 종류 개수 계산 - <code>N/2</code>개만 선택 가능하므로 둘 중 작은 값이 정답</p>
</section>
<section id="해시맵dictionary-방법" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="해시맵dictionary-방법"><span class="header-section-number">3.3.3</span> 해시맵(Dictionary) 방법</h3>
<p><strong>시간복잡도</strong>: O(n)<br>
<strong>공간복잡도</strong>: O(n)</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(nums):</span>
<span id="cb2-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 각 종류별 개수 카운트</span></span>
<span id="cb2-3">    pokemon_count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {}</span>
<span id="cb2-4">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> pokemon <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> nums:</span>
<span id="cb2-5">        pokemon_count[pokemon] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> pokemon_count.get(pokemon, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb2-6">    </span>
<span id="cb2-7">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 고유 종류 수와 선택 가능 수 비교</span></span>
<span id="cb2-8">    unique_types <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(pokemon_count)</span>
<span id="cb2-9">    max_selection <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">//</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span></span>
<span id="cb2-10">    </span>
<span id="cb2-11">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(unique_types, max_selection)</span></code></pre></div>
<p><strong>동작 원리</strong>: - 각 폰켓몬 종류별로 개수를 딕셔너리에 저장 - 딕셔너리의 키 개수 = 고유 종류 수 - min(고유 종류 수, N/2) 반환</p>
</section>
<section id="정렬-중복-제거-방법" class="level3" data-number="3.3.4">
<h3 data-number="3.3.4" class="anchored" data-anchor-id="정렬-중복-제거-방법"><span class="header-section-number">3.3.4</span> 정렬 + 중복 제거 방법</h3>
<p><strong>시간복잡도</strong>: O(n log n)<br>
<strong>공간복잡도</strong>: O(1)</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(nums):</span>
<span id="cb3-2">    nums.sort()  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 정렬 O(n log n)</span></span>
<span id="cb3-3">    </span>
<span id="cb3-4">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 인접한 요소 비교로 고유 종류 개수 계산</span></span>
<span id="cb3-5">    unique_count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 첫 번째 요소는 항상 고유</span></span>
<span id="cb3-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums)):</span>
<span id="cb3-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">if</span> nums[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">!=</span> nums[i<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>]:  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 이전 요소와 다르면 새로운 종류</span></span>
<span id="cb3-8">            unique_count <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb3-9">    </span>
<span id="cb3-10">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(unique_count, <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">//</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span></code></pre></div>
<p><strong>특징</strong>: - 메모리 효율적이지만 정렬로 인한 시간 오버헤드 존재 - 메모리 제약이 있는 환경에서 고려</p>
</section>
</section>
<section id="정답-코드" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="정답-코드"><span class="header-section-number">3.4</span> 정답 코드</h2>
<section id="최적-해답-해시셋-사용" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="최적-해답-해시셋-사용"><span class="header-section-number">3.4.1</span> 최적 해답 (해시셋 사용)</h3>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(nums):</span>
<span id="cb4-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 가장 간단하고 직관적</span></span>
<span id="cb4-3">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">set</span>(nums)), <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">//</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span></code></pre></div>
</section>
<section id="해시맵-사용-해답" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="해시맵-사용-해답"><span class="header-section-number">3.4.2</span> 해시맵 사용 해답</h3>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(nums):</span>
<span id="cb5-2">    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 종류별 개수까지 알고 싶을 때</span></span>
<span id="cb5-3">    pokemon_types <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> {}</span>
<span id="cb5-4">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">for</span> pokemon <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">in</span> nums:</span>
<span id="cb5-5">        pokemon_types[pokemon] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> pokemon_types.get(pokemon, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb5-6">    </span>
<span id="cb5-7">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(pokemon_types), <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">//</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span></code></pre></div>
</section>
<section id="한-줄-해답-고급" class="level3" data-number="3.4.3">
<h3 data-number="3.4.3" class="anchored" data-anchor-id="한-줄-해답-고급"><span class="header-section-number">3.4.3</span> 한 줄 해답 (고급)</h3>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">def</span> solution(nums):</span>
<span id="cb6-2">    <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">return</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">set</span>(nums)), <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(nums) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">//</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span></code></pre></div>
</section>
</section>
<section id="복잡도-비교표" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="복잡도-비교표"><span class="header-section-number">3.5</span> 복잡도 비교표</h2>
<table class="caption-top table">
<thead>
<tr class="header">
<th>방법</th>
<th>시간복잡도</th>
<th>공간복잡도</th>
<th>특징</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>해시셋</td>
<td>O(n)</td>
<td>O(n)</td>
<td><strong>최적 성능, 가장 간단</strong></td>
</tr>
<tr class="even">
<td>해시맵</td>
<td>O(n)</td>
<td>O(n)</td>
<td>종류별 개수 정보 추가 제공</td>
</tr>
<tr class="odd">
<td>정렬</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>메모리 효율적</td>
</tr>
</tbody>
</table>
</section>
<section id="왜-해시셋이-최적인가" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="왜-해시셋이-최적인가"><span class="header-section-number">3.6</span> 왜 해시셋이 최적인가?</h2>
<ol type="1">
<li><strong>단순함</strong>: <code>min(len(set(nums)), len(nums) // 2)</code> 한 줄로 해결</li>
<li><strong>시간 효율성</strong>: O(n) - 배열을 한 번만 순회</li>
<li><strong>직관성</strong>: “고유한 종류 수”라는 개념과 정확히 일치</li>
<li><strong>자동 중복 제거</strong>: set 자료구조가 자동으로 중복을 제거</li>
</ol>
</section>
<section id="핵심-포인트-1" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="핵심-포인트-1"><span class="header-section-number">3.7</span> 핵심 포인트</h2>
<ul>
<li><strong>중복 제거</strong>: set을 사용해 고유 종류만 추출</li>
<li><strong>그리디 전략</strong>: 최대한 다양한 종류를 선택하는 것이 최적</li>
<li><strong>제한 조건</strong>: N/2개만 선택할 수 있으므로 min() 함수 사용</li>
</ul>
<p>이 문제의 핵심은 <strong>“가능한 많은 종류를 선택하되, N/2개 제한을 넘지 않는 것”</strong>입니다.</p>
</section>
<section id="예제별-동작-과정" class="level2" data-number="3.8">
<h2 data-number="3.8" class="anchored" data-anchor-id="예제별-동작-과정"><span class="header-section-number">3.8</span> 예제별 동작 과정</h2>
<section id="예제-1-3123-결과-2" class="level3" data-number="3.8.1">
<h3 data-number="3.8.1" class="anchored" data-anchor-id="예제-1-3123-결과-2"><span class="header-section-number">3.8.1</span> 예제 1: <code>[3,1,2,3]</code> → 결과: 2</h3>
<p><strong>해시셋 방법</strong>: 1. <code>set([3,1,2,3])</code> = <code>{1, 2, 3}</code> → 고유 종류: 3개 2. <code>len([3,1,2,3]) // 2</code> = <code>4 // 2</code> = 2 → 선택 가능: 2개 3. <code>min(3, 2)</code> = 2 → <strong>답: 2</strong></p>
</section>
<section id="예제-2-333224-결과-3" class="level3" data-number="3.8.2">
<h3 data-number="3.8.2" class="anchored" data-anchor-id="예제-2-333224-결과-3"><span class="header-section-number">3.8.2</span> 예제 2: <code>[3,3,3,2,2,4]</code> → 결과: 3</h3>
<p><strong>해시셋 방법</strong>: 1. <code>set([3,3,3,2,2,4])</code> = <code>{2, 3, 4}</code> → 고유 종류: 3개 2. <code>len([3,3,3,2,2,4]) // 2</code> = <code>6 // 2</code> = 3 → 선택 가능: 3개 3. <code>min(3, 3)</code> = 3 → <strong>답: 3</strong></p>
</section>
<section id="예제-3-333222-결과-2" class="level3" data-number="3.8.3">
<h3 data-number="3.8.3" class="anchored" data-anchor-id="예제-3-333222-결과-2"><span class="header-section-number">3.8.3</span> 예제 3: <code>[3,3,3,2,2,2]</code> → 결과: 2</h3>
<p><strong>해시셋 방법</strong>: 1. <code>set([3,3,3,2,2,2])</code> = <code>{2, 3}</code> → 고유 종류: 2개 2. <code>len([3,3,3,2,2,2]) // 2</code> = <code>6 // 2</code> = 3 → 선택 가능: 3개 3. <code>min(2, 3)</code> = 2 → <strong>답: 2</strong> (종류가 부족해서 제한됨)</p>


</section>
</section>
</section>

 ]]></description>
  <category>Code Test</category>
  <category>Algorithm Test</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Code_Test/algorithm/hash_level1_pocketmon.html</guid>
  <pubDate>Wed, 10 Sep 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>VSCode 환경설정</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/RAG/00-Intro/2-3.settings_VScode_JASON.html</link>
  <description><![CDATA[ 





<section id="vs-code-환경설정-optional" class="level1" data-number="1">

<ul>
<li>안해도됨</li>
<li><code>ctrl + shift + p</code>: ‘Preferences: Open User Settings (JSON)’
<ul>
<li>아래 내용 추가</li>
</ul>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode numberSource json number-lines code-with-copy"><code class="sourceCode json"><span id="cb1-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb1-2">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">에디터</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">관련</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-3">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.fontSize"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">16</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">에디터의</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">기본</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">글꼴</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">크기를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">16으로</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-4">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.fontVariations"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">false</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">글꼴</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">스타일</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">변형을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">사용하지</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">않음</span></span>
<span id="cb1-5">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.defaultFormatter"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ms-python.black-formatter"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">에디터의</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">기본</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">코드</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">포맷터로</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">Black을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">지정</span></span>
<span id="cb1-6">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.autoClosingBrackets"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"never"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">자동</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">괄호</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">닫기</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">기능을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">사용하지</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">않음</span></span>
<span id="cb1-7">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.autoClosingQuotes"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"never"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">자동</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">인용</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">부호</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">닫기</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">기능을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">사용하지</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">않음</span></span>
<span id="cb1-8">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.inlineSuggest.enabled"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">인라인</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">자동</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">완성을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">활성화</span></span>
<span id="cb1-9">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.parameterHints.enabled"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">함수</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">호출</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">시</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">파라미터</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">정보를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">보여주는</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">힌트를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">활성화</span></span>
<span id="cb1-10">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.quickSuggestions"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb1-11">        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"other"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">기타</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">텍스트에서는</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">제안을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">활성화</span></span>
<span id="cb1-12">        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"comments"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">false</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">주석에서는</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">제안을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">비활성화</span></span>
<span id="cb1-13">        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"strings"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">false</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">문자열</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">내에서는</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">제안을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">비활성화</span></span>
<span id="cb1-14">    <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">},</span></span>
<span id="cb1-15">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.quickSuggestionsDelay"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">빠른</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">제안이</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">나타나기까지의</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">지연</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">시간(밀리초)을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-16">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.suggestOnTriggerCharacters"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">트리거</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">문자</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">입력</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">시</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">자동으로</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">제안을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">표시</span></span>
<span id="cb1-17">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.suggest.localityBonus"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">커서</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">근처에</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">나타나는</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">단어를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">우선적으로</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">제안</span></span>
<span id="cb1-18">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.wordBasedSuggestions"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"matchingDocuments"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">문서</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">내</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">매칭된</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">단어</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">기반의</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">제안을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">활성화</span></span>
<span id="cb1-19">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.acceptSuggestionOnCommitCharacter"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">커밋</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">문자에서</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">제안을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">수락</span></span>
<span id="cb1-20">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.acceptSuggestionOnEnter"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"on"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">Enter</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">키를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">누를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">때</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">제안을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">수락</span></span>
<span id="cb1-21"></span>
<span id="cb1-22">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">터미널</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-23">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"terminal.integrated.fontSize"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">20</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">터미널</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">내부의</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">글꼴</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">크기를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">20으로</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-24">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"terminal.integrated.inheritEnv"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">false</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">터미널이</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">시스템</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">환경</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">변수를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">상속받지</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">않도록</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-25"></span>
<span id="cb1-26">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">Git</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-27">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"git.autofetch"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">Git</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">저장소를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">자동으로</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">fetch하는</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">기능을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">활성화</span></span>
<span id="cb1-28"></span>
<span id="cb1-29">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">마크다운</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-30">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"markdown.preview.fontSize"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">20</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">마크다운</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">미리보기에서</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">사용할</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">글꼴</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">크기를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">20으로</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-31">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"markdown.styles"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">마크다운</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">스타일시트</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">URL을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-32">        <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"https://use.fontawesome.com/releases/v5.7.1/css/all.css"</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb1-33">        <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"markdown-stype.css"</span></span>
<span id="cb1-34">    <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb1-35"></span>
<span id="cb1-36">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">소스</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">코드</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">관리</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-37">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"scm.inputFontSize"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">20</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">소스</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">코드</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">관리</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">입력</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">필드의</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">글꼴</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">크기를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">20으로</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-38"></span>
<span id="cb1-39">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">워크벤치</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-40">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"workbench.startupEditor"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"none"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">VS</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">Code</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">시작</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">시</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">에디터를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">열지</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">않도록</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-41"></span>
<span id="cb1-42">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">보안</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-43">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"security.workspace.trust.untrustedFiles"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"open"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">신뢰되지</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">않은</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">파일을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">열</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">때</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">자동으로</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">염</span></span>
<span id="cb1-44"></span>
<span id="cb1-45">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">탐색기</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-46">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"explorer.confirmDelete"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">false</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">파일을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">삭제할</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">때</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">확인</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">메시지를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">표시하지</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">않음</span></span>
<span id="cb1-47">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"explorer.compactFolders"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">false</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">탐색기에서</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">폴더를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">컴팩트하게</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">표시하지</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">않음</span></span>
<span id="cb1-48">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"explorer.confirmDragAndDrop"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">false</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">드래그</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">앤</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">드롭을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">할</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">때</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">확인</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">메시지를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">표시하지</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">않음</span></span>
<span id="cb1-49">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"explorer.confirmPasteNative"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">false</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">네이티브</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">파일을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">붙여넣을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">때</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">확인</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">메시지를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">표시하지</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">않음</span></span>
<span id="cb1-50"></span>
<span id="cb1-51">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">파일</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-52">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"files.autoSave"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"afterDelay"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">파일을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">변경</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">후</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">일정</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">시간이</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">지나면</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">자동</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">저장</span></span>
<span id="cb1-53"></span>
<span id="cb1-54">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">브레드크럼</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-55">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"breadcrumbs.enabled"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">false</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">파일</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">경로</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">내비게이션을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">비활성화</span></span>
<span id="cb1-56"></span>
<span id="cb1-57">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">Jupyter</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-58">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"jupyter.themeMatplotlibPlots"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">Jupyter에서</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">Matplotlib</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">플롯을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">현재</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">테마에</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">맞게</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">색상화</span></span>
<span id="cb1-59">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"jupyter.askForKernelRestart"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">false</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">Jupyter</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">커널</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">재시작을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">요청하지</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">않음</span></span>
<span id="cb1-60">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"jupyter.widgetScriptSources"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">Jupyter</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">위젯을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">위한</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">스크립트</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">소스를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-61">        <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"jsdelivr.com"</span><span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb1-62">        <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"unpkg.com"</span></span>
<span id="cb1-63">    <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">]</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb1-64"></span>
<span id="cb1-65">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">노트북</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-66">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"notebook.output.wordWrap"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">노트북</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">출력에서</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">자동</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">줄바꿈을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">활성화</span></span>
<span id="cb1-67">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"notebook.formatOnSave.enabled"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">노트북</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">저장</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">시</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">자동으로</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">포맷</span></span>
<span id="cb1-68">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"notebook.output.scrolling"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">노트북</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">출력을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">스크롤</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">가능하게</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-69">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"notebook.lineNumbers"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"on"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">노트북에서</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">줄</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">번호를</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">표시</span></span>
<span id="cb1-70"></span>
<span id="cb1-71">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">CSS</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span></span>
<span id="cb1-72">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"css.lint.emptyRules"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ignore"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span>  <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">CSS</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">린트에서</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">빈</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">규칙을</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">무시</span></span>
<span id="cb1-73"></span>
<span id="cb1-74">    <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">//</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">언어별</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">설정</span> <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">(Python)</span></span>
<span id="cb1-75">    <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"[python]"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">{</span></span>
<span id="cb1-76">        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.defaultFormatter"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"ms-python.black-formatter"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb1-77">        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.formatOnType"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb1-78">        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.formatOnSave"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb1-79">        <span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">"editor.parameterHints.enabled"</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">true</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">,</span></span>
<span id="cb1-80">    <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}</span></span>
<span id="cb1-81"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">}</span></span></code></pre></div></li>
<li>extension 설치
<ul>
<li>Black Formatter</li>
<li>Ruff Linter</li>
</ul></li>
</ul>


</section>

 ]]></description>
  <category>RAG</category>
  <guid>kk3225.netlify.app/docs/blog/posts/RAG/00-Intro/2-3.settings_VScode_JASON.html</guid>
  <pubDate>Wed, 04 Jun 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>LangChain 소개</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/RAG/00-Intro/3-0.LangChain_intro.html</link>
  <description><![CDATA[ 





<section id="langchain-소개" class="level1" data-number="1">

<section id="langchain이란" class="level2" data-number="1.1">

<ul>
<li>LangChain은 대규모 언어 모델(LLM)을 활용한 애플리케이션을 쉽게 개발할 수 있도록 도와주는 오픈소스 프레임워크다.</li>
<li>똑똑한 LLM을 제대로 사용하기 위해선 Prompt에 질문을 잘 입력해야하지만 어렵거나 많은 대화를 주고 받아야한다.</li>
<li>LangChain은 이러한 문제를 해결하여 원하는 비즈니스 로직을 구현하기 위한 프레임워크다.
<ul>
<li>자동화 또는 workflow들을 chain으로 엮어 관리</li>
</ul></li>
<li>예를 들어, 문서를 넣고 임베딩하여 벡터 데이터베이스에 저장하고, 검색하여 원하는 정보를 추출하는 것을 자동화 할 수 있다.
<ul>
<li>langchain에서는 이 과정이 굉장히 편하게 구현될 수 있다.</li>
<li>문서의 어떤 부분이 입력부분으로 사용되는지</li>
<li>프롬프트는 어떻게 작성되었는지</li>
<li>출력은 어떻게 되는지를 세세하게 관찰 및 관리하여 성능을 높혀야한다.</li>
</ul></li>
<li>Langchain의 규모는 점점 커지고 있고 많은 DBMS 기업들과 같은 대형 기업들이 Langchain 개발사와 협력하고 있다.</li>
<li>여러 지원 프로그램을 사용해서 더 쉽게 사용할 수 있다.
<ul>
<li>LangSmith: 추적 기능 서비스</li>
<li>LangGraph: 다중 협업 관리 서비스</li>
<li>LangServe: 배포를 쉽게 할 수 있는 서비스</li>
</ul></li>
</ul>
<section id="주요-특징" class="level3" data-number="1.1.1">

<ul>
<li><strong>모듈화된 구조</strong>: 각 기능을 독립적인 모듈로 제공하여 필요한 부분만 선택적으로 사용 가능</li>
<li><strong>다양한 LLM 지원</strong>: OpenAI GPT, Anthropic Claude, Google PaLM 등 다양한 LLM 모델 지원</li>
<li><strong>체인 구성</strong>: 여러 작업을 연결하여 복잡한 워크플로우 구성 가능</li>
<li><strong>메모리 관리</strong>: 대화 기록 및 컨텍스트 관리 기능 제공</li>
<li><strong>외부 도구 연동</strong>: 검색 엔진, 데이터베이스, API 등 외부 도구와의 연동 지원</li>
</ul>
</section>
</section>
<section id="langchain의-핵심-구성-요소" class="level2" data-number="1.2">

<section id="models-모델" class="level3" data-number="1.2.1">

<ul>
<li><strong>LLMs</strong>: 텍스트 입력을 받아 텍스트를 생성하는 모델</li>
<li><strong>Chat Models</strong>: 대화형 인터페이스를 제공하는 모델</li>
<li><strong>Text Embedding Models</strong>: 텍스트를 벡터로 변환하는 모델</li>
</ul>
</section>
<section id="prompts-프롬프트" class="level3" data-number="1.2.2">

<ul>
<li><strong>Prompt Templates</strong>: 동적으로 프롬프트를 생성하는 템플릿</li>
<li><strong>Example Selectors</strong>: 상황에 맞는 예시를 선택하는 도구</li>
<li><strong>Output Parsers</strong>: LLM 출력을 구조화된 형태로 파싱</li>
</ul>
</section>
<section id="chains-체인" class="level3" data-number="1.2.3">

<ul>
<li><strong>Simple Chains</strong>: 단순한 작업 연결</li>
<li><strong>Sequential Chains</strong>: 순차적 작업 실행</li>
<li><strong>Router Chains</strong>: 조건에 따른 분기 처리</li>
</ul>
</section>
<section id="memory-메모리" class="level3" data-number="1.2.4">

<ul>
<li><strong>Conversation Buffer Memory</strong>: 대화 기록 저장</li>
<li><strong>Conversation Summary Memory</strong>: 대화 요약 저장</li>
<li><strong>Vector Store Memory</strong>: 벡터 기반 메모리 저장</li>
</ul>
</section>
<section id="agents-에이전트" class="level3" data-number="1.2.5">

<ul>
<li><strong>Tool-using Agents</strong>: 외부 도구를 사용하는 에이전트</li>
<li><strong>Conversational Agents</strong>: 대화형 에이전트</li>
<li><strong>Custom Agents</strong>: 사용자 정의 에이전트</li>
</ul>
</section>
</section>
<section id="langchain의-장점" class="level2" data-number="1.3">

<section id="개발-생산성-향상" class="level3" data-number="1.3.1">

<ul>
<li>복잡한 LLM 애플리케이션을 간단한 코드로 구현 가능</li>
<li>재사용 가능한 컴포넌트 제공</li>
<li>풍부한 문서와 예제 제공</li>
</ul>
</section>
<section id="확장성" class="level3" data-number="1.3.2">

<ul>
<li>모듈화된 구조로 필요에 따라 기능 추가/제거 가능</li>
<li>다양한 LLM 모델과 외부 서비스 연동 지원</li>
<li>커스텀 컴포넌트 개발 가능</li>
</ul>
</section>
<section id="유연성" class="level3" data-number="1.3.3">

<ul>
<li>다양한 사용 사례에 맞는 템플릿 제공</li>
<li>체인을 통한 복잡한 워크플로우 구성</li>
<li>조건부 로직 및 분기 처리 지원</li>
</ul>
</section>
</section>
<section id="주요-사용-사례" class="level2" data-number="1.4">

<section id="챗봇-개발" class="level3" data-number="1.4.1">

<ul>
<li>고객 서비스 챗봇</li>
<li>개인 비서 챗봇</li>
<li>도메인 특화 Q&amp;A 시스템</li>
</ul>
</section>
<section id="문서-분석" class="level3" data-number="1.4.2">

<ul>
<li>문서 요약</li>
<li>정보 추출</li>
<li>문서 검색 및 질의응답</li>
</ul>
</section>
<section id="코드-생성" class="level3" data-number="1.4.3">

<ul>
<li>자동 코드 생성</li>
<li>코드 리뷰 및 최적화</li>
<li>기술 문서 생성</li>
</ul>
</section>
<section id="데이터-분석" class="level3" data-number="1.4.4">

<ul>
<li>자연어 기반 데이터 쿼리</li>
<li>보고서 자동 생성</li>
<li>인사이트 추출</li>
</ul>
</section>
</section>
<section id="langchain-vs-다른-프레임워크" class="level2" data-number="1.5">

<section id="langchain의-차별점" class="level3" data-number="1.5.1">

<ul>
<li><strong>포괄적인 생태계</strong>: LLM 애플리케이션 개발에 필요한 모든 도구 제공</li>
<li><strong>활발한 커뮤니티</strong>: 지속적인 업데이트와 풍부한 리소스</li>
<li><strong>실용적 접근</strong>: 실제 프로덕션 환경에서 사용 가능한 안정성</li>
<li><strong>교육 자료</strong>: 체계적인 학습 자료와 튜토리얼 제공</li>
</ul>
</section>
</section>
<section id="시작하기-전-준비사항" class="level2" data-number="1.6">

<section id="필수-지식" class="level3" data-number="1.6.1">

<ul>
<li>Python 기본 문법</li>
<li>API 사용 경험</li>
<li>기본적인 머신러닝 개념</li>
</ul>
</section>
<section id="권장-지식" class="level3" data-number="1.6.2">

<ul>
<li>자연어 처리 기초</li>
<li>벡터 데이터베이스 개념</li>
<li>클라우드 서비스 사용 경험</li>
</ul>
</section>
<section id="개발-환경" class="level3" data-number="1.6.3">

<ul>
<li>Python 3.8 이상</li>
<li>OpenAI API 키 (또는 다른 LLM 서비스 키)</li>
<li>적절한 IDE (VSCode, PyCharm 등)</li>
</ul>


</section>
</section>
</section>

 ]]></description>
  <category>RAG</category>
  <guid>kk3225.netlify.app/docs/blog/posts/RAG/00-Intro/3-0.LangChain_intro.html</guid>
  <pubDate>Wed, 04 Jun 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>LangSmith 환경설정</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/RAG/00-Intro/2-2.settings_LangSmith.html</link>
  <description><![CDATA[ 





<section id="langsmith-추적-환경설정" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> LangSmith 추적 환경설정</h1>
<ul>
<li>LangSmith는 LLM 애플리케이션 개발, 모니터링 및 테스트 를 위한 플랫폼</li>
<li>프로젝트나 LangChain 학습자들은 LangSmith를 설정 후 진행하는 것을 추천</li>
</ul>
<section id="langsmith-의-추적기능" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="langsmith-의-추적기능"><span class="header-section-number">1.1</span> LangSmith 의 추적기능</h2>
<ul>
<li>추적은 LLM 애플리케이션의 동작을 이해하기 위한 강력한 도구</li>
<li>LangSmith는 LangChain 사용 여부와 관계없이 동급 최고의 추적 기능을 제공</li>
<li>추적은 다음과 같은 문제를 추적하는 데 도움이 될 수 있음
<ul>
<li>예상치 못한 최종 결과</li>
<li>에이전트가 루핑되는 이유</li>
<li>체인이 예상보다 느린 이유</li>
<li>에이전트가 각 단계에서 사용한 토큰 수</li>
<li>프로젝트 단위 추적
<ul>
<li>프로젝트 단위로 실행 카운트, Error 발생률, 토큰 사용량, 과금 정보등을 확인</li>
</ul></li>
</ul></li>
<li><a href="https://smith.langchain.com/">Lang Smith, https://smith.langchain.com/</a></li>
<li>회원 가입 및 API 키 발급
<ul>
<li><p>LangSmith API Key 발급</p>
<ul>
<li>https://smith.langchain.com/ 으로 접속하여 회원가입을 진행</li>
<li>가입후 이메일 인증하는 절차를 진행</li>
<li>왼쪽 톱니바퀴(Setting) - 가운데 “Personal” - “Create API Key” 를 눌러 API 키를 발급</li>
</ul></li>
<li><p>.env 에 LangSmith 키 설정</p>
<ul>
<li>먼저, .env 파일에 LangSmith 에서 발급받은 키와 프로젝트 정보를 입력</li>
<li>LANGCHAIN_TRACING_V2: “true” 로 설정하면 추적을 시작</li>
<li>LANGCHAIN_ENDPOINT: https://api.smith.langchain.com 변경하지 않는다.</li>
<li>LANGCHAIN_API_KEY: 이전 단계에서 발급받은 키 를 입력</li>
<li>LANGCHAIN_PROJECT: 프로젝트 명 을 기입하면 해당 프로젝트 그룹으로 모든 실행(Run) 이 추적</li>
</ul></li>
<li><p><code>.env</code> 파일에 발급받은 API 키 입력</p>
<pre><code>OPENAI_API_KEY=sk-proj-81qk0Zx...... # open AI key
LANGSMITH_TRACING=true
LANGSMITH_ENDPOINT=https://api.smith.langchain.com
LANGSMITH_API_KEY=lsv2_pt....... # lang smith key
LANGSMITH_PROJECT=Rag-Test</code></pre></li>
</ul></li>
</ul>
</section>
<section id="langsmith-추적-활성화" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="langsmith-추적-활성화"><span class="header-section-number">1.2</span> LangSmith 추적 활성화</h2>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> dotenv <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> load_dotenv</span>
<span id="cb2-2"></span>
<span id="cb2-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># .env 에 설정한 내용을 불러옴</span></span>
<span id="cb2-4">load_dotenv()</span></code></pre></div>
<ul>
<li>퀄리 날리고 API 호출해서 사용 후</li>
<li>LangSmith 웹사이트에 접속 해서 추적 확인</li>
</ul>
</section>
<section id="변경사항을-저장하고-싶을-떄" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="변경사항을-저장하고-싶을-떄"><span class="header-section-number">1.3</span> 변경사항을 저장하고 싶을 떄</h2>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> os</span>
<span id="cb3-2"></span>
<span id="cb3-3">os.environ[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"LANGCHAIN_TRACING_V2"</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"true"</span></span>
<span id="cb3-4">os.environ[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"LANGCHAIN_ENDPOINT"</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"https://api.smith.langchain.com"</span></span>
<span id="cb3-5">os.environ[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"LANGCHAIN_PROJECT"</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"LangChain 프로젝트명"</span></span>
<span id="cb3-6">os.environ[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"LANGCHAIN_API_KEY"</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"LangChain API KEY 입력"</span></span></code></pre></div>
</section>
<section id="langchain-teddynote-사용" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="langchain-teddynote-사용"><span class="header-section-number">1.4</span> langchain-teddynote 사용</h2>
<ul>
<li>langchain-teddynote 패키지: langchain 관련 기능을 보다 더 편리하게 사용하기 위한 목적으로 만들어진 패키지</li>
<li>패키지 설치: <code>pip install langchain-teddynote</code></li>
</ul>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> langchain_teddynote <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> logging</span>
<span id="cb4-2"></span>
<span id="cb4-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 프로젝트 이름을 입력합니다.</span></span>
<span id="cb4-4">logging.langsmith(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"원하는 프로젝트명"</span>)</span>
<span id="cb4-5"></span>
<span id="cb4-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력</span></span>
<span id="cb4-7"></span>
<span id="cb4-8"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#LangSmith 추적을 시작합니다.</span></span>
<span id="cb4-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#[프로젝트명]</span></span>
<span id="cb4-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">#랭체인 튜토리얼 프로젝트</span></span>
<span id="cb4-11"></span>
<span id="cb4-12"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력을 원하지 않을 때</span></span>
<span id="cb4-13"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> langchain_teddynote <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> logging</span>
<span id="cb4-14"></span>
<span id="cb4-15"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># set_enable=False 로 지정하면 추적을 하지 않습니다.</span></span>
<span id="cb4-16">logging.langsmith(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"랭체인 튜토리얼 프로젝트"</span>, set_enable<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">False</span>)</span></code></pre></div>


</section>
</section>

 ]]></description>
  <category>RAG</category>
  <guid>kk3225.netlify.app/docs/blog/posts/RAG/00-Intro/2-2.settings_LangSmith.html</guid>
  <pubDate>Tue, 03 Jun 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>OpenAI API 설정</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/RAG/00-Intro/2-1.settings_api_issue.html</link>
  <description><![CDATA[ 





<section id="openai-키-발급" class="level2" data-number="1">

<ul>
<li>OpenAI API 웹사이트에 접속</li>
<li><a href="https://platform.openai.com/docs/overview">링크: https://platform.openai.com/docs/overview</a></li>
<li>설정 &gt; Billing &gt; Payment methods &gt; 신용카드 등록 &gt; add to credit &gt; $10 충전 &gt; continue &gt; Usage Limits
<ul>
<li>“Set a monthly budge”: 월간 사용한도를 지정. 이 금액에 도달하면 더이상 과금하지 않고 API 는 사용을 멈춤</li>
<li>“Set an email notification threshold”: 이메일이 발송되는 요금을 지정. 이 금액에 도달하면 이메일이 발송됨</li>
</ul></li>
<li>우측 프로필 이미지 클릭 - “Your profile”</li>
<li>API Key 관리 메뉴 로 접속
<ul>
<li><a href="https://platform.openai.com/api-keys">링크: https://platform.openai.com/api-keys</a></li>
<li>“Create new secret key” 를 클릭</li>
<li>생성된 API key 복사</li>
<li>키가 유출되면 다른 사람이 내 API KEY 를 사용하여 GPT 를 사용할 수 있다.</li>
<li>절대 키는 타인에게 공유하지 말고, 안전한 곳에 보관</li>
</ul></li>
</ul>
</section>
<section id="env-파일-설정" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="env-파일-설정"><span class="header-section-number">2</span> .env 파일 설정</h2>
<ul>
<li>프로젝트 루트 디렉토리에 .env 파일을 생성</li>
<li>.env 파일에 OPENAI_API_KEY=방금복사한 키를 입력 한 뒤 Ctrl + S 를 눌러 저장하고 파일을 닫는다.</li>
</ul>
<pre><code>OPENAI_API_KEY=sk-proj-81q....</code></pre>
</section>
<section id="환경변수-설정" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="환경변수-설정"><span class="header-section-number">3</span> 환경변수 설정</h2>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># API KEY를 환경변수로 관리하기 위한 설정 파일</span></span>
<span id="cb2-2"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> dotenv <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> load_dotenv</span>
<span id="cb2-3"></span>
<span id="cb2-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># API KEY 정보로드</span></span>
<span id="cb2-5">load_dotenv()</span>
<span id="cb2-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력: True</span></span>
<span id="cb2-7"></span>
<span id="cb2-8"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> os</span>
<span id="cb2-9"></span>
<span id="cb2-10"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"[API KEY]</span><span class="ch" style="color: #20794D;
background-color: null;
font-style: inherit;">\n</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>os<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>environ[<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'OPENAI_API_KEY'</span>][:<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span>]<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"*"</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">15</span>)</span>
<span id="cb2-11"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력: sk-proj-81qk0Z***************</span></span></code></pre></div>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">from</span> langchain_openai <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> ChatOpenAI</span>
<span id="cb3-2"></span>
<span id="cb3-3"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 객체 생성</span></span>
<span id="cb3-4">llm <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> ChatOpenAI(</span>
<span id="cb3-5">    temperature<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.1</span>,  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 창의성 (0.0 ~ 2.0)</span></span>
<span id="cb3-6">    model_name<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"gpt-4.1-mini"</span>,  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 모델명</span></span>
<span id="cb3-7">)</span>
<span id="cb3-8"></span>
<span id="cb3-9"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 질의내용</span></span>
<span id="cb3-10">question <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"대한민국의 수도는 어디인가요?"</span></span>
<span id="cb3-11"></span>
<span id="cb3-12"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 질의</span></span>
<span id="cb3-13"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">print</span>(<span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">f"[답변]: </span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">{</span>llm<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">.</span>invoke(question)<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">}</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb3-14"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력: [답변]: content='대한민국의 수도는 서울특별시입니다.' additional_kwargs={'refusal': None} response_metadata={'token_usage': {'completion_tokens': 11, 'prompt_tokens': 16, 'total_tokens': 27, 'completion_tokens_details': {'accepted_prediction_tokens': 0, 'audio_tokens': 0, 'reasoning_tokens': 0, 'rejected_prediction_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': 0, 'cached_tokens': 0}}, 'model_name': 'gpt-4.1-mini-2025-04-14', 'system_fingerprint': 'fp_658b958c37', 'id': 'chatcmpl-BgLGZlSCdQpopkgabeEolgKOjSec5', 'finish_reason': 'stop', 'logprobs': None} id='run-7cd14eae-4ceb-4eda-9565-3076148bf702-0' usage_metadata={'input_tokens': 16, 'output_tokens': 11, 'total_tokens': 27, 'input_token_details': {'audio': 0, 'cache_read': 0}, 'output_token_details': {'audio': 0, 'reasoning': 0}}</span></span>
<span id="cb3-15"></span>
<span id="cb3-16"></span>
<span id="cb3-17"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 질의내용</span></span>
<span id="cb3-18">question <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"대한민국의 수도는 어디인가요?"</span></span>
<span id="cb3-19"></span>
<span id="cb3-20"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 질의</span></span>
<span id="cb3-21">response <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> llm.invoke(question)</span>
<span id="cb3-22">response</span>
<span id="cb3-23"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># AIMessage(content='대한민국의 수도는 서울입니다.', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 8, 'prompt_tokens': 16, 'total_tokens': 24, 'completion_tokens_details': {'accepted_prediction_tokens': 0, 'audio_tokens': 0, 'reasoning_tokens': 0, 'rejected_prediction_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': 0, 'cached_tokens': 0}}, 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_07871e2ad8', 'id': 'chatcmpl-BgLBMjx3jC0X772uUgb5BnYMd5x8c', 'finish_reason': 'stop', 'logprobs': None}, id='run-dbfc16ce-51ce-43c8-a01e-8d8bfc2debe1-0', usage_metadata={'input_tokens': 16, 'output_tokens': 8, 'total_tokens': 24, 'input_token_details': {'audio': 0, 'cache_read': 0}, 'output_token_details': {'audio': 0, 'reasoning': 0}})</span></span>
<span id="cb3-24"></span>
<span id="cb3-25">response.content</span>
<span id="cb3-26"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력: '대한민국의 수도는 서울입니다.'</span></span>
<span id="cb3-27">response.response_metadata</span>
<span id="cb3-28"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 출력: {'token_usage': {'completion_tokens': 8, 'prompt_tokens': 16, 'total_tokens': 24, 'completion_tokens_details': {'accepted_prediction_tokens': 0, 'audio_tokens': 0, 'reasoning_tokens': 0, 'rejected_prediction_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': 0, 'cached_tokens': 0}}, 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_07871e2ad8', 'id': 'chatcmpl-BgLBMjx3jC0X772uUgb5BnYMd5x8c', 'finish_reason': 'stop', 'logprobs': None}</span></span></code></pre></div>


</section>

 ]]></description>
  <category>RAG</category>
  <guid>kk3225.netlify.app/docs/blog/posts/RAG/00-Intro/2-1.settings_api_issue.html</guid>
  <pubDate>Mon, 02 Jun 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>LangChain 환경설정</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/RAG/00-Intro/2-0.settings.html</link>
  <description><![CDATA[ 





<section id="환경설정" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 환경설정</h1>
<section id="windows-환경-설정" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="windows-환경-설정"><span class="header-section-number">1.1</span> Windows 환경 설정</h2>
<section id="git-설치" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="git-설치"><span class="header-section-number">1.1.1</span> git 설치</h3>
<ul>
<li>실습 코드를 GitHub에서 다운로드하고 버전 관리를 위해 필요</li>
<li>64-bit Git for Windows Setup 다운로드: <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></li>
<li><code>add a git bash profile to windows terminal</code> 옵션 선택</li>
<li>powershell 관리자 권한으로 실행</li>
<li>다음의 명령어를 입력하여 정상 동작하는지 확인</li>
</ul>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">git</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--version</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># or</span></span>
<span id="cb1-2"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">git</span></span></code></pre></div>
</section>
<section id="powershell-policy-적용" class="level3" data-number="1.1.2">
<h3 data-number="1.1.2" class="anchored" data-anchor-id="powershell-policy-적용"><span class="header-section-number">1.1.2</span> PowerShell Policy 적용</h3>
<ul>
<li>Windows에서 PowerShell 스크립트 실행을 허용하기 위해 필요</li>
<li>기본적으로 Windows는 보안상 외부 스크립트 실행을 제한하는데, <code>pyenv</code>와 <code>poetry</code> 같은 도구들이 PowerShell 스크립트를 사용하므로 이 제한을 해제해야 함</li>
<li>Window 키 - PowerShell 을 반드시 관리자 권한으로 실행</li>
<li>다음의 명령어를 입력하여 Policy 를 적용</li>
</ul>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">Set-ExecutionPolicy</span> RemoteSigned <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-Scope</span> CurrentUser <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-Force</span></span></code></pre></div>
<ul>
<li>적용이 완료된 후 Windows PowerShell 을 껐다가 킨다</li>
<li>아래의 진행을 위하여 Windows PowerShell 실행시 “관리자 권한으로 실행”</li>
</ul>
</section>
<section id="pyenv-설치" class="level3" data-number="1.1.3">
<h3 data-number="1.1.3" class="anchored" data-anchor-id="pyenv-설치"><span class="header-section-number">1.1.3</span> pyenv 설치</h3>
<ul>
<li>pyenv 설치</li>
</ul>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">git</span> clone https://github.com/pyenv-win/pyenv-win.git <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$env</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">:USERPROFILE\.pyenv"</span></span></code></pre></div>
<ul>
<li>여러 Python 버전을 관리하기 위한 도구</li>
<li>pyenv는 배포자가 만든 가상환경이 아니라, Python 버전 관리 도구</li>
<li>LangChain은 특정 Python 버전(3.11)에서 최적으로 동작하며, 시스템에 설치된 기본 Python과 충돌 없이 원하는 버전을 사용할 수 있게 해줌</li>
<li><strong>주의</strong>: pyenv는 Python 인터프리터 버전만 관리하며, 가상환경과 패키지 관리는 Poetry가 담당</li>
<li>pyenv: Python 인터프리터 버전 관리 (3.8, 3.9, 3.11 등)</li>
<li>가상환경 도구: venv, virtualenv, Poetry, conda 등이 패키지 격리 담당</li>
<li>실제 작업 흐름:
<ul>
<li>pyenv로 Python 3.11 설치 및 선택</li>
<li>Poetry로 해당 Python 버전 기반의 가상환경 생성 + 패키지 관리</li>
</ul></li>
</ul>
</section>
<section id="환경변수-추가" class="level3" data-number="1.1.4">
<h3 data-number="1.1.4" class="anchored" data-anchor-id="환경변수-추가"><span class="header-section-number">1.1.4</span> 환경변수 추가</h3>
<ul>
<li>pyenv가 시스템 어디서든 실행될 수 있도록 PATH 환경변수에 pyenv 경로를 추가해야 터미널에서 <code>pyenv</code> 명령어를 사용할 수 있음</li>
</ul>
<p>아래의 내용을 복사하여 붙혀넣기 후 실행</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">[System.Environment]::SetEnvironmentVariable</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'PYENV'</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">,</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$env</span>:USERPROFILE + <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"\.pyenv\pyenv-win</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\"</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">, "</span>User<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">")</span></span>
<span id="cb4-2"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">[System.Environment]::SetEnvironmentVariable('PYENV_ROOT', </span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$env</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">:USERPROFILE + "</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\.</span>pyenv<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\p</span>yenv-win<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"User"</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">)</span></span>
<span id="cb4-3"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">[System.Environment]::SetEnvironmentVariable</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'PYENV_HOME'</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">,</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$env</span>:USERPROFILE + <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"\.pyenv\pyenv-win</span><span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\"</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">, "</span>User<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">")</span></span></code></pre></div>
<p>아래의 내용을 복사하여 붙혀넣기 후 실행</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">[System.Environment]::SetEnvironmentVariable</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'PATH'</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">,</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$env</span>:USERPROFILE + <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"\.pyenv\pyenv-win\bin;"</span> + <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$env</span>:USERPROFILE + <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"\.pyenv\pyenv-win\shims;"</span> + <span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">[</span><span class="ss" style="color: #20794D;
background-color: null;
font-style: inherit;">System.Environment</span><span class="pp" style="color: #AD0000;
background-color: null;
font-style: inherit;">]</span>::GetEnvironmentVariable<span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'PATH'</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">,</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"User"</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">)</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">,</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"User"</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">)</span></span></code></pre></div>
<p><em>현재의 Windows PowerShell 을 종료 후 다시 실행</em></p>
<ul>
<li><code>pyenv</code> 를 입력하여 정상 동작하는지 확인</li>
</ul>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">pyenv</span></span></code></pre></div>
</section>
<section id="파이썬-설치" class="level3" data-number="1.1.5">
<h3 data-number="1.1.5" class="anchored" data-anchor-id="파이썬-설치"><span class="header-section-number">1.1.5</span> 파이썬 설치</h3>
<ul>
<li>LangChain과 관련 패키지들이 안정적으로 동작하는 Python 3.11 버전을 설치</li>
<li>최신 버전보다는 검증된 안정 버전을 사용하여 호환성 문제를 방지</li>
<li>파이썬 3.11 버전 설치</li>
</ul>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">pyenv</span> install 3.11</span></code></pre></div>
<ul>
<li>3.11 버전의 python 설정</li>
</ul>
<div class="sourceCode" id="cb8" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">pyenv</span> global 3.11 <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 시스템의 기본 Python 버전을 3.11로 설정</span></span></code></pre></div>
<ul>
<li>파이썬 버전 확인</li>
</ul>
<div class="sourceCode" id="cb9" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb9-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">python</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--version</span></span></code></pre></div>
<ul>
<li>3.11.9 버전이 설치되어 있나 확인 (혹은 3.11.11 버전으로 설치되어도 무방)</li>
</ul>
</section>
<section id="poetry-설치" class="level3" data-number="1.1.6">
<h3 data-number="1.1.6" class="anchored" data-anchor-id="poetry-설치"><span class="header-section-number">1.1.6</span> Poetry 설치</h3>
<ul>
<li>LangChain 실습을 위해 수 많은 패키지를 설치해야하는데 각 패키지들의 dependency 관리가 매우 복잡</li>
<li>Poetry는 패키지 의존성을 자동으로 해결하고 가상환경을 관리해주어 패키지 충돌 문제를 방지</li>
<li>배포자가 편의를 위해 Poetry를 사용하여 dependency 관리가 끝난 자료 배포</li>
<li>Poetry가 conda보다 더 정밀한 패키지 의존성 관리 제공</li>
<li>현대적인 Python 패키지 관리 방식</li>
<li><strong>conda vs pyenv+Poetry 비교</strong>:
<ul>
<li><code>conda</code>: Python 버전 관리 + 패키지 관리 통합 도구 (주로 데이터 사이언스용)</li>
<li><code>pyenv + Poetry</code>: Python 버전 관리(pyenv) + 패키지 관리(Poetry) 분리</li>
<li>Poetry는 <code>pyproject.toml</code>과 <code>poetry.lock</code> 파일로 더 정밀한 의존성 관리 제공</li>
</ul></li>
<li>아래의 명령어를 실행하여 Poetry 패키지 관리 도구를 설치</li>
</ul>
<div class="sourceCode" id="cb10" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb10-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">pip3</span> install poetry==1.8.5</span></code></pre></div>
</section>
<section id="실습코드-실행" class="level3" data-number="1.1.7">
<h3 data-number="1.1.7" class="anchored" data-anchor-id="실습코드-실행"><span class="header-section-number">1.1.7</span> 실습코드 실행</h3>
<ul>
<li>LangChain 학습을 위한 예제 코드와 실습 자료를 다운로드하여 실제 개발 환경을 구축</li>
<li><a href="https://github.com/teddylee777/langchain-kr">실습코드 링크</a></li>
<li>도큐먼트(Documents) 폴더로 이동</li>
</ul>
<div class="sourceCode" id="cb11" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb11-1"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">cd</span> ~/Documents</span></code></pre></div>
<ul>
<li>아래의 명령어를 실행하여 소스코드를 받는다</li>
</ul>
<div class="sourceCode" id="cb12" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb12-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">git</span> clone https://github.com/teddylee777/langchain-kr.git</span></code></pre></div>
<ul>
<li>아래의 명령어를 실행하여 langchain-kr 디렉토리로 이동</li>
</ul>
<div class="sourceCode" id="cb13" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb13-1"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">cd</span> langchain-kr</span></code></pre></div>
<ul>
<li>파이썬 가상환경 설정</li>
</ul>
<div class="sourceCode" id="cb14" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb14-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">poetry</span> shell</span></code></pre></div>
<ul>
<li>파이썬 패키지 일괄 업데이트</li>
</ul>
<div class="sourceCode" id="cb15" style="background: #f1f3f5;"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb15-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">poetry</span> update</span></code></pre></div>
</section>
<section id="visual-studio-code-설치" class="level3" data-number="1.1.8">
<h3 data-number="1.1.8" class="anchored" data-anchor-id="visual-studio-code-설치"><span class="header-section-number">1.1.8</span> Visual Studio Code 설치</h3>
<ul>
<li>Python 개발과 Jupyter 노트북 실행에 최적화된 통합 개발 환경(IDE)을 제공</li>
<li>코드 편집, 디버깅, 패키지 관리를 한 곳에서 할 수 있음</li>
<li>Visual Studio Code 다운로드</li>
<li><a href="https://code.visualstudio.com/download">다운로드 링크: https://code.visualstudio.com/download</a></li>
<li>다운로드 받은 Visual Studio Code 를 설치 (Applications 폴더에 복사)</li>
<li>왼쪽 install extensions 클릭
<ul>
<li>“python” 검색 후 설치</li>
<li>“jupyter” 검색 후 설치</li>
</ul></li>
<li>Visual Studio Code 껐다가 재실행</li>
<li>우측 상단 “select kernel”
<ul>
<li>python environment 클릭 - 설치한 가상환경이 안뜬다면 Visual Studio Code 껐다가 재실행</li>
</ul></li>
</ul>


</section>
</section>
</section>

 ]]></description>
  <category>RAG</category>
  <guid>kk3225.netlify.app/docs/blog/posts/RAG/00-Intro/2-0.settings.html</guid>
  <pubDate>Sun, 01 Jun 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Coding Test</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Code_Test/</link>
  <description><![CDATA[ 





<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="kk3225.netlify.app/images/code_test.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Coding Test</figcaption>
</figure>
</div>
<section id="문제-정의-모델-선택-역량" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="문제-정의-모델-선택-역량"><span class="header-section-number">1</span> 문제 정의 &amp; 모델 선택 역량</h2>
<section id="비즈니스-문제-분석" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="비즈니스-문제-분석"><span class="header-section-number">1.1</span> 비즈니스 문제 분석</h3>
<ul>
<li>문제 유형 분류 (분류/회귀/생성/검색/최적화)</li>
<li>ROI 계산 및 성공 지표 정의</li>
<li>데이터 가용성 vs 모델 요구사항 분석</li>
<li>기술적 제약사항 파악 (지연시간, 정확도, 비용)</li>
</ul>
</section>
<section id="모델-생태계-이해" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="모델-생태계-이해"><span class="header-section-number">1.2</span> 모델 생태계 이해</h3>
<ul>
<li>Hugging Face Hub 활용: 모델 탐색, 벤치마크 해석</li>
<li>Foundation Models 맵핑: GPT-4, Claude, Llama, Mistral 등 특성</li>
<li>Computer Vision: CLIP, SAM, YOLO, ViT 계열</li>
<li>테이블형 데이터: AutoML vs 전통 ML 판단 기준</li>
</ul>
</section>
<section id="모델-성능-평가" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="모델-성능-평가"><span class="header-section-number">1.3</span> 모델 성능 평가</h3>
<ul>
<li>벤치마크 해석 (BLEU, ROUGE, MMLU, HellaSwag 등)</li>
<li>도메인별 평가 지표 설계</li>
<li>A/B 테스트 설계 원칙</li>
<li>비용-성능 트레이드오프 분석</li>
</ul>
</section>
</section>
<section id="fine-tuning-api-활용---langchain" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="fine-tuning-api-활용---langchain"><span class="header-section-number">2</span> Fine-tuning &amp; API 활용 - LangChain</h2>
<section id="llm-fine-tuning-전략" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="llm-fine-tuning-전략"><span class="header-section-number">2.1</span> LLM Fine-tuning 전략</h3>
<ul>
<li>Parameter-Efficient Fine-tuning: LoRA, QLoRA, Adapter</li>
<li>Instruction Tuning: 태스크별 프롬프트 데이터셋 구축</li>
<li>RLHF 개념: 인간 피드백 활용 방법론</li>
<li>도메인 적응: 의료, 법률, 금융 등 특화 모델 구축</li>
</ul>
</section>
<section id="api-활용-및-최적화" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="api-활용-및-최적화"><span class="header-section-number">2.2</span> API 활용 및 최적화</h3>
<ul>
<li>OpenAI API: GPT-4, Fine-tuning, Assistants API</li>
<li>Anthropic Claude: Constitutional AI, Function Calling</li>
<li>오픈소스 API: Ollama, vLLM, Text Generation Inference</li>
<li>멀티모달 API: GPT-4V, Claude-3, Gemini 활용</li>
</ul>
</section>
<section id="프롬프트-엔지니어링" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="프롬프트-엔지니어링"><span class="header-section-number">2.3</span> 프롬프트 엔지니어링</h3>
<ul>
<li>Few-shot Learning 전략</li>
<li>Chain-of-Thought, Tree-of-Thought</li>
<li>프롬프트 최적화 도구 (DSPy, Guidance)</li>
<li>프롬프트 보안 (Jailbreaking 방지)</li>
</ul>
</section>
</section>
<section id="시스템-통합-아키텍처---langchain" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="시스템-통합-아키텍처---langchain"><span class="header-section-number">3</span> 시스템 통합 &amp; 아키텍처 - LangChain</h2>
<section id="ai-애플리케이션-아키텍처" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="ai-애플리케이션-아키텍처"><span class="header-section-number">3.1</span> AI 애플리케이션 아키텍처</h3>
<ul>
<li>RAG 시스템 설계: Vector DB, Embedding, Retrieval 전략</li>
<li>Agent Framework: LangChain, CrewAI, AutoGen</li>
<li>워크플로우 엔진: 복잡한 AI 태스크 체이닝</li>
<li>멀티모달 파이프라인: 텍스트+이미지+음성 통합</li>
</ul>
</section>
<section id="벡터-데이터베이스-검색" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="벡터-데이터베이스-검색"><span class="header-section-number">3.2</span> 벡터 데이터베이스 &amp; 검색</h3>
<ul>
<li>Vector DB: Pinecone, Weaviate, Chroma, FAISS</li>
<li>Embedding 전략: 텍스트, 이미지, 코드 임베딩</li>
<li>하이브리드 검색: 키워드 + 시맨틱 검색 결합</li>
<li>검색 성능 최적화: 인덱싱, 캐싱 전략</li>
</ul>
</section>
<section id="모델-서빙-인프라" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="모델-서빙-인프라"><span class="header-section-number">3.3</span> 모델 서빙 &amp; 인프라</h3>
<ul>
<li>모델 서빙: TorchServe, TensorFlow Serving, vLLM</li>
<li>로드 밸런싱: 모델별 트래픽 분산</li>
<li>캐싱 전략: 응답 캐시, 임베딩 캐시</li>
<li>비용 최적화: GPU 사용량, API 호출 최적화</li>
</ul>
</section>
</section>
<section id="운영-mlops---langchain" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="운영-mlops---langchain"><span class="header-section-number">4</span> 운영 &amp; MLOps - LangChain</h2>
<section id="모델-모니터링" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="모델-모니터링"><span class="header-section-number">4.1</span> 모델 모니터링</h3>
<ul>
<li>성능 드리프트: 입력 분포 변화 감지</li>
<li>출력 품질 모니터링: 응답 길이, 독성 탐지, 할루시네이션</li>
<li>사용자 피드백: 만족도, 정확도 추적</li>
<li>비용 모니터링: 토큰 사용량, API 비용 추적</li>
</ul>
</section>
<section id="ab-테스트-실험" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="ab-테스트-실험"><span class="header-section-number">4.2</span> A/B 테스트 &amp; 실험</h3>
<ul>
<li>모델 비교: 다양한 모델/프롬프트 성능 비교</li>
<li>점진적 롤아웃: Canary 배포, Blue-Green 배포</li>
<li>실험 설계: 통계적 유의성, 표본 크기 계산</li>
<li>결과 분석: 비즈니스 메트릭 vs 기술 메트릭</li>
</ul>
</section>
<section id="거버넌스-윤리" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="거버넌스-윤리"><span class="header-section-number">4.3</span> 거버넌스 &amp; 윤리</h3>
<ul>
<li>AI 안전성: Content Filtering, Bias 탐지</li>
<li>데이터 프라이버시: PII 마스킹, GDPR 준수</li>
<li>모델 해석성: LIME, SHAP 등 설명 가능 AI</li>
<li>규제 준수: AI Act, 금융/의료 규제 대응</li>
</ul>
</section>
</section>
<section id="고급-통합-자동화---langchain-일부-커버" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="고급-통합-자동화---langchain-일부-커버"><span class="header-section-number">5</span> 고급 통합 &amp; 자동화 - LangChain 일부 커버</h2>
<section id="automl-모델-자동화" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="automl-모델-자동화"><span class="header-section-number">5.1</span> AutoML &amp; 모델 자동화</h3>
<ul>
<li>AutoML 플랫폼: H2O.ai, DataRobot, AutoGluon</li>
<li>하이퍼파라미터 최적화: Optuna, Ray Tune</li>
<li>뉴럴 아키텍처 서치: 모델 구조 자동 탐색</li>
<li>모델 압축: Pruning, Quantization, Distillation</li>
</ul>
</section>
<section id="고급-ai-패턴" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="고급-ai-패턴"><span class="header-section-number">5.2</span> 고급 AI 패턴</h3>
<ul>
<li>Multi-Agent Systems: 협업하는 AI 에이전트</li>
<li>Tool-Using AI: 외부 도구/API 활용하는 AI</li>
<li>Self-Improving Systems: 피드백 기반 자동 개선</li>
<li>Federated Learning: 분산 학습 시스템</li>
</ul>
</section>
</section>
<section id="실습-프로젝트-로드맵" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="실습-프로젝트-로드맵"><span class="header-section-number">6</span> 실습 프로젝트 로드맵</h2>
<section id="초급" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="초급"><span class="header-section-number">6.1</span> 초급</h3>
<ol type="1">
<li><strong>문서 QA 시스템</strong>: RAG + OpenAI API</li>
<li><strong>이미지 분류 API</strong>: Pre-trained Vision 모델 + FastAPI</li>
</ol>
</section>
<section id="중급" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="중급"><span class="header-section-number">6.2</span> 중급</h3>
<ol start="3" type="1">
<li><strong>커스텀 챗봇</strong>: Fine-tuned LLM + 벡터DB</li>
<li><strong>멀티모달 검색</strong>: 텍스트+이미지 통합 검색</li>
</ol>
</section>
<section id="고급" class="level3" data-number="6.3">
<h3 data-number="6.3" class="anchored" data-anchor-id="고급"><span class="header-section-number">6.3</span> 고급</h3>
<ol start="5" type="1">
<li><strong>AI 에이전트 시스템</strong>: 복잡한 태스크 자동화</li>
<li><strong>A/B 테스트 플랫폼</strong>: 모델 성능 비교 시스템</li>
</ol>


</section>
</section>

 ]]></description>
  <category>Code Test</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Code_Test/</guid>
  <pubDate>Sat, 31 May 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Data Science: Methodology and Evolution</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Data_Science/0.intro.html</link>
  <description><![CDATA[ 





<section id="개념적-독립성" class="level3" data-number="0.1">
<h3 data-number="0.1" class="anchored" data-anchor-id="개념적-독립성"><span class="header-section-number">0.1</span> 개념적 독립성</h3>
<ul>
<li><strong>Statistics</strong>: 수학적 이론 기반 (hypothesis testing, distribution theory)</li>
<li><strong>Machine Learning</strong>: 알고리즘과 예측 모델 중심</li>
<li><strong>Deep Learning</strong>: Neural network 특화 기법</li>
<li><strong>Data Science</strong>: 위 세 가지를 포함하되, 비즈니스 문제 해결 프로세스 중심</li>
<li>예시
<ul>
<li>Statistics: “t-test의 수학적 유도와 가정”</li>
<li>Machine Learning: “Random Forest 알고리즘 구현”</li>
<li>Deep Learning: “Transformer architecture 설명”</li>
<li>Data Science: “고객 이탈 예측 프로젝트 (위 세 가지 모두 활용)”</li>
</ul></li>
</ul>
</section>
<section id="실무자-관점" class="level3" data-number="0.2">
<h3 data-number="0.2" class="anchored" data-anchor-id="실무자-관점"><span class="header-section-number">0.2</span> 실무자 관점</h3>
<p>통계학을 공부하는 사람이 반드시 딥러닝을 배우는 것은 아니다. 각 분야는 독립적인 학습 및 연구경로를 가진다.</p>
<ul>
<li>독립적 학습 경로
<ul>
<li>Statistics → Econometrics (ML 불필요)</li>
<li>Statistics → Biostatistics (DL 불필요)</li>
<li>ML → Classical ML only (DL 불필요)</li>
<li>DL → Computer Vision (통계 이론 최소)</li>
</ul></li>
<li>검색과 탐색 효율성
<ul>
<li>실무자 및 학습자가 “Bayesian inference”를 찾을 때 DL 콘텐츠와 섞여있으면 혼란스럽다.</li>
</ul></li>
<li>블로그 콘텐츠 성격 차이</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 19%">
<col style="width: 42%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th>폴더</th>
<th>콘텐츠 성격</th>
<th>예시 토픽</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>statistics</strong></td>
<td>수학적 증명, 이론적 기초</td>
<td>Central Limit Theorem, MLE, Hypothesis Testing</td>
</tr>
<tr class="even">
<td><strong>machine_learning</strong></td>
<td>알고리즘 구현, 모델 비교</td>
<td>Gradient Boosting, Cross-validation, Hyperparameter Tuning</td>
</tr>
<tr class="odd">
<td><strong>deep_learning</strong></td>
<td>아키텍처, 학습 기법</td>
<td>Attention Mechanism, Batch Normalization, Transfer Learning</td>
</tr>
<tr class="even">
<td><strong>data_science</strong></td>
<td>End-to-end 프로젝트, 방법론</td>
<td>EDA, Feature Engineering, Model Deployment, A/B Testing</td>
</tr>
</tbody>
</table>
</section>
<section id="data-science-폴더에-포함할-내용" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="data-science-폴더에-포함할-내용"><span class="header-section-number">1</span> Data Science 폴더에 포함할 내용</h2>
<ul>
<li>Data Science는 “통합자(integrator)” 역할로, 다른 블로그의 기술들을 <strong>어떻게 조합해서 문제를 푸는가</strong>에 초점을 맞춘다.</li>
<li>예시</li>
</ul>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode numberSource yaml number-lines code-with-copy"><code class="sourceCode yaml"><span id="cb1-1"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">data_science/</span></span>
<span id="cb1-2"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">├── methodology/</span></span>
<span id="cb1-3"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   ├── crisp_dm.qmd</span><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">              # 프로세스 방법론</span></span>
<span id="cb1-4"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   ├── problem_framing.qmd</span><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">        # 문제 정의</span></span>
<span id="cb1-5"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   └── stakeholder_management.qmd</span><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"> # 이해관계자 관리</span></span>
<span id="cb1-6"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">├── eda/</span></span>
<span id="cb1-7"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   ├── exploratory_data_analysis.qmd</span></span>
<span id="cb1-8"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   ├── data_profiling.qmd</span></span>
<span id="cb1-9"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   └── visualization_principles.qmd</span></span>
<span id="cb1-10"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">├── feature_engineering/</span></span>
<span id="cb1-11"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   ├── feature_creation.qmd</span></span>
<span id="cb1-12"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   ├── feature_selection.qmd</span></span>
<span id="cb1-13"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   └── domain_knowledge_integration.qmd</span></span>
<span id="cb1-14"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">├── model_selection/</span></span>
<span id="cb1-15"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   ├── baseline_models.qmd</span></span>
<span id="cb1-16"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   ├── model_comparison.qmd</span></span>
<span id="cb1-17"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   └── ensemble_strategies.qmd</span></span>
<span id="cb1-18"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">├── evaluation/</span></span>
<span id="cb1-19"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   ├── business_metrics.qmd</span><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">      # ROI, Lift, Cost-benefit</span></span>
<span id="cb1-20"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   ├── model_monitoring.qmd</span></span>
<span id="cb1-21"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   └── ab_testing_integration.qmd</span></span>
<span id="cb1-22"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">├── deployment/</span></span>
<span id="cb1-23"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   ├── model_serving.qmd</span></span>
<span id="cb1-24"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   ├── mlops_basics.qmd</span></span>
<span id="cb1-25"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">│   └── production_best_practices.qmd</span></span>
<span id="cb1-26"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">└── case_studies/</span></span>
<span id="cb1-27"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    ├── churn_prediction.qmd</span><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">      # 실제 프로젝트 사례</span></span>
<span id="cb1-28"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    ├── recommendation_system.qmd</span></span>
<span id="cb1-29"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    └── demand_forecasting.qmd</span></span></code></pre></div>
</section>
<section id="각-블로그의-경계-기준" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="각-블로그의-경계-기준"><span class="header-section-number">2</span> 각 블로그의 경계 기준</h2>
<ol type="1">
<li>블로그를 <strong>물리적으로 분리</strong>하되, 논리적으로 연결 (cross-reference)
<ul>
<li>Statistics
<ul>
<li>✅ <strong>포함</strong>: 확률분포, 추정, 검정, 회귀분석, 베이지안 통계</li>
<li>❌ <strong>제외</strong>: 알고리즘 구현, 대용량 데이터 처리, 프로덕션 배포</li>
</ul></li>
<li>Machine Learning
<ul>
<li>✅ <strong>포함</strong>: Supervised/Unsupervised 알고리즘, 앙상블, 커널 방법</li>
<li>❌ <strong>제외</strong>: 신경망(DL로), 비즈니스 ROI 분석(DS로)</li>
</ul></li>
<li>Deep Learning
<ul>
<li>✅ <strong>포함</strong>: CNN, RNN, Transformer, 학습 기법, 아키텍처</li>
<li>❌ <strong>제외</strong>: Classical ML 알고리즘, 통계 이론</li>
</ul></li>
<li>Data Science
<ul>
<li>✅ <strong>포함</strong>: 전체 프로세스, 비즈니스 맥락, 실무 케이스</li>
<li>❌ <strong>제외</strong>: 알고리즘 깊은 이론 (해당 폴더로 링크)</li>
</ul></li>
<li>Experimentation
<ul>
<li>Experimentation은 독립 폴더로 유지하되, Data Science와 긴밀히 연결된다.</li>
<li>Data를 생성하는 것부터 활용하는 단계까지 효율적인 파이프라인을 생성하기 위해 필요한 지식
<ol type="1">
<li>Experimentation은 <strong>독립된 학문 분야</strong> (통계학, 역학, 인과추론)</li>
<li>DS만이 아니라 <strong>Product, Marketing, Engineering</strong>도 사용</li>
<li>충분히 방대한 콘텐츠 (A/B Testing, MAB, Causal Inference)</li>
</ol></li>
</ul></li>
<li>예시:
<ul>
<li>Data Science: Model Evaluation
<ul>
<li>새 모델을 프로덕션에 배포하기 전 A/B 테스트가 필요하다.</li>
<li><a href="../../experimentation/AB_test/index.qmd">A/B Testing 가이드</a></li>
</ul></li>
<li>Experimentation: HTE Analysis
<ul>
<li>사용자 세그먼트별 효과 추정에 ML 모델을 활용</li>
<li><a href="../../machine_learning/causal_ml/index.qmd">Causal ML 기법</a></li>
</ul></li>
</ul></li>
</ul></li>
<li>각 섹션은 <strong>독립적으로 학습 가능</strong>하도록 배치<br>
</li>
<li>Data Science는 <strong>허브(hub) 역할</strong>, 다른 폴더를 조율<br>
</li>
<li>이렇게 하면:
<ul>
<li>각 분야 전문가가 해당 폴더만 집중 가능<br>
</li>
<li>초보자가 학습 경로를 명확히 파악<br>
</li>
<li>검색과 내비게이션 효율성 강화<br>
</li>
<li>콘텐츠 중복 최소화 (링크로 해결)</li>
</ul></li>
</ol>
</section>
<section id="the-evolution-from-statistics-to-ai" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="the-evolution-from-statistics-to-ai"><span class="header-section-number">3</span> The Evolution from Statistics to AI</h2>
<p>데이터 분석의 여정은 통계학에서 시작하여 인공지능까지 자연스럽게 발전해왔다. 각 단계는 이전 단계의 한계를 극복하면서 더 복잡하고 현실적인 문제를 해결할 수 있는 방법론으로 진화했다.</p>
<p><strong>통계학(Statistics)</strong>은 수학적으로 엄격한 기반 위에서 데이터를 분석한다. 확률 이론과 추론 통계를 통해 데이터에서 의미 있는 패턴을 발견하고, 가설을 검증하며, 불확실성을 정량화한다. 잘 설계된 실험과 데이터에 대해서는 수학적으로 매우 높은 설명력을 제공한다. 그러나 정규성(normality), 독립성(independence), 등분산성(homoscedasticity) 등 많은 가정을 필요로 하며, 이러한 가정이 충족되지 않는 현실 데이터에서는 한계를 보인다.</p>
<p><strong>데이터 과학(Data Science)</strong>은 통계학의 수학적 엄격함을 유지하면서도, 컴퓨터 과학의 계산 능력과 도메인 지식을 결합한다. 통계적 가정을 완전히 만족하지 않는 대규모 데이터도 처리할 수 있고, 데이터 전처리, 탐색, 시각화, 의사소통까지 포괄하는 전체 파이프라인을 다룬다. 실제 비즈니스 문제 해결에 초점을 맞춘다.</p>
<p><strong>머신러닝(Machine Learning)</strong>은 명시적인 통계적 가정 없이도 데이터에서 패턴을 자동으로 학습한다. 전통적 통계 모델이 요구하는 복잡한 전제 조건들을 완화하고, 비선형적이고 고차원적인 관계도 포착할 수 있다. 모델이 데이터로부터 스스로 학습하므로, 사람이 일일이 특성을 설계하지 않아도 된다.</p>
<p><strong>딥러닝(Deep Learning)</strong>은 인간의 뇌 구조에서 영감을 받은 다층 신경망을 통해 더욱 복잡한 패턴과 추상적인 표현을 학습한다. 이미지, 음성, 텍스트와 같은 비정형 데이터에서 뛰어난 성능을 보이며, 전통적인 특성 공학(feature engineering)의 필요성을 크게 줄였다.</p>
<p><strong>인공지능(Artificial Intelligence)</strong>은 이 모든 기술을 통합하여, 인간의 인지 능력을 모방하고 자율적으로 의사결정을 내릴 수 있는 시스템을 구축한다. 단순한 예측을 넘어 추론, 계획, 자연어 이해 등 복합적인 지능적 행동을 수행한다.</p>
</section>
<section id="statistics-mathematical-foundation-with-strict-assumptions" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="statistics-mathematical-foundation-with-strict-assumptions"><span class="header-section-number">4</span> Statistics: Mathematical Foundation with Strict Assumptions</h2>
<p>통계학은 데이터 분석의 수학적 기초를 제공하며, 엄격한 이론적 프레임워크를 통해 신뢰할 수 있는 추론을 가능하게 한다.</p>
<section id="핵심-강점" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="핵심-강점"><span class="header-section-number">4.1</span> 핵심 강점</h3>
<ul>
<li><strong>수학적 엄밀성</strong>: 확률 이론에 기반한 정확한 추론</li>
<li><strong>불확실성 정량화</strong>: p-value, 신뢰구간을 통한 통계적 유의성 측정</li>
<li><strong>해석 가능성</strong>: 명확한 인과관계와 변수 간 관계 설명</li>
<li><strong>작은 샘플에서도 효과적</strong>: 적절한 실험 설계로 적은 데이터로도 신뢰할 수 있는 결론 도출</li>
</ul>
</section>
<section id="주요-한계" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="주요-한계"><span class="header-section-number">4.2</span> 주요 한계</h3>
<ul>
<li><strong>많은 가정 요구</strong>: 정규성, 독립성, 등분산성, 선형성 등</li>
<li><strong>현실 데이터와의 괴리</strong>: 실제 데이터는 가정을 위반하는 경우가 많음</li>
<li><strong>고차원 데이터 처리 어려움</strong>: 변수가 많아지면 다중공선성, 차원의 저주 문제</li>
<li><strong>비선형 관계 모델링 한계</strong>: 복잡한 비선형 패턴을 포착하기 어려움</li>
<li><strong>수동 특성 선택</strong>: 분석가가 어떤 변수를 사용할지 미리 결정해야 함</li>
</ul>
<blockquote class="blockquote">
<p>이러한 한계로 인해 더 유연하고 자동화된 방법론이 필요하게 되었다.</p>
</blockquote>
</section>
</section>
<section id="statistics-key-concepts" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="statistics-key-concepts"><span class="header-section-number">5</span> Statistics: Key Concepts</h2>
<section id="중심극한정리-central-limit-theorem" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="중심극한정리-central-limit-theorem"><span class="header-section-number">5.1</span> 중심극한정리 (Central Limit Theorem)</h3>
<p>중심극한정리는 확률론과 통계학의 핵심 개념이다. 모집단에서 충분히 큰 표본을 추출하면, 원래 모집단의 분포 형태와 무관하게 표본 평균들의 분포는 근사적으로 정규분포를 따른다는 정리다.</p>
<p>더 쉽게 말하면, 표본 크기가 증가할수록 표본 평균은 모집단 평균을 더 정확하게 대표하게 되며, 표본 평균들의 분포는 종 모양의 대칭적인 정규분포에 가까워진다는 것이다.</p>
<p>중심극한정리가 중요한 이유는 모집단 분포의 정확한 형태를 모르더라도 표본을 기반으로 모집단에 대한 통계적 추론을 할 수 있게 해주기 때문이다. 또한 많은 통계 검정과 모델에서 사용되는 핵심 모수인 표본 평균과 표준편차의 행동을 이해하는 데 도움을 준다.</p>
<section id="예시" class="level4" data-number="5.1.1">
<h4 data-number="5.1.1" class="anchored" data-anchor-id="예시"><span class="header-section-number">5.1.1</span> 예시</h4>
<p><strong>예시 1: 모집단의 평균 체중</strong></p>
<p>한 국가의 모든 사람의 평균 체중을 알고 싶다고 가정하자. 모든 사람의 체중을 측정하는 것은 비현실적이므로, 1000명의 표본을 추출한다. 중심극한정리에 따르면 크기 1000인 표본을 충분히 많이(30개 이상) 추출하면, 이 표본들의 평균은 정규분포를 따른다. 이를 통해 우리의 표본 평균을 기반으로 모집단 평균에 대한 추론을 할 수 있다.</p>
<p><strong>예시 2: 품질 관리</strong></p>
<p>공장에서 대량의 동일한 제품을 생산하며, 각 제품의 무게는 평균 500그램, 표준편차 10그램의 정규분포를 따른다고 가정하자. 공장은 100개 제품 배치의 평균 무게가 498그램에서 502그램 사이에 있는지를 95% 신뢰수준으로 확인하고자 한다.</p>
<p>중심극한정리를 사용하여 모집단에서 100개 제품의 무작위 표본을 추출하고, 각 표본의 평균 무게를 계산하여 평균들의 표본분포를 만들 수 있다. 표본 크기가 충분히 크므로(n &gt; 30), 중심극한정리에 따르면 평균들의 표본분포는 평균 500그램, 표준편차 1그램(모집단 표준편차를 표본 크기의 제곱근으로 나눈 값)의 근사적 정규분포를 따른다.</p>
<p>이 정보를 사용하여 100개 제품 배치의 평균 무게가 원하는 범위 내에 있을 확률을 계산할 수 있다. 표준정규분포표나 소프트웨어를 사용하여 범위의 각 끝점(498과 502)에 대한 z-점수를 찾고, 무작위로 선택된 100개 제품 표본의 평균 무게가 이 범위 내에 있을 확률을 계산한다. 확률이 최소 95%라면, 공장의 품질 관리 기준이 충족된다고 결론지을 수 있다.</p>
</section>
</section>
<section id="표본추출-sampling" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="표본추출-sampling"><span class="header-section-number">5.2</span> 표본추출 (Sampling)</h3>
<p>표본추출의 목적은 더 큰 모집단에 대한 추론이나 결론을 도출하는 데 사용할 수 있는 대표적인 부분집합을 얻는 것이다.</p>
<section id="확률적-표본추출-probabilistic-sampling" class="level4" data-number="5.2.1">
<h4 data-number="5.2.1" class="anchored" data-anchor-id="확률적-표본추출-probabilistic-sampling"><span class="header-section-number">5.2.1</span> 확률적 표본추출 (Probabilistic Sampling)</h4>
<ul>
<li><strong>단순 무작위 추출 (Simple Random Sampling)</strong>: 모집단의 각 개인이나 단위가 표본으로 선택될 동등한 기회를 갖는다. 보통 난수 생성기나 난수표를 사용한다.</li>
<li><strong>층화 추출 (Stratified Sampling)</strong>: 모집단을 특성(연령, 성별, 지리적 위치 등)에 따라 하위 그룹(층)으로 나누고, 각 층에서 무작위 표본을 선택한다. 이는 관심 특성과 관련하여 표본이 모집단을 대표하도록 보장한다.</li>
<li><strong>집락 추출 (Cluster Sampling)</strong>: 모집단을 가구나 학교 같은 집락으로 나누고, 조사할 집락의 무작위 표본을 선택한다. 선택된 각 집락 내의 모든 개인이나 단위를 조사한다.</li>
<li><strong>계통 추출 (Systematic Sampling)</strong>: 모집단에서 무작위 시작점을 선택하고, n번째마다 개인이나 단위를 선택한다. 여기서 n은 미리 정해진 간격이다.</li>
</ul>
</section>
<section id="비확률적-표본추출-non-probabilistic-sampling" class="level4" data-number="5.2.2">
<h4 data-number="5.2.2" class="anchored" data-anchor-id="비확률적-표본추출-non-probabilistic-sampling"><span class="header-section-number">5.2.2</span> 비확률적 표본추출 (Non-Probabilistic Sampling)</h4>
<ul>
<li><strong>편의 추출 (Convenience Sampling)</strong>: 공식적인 표본추출 기법보다는 편의성이나 이용 가능성에 기반하여 개인이나 단위를 선택한다. 편리하지만 편향된 결과를 초래할 수 있으며 연구 목적으로는 일반적으로 권장되지 않는다.</li>
<li><strong>눈덩이 추출 (Snowball Sampling)</strong>: 접근하기 어렵거나 제한적인 모집단을 연구할 때 주로 사용된다. 특정 기준을 충족하는 작은 그룹으로 시작하여, 그들이 동일한 기준을 충족하는 다른 개인을 추천하게 한다. 원하는 표본 크기에 도달할 때까지 이 과정을 계속한다.</li>
</ul>
</section>
</section>
<section id="제1종-오류-vs-제2종-오류-type-i-vs-type-ii-error" class="level3" data-number="5.3">
<h3 data-number="5.3" class="anchored" data-anchor-id="제1종-오류-vs-제2종-오류-type-i-vs-type-ii-error"><span class="header-section-number">5.3</span> 제1종 오류 vs 제2종 오류 (Type I vs Type II Error)</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 31%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">진실</th>
<th style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?H_%7Bnull%7D"> 기각</th>
<th style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?H_%7Bnull%7D"> 기각 실패</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?H_%7Bnull%7D"> = 참</td>
<td style="text-align: center;">제1종 오류, <img src="https://latex.codecogs.com/png.latex?%5Calpha">, 거짓 양성</td>
<td style="text-align: center;">올바른 결정 (1 - <img src="https://latex.codecogs.com/png.latex?%5Calpha">), 참 음성</td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?H_%7Bnull%7D"> = 거짓</td>
<td style="text-align: center;">올바른 결정 (검정력, 1-<img src="https://latex.codecogs.com/png.latex?%5Cbeta">), 참 양성</td>
<td style="text-align: center;">제2종 오류, <img src="https://latex.codecogs.com/png.latex?%5Cbeta">, 거짓 음성</td>
</tr>
</tbody>
</table>
<p>가설 검정에서 제1종 오류는 실제로 참인 귀무가설을 기각할 때 발생한다. 즉, 실제로는 유의한 효과나 차이가 없는데 있다고 결론 내리는 것이다. 이 오류는 거짓 양성(false positive)이라고도 한다.</p>
<p>반면, 제2종 오류는 실제로 거짓인 귀무가설을 기각하지 못할 때 발생한다. 즉, 실제로는 유의한 효과나 차이가 있는데 없다고 결론 내리는 것이다. 이 오류는 거짓 음성(false negative)이라고도 한다.</p>
</section>
<section id="선형회귀-linear-regression" class="level3" data-number="5.4">
<h3 data-number="5.4" class="anchored" data-anchor-id="선형회귀-linear-regression"><span class="header-section-number">5.4</span> 선형회귀 (Linear Regression)</h3>
<p>선형회귀는 종속변수(반응변수)와 하나 이상의 독립변수(예측변수 또는 설명변수) 간의 관계를 모델링하는 데 사용되는 통계 기법이다. 선형회귀의 목표는 종속변수의 값을 예측하는 데 사용할 수 있는 종속변수와 독립변수 간의 최적의 선형 관계를 찾는 것이다.</p>
<p>선형회귀에서 p-value, 계수, R-squared 값은 모델의 통계적 유의성과 예측력을 평가하는 데 도움이 되는 중요한 구성요소다:</p>
<p><strong>P-value</strong>: p-value는 귀무가설이 참이라고 가정할 때, 관찰된 것만큼 극단적인 결과를 얻을 확률을 측정한다. 선형회귀의 맥락에서 귀무가설은 독립변수의 계수가 0이라는 것, 즉 독립변수와 종속변수 간에 선형 관계가 없다는 것이다. 낮은 p-value(일반적으로 0.05 미만)는 독립변수와 종속변수 간의 관계가 통계적으로 유의하며, 귀무가설을 기각할 수 있음을 나타낸다.</p>
<p><strong>계수 (Coefficient)</strong>: 계수는 독립변수와 종속변수 간의 선형 관계를 나타내는 직선의 기울기다. 다른 모든 변수를 일정하게 유지하면서, 독립변수의 한 단위 변화로 인한 종속변수의 변화량을 측정한다. 양의 계수는 독립변수와 종속변수 간의 양의 관계를 나타내고, 음의 계수는 음의 관계를 나타낸다.</p>
<p><strong>R-squared 값</strong>: R-squared 값은 독립변수의 변동으로 설명되는 종속변수의 변동 비율을 측정한다. 모델의 적합도를 나타내는 척도이며, 0에서 1 사이의 값을 갖는다. 높은 R-squared 값은 모델이 종속변수의 변동 중 큰 비율을 설명하며, 종속변수의 좋은 예측변수임을 나타낸다.</p>
<p>선형회귀에서 각 구성요소의 중요성: - <strong>P-value</strong>: 독립변수와 종속변수 간의 관계가 통계적으로 유의한지, 모델을 유효한 예측에 사용할 수 있는지 판단하는 데 도움을 준다. - <strong>계수</strong>: 독립변수와 종속변수 간 선형 관계의 방향과 강도를 결정하고, 독립변수의 변화에 따른 종속변수 예측을 수행하는 데 도움을 준다. - <strong>R-squared 값</strong>: 모델의 전반적인 적합도를 평가하고, 여러 모델을 비교하여 종속변수의 최적 예측변수를 결정하는 데 도움을 준다.</p>
</section>
<section id="선택-편향-selection-bias" class="level3" data-number="5.5">
<h3 data-number="5.5" class="anchored" data-anchor-id="선택-편향-selection-bias"><span class="header-section-number">5.5</span> 선택 편향 (Selection Bias)</h3>
<p>선택 편향은 연구나 분석에 참여할 개인이나 그룹을 선택하는 과정이 무작위적이지 않거나 관심 모집단을 대표하지 못할 때 발생하는 편향의 한 유형이다. 선택 편향은 모집단 모수의 편향된 추정을 초래하고 연구의 내적 및 외적 타당도에 영향을 미칠 수 있다.</p>
<p>선택 편향은 연구나 분석의 다양한 단계에서 발생할 수 있다:</p>
<p><strong>표본추출 편향 (Sampling bias)</strong>: 표본이 관심 모집단을 대표하지 못할 때 발생한다. 예를 들어, 질병 유병률에 대한 연구가 특정 인구통계학적 또는 지리적 지역의 참가자만 포함한다면, 결과를 전체 모집단에 일반화할 수 없다.</p>
<p><strong>무응답 편향 (Non-response bias)</strong>: 응답률이 낮거나, 참여를 거부한 참가자가 참여에 동의한 참가자와 다를 때 발생한다. 이는 대표성 없는 표본과 편향된 추정으로 이어질 수 있다.</p>
<p><strong>생존 편향 (Survivorship bias)</strong>: 표본이 추적 연구와 같은 특정 선택 과정을 거쳐 생존하거나 지속된 개인이나 그룹만 포함할 때 발생한다. 이는 생존율이나 다른 결과의 과대평가로 이어질 수 있다.</p>
<p><strong>버크슨 편향 (Berkson’s bias)</strong>: 표본이 노출이나 관심 결과와 관련된 조건에 기반하여 선택될 때 발생한다. 예를 들어 병원 기반 표본의 경우다. 이는 노출과 결과 간 연관성의 과소평가로 이어질 수 있다.</p>
<p>선택 편향은 무작위 표본추출 기법을 사용하고 표본이 관심 모집단을 대표하도록 보장함으로써 최소화할 수 있다. 또한 결과가 올바르게 해석되도록 연구의 잠재적 편향과 한계를 분석하고 보고하는 것이 중요하다.</p>
</section>
</section>
<section id="data-science-bridging-statistics-and-computation" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="data-science-bridging-statistics-and-computation"><span class="header-section-number">6</span> Data Science: Bridging Statistics and Computation</h2>
<p>통계학의 한계를 극복하기 위해 등장한 데이터 과학은 통계적 방법론에 컴퓨터 과학의 계산 능력을 결합하여 더 큰 규모와 복잡도의 데이터를 다룰 수 있게 한다.</p>
<section id="핵심-강점-1" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="핵심-강점-1"><span class="header-section-number">6.1</span> 핵심 강점</h3>
<ul>
<li><strong>대규모 데이터 처리</strong>: 분산 컴퓨팅과 병렬 처리로 빅데이터 분석 가능</li>
<li><strong>실용적 접근</strong>: 통계적 가정을 완벽히 만족하지 않아도 유용한 인사이트 도출</li>
<li><strong>End-to-End 파이프라인</strong>: 데이터 수집, 전처리, 분석, 시각화, 배포까지 전체 과정 포괄</li>
<li><strong>도메인 지식 통합</strong>: 비즈니스 문제를 이해하고 실제 가치 창출에 집중</li>
<li><strong>다양한 도구 활용</strong>: Python, R, SQL, Hadoop, Spark 등 다양한 기술 스택</li>
</ul>
</section>
<section id="데이터-과학의-정의" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="데이터-과학의-정의"><span class="header-section-number">6.2</span> 데이터 과학의 정의</h3>
<p>데이터 과학은 통계적, 계산적, 도메인 특화 지식과 기법을 사용하여 데이터로부터 인사이트와 지식을 추출하는 학제간 분야다. 통계학, 컴퓨터 과학, 수학, 도메인 지식의 방법과 개념을 결합하여 복잡한 데이터 관련 문제를 해결한다.</p>
<p>통계학과 컴퓨터 과학은 데이터 과학의 두 가지 중요한 구성요소다. 통계학은 데이터 분석과 모델링을 위한 기초적인 방법을 제공하고, 컴퓨터 과학은 데이터 저장, 처리, 분석을 위한 계산 인프라와 도구를 제공한다. 또한 컴퓨터 과학은 대규모 데이터셋에서 인사이트와 지식을 추출하는 데 사용할 수 있는 데이터 시각화, 머신러닝, 인공지능 기법을 제공한다.</p>
<p>데이터 과학은 데이터 수집, 정제 및 전처리, 탐색적 데이터 분석, 모델링 및 예측, 데이터 시각화, 결과 커뮤니케이션 등 광범위한 활동을 포함한다. 통계학, 프로그래밍, 도메인 지식에 대한 탄탄한 기초와 데이터 관리, 데이터 시각화, 머신러닝에 대한 전문 지식이 필요하다.</p>
</section>
<section id="여전히-남는-한계" class="level3" data-number="6.3">
<h3 data-number="6.3" class="anchored" data-anchor-id="여전히-남는-한계"><span class="header-section-number">6.3</span> 여전히 남는 한계</h3>
<ul>
<li><strong>모델 선택의 어려움</strong>: 어떤 모델을 사용할지 여전히 전문가의 판단 필요</li>
<li><strong>특성 공학 부담</strong>: 좋은 특성을 설계하는 것이 성능에 결정적이지만 시간 소모적</li>
<li><strong>해석과 예측의 트레이드오프</strong>: 복잡한 모델은 정확하지만 해석하기 어려움</li>
<li><strong>수동 하이퍼파라미터 튜닝</strong>: 모델 성능 최적화를 위한 반복적 실험 필요</li>
</ul>
<blockquote class="blockquote">
<p><strong>이러한 한계를 극복하기 위해 데이터로부터 자동으로 학습하는 머신러닝이 발전했다.</strong></p>
</blockquote>
</section>
</section>
<section id="machine-learning-learning-patterns-from-data" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="machine-learning-learning-patterns-from-data"><span class="header-section-number">7</span> Machine Learning: Learning Patterns from Data</h2>
<p>머신러닝은 명시적으로 프로그래밍하지 않고도 데이터에서 패턴을 자동으로 학습하여 예측과 의사결정을 수행한다.</p>
<section id="핵심-강점-2" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="핵심-강점-2"><span class="header-section-number">7.1</span> 핵심 강점</h3>
<ul>
<li><strong>자동 패턴 학습</strong>: 데이터에서 스스로 규칙과 패턴을 발견</li>
<li><strong>비선형 모델링</strong>: 복잡한 비선형 관계도 효과적으로 포착</li>
<li><strong>고차원 데이터 처리</strong>: 수천, 수만 개의 특성도 처리 가능</li>
<li><strong>유연한 가정</strong>: 엄격한 통계적 가정 없이도 작동</li>
<li><strong>지속적 개선</strong>: 새로운 데이터로 모델을 계속 업데이트하고 개선</li>
</ul>
</section>
<section id="주요-알고리즘-유형" class="level3" data-number="7.2">
<h3 data-number="7.2" class="anchored" data-anchor-id="주요-알고리즘-유형"><span class="header-section-number">7.2</span> 주요 알고리즘 유형</h3>
<ul>
<li><strong>Supervised Learning</strong>: 입력과 정답 쌍으로 학습 (회귀, 분류)
<ul>
<li>Linear/Logistic Regression, Decision Trees, Random Forest, SVM, Gradient Boosting</li>
</ul></li>
<li><strong>Unsupervised Learning</strong>: 정답 없이 데이터 구조 발견 (군집화, 차원축소)
<ul>
<li>K-Means, Hierarchical Clustering, PCA, t-SNE</li>
</ul></li>
<li><strong>Ensemble Methods</strong>: 여러 모델을 결합하여 성능 향상
<ul>
<li>Bagging, Boosting, Stacking</li>
</ul></li>
</ul>
</section>
<section id="한계" class="level3" data-number="7.3">
<h3 data-number="7.3" class="anchored" data-anchor-id="한계"><span class="header-section-number">7.3</span> 한계</h3>
<ul>
<li><strong>대량의 데이터 필요</strong>: 좋은 성능을 위해 많은 학습 데이터 필요</li>
<li><strong>특성 공학 여전히 중요</strong>: 좋은 특성 설계가 성능에 큰 영향</li>
<li><strong>해석 가능성 낮음</strong>: 특히 앙상블 모델은 블랙박스처럼 작동</li>
<li><strong>비정형 데이터 처리 한계</strong>: 이미지, 음성, 텍스트 같은 원시 데이터에는 수동 전처리 필요</li>
</ul>
<blockquote class="blockquote">
<p><strong>특히 비정형 데이터 처리와 자동 특성 추출을 위해 딥러닝이 등장했다.</strong></p>
</blockquote>
</section>
</section>
<section id="deep-learning-hierarchical-representation-learning" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="deep-learning-hierarchical-representation-learning"><span class="header-section-number">8</span> Deep Learning: Hierarchical Representation Learning</h2>
<p>딥러닝은 다층 신경망을 통해 데이터의 계층적 표현을 자동으로 학습하며, 특히 비정형 데이터에서 혁신적인 성능을 달성했다.</p>
<section id="핵심-강점-3" class="level3" data-number="8.1">
<h3 data-number="8.1" class="anchored" data-anchor-id="핵심-강점-3"><span class="header-section-number">8.1</span> 핵심 강점</h3>
<ul>
<li><strong>자동 특성 추출</strong>: 원시 데이터에서 자동으로 유용한 특성 학습</li>
<li><strong>계층적 표현</strong>: 저수준 특성에서 고수준 추상 개념까지 단계적 학습</li>
<li><strong>비정형 데이터 탁월</strong>: 이미지, 음성, 텍스트 처리에서 인간 수준 성능</li>
<li><strong>End-to-End 학습</strong>: 전처리에서 예측까지 하나의 통합 모델로 학습</li>
<li><strong>전이 학습</strong>: 한 작업에서 학습한 지식을 다른 작업에 재사용</li>
</ul>
</section>
<section id="주요-아키텍처" class="level3" data-number="8.2">
<h3 data-number="8.2" class="anchored" data-anchor-id="주요-아키텍처"><span class="header-section-number">8.2</span> 주요 아키텍처</h3>
<ul>
<li><strong>Convolutional Neural Networks (CNN)</strong>: 이미지 처리, 공간적 패턴 인식</li>
<li><strong>Recurrent Neural Networks (RNN/LSTM/GRU)</strong>: 시계열, 자연어 처리</li>
<li><strong>Transformer</strong>: 자연어 이해, 번역, 생성 (BERT, GPT)</li>
<li><strong>Generative Models</strong>: GAN, VAE - 새로운 데이터 생성</li>
<li><strong>Graph Neural Networks</strong>: 그래프 구조 데이터 처리</li>
</ul>
</section>
<section id="한계-1" class="level3" data-number="8.3">
<h3 data-number="8.3" class="anchored" data-anchor-id="한계-1"><span class="header-section-number">8.3</span> 한계</h3>
<ul>
<li><strong>막대한 데이터 요구</strong>: 수백만~수십억 개의 샘플 필요</li>
<li><strong>계산 자원 집약적</strong>: 강력한 GPU/TPU와 많은 전력 소비</li>
<li><strong>블랙박스 특성</strong>: 왜 그런 예측을 했는지 설명하기 매우 어려움</li>
<li><strong>과적합 위험</strong>: 모델이 너무 복잡하면 훈련 데이터에만 과도하게 맞춰짐</li>
<li><strong>하이퍼파라미터 민감</strong>: 학습률, 배치 크기 등 설정에 따라 성능 크게 변동</li>
</ul>
<blockquote class="blockquote">
<p><strong>딥러닝의 성능을 더욱 발전시키고 추론, 계획 등 고차원 인지 능력을 구현하기 위해 현대 AI가 발전하고 있다.</strong></p>
</blockquote>
</section>
</section>
<section id="artificial-intelligence-towards-human-like-intelligence" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="artificial-intelligence-towards-human-like-intelligence"><span class="header-section-number">9</span> Artificial Intelligence: Towards Human-like Intelligence</h2>
<p>인공지능은 머신러닝과 딥러닝을 기반으로, 인간의 인지 능력을 모방하고 자율적으로 의사결정을 내릴 수 있는 시스템을 구현한다.</p>
<section id="ai의-발전-단계" class="level3" data-number="9.1">
<h3 data-number="9.1" class="anchored" data-anchor-id="ai의-발전-단계"><span class="header-section-number">9.1</span> AI의 발전 단계</h3>
<section id="rule-based-systems-expert-systems---초기-ai-1970-80년대" class="level4" data-number="9.1.1">
<h4 data-number="9.1.1" class="anchored" data-anchor-id="rule-based-systems-expert-systems---초기-ai-1970-80년대"><span class="header-section-number">9.1.1</span> Rule-Based Systems (Expert Systems) - 초기 AI (1970-80년대)</h4>
<p>초기 AI는 전문가의 지식을 if-then 규칙으로 명시적으로 코딩하는 방식으로 시작했다.</p>
<p><strong>작동 방식:</strong></p>
<pre><code>IF 환자의 체온 &gt; 38도 AND 기침 = 있음 THEN 감기 가능성 높음
IF 고객의 구매이력 &gt; 10회 AND 최근방문 &lt; 30일 THEN VIP 등급 부여</code></pre>
<p><strong>강점:</strong> - <strong>완전한 제어</strong>: 시스템의 모든 동작을 정확히 예측 가능 - <strong>해석 가능성</strong>: 왜 그런 결론에 도달했는지 명확히 설명 가능 - <strong>도메인 지식 활용</strong>: 전문가의 경험과 지식을 직접 시스템에 반영 - <strong>데이터 불필요</strong>: 학습 데이터 없이도 작동</p>
<p><strong>치명적 한계:</strong> - <strong>확장성 없음</strong>: 규칙이 수백, 수천 개로 늘어나면 관리 불가능 - <strong>규칙 충돌</strong>: 여러 규칙이 상충할 때 해결 방법 불명확 - <strong>예외 처리 어려움</strong>: 모든 상황을 규칙으로 만들 수 없음 - <strong>변화 적응 불가</strong>: 새로운 패턴이나 상황에 자동으로 대응 못함 - <strong>암묵적 지식 표현 한계</strong>: 전문가도 설명 못하는 직관적 판단을 코딩할 수 없음</p>
<p><strong>실패 사례: AI의 겨울</strong></p>
<p>1980년대 후반, 많은 기업이 expert system에 막대한 투자를 했지만 실용성 부족으로 실패했다. 이는 “AI의 겨울”로 이어졌고, 데이터로부터 학습하는 머신러닝 접근법의 필요성을 입증했다.</p>
<blockquote class="blockquote">
<p><strong>규칙을 수동으로 만드는 것의 한계가 명확해지면서, 데이터로부터 자동으로 패턴을 학습하는 머신러닝과 딥러닝이 주류가 되었다.</strong></p>
</blockquote>
</section>
<section id="machine-learning-deep-learning-era-1990-2020년대" class="level4" data-number="9.1.2">
<h4 data-number="9.1.2" class="anchored" data-anchor-id="machine-learning-deep-learning-era-1990-2020년대"><span class="header-section-number">9.1.2</span> Machine Learning &amp; Deep Learning Era (1990-2020년대)</h4>
<p>통계적 학습과 신경망 기반의 머신러닝이 AI의 중심이 되었다. (앞서 Machine Learning과 Deep Learning 섹션 참조)</p>
</section>
<section id="modern-ai-integration-and-emergence-2020년대" class="level4" data-number="9.1.3">
<h4 data-number="9.1.3" class="anchored" data-anchor-id="modern-ai-integration-and-emergence-2020년대"><span class="header-section-number">9.1.3</span> Modern AI: Integration and Emergence (2020년대~)</h4>
<p>현대 AI는 대규모 데이터와 컴퓨팅 파워를 활용하여 인간 수준의 능력을 보이기 시작했다.</p>
</section>
</section>
<section id="핵심-발전-방향" class="level3" data-number="9.2">
<h3 data-number="9.2" class="anchored" data-anchor-id="핵심-발전-방향"><span class="header-section-number">9.2</span> 핵심 발전 방향</h3>
<ul>
<li><strong>Large Language Models (LLMs)</strong>: GPT, Claude 등 대규모 언어 모델
<ul>
<li>자연어 이해, 생성, 추론, 대화</li>
<li>Few-shot/Zero-shot Learning: 적은 예제 또는 예제 없이도 새 작업 수행</li>
</ul></li>
<li><strong>Multimodal AI</strong>: 텍스트, 이미지, 음성을 통합 처리
<ul>
<li>CLIP, GPT-4V 등 여러 모달리티 동시 이해</li>
</ul></li>
<li><strong>Reinforcement Learning</strong>: 환경과 상호작용하며 최적 전략 학습
<ul>
<li>AlphaGo, OpenAI Five - 게임, 로봇 제어</li>
</ul></li>
<li><strong>Explainable AI (XAI)</strong>: 블랙박스 모델의 의사결정 과정 설명
<ul>
<li>SHAP, LIME, Attention Visualization</li>
</ul></li>
<li><strong>AutoML</strong>: 모델 선택과 하이퍼파라미터 튜닝 자동화</li>
</ul>
</section>
<section id="ai의-현재와-미래" class="level3" data-number="9.3">
<h3 data-number="9.3" class="anchored" data-anchor-id="ai의-현재와-미래"><span class="header-section-number">9.3</span> AI의 현재와 미래</h3>
<ul>
<li><strong>현재 달성한 것</strong>:
<ul>
<li>이미지 분류, 객체 인식에서 인간 수준 성능</li>
<li>자연어 이해와 생성에서 놀라운 능력</li>
<li>특정 게임과 작업에서 인간 능가</li>
<li>의료 진단, 약물 발견, 과학 연구 지원</li>
</ul></li>
<li><strong>여전히 어려운 것</strong>:
<ul>
<li>상식 추론과 인과관계 이해</li>
<li>소수 샘플로 학습 (Few-shot Learning 개선 필요)</li>
<li>신뢰성과 안전성 보장</li>
<li>편향과 공정성 문제 해결</li>
<li>에너지 효율성 개선</li>
</ul></li>
</ul>
</section>
<section id="ai-윤리와-책임" class="level3" data-number="9.4">
<h3 data-number="9.4" class="anchored" data-anchor-id="ai-윤리와-책임"><span class="header-section-number">9.4</span> AI 윤리와 책임</h3>
<ul>
<li><strong>공정성</strong>: 편향되지 않은 데이터와 알고리즘</li>
<li><strong>투명성</strong>: 의사결정 과정의 설명 가능성</li>
<li><strong>프라이버시</strong>: 개인정보 보호와 데이터 거버넌스</li>
<li><strong>책임성</strong>: AI 시스템의 결정에 대한 책임 소재</li>
</ul>
</section>
</section>
<section id="conclusion-the-continuous-evolution" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="conclusion-the-continuous-evolution"><span class="header-section-number">10</span> Conclusion: The Continuous Evolution</h2>
<p>통계학에서 AI까지의 여정은 각 단계가 이전의 한계를 극복하면서 발전한 자연스러운 진화 과정이다:</p>
<ol type="1">
<li><strong>통계학</strong>: 수학적으로 엄밀하지만 많은 가정과 제약</li>
<li><strong>데이터 과학</strong>: 계산 능력으로 대규모 데이터 처리, 하지만 여전히 수동 작업 많음</li>
<li><strong>머신러닝</strong>: 자동 패턴 학습으로 유연성 확보, 하지만 특성 공학 필요</li>
<li><strong>딥러닝</strong>: 자동 특성 추출로 비정형 데이터 정복, 하지만 해석 어려움</li>
<li><strong>AI 발전</strong>:
<ul>
<li>초기 Rule-based: 완전한 제어와 해석 가능성, 하지만 확장성 없음</li>
<li>현대 Learning-based: 데이터로부터 학습하여 복잡한 패턴 포착, 인간 수준 인지 능력 지향</li>
</ul></li>
</ol>
<p>각 방법론은 서로를 대체하는 것이 아니라 보완하는 관계다. 실제로 많은 현대 AI 시스템은 딥러닝과 규칙 기반 시스템을 결합한다: - <strong>Hybrid Systems</strong>: 딥러닝으로 패턴 학습 + 규칙으로 안전장치와 제약조건 구현 - <strong>Neural-Symbolic AI</strong>: 신경망의 학습 능력 + 기호적 추론의 논리성</p>
<p>문제의 특성, 데이터의 양과 질, 해석 가능성의 중요도, 계산 자원, 안전성 요구사항 등을 고려하여 적절한 방법을 선택하고 결합하는 것이 중요하다.</p>
<p>미래의 데이터 과학자와 AI 연구자는 이 모든 단계를 이해하고, 각각의 강점과 한계를 파악하여, 실제 문제에 가장 적합한 접근법을 선택할 수 있어야 한다.</p>


</section>

 ]]></description>
  <category>Data Science</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Data_Science/0.intro.html</guid>
  <pubDate>Sat, 31 May 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Data Science</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Data_Science/</link>
  <description><![CDATA[ 





<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="kk3225.netlify.app/images/data_science/data_science.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Data Science</figcaption>
</figure>
</div>
<section id="the-evolution-from-statistics-to-ai" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="the-evolution-from-statistics-to-ai"><span class="header-section-number">1</span> The Evolution from Statistics to AI</h2>
<p>데이터 분석의 여정은 통계학에서 시작하여 인공지능까지 자연스럽게 발전해왔다. 각 단계는 이전 단계의 한계를 극복하면서 더 복잡하고 현실적인 문제를 해결할 수 있는 방법론으로 진화했다.</p>
<p><strong>통계학(Statistics)</strong>은 수학적으로 엄격한 기반 위에서 데이터를 분석한다. 확률 이론과 추론 통계를 통해 데이터에서 의미 있는 패턴을 발견하고, 가설을 검증하며, 불확실성을 정량화한다. 잘 설계된 실험과 데이터에 대해서는 수학적으로 매우 높은 설명력을 제공한다. 그러나 정규성(normality), 독립성(independence), 등분산성(homoscedasticity) 등 많은 가정을 필요로 하며, 이러한 가정이 충족되지 않는 현실 데이터에서는 한계를 보인다.</p>
<p><strong>데이터 과학(Data Science)</strong>은 통계학의 수학적 엄격함을 유지하면서도, 컴퓨터 과학의 계산 능력과 도메인 지식을 결합한다. 통계적 가정을 완전히 만족하지 않는 대규모 데이터도 처리할 수 있고, 데이터 전처리, 탐색, 시각화, 의사소통까지 포괄하는 전체 파이프라인을 다룬다. 실제 비즈니스 문제 해결에 초점을 맞춘다.</p>
<p><strong>머신러닝(Machine Learning)</strong>은 명시적인 통계적 가정 없이도 데이터에서 패턴을 자동으로 학습한다. 전통적 통계 모델이 요구하는 복잡한 전제 조건들을 완화하고, 비선형적이고 고차원적인 관계도 포착할 수 있다. 모델이 데이터로부터 스스로 학습하므로, 사람이 일일이 특성을 설계하지 않아도 된다.</p>
<p><strong>딥러닝(Deep Learning)</strong>은 인간의 뇌 구조에서 영감을 받은 다층 신경망을 통해 더욱 복잡한 패턴과 추상적인 표현을 학습한다. 이미지, 음성, 텍스트와 같은 비정형 데이터에서 뛰어난 성능을 보이며, 전통적인 특성 공학(feature engineering)의 필요성을 크게 줄였다.</p>
<p><strong>인공지능(Artificial Intelligence)</strong>은 이 모든 기술을 통합하여, 인간의 인지 능력을 모방하고 자율적으로 의사결정을 내릴 수 있는 시스템을 구축한다. 단순한 예측을 넘어 추론, 계획, 자연어 이해 등 복합적인 지능적 행동을 수행한다.</p>
</section>
<section id="statistics-mathematical-foundation-with-strict-assumptions" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="statistics-mathematical-foundation-with-strict-assumptions"><span class="header-section-number">2</span> Statistics: Mathematical Foundation with Strict Assumptions</h2>
<p>통계학은 데이터 분석의 수학적 기초를 제공하며, 엄격한 이론적 프레임워크를 통해 신뢰할 수 있는 추론을 가능하게 한다.</p>
<section id="핵심-강점" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="핵심-강점"><span class="header-section-number">2.1</span> 핵심 강점</h3>
<ul>
<li><strong>수학적 엄밀성</strong>: 확률 이론에 기반한 정확한 추론</li>
<li><strong>불확실성 정량화</strong>: p-value, 신뢰구간을 통한 통계적 유의성 측정</li>
<li><strong>해석 가능성</strong>: 명확한 인과관계와 변수 간 관계 설명</li>
<li><strong>작은 샘플에서도 효과적</strong>: 적절한 실험 설계로 적은 데이터로도 신뢰할 수 있는 결론 도출</li>
</ul>
</section>
<section id="주요-한계" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="주요-한계"><span class="header-section-number">2.2</span> 주요 한계</h3>
<ul>
<li><strong>많은 가정 요구</strong>: 정규성, 독립성, 등분산성, 선형성 등</li>
<li><strong>현실 데이터와의 괴리</strong>: 실제 데이터는 가정을 위반하는 경우가 많음</li>
<li><strong>고차원 데이터 처리 어려움</strong>: 변수가 많아지면 다중공선성, 차원의 저주 문제</li>
<li><strong>비선형 관계 모델링 한계</strong>: 복잡한 비선형 패턴을 포착하기 어려움</li>
<li><strong>수동 특성 선택</strong>: 분석가가 어떤 변수를 사용할지 미리 결정해야 함</li>
</ul>
<blockquote class="blockquote">
<p>이러한 한계로 인해 더 유연하고 자동화된 방법론이 필요하게 되었다.</p>
</blockquote>
</section>
</section>
<section id="statistics-key-concepts" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="statistics-key-concepts"><span class="header-section-number">3</span> Statistics: Key Concepts</h2>
<section id="중심극한정리-central-limit-theorem" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="중심극한정리-central-limit-theorem"><span class="header-section-number">3.1</span> 중심극한정리 (Central Limit Theorem)</h3>
<p>중심극한정리는 확률론과 통계학의 핵심 개념이다. 모집단에서 충분히 큰 표본을 추출하면, 원래 모집단의 분포 형태와 무관하게 표본 평균들의 분포는 근사적으로 정규분포를 따른다는 정리다.</p>
<p>더 쉽게 말하면, 표본 크기가 증가할수록 표본 평균은 모집단 평균을 더 정확하게 대표하게 되며, 표본 평균들의 분포는 종 모양의 대칭적인 정규분포에 가까워진다는 것이다.</p>
<p>중심극한정리가 중요한 이유는 모집단 분포의 정확한 형태를 모르더라도 표본을 기반으로 모집단에 대한 통계적 추론을 할 수 있게 해주기 때문이다. 또한 많은 통계 검정과 모델에서 사용되는 핵심 모수인 표본 평균과 표준편차의 행동을 이해하는 데 도움을 준다.</p>
<section id="예시" class="level4" data-number="3.1.1">
<h4 data-number="3.1.1" class="anchored" data-anchor-id="예시"><span class="header-section-number">3.1.1</span> 예시</h4>
<p><strong>예시 1: 모집단의 평균 체중</strong></p>
<p>한 국가의 모든 사람의 평균 체중을 알고 싶다고 가정하자. 모든 사람의 체중을 측정하는 것은 비현실적이므로, 1000명의 표본을 추출한다. 중심극한정리에 따르면 크기 1000인 표본을 충분히 많이(30개 이상) 추출하면, 이 표본들의 평균은 정규분포를 따른다. 이를 통해 우리의 표본 평균을 기반으로 모집단 평균에 대한 추론을 할 수 있다.</p>
<p><strong>예시 2: 품질 관리</strong></p>
<p>공장에서 대량의 동일한 제품을 생산하며, 각 제품의 무게는 평균 500그램, 표준편차 10그램의 정규분포를 따른다고 가정하자. 공장은 100개 제품 배치의 평균 무게가 498그램에서 502그램 사이에 있는지를 95% 신뢰수준으로 확인하고자 한다.</p>
<p>중심극한정리를 사용하여 모집단에서 100개 제품의 무작위 표본을 추출하고, 각 표본의 평균 무게를 계산하여 평균들의 표본분포를 만들 수 있다. 표본 크기가 충분히 크므로(n &gt; 30), 중심극한정리에 따르면 평균들의 표본분포는 평균 500그램, 표준편차 1그램(모집단 표준편차를 표본 크기의 제곱근으로 나눈 값)의 근사적 정규분포를 따른다.</p>
<p>이 정보를 사용하여 100개 제품 배치의 평균 무게가 원하는 범위 내에 있을 확률을 계산할 수 있다. 표준정규분포표나 소프트웨어를 사용하여 범위의 각 끝점(498과 502)에 대한 z-점수를 찾고, 무작위로 선택된 100개 제품 표본의 평균 무게가 이 범위 내에 있을 확률을 계산한다. 확률이 최소 95%라면, 공장의 품질 관리 기준이 충족된다고 결론지을 수 있다.</p>
</section>
</section>
<section id="표본추출-sampling" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="표본추출-sampling"><span class="header-section-number">3.2</span> 표본추출 (Sampling)</h3>
<p>표본추출의 목적은 더 큰 모집단에 대한 추론이나 결론을 도출하는 데 사용할 수 있는 대표적인 부분집합을 얻는 것이다.</p>
<section id="확률적-표본추출-probabilistic-sampling" class="level4" data-number="3.2.1">
<h4 data-number="3.2.1" class="anchored" data-anchor-id="확률적-표본추출-probabilistic-sampling"><span class="header-section-number">3.2.1</span> 확률적 표본추출 (Probabilistic Sampling)</h4>
<ul>
<li><strong>단순 무작위 추출 (Simple Random Sampling)</strong>: 모집단의 각 개인이나 단위가 표본으로 선택될 동등한 기회를 갖는다. 보통 난수 생성기나 난수표를 사용한다.</li>
<li><strong>층화 추출 (Stratified Sampling)</strong>: 모집단을 특성(연령, 성별, 지리적 위치 등)에 따라 하위 그룹(층)으로 나누고, 각 층에서 무작위 표본을 선택한다. 이는 관심 특성과 관련하여 표본이 모집단을 대표하도록 보장한다.</li>
<li><strong>집락 추출 (Cluster Sampling)</strong>: 모집단을 가구나 학교 같은 집락으로 나누고, 조사할 집락의 무작위 표본을 선택한다. 선택된 각 집락 내의 모든 개인이나 단위를 조사한다.</li>
<li><strong>계통 추출 (Systematic Sampling)</strong>: 모집단에서 무작위 시작점을 선택하고, n번째마다 개인이나 단위를 선택한다. 여기서 n은 미리 정해진 간격이다.</li>
</ul>
</section>
<section id="비확률적-표본추출-non-probabilistic-sampling" class="level4" data-number="3.2.2">
<h4 data-number="3.2.2" class="anchored" data-anchor-id="비확률적-표본추출-non-probabilistic-sampling"><span class="header-section-number">3.2.2</span> 비확률적 표본추출 (Non-Probabilistic Sampling)</h4>
<ul>
<li><strong>편의 추출 (Convenience Sampling)</strong>: 공식적인 표본추출 기법보다는 편의성이나 이용 가능성에 기반하여 개인이나 단위를 선택한다. 편리하지만 편향된 결과를 초래할 수 있으며 연구 목적으로는 일반적으로 권장되지 않는다.</li>
<li><strong>눈덩이 추출 (Snowball Sampling)</strong>: 접근하기 어렵거나 제한적인 모집단을 연구할 때 주로 사용된다. 특정 기준을 충족하는 작은 그룹으로 시작하여, 그들이 동일한 기준을 충족하는 다른 개인을 추천하게 한다. 원하는 표본 크기에 도달할 때까지 이 과정을 계속한다.</li>
</ul>
</section>
</section>
<section id="제1종-오류-vs-제2종-오류-type-i-vs-type-ii-error" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="제1종-오류-vs-제2종-오류-type-i-vs-type-ii-error"><span class="header-section-number">3.3</span> 제1종 오류 vs 제2종 오류 (Type I vs Type II Error)</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 31%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">진실</th>
<th style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?H_%7Bnull%7D"> 기각</th>
<th style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?H_%7Bnull%7D"> 기각 실패</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?H_%7Bnull%7D"> = 참</td>
<td style="text-align: center;">제1종 오류, <img src="https://latex.codecogs.com/png.latex?%5Calpha">, 거짓 양성</td>
<td style="text-align: center;">올바른 결정 (1 - <img src="https://latex.codecogs.com/png.latex?%5Calpha">), 참 음성</td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="https://latex.codecogs.com/png.latex?H_%7Bnull%7D"> = 거짓</td>
<td style="text-align: center;">올바른 결정 (검정력, 1-<img src="https://latex.codecogs.com/png.latex?%5Cbeta">), 참 양성</td>
<td style="text-align: center;">제2종 오류, <img src="https://latex.codecogs.com/png.latex?%5Cbeta">, 거짓 음성</td>
</tr>
</tbody>
</table>
<p>가설 검정에서 제1종 오류는 실제로 참인 귀무가설을 기각할 때 발생한다. 즉, 실제로는 유의한 효과나 차이가 없는데 있다고 결론 내리는 것이다. 이 오류는 거짓 양성(false positive)이라고도 한다.</p>
<p>반면, 제2종 오류는 실제로 거짓인 귀무가설을 기각하지 못할 때 발생한다. 즉, 실제로는 유의한 효과나 차이가 있는데 없다고 결론 내리는 것이다. 이 오류는 거짓 음성(false negative)이라고도 한다.</p>
</section>
<section id="선형회귀-linear-regression" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="선형회귀-linear-regression"><span class="header-section-number">3.4</span> 선형회귀 (Linear Regression)</h3>
<p>선형회귀는 종속변수(반응변수)와 하나 이상의 독립변수(예측변수 또는 설명변수) 간의 관계를 모델링하는 데 사용되는 통계 기법이다. 선형회귀의 목표는 종속변수의 값을 예측하는 데 사용할 수 있는 종속변수와 독립변수 간의 최적의 선형 관계를 찾는 것이다.</p>
<p>선형회귀에서 p-value, 계수, R-squared 값은 모델의 통계적 유의성과 예측력을 평가하는 데 도움이 되는 중요한 구성요소다:</p>
<p><strong>P-value</strong>: p-value는 귀무가설이 참이라고 가정할 때, 관찰된 것만큼 극단적인 결과를 얻을 확률을 측정한다. 선형회귀의 맥락에서 귀무가설은 독립변수의 계수가 0이라는 것, 즉 독립변수와 종속변수 간에 선형 관계가 없다는 것이다. 낮은 p-value(일반적으로 0.05 미만)는 독립변수와 종속변수 간의 관계가 통계적으로 유의하며, 귀무가설을 기각할 수 있음을 나타낸다.</p>
<p><strong>계수 (Coefficient)</strong>: 계수는 독립변수와 종속변수 간의 선형 관계를 나타내는 직선의 기울기다. 다른 모든 변수를 일정하게 유지하면서, 독립변수의 한 단위 변화로 인한 종속변수의 변화량을 측정한다. 양의 계수는 독립변수와 종속변수 간의 양의 관계를 나타내고, 음의 계수는 음의 관계를 나타낸다.</p>
<p><strong>R-squared 값</strong>: R-squared 값은 독립변수의 변동으로 설명되는 종속변수의 변동 비율을 측정한다. 모델의 적합도를 나타내는 척도이며, 0에서 1 사이의 값을 갖는다. 높은 R-squared 값은 모델이 종속변수의 변동 중 큰 비율을 설명하며, 종속변수의 좋은 예측변수임을 나타낸다.</p>
<p>선형회귀에서 각 구성요소의 중요성: - <strong>P-value</strong>: 독립변수와 종속변수 간의 관계가 통계적으로 유의한지, 모델을 유효한 예측에 사용할 수 있는지 판단하는 데 도움을 준다. - <strong>계수</strong>: 독립변수와 종속변수 간 선형 관계의 방향과 강도를 결정하고, 독립변수의 변화에 따른 종속변수 예측을 수행하는 데 도움을 준다. - <strong>R-squared 값</strong>: 모델의 전반적인 적합도를 평가하고, 여러 모델을 비교하여 종속변수의 최적 예측변수를 결정하는 데 도움을 준다.</p>
</section>
<section id="선택-편향-selection-bias" class="level3" data-number="3.5">
<h3 data-number="3.5" class="anchored" data-anchor-id="선택-편향-selection-bias"><span class="header-section-number">3.5</span> 선택 편향 (Selection Bias)</h3>
<p>선택 편향은 연구나 분석에 참여할 개인이나 그룹을 선택하는 과정이 무작위적이지 않거나 관심 모집단을 대표하지 못할 때 발생하는 편향의 한 유형이다. 선택 편향은 모집단 모수의 편향된 추정을 초래하고 연구의 내적 및 외적 타당도에 영향을 미칠 수 있다.</p>
<p>선택 편향은 연구나 분석의 다양한 단계에서 발생할 수 있다:</p>
<p><strong>표본추출 편향 (Sampling bias)</strong>: 표본이 관심 모집단을 대표하지 못할 때 발생한다. 예를 들어, 질병 유병률에 대한 연구가 특정 인구통계학적 또는 지리적 지역의 참가자만 포함한다면, 결과를 전체 모집단에 일반화할 수 없다.</p>
<p><strong>무응답 편향 (Non-response bias)</strong>: 응답률이 낮거나, 참여를 거부한 참가자가 참여에 동의한 참가자와 다를 때 발생한다. 이는 대표성 없는 표본과 편향된 추정으로 이어질 수 있다.</p>
<p><strong>생존 편향 (Survivorship bias)</strong>: 표본이 추적 연구와 같은 특정 선택 과정을 거쳐 생존하거나 지속된 개인이나 그룹만 포함할 때 발생한다. 이는 생존율이나 다른 결과의 과대평가로 이어질 수 있다.</p>
<p><strong>버크슨 편향 (Berkson’s bias)</strong>: 표본이 노출이나 관심 결과와 관련된 조건에 기반하여 선택될 때 발생한다. 예를 들어 병원 기반 표본의 경우다. 이는 노출과 결과 간 연관성의 과소평가로 이어질 수 있다.</p>
<p>선택 편향은 무작위 표본추출 기법을 사용하고 표본이 관심 모집단을 대표하도록 보장함으로써 최소화할 수 있다. 또한 결과가 올바르게 해석되도록 연구의 잠재적 편향과 한계를 분석하고 보고하는 것이 중요하다.</p>
</section>
</section>
<section id="data-science-bridging-statistics-and-computation" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="data-science-bridging-statistics-and-computation"><span class="header-section-number">4</span> Data Science: Bridging Statistics and Computation</h2>
<p>통계학의 한계를 극복하기 위해 등장한 데이터 과학은 통계적 방법론에 컴퓨터 과학의 계산 능력을 결합하여 더 큰 규모와 복잡도의 데이터를 다룰 수 있게 한다.</p>
<section id="핵심-강점-1" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="핵심-강점-1"><span class="header-section-number">4.1</span> 핵심 강점</h3>
<ul>
<li><strong>대규모 데이터 처리</strong>: 분산 컴퓨팅과 병렬 처리로 빅데이터 분석 가능</li>
<li><strong>실용적 접근</strong>: 통계적 가정을 완벽히 만족하지 않아도 유용한 인사이트 도출</li>
<li><strong>End-to-End 파이프라인</strong>: 데이터 수집, 전처리, 분석, 시각화, 배포까지 전체 과정 포괄</li>
<li><strong>도메인 지식 통합</strong>: 비즈니스 문제를 이해하고 실제 가치 창출에 집중</li>
<li><strong>다양한 도구 활용</strong>: Python, R, SQL, Hadoop, Spark 등 다양한 기술 스택</li>
</ul>
</section>
<section id="데이터-과학의-정의" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="데이터-과학의-정의"><span class="header-section-number">4.2</span> 데이터 과학의 정의</h3>
<p>데이터 과학은 통계적, 계산적, 도메인 특화 지식과 기법을 사용하여 데이터로부터 인사이트와 지식을 추출하는 학제간 분야다. 통계학, 컴퓨터 과학, 수학, 도메인 지식의 방법과 개념을 결합하여 복잡한 데이터 관련 문제를 해결한다.</p>
<p>통계학과 컴퓨터 과학은 데이터 과학의 두 가지 중요한 구성요소다. 통계학은 데이터 분석과 모델링을 위한 기초적인 방법을 제공하고, 컴퓨터 과학은 데이터 저장, 처리, 분석을 위한 계산 인프라와 도구를 제공한다. 또한 컴퓨터 과학은 대규모 데이터셋에서 인사이트와 지식을 추출하는 데 사용할 수 있는 데이터 시각화, 머신러닝, 인공지능 기법을 제공한다.</p>
<p>데이터 과학은 데이터 수집, 정제 및 전처리, 탐색적 데이터 분석, 모델링 및 예측, 데이터 시각화, 결과 커뮤니케이션 등 광범위한 활동을 포함한다. 통계학, 프로그래밍, 도메인 지식에 대한 탄탄한 기초와 데이터 관리, 데이터 시각화, 머신러닝에 대한 전문 지식이 필요하다.</p>
</section>
<section id="여전히-남는-한계" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="여전히-남는-한계"><span class="header-section-number">4.3</span> 여전히 남는 한계</h3>
<ul>
<li><strong>모델 선택의 어려움</strong>: 어떤 모델을 사용할지 여전히 전문가의 판단 필요</li>
<li><strong>특성 공학 부담</strong>: 좋은 특성을 설계하는 것이 성능에 결정적이지만 시간 소모적</li>
<li><strong>해석과 예측의 트레이드오프</strong>: 복잡한 모델은 정확하지만 해석하기 어려움</li>
<li><strong>수동 하이퍼파라미터 튜닝</strong>: 모델 성능 최적화를 위한 반복적 실험 필요</li>
</ul>
<blockquote class="blockquote">
<p><strong>이러한 한계를 극복하기 위해 데이터로부터 자동으로 학습하는 머신러닝이 발전했다.</strong></p>
</blockquote>
</section>
</section>
<section id="machine-learning-learning-patterns-from-data" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="machine-learning-learning-patterns-from-data"><span class="header-section-number">5</span> Machine Learning: Learning Patterns from Data</h2>
<p>머신러닝은 명시적으로 프로그래밍하지 않고도 데이터에서 패턴을 자동으로 학습하여 예측과 의사결정을 수행한다.</p>
<section id="핵심-강점-2" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="핵심-강점-2"><span class="header-section-number">5.1</span> 핵심 강점</h3>
<ul>
<li><strong>자동 패턴 학습</strong>: 데이터에서 스스로 규칙과 패턴을 발견</li>
<li><strong>비선형 모델링</strong>: 복잡한 비선형 관계도 효과적으로 포착</li>
<li><strong>고차원 데이터 처리</strong>: 수천, 수만 개의 특성도 처리 가능</li>
<li><strong>유연한 가정</strong>: 엄격한 통계적 가정 없이도 작동</li>
<li><strong>지속적 개선</strong>: 새로운 데이터로 모델을 계속 업데이트하고 개선</li>
</ul>
</section>
<section id="주요-알고리즘-유형" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="주요-알고리즘-유형"><span class="header-section-number">5.2</span> 주요 알고리즘 유형</h3>
<ul>
<li><strong>Supervised Learning</strong>: 입력과 정답 쌍으로 학습 (회귀, 분류)
<ul>
<li>Linear/Logistic Regression, Decision Trees, Random Forest, SVM, Gradient Boosting</li>
</ul></li>
<li><strong>Unsupervised Learning</strong>: 정답 없이 데이터 구조 발견 (군집화, 차원축소)
<ul>
<li>K-Means, Hierarchical Clustering, PCA, t-SNE</li>
</ul></li>
<li><strong>Ensemble Methods</strong>: 여러 모델을 결합하여 성능 향상
<ul>
<li>Bagging, Boosting, Stacking</li>
</ul></li>
</ul>
</section>
<section id="한계" class="level3" data-number="5.3">
<h3 data-number="5.3" class="anchored" data-anchor-id="한계"><span class="header-section-number">5.3</span> 한계</h3>
<ul>
<li><strong>대량의 데이터 필요</strong>: 좋은 성능을 위해 많은 학습 데이터 필요</li>
<li><strong>특성 공학 여전히 중요</strong>: 좋은 특성 설계가 성능에 큰 영향</li>
<li><strong>해석 가능성 낮음</strong>: 특히 앙상블 모델은 블랙박스처럼 작동</li>
<li><strong>비정형 데이터 처리 한계</strong>: 이미지, 음성, 텍스트 같은 원시 데이터에는 수동 전처리 필요</li>
</ul>
<blockquote class="blockquote">
<p><strong>특히 비정형 데이터 처리와 자동 특성 추출을 위해 딥러닝이 등장했다.</strong></p>
</blockquote>
</section>
</section>
<section id="deep-learning-hierarchical-representation-learning" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="deep-learning-hierarchical-representation-learning"><span class="header-section-number">6</span> Deep Learning: Hierarchical Representation Learning</h2>
<p>딥러닝은 다층 신경망을 통해 데이터의 계층적 표현을 자동으로 학습하며, 특히 비정형 데이터에서 혁신적인 성능을 달성했다.</p>
<section id="핵심-강점-3" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="핵심-강점-3"><span class="header-section-number">6.1</span> 핵심 강점</h3>
<ul>
<li><strong>자동 특성 추출</strong>: 원시 데이터에서 자동으로 유용한 특성 학습</li>
<li><strong>계층적 표현</strong>: 저수준 특성에서 고수준 추상 개념까지 단계적 학습</li>
<li><strong>비정형 데이터 탁월</strong>: 이미지, 음성, 텍스트 처리에서 인간 수준 성능</li>
<li><strong>End-to-End 학습</strong>: 전처리에서 예측까지 하나의 통합 모델로 학습</li>
<li><strong>전이 학습</strong>: 한 작업에서 학습한 지식을 다른 작업에 재사용</li>
</ul>
</section>
<section id="주요-아키텍처" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="주요-아키텍처"><span class="header-section-number">6.2</span> 주요 아키텍처</h3>
<ul>
<li><strong>Convolutional Neural Networks (CNN)</strong>: 이미지 처리, 공간적 패턴 인식</li>
<li><strong>Recurrent Neural Networks (RNN/LSTM/GRU)</strong>: 시계열, 자연어 처리</li>
<li><strong>Transformer</strong>: 자연어 이해, 번역, 생성 (BERT, GPT)</li>
<li><strong>Generative Models</strong>: GAN, VAE - 새로운 데이터 생성</li>
<li><strong>Graph Neural Networks</strong>: 그래프 구조 데이터 처리</li>
</ul>
</section>
<section id="한계-1" class="level3" data-number="6.3">
<h3 data-number="6.3" class="anchored" data-anchor-id="한계-1"><span class="header-section-number">6.3</span> 한계</h3>
<ul>
<li><strong>막대한 데이터 요구</strong>: 수백만~수십억 개의 샘플 필요</li>
<li><strong>계산 자원 집약적</strong>: 강력한 GPU/TPU와 많은 전력 소비</li>
<li><strong>블랙박스 특성</strong>: 왜 그런 예측을 했는지 설명하기 매우 어려움</li>
<li><strong>과적합 위험</strong>: 모델이 너무 복잡하면 훈련 데이터에만 과도하게 맞춰짐</li>
<li><strong>하이퍼파라미터 민감</strong>: 학습률, 배치 크기 등 설정에 따라 성능 크게 변동</li>
</ul>
<blockquote class="blockquote">
<p><strong>딥러닝의 성능을 더욱 발전시키고 추론, 계획 등 고차원 인지 능력을 구현하기 위해 현대 AI가 발전하고 있다.</strong></p>
</blockquote>
</section>
</section>
<section id="artificial-intelligence-towards-human-like-intelligence" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="artificial-intelligence-towards-human-like-intelligence"><span class="header-section-number">7</span> Artificial Intelligence: Towards Human-like Intelligence</h2>
<p>인공지능은 머신러닝과 딥러닝을 기반으로, 인간의 인지 능력을 모방하고 자율적으로 의사결정을 내릴 수 있는 시스템을 구현한다.</p>
<section id="ai의-발전-단계" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="ai의-발전-단계"><span class="header-section-number">7.1</span> AI의 발전 단계</h3>
<section id="rule-based-systems-expert-systems---초기-ai-1970-80년대" class="level4" data-number="7.1.1">
<h4 data-number="7.1.1" class="anchored" data-anchor-id="rule-based-systems-expert-systems---초기-ai-1970-80년대"><span class="header-section-number">7.1.1</span> Rule-Based Systems (Expert Systems) - 초기 AI (1970-80년대)</h4>
<p>초기 AI는 전문가의 지식을 if-then 규칙으로 명시적으로 코딩하는 방식으로 시작했다.</p>
<p><strong>작동 방식:</strong></p>
<pre><code>IF 환자의 체온 &gt; 38도 AND 기침 = 있음 THEN 감기 가능성 높음
IF 고객의 구매이력 &gt; 10회 AND 최근방문 &lt; 30일 THEN VIP 등급 부여</code></pre>
<p><strong>강점:</strong> - <strong>완전한 제어</strong>: 시스템의 모든 동작을 정확히 예측 가능 - <strong>해석 가능성</strong>: 왜 그런 결론에 도달했는지 명확히 설명 가능 - <strong>도메인 지식 활용</strong>: 전문가의 경험과 지식을 직접 시스템에 반영 - <strong>데이터 불필요</strong>: 학습 데이터 없이도 작동</p>
<p><strong>치명적 한계:</strong> - <strong>확장성 없음</strong>: 규칙이 수백, 수천 개로 늘어나면 관리 불가능 - <strong>규칙 충돌</strong>: 여러 규칙이 상충할 때 해결 방법 불명확 - <strong>예외 처리 어려움</strong>: 모든 상황을 규칙으로 만들 수 없음 - <strong>변화 적응 불가</strong>: 새로운 패턴이나 상황에 자동으로 대응 못함 - <strong>암묵적 지식 표현 한계</strong>: 전문가도 설명 못하는 직관적 판단을 코딩할 수 없음</p>
<p><strong>실패 사례: AI의 겨울</strong></p>
<p>1980년대 후반, 많은 기업이 expert system에 막대한 투자를 했지만 실용성 부족으로 실패했다. 이는 “AI의 겨울”로 이어졌고, 데이터로부터 학습하는 머신러닝 접근법의 필요성을 입증했다.</p>
<blockquote class="blockquote">
<p><strong>규칙을 수동으로 만드는 것의 한계가 명확해지면서, 데이터로부터 자동으로 패턴을 학습하는 머신러닝과 딥러닝이 주류가 되었다.</strong></p>
</blockquote>
</section>
<section id="machine-learning-deep-learning-era-1990-2020년대" class="level4" data-number="7.1.2">
<h4 data-number="7.1.2" class="anchored" data-anchor-id="machine-learning-deep-learning-era-1990-2020년대"><span class="header-section-number">7.1.2</span> Machine Learning &amp; Deep Learning Era (1990-2020년대)</h4>
<p>통계적 학습과 신경망 기반의 머신러닝이 AI의 중심이 되었다. (앞서 Machine Learning과 Deep Learning 섹션 참조)</p>
</section>
<section id="modern-ai-integration-and-emergence-2020년대" class="level4" data-number="7.1.3">
<h4 data-number="7.1.3" class="anchored" data-anchor-id="modern-ai-integration-and-emergence-2020년대"><span class="header-section-number">7.1.3</span> Modern AI: Integration and Emergence (2020년대~)</h4>
<p>현대 AI는 대규모 데이터와 컴퓨팅 파워를 활용하여 인간 수준의 능력을 보이기 시작했다.</p>
</section>
</section>
<section id="핵심-발전-방향" class="level3" data-number="7.2">
<h3 data-number="7.2" class="anchored" data-anchor-id="핵심-발전-방향"><span class="header-section-number">7.2</span> 핵심 발전 방향</h3>
<ul>
<li><strong>Large Language Models (LLMs)</strong>: GPT, Claude 등 대규모 언어 모델
<ul>
<li>자연어 이해, 생성, 추론, 대화</li>
<li>Few-shot/Zero-shot Learning: 적은 예제 또는 예제 없이도 새 작업 수행</li>
</ul></li>
<li><strong>Multimodal AI</strong>: 텍스트, 이미지, 음성을 통합 처리
<ul>
<li>CLIP, GPT-4V 등 여러 모달리티 동시 이해</li>
</ul></li>
<li><strong>Reinforcement Learning</strong>: 환경과 상호작용하며 최적 전략 학습
<ul>
<li>AlphaGo, OpenAI Five - 게임, 로봇 제어</li>
</ul></li>
<li><strong>Explainable AI (XAI)</strong>: 블랙박스 모델의 의사결정 과정 설명
<ul>
<li>SHAP, LIME, Attention Visualization</li>
</ul></li>
<li><strong>AutoML</strong>: 모델 선택과 하이퍼파라미터 튜닝 자동화</li>
</ul>
</section>
<section id="ai의-현재와-미래" class="level3" data-number="7.3">
<h3 data-number="7.3" class="anchored" data-anchor-id="ai의-현재와-미래"><span class="header-section-number">7.3</span> AI의 현재와 미래</h3>
<ul>
<li><strong>현재 달성한 것</strong>:
<ul>
<li>이미지 분류, 객체 인식에서 인간 수준 성능</li>
<li>자연어 이해와 생성에서 놀라운 능력</li>
<li>특정 게임과 작업에서 인간 능가</li>
<li>의료 진단, 약물 발견, 과학 연구 지원</li>
</ul></li>
<li><strong>여전히 어려운 것</strong>:
<ul>
<li>상식 추론과 인과관계 이해</li>
<li>소수 샘플로 학습 (Few-shot Learning 개선 필요)</li>
<li>신뢰성과 안전성 보장</li>
<li>편향과 공정성 문제 해결</li>
<li>에너지 효율성 개선</li>
</ul></li>
</ul>
</section>
<section id="ai-윤리와-책임" class="level3" data-number="7.4">
<h3 data-number="7.4" class="anchored" data-anchor-id="ai-윤리와-책임"><span class="header-section-number">7.4</span> AI 윤리와 책임</h3>
<ul>
<li><strong>공정성</strong>: 편향되지 않은 데이터와 알고리즘</li>
<li><strong>투명성</strong>: 의사결정 과정의 설명 가능성</li>
<li><strong>프라이버시</strong>: 개인정보 보호와 데이터 거버넌스</li>
<li><strong>책임성</strong>: AI 시스템의 결정에 대한 책임 소재</li>
</ul>
</section>
</section>
<section id="conclusion-the-continuous-evolution" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="conclusion-the-continuous-evolution"><span class="header-section-number">8</span> Conclusion: The Continuous Evolution</h2>
<p>통계학에서 AI까지의 여정은 각 단계가 이전의 한계를 극복하면서 발전한 자연스러운 진화 과정이다:</p>
<ol type="1">
<li><strong>통계학</strong>: 수학적으로 엄밀하지만 많은 가정과 제약</li>
<li><strong>데이터 과학</strong>: 계산 능력으로 대규모 데이터 처리, 하지만 여전히 수동 작업 많음</li>
<li><strong>머신러닝</strong>: 자동 패턴 학습으로 유연성 확보, 하지만 특성 공학 필요</li>
<li><strong>딥러닝</strong>: 자동 특성 추출로 비정형 데이터 정복, 하지만 해석 어려움</li>
<li><strong>AI 발전</strong>:
<ul>
<li>초기 Rule-based: 완전한 제어와 해석 가능성, 하지만 확장성 없음</li>
<li>현대 Learning-based: 데이터로부터 학습하여 복잡한 패턴 포착, 인간 수준 인지 능력 지향</li>
</ul></li>
</ol>
<p>각 방법론은 서로를 대체하는 것이 아니라 보완하는 관계다. 실제로 많은 현대 AI 시스템은 딥러닝과 규칙 기반 시스템을 결합한다: - <strong>Hybrid Systems</strong>: 딥러닝으로 패턴 학습 + 규칙으로 안전장치와 제약조건 구현 - <strong>Neural-Symbolic AI</strong>: 신경망의 학습 능력 + 기호적 추론의 논리성</p>
<p>문제의 특성, 데이터의 양과 질, 해석 가능성의 중요도, 계산 자원, 안전성 요구사항 등을 고려하여 적절한 방법을 선택하고 결합하는 것이 중요하다.</p>
<p>미래의 데이터 과학자와 AI 연구자는 이 모든 단계를 이해하고, 각각의 강점과 한계를 파악하여, 실제 문제에 가장 적합한 접근법을 선택할 수 있어야 한다.</p>
</section>
<section id="문제-정의-모델-선택-역량" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="문제-정의-모델-선택-역량"><span class="header-section-number">9</span> 문제 정의 &amp; 모델 선택 역량</h2>
<section id="비즈니스-문제-분석" class="level3" data-number="9.1">
<h3 data-number="9.1" class="anchored" data-anchor-id="비즈니스-문제-분석"><span class="header-section-number">9.1</span> 비즈니스 문제 분석</h3>
<ul>
<li>문제 유형 분류 (분류/회귀/생성/검색/최적화)</li>
<li>ROI 계산 및 성공 지표 정의</li>
<li>데이터 가용성 vs 모델 요구사항 분석</li>
<li>기술적 제약사항 파악 (지연시간, 정확도, 비용)</li>
</ul>
</section>
<section id="모델-생태계-이해" class="level3" data-number="9.2">
<h3 data-number="9.2" class="anchored" data-anchor-id="모델-생태계-이해"><span class="header-section-number">9.2</span> 모델 생태계 이해</h3>
<ul>
<li>Hugging Face Hub 활용: 모델 탐색, 벤치마크 해석</li>
<li>Foundation Models 맵핑: GPT-4, Claude, Llama, Mistral 등 특성</li>
<li>Computer Vision: CLIP, SAM, YOLO, ViT 계열</li>
<li>테이블형 데이터: AutoML vs 전통 ML 판단 기준</li>
</ul>
</section>
<section id="모델-성능-평가" class="level3" data-number="9.3">
<h3 data-number="9.3" class="anchored" data-anchor-id="모델-성능-평가"><span class="header-section-number">9.3</span> 모델 성능 평가</h3>
<ul>
<li>벤치마크 해석 (BLEU, ROUGE, MMLU, HellaSwag 등)</li>
<li>도메인별 평가 지표 설계</li>
<li>A/B 테스트 설계 원칙</li>
<li>비용-성능 트레이드오프 분석</li>
</ul>
</section>
</section>
<section id="fine-tuning-api-활용---langchain" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="fine-tuning-api-활용---langchain"><span class="header-section-number">10</span> Fine-tuning &amp; API 활용 - LangChain</h2>
<section id="llm-fine-tuning-전략" class="level3" data-number="10.1">
<h3 data-number="10.1" class="anchored" data-anchor-id="llm-fine-tuning-전략"><span class="header-section-number">10.1</span> LLM Fine-tuning 전략</h3>
<ul>
<li>Parameter-Efficient Fine-tuning: LoRA, QLoRA, Adapter</li>
<li>Instruction Tuning: 태스크별 프롬프트 데이터셋 구축</li>
<li>RLHF 개념: 인간 피드백 활용 방법론</li>
<li>도메인 적응: 의료, 법률, 금융 등 특화 모델 구축</li>
</ul>
</section>
<section id="api-활용-및-최적화" class="level3" data-number="10.2">
<h3 data-number="10.2" class="anchored" data-anchor-id="api-활용-및-최적화"><span class="header-section-number">10.2</span> API 활용 및 최적화</h3>
<ul>
<li>OpenAI API: GPT-4, Fine-tuning, Assistants API</li>
<li>Anthropic Claude: Constitutional AI, Function Calling</li>
<li>오픈소스 API: Ollama, vLLM, Text Generation Inference</li>
<li>멀티모달 API: GPT-4V, Claude-3, Gemini 활용</li>
</ul>
</section>
<section id="프롬프트-엔지니어링" class="level3" data-number="10.3">
<h3 data-number="10.3" class="anchored" data-anchor-id="프롬프트-엔지니어링"><span class="header-section-number">10.3</span> 프롬프트 엔지니어링</h3>
<ul>
<li>Few-shot Learning 전략</li>
<li>Chain-of-Thought, Tree-of-Thought</li>
<li>프롬프트 최적화 도구 (DSPy, Guidance)</li>
<li>프롬프트 보안 (Jailbreaking 방지)</li>
</ul>
</section>
</section>
<section id="시스템-통합-아키텍처---langchain" class="level2" data-number="11">
<h2 data-number="11" class="anchored" data-anchor-id="시스템-통합-아키텍처---langchain"><span class="header-section-number">11</span> 시스템 통합 &amp; 아키텍처 - LangChain</h2>
<section id="ai-애플리케이션-아키텍처" class="level3" data-number="11.1">
<h3 data-number="11.1" class="anchored" data-anchor-id="ai-애플리케이션-아키텍처"><span class="header-section-number">11.1</span> AI 애플리케이션 아키텍처</h3>
<ul>
<li>RAG 시스템 설계: Vector DB, Embedding, Retrieval 전략</li>
<li>Agent Framework: LangChain, CrewAI, AutoGen</li>
<li>워크플로우 엔진: 복잡한 AI 태스크 체이닝</li>
<li>멀티모달 파이프라인: 텍스트+이미지+음성 통합</li>
</ul>
</section>
<section id="벡터-데이터베이스-검색" class="level3" data-number="11.2">
<h3 data-number="11.2" class="anchored" data-anchor-id="벡터-데이터베이스-검색"><span class="header-section-number">11.2</span> 벡터 데이터베이스 &amp; 검색</h3>
<ul>
<li>Vector DB: Pinecone, Weaviate, Chroma, FAISS</li>
<li>Embedding 전략: 텍스트, 이미지, 코드 임베딩</li>
<li>하이브리드 검색: 키워드 + 시맨틱 검색 결합</li>
<li>검색 성능 최적화: 인덱싱, 캐싱 전략</li>
</ul>
</section>
<section id="모델-서빙-인프라" class="level3" data-number="11.3">
<h3 data-number="11.3" class="anchored" data-anchor-id="모델-서빙-인프라"><span class="header-section-number">11.3</span> 모델 서빙 &amp; 인프라</h3>
<ul>
<li>모델 서빙: TorchServe, TensorFlow Serving, vLLM</li>
<li>로드 밸런싱: 모델별 트래픽 분산</li>
<li>캐싱 전략: 응답 캐시, 임베딩 캐시</li>
<li>비용 최적화: GPU 사용량, API 호출 최적화</li>
</ul>
</section>
</section>
<section id="운영-mlops---langchain" class="level2" data-number="12">
<h2 data-number="12" class="anchored" data-anchor-id="운영-mlops---langchain"><span class="header-section-number">12</span> 운영 &amp; MLOps - LangChain</h2>
<section id="모델-모니터링" class="level3" data-number="12.1">
<h3 data-number="12.1" class="anchored" data-anchor-id="모델-모니터링"><span class="header-section-number">12.1</span> 모델 모니터링</h3>
<ul>
<li>성능 드리프트: 입력 분포 변화 감지</li>
<li>출력 품질 모니터링: 응답 길이, 독성 탐지, 할루시네이션</li>
<li>사용자 피드백: 만족도, 정확도 추적</li>
<li>비용 모니터링: 토큰 사용량, API 비용 추적</li>
</ul>
</section>
<section id="ab-테스트-실험" class="level3" data-number="12.2">
<h3 data-number="12.2" class="anchored" data-anchor-id="ab-테스트-실험"><span class="header-section-number">12.2</span> A/B 테스트 &amp; 실험</h3>
<ul>
<li>모델 비교: 다양한 모델/프롬프트 성능 비교</li>
<li>점진적 롤아웃: Canary 배포, Blue-Green 배포</li>
<li>실험 설계: 통계적 유의성, 표본 크기 계산</li>
<li>결과 분석: 비즈니스 메트릭 vs 기술 메트릭</li>
</ul>
</section>
<section id="거버넌스-윤리" class="level3" data-number="12.3">
<h3 data-number="12.3" class="anchored" data-anchor-id="거버넌스-윤리"><span class="header-section-number">12.3</span> 거버넌스 &amp; 윤리</h3>
<ul>
<li>AI 안전성: Content Filtering, Bias 탐지</li>
<li>데이터 프라이버시: PII 마스킹, GDPR 준수</li>
<li>모델 해석성: LIME, SHAP 등 설명 가능 AI</li>
<li>규제 준수: AI Act, 금융/의료 규제 대응</li>
</ul>
</section>
</section>
<section id="고급-통합-자동화---langchain-일부-커버" class="level2" data-number="13">
<h2 data-number="13" class="anchored" data-anchor-id="고급-통합-자동화---langchain-일부-커버"><span class="header-section-number">13</span> 고급 통합 &amp; 자동화 - LangChain 일부 커버</h2>
<section id="automl-모델-자동화" class="level3" data-number="13.1">
<h3 data-number="13.1" class="anchored" data-anchor-id="automl-모델-자동화"><span class="header-section-number">13.1</span> AutoML &amp; 모델 자동화</h3>
<ul>
<li>AutoML 플랫폼: H2O.ai, DataRobot, AutoGluon</li>
<li>하이퍼파라미터 최적화: Optuna, Ray Tune</li>
<li>뉴럴 아키텍처 서치: 모델 구조 자동 탐색</li>
<li>모델 압축: Pruning, Quantization, Distillation</li>
</ul>
</section>
<section id="고급-ai-패턴" class="level3" data-number="13.2">
<h3 data-number="13.2" class="anchored" data-anchor-id="고급-ai-패턴"><span class="header-section-number">13.2</span> 고급 AI 패턴</h3>
<ul>
<li>Multi-Agent Systems: 협업하는 AI 에이전트</li>
<li>Tool-Using AI: 외부 도구/API 활용하는 AI</li>
<li>Self-Improving Systems: 피드백 기반 자동 개선</li>
<li>Federated Learning: 분산 학습 시스템</li>
</ul>
</section>
</section>
<section id="실습-프로젝트-로드맵" class="level2" data-number="14">
<h2 data-number="14" class="anchored" data-anchor-id="실습-프로젝트-로드맵"><span class="header-section-number">14</span> 실습 프로젝트 로드맵</h2>
<section id="초급" class="level3" data-number="14.1">
<h3 data-number="14.1" class="anchored" data-anchor-id="초급"><span class="header-section-number">14.1</span> 초급</h3>
<ol type="1">
<li><strong>문서 QA 시스템</strong>: RAG + OpenAI API</li>
<li><strong>이미지 분류 API</strong>: Pre-trained Vision 모델 + FastAPI</li>
</ol>
</section>
<section id="중급" class="level3" data-number="14.2">
<h3 data-number="14.2" class="anchored" data-anchor-id="중급"><span class="header-section-number">14.2</span> 중급</h3>
<ol start="3" type="1">
<li><strong>커스텀 챗봇</strong>: Fine-tuned LLM + 벡터DB</li>
<li><strong>멀티모달 검색</strong>: 텍스트+이미지 통합 검색</li>
</ol>
</section>
<section id="고급" class="level3" data-number="14.3">
<h3 data-number="14.3" class="anchored" data-anchor-id="고급"><span class="header-section-number">14.3</span> 고급</h3>
<ol start="5" type="1">
<li><strong>AI 에이전트 시스템</strong>: 복잡한 태스크 자동화</li>
<li><strong>A/B 테스트 플랫폼</strong>: 모델 성능 비교 시스템</li>
</ol>


</section>
</section>

 ]]></description>
  <category>Data Science</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Data_Science/</guid>
  <pubDate>Sat, 31 May 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>RAG과 LangChain 소개</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/RAG/00-Intro/1.intro_rag.html</link>
  <description><![CDATA[ 





<section id="rag-소개" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> RAG 소개</h1>
<section id="rag이란" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="rag이란"><span class="header-section-number">1.1</span> RAG이란?</h2>
<ul>
<li>Retrieve = “검색하다”, “가져오다”, “찾아오다”, <strong>검색하여 찾아오다</strong> 라고 이해하면 된다. IT 분야에선 대충 아래와 같은 의미를 갖는다.
<ul>
<li>데이터 검색: 데이터베이스에서 정보를 찾아오다</li>
<li>파일 복구: 삭제된 파일을 되살리다</li>
<li>정보 추출: 시스템에서 필요한 정보를 가져오다</li>
</ul></li>
<li>RAG(Retrieval-Augmented Generation)는 <strong>검색 증강 생성</strong> 기술로, 대규모 언어 모델(LLM)의 생성 능력과 외부 지식 검색을 결합한 AI 기술이다.
<ul>
<li>검색(Retrieval): 질문과 관련된 정보를 외부 데이터베이스나 문서에서 검색</li>
<li>증강(Augmented): 검색된 정보를 LLM의 입력에 추가하여 컨텍스트 (또는 문맥) 강화</li>
<li>생성(Generation): 증강된 정보를 바탕으로 더 정확하고 근거 있는 답변 생성</li>
</ul></li>
</ul>
</section>
<section id="왜-rag가-필요한가" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="왜-rag가-필요한가"><span class="header-section-number">1.2</span> 왜 RAG가 필요한가?</h2>
<section id="chat-gpt-도래-및-성공" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="chat-gpt-도래-및-성공"><span class="header-section-number">1.2.1</span> Chat GPT 도래 및 성공</h3>
<ul>
<li><strong>2022년 11월 출시</strong>: OpenAI ChatGPT 공개 후 폭발적 인기</li>
<li><strong>사용자 급증</strong>: 출시 2개월 만에 1억 사용자 돌파</li>
<li><strong>산업 변화</strong>: AI 기반 대화형 인터페이스의 새로운 표준 제시</li>
<li><strong>기술 혁신</strong>: Transformer 기반 대화형 AI의 상용화 성공</li>
<li><strong>생성형 AI 붐</strong>: GPT 성공으로 생성형 AI 시장 급성장</li>
</ul>
</section>
<section id="chat-gpt의-문제점" class="level3" data-number="1.2.2">
<h3 data-number="1.2.2" class="anchored" data-anchor-id="chat-gpt의-문제점"><span class="header-section-number">1.2.2</span> Chat GPT의 문제점</h3>
<ul>
<li><strong>할루시네이션(Hallucination)</strong>: 그럴듯하지만 잘못된 정보 생성</li>
<li><strong>지식 컷오프</strong>: 학습 데이터 시점 이후 정보 부족</li>
<li><strong>일관성 부족</strong>: 같은 질문에 다른 답변 제공 가능</li>
<li><strong>도메인 특화 한계</strong>: 전문 분야 지식의 정확도 부족</li>
<li><strong>출처 불명</strong>: 답변 근거가 되는 정보 출처 제공 불가</li>
</ul>
</section>
<section id="rag-vs-일반-llm" class="level3" data-number="1.2.3">
<h3 data-number="1.2.3" class="anchored" data-anchor-id="rag-vs-일반-llm"><span class="header-section-number">1.2.3</span> RAG vs 일반 LLM</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>구분</th>
<th>일반 LLM</th>
<th>RAG</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>지식 소스</td>
<td>outdated 학습 데이터만 활용</td>
<td>학습 데이터 + 외부 검색</td>
</tr>
<tr class="even">
<td>정보 업데이트</td>
<td>재학습 필요</td>
<td>문서 추가만으로 가능</td>
</tr>
<tr class="odd">
<td>답변 근거</td>
<td>불명확</td>
<td>검색된 문서 기반</td>
</tr>
<tr class="even">
<td>도메인 특화</td>
<td>제한적</td>
<td>전문 문서 활용 가능</td>
</tr>
<tr class="odd">
<td>할루시네이션</td>
<td>높은 위험</td>
<td>상대적으로 낮음</td>
</tr>
</tbody>
</table>
<ul>
<li>가령, 최근 뉴스 동향에 대한 질문을 하면 검색기능이 없는 일반 LLM은 학습 데이터 시점 이후의 정보를 가지고 있지 않기 때문에 답변을 할 수 없다.</li>
<li>하지만, RAG를 사용하면 최신 정보나 전문적인 내용이 담긴 문서 (또는 텍스트)를 제공해주면 더 구체적이고 최신의 정보를 검색하여 답변을 할 수 있다.</li>
<li>따라서, RAG을 사용하면 아래와 같은 문제를 해결할 수 있다.
<ul>
<li>LLM의 한계 극복: Hallucination 문제 해결 및 학습 데터 시점 이후 정보 부족 문제 해결</li>
<li>실시간 정보 활용: 최신 정보를 동적으로 검색하여 활용</li>
<li>도메인 특화: 특정 분야의 전문 지식 기반 답변 생성</li>
<li>비용 효율성: 전체 모델 재학습 없이 지식 확장 가능</li>
<li>신뢰성 향상: 검색된 문서 기반으로 답변의 근거 제공</li>
<li>근거 기반 답변: 검색된 문서를 바탕으로 답변 생성</li>
<li>일관성 개선: 동일한 문서 소스 기반으로 일관된 답변</li>
<li>출처 추적: 답변에 사용된 문서 출처 명시</li>
</ul></li>
</ul>
</section>
</section>
<section id="rag-적용-방법" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="rag-적용-방법"><span class="header-section-number">1.3</span> RAG 적용 방법</h2>
<p>Chat GPT의 할루시네이션을 줄이고 방대한 지식 기반으로 답변하는 도메인 특화 chatbot 구축 가능</p>
<p>즉, RAG란 chat gpt에게 잘 정제된 데이터를 제공하여 더 정확하고 신뢰할 수 있는 답변을 제공하는 방법이다.</p>
<p><strong>주요 과제들:</strong> - Chat GPT의 RAG 과정은 비공개되어 user가 통제할 수 없는 부분이기 때문에 사용자들은 문서를 chat gpt가 잘 검색할 수 있는 형태로 변경하는 것이 중요 - 어려운 점은 각 문서마다 파일 형식이 다르고 이를 gpt가 처리가능한 형태로 전처리하는 과정이 공수가 많이 들어감 - 고유의 RAG를 만들어줘야 함</p>
<section id="일반-llm-process" class="level3" data-number="1.3.1">
<h3 data-number="1.3.1" class="anchored" data-anchor-id="일반-llm-process"><span class="header-section-number">1.3.1</span> 일반 LLM Process</h3>
<pre><code>사용자 질문 → 프롬프트 → LLM (with Black Box의 RAG 처리과정) → 답변 생성</code></pre>
<ul>
<li>특징
<ul>
<li>통제할수 없는 RAG 구조: 질문을 직접 LLM에 입력하여 자체 Black Box의 RAG 처리과정을 통해 답변 생성</li>
<li>학습 데이터 의존: 검색 대상의 데이터가 모델이 사전에 학습한 데이터</li>
<li>방대한 학습데이터 의존: 너무 방대한 학습 데이터로 질문과 연관된 데이터를 검색하는데 한계가 있음, 전문적이고 디테일한 질문일수록 검색 결과의 질이 떨어짐</li>
<li>정적 지식: 학습 시점 이후의 새로운 정보 반영 불가</li>
<li>제한된 컨텍스트: 입력 토큰 길이 제한으로 긴 문서를 업로드하여 질문하면 긴 문서의 처리가 어려움</li>
<li>할루시네이션 위험: 학습되지 않은 정보에 대해 그럴듯한 거짓 답변 생성 가능</li>
</ul></li>
<li>따라서, RAG은 이 일반 LLM Process에 최신 정보 또는 추가 정보를 제공하여 Context(문맥)을 강화하여 더 정확하고 신뢰할 수 있는 답변을 제공하는 방법이다.</li>
</ul>
</section>
<section id="rag-process" class="level3" data-number="1.3.2">
<h3 data-number="1.3.2" class="anchored" data-anchor-id="rag-process"><span class="header-section-number">1.3.2</span> RAG Process</h3>
<pre><code>query -&gt; RAG(Retriever -&gt; Similiarity Search -&gt; Vector Store (DB) Pre-Processed Chunks-&gt; Most Similar Chunk -&gt; Retriver -&gt; Promptanswer</code></pre>
<ol type="1">
<li>질문 또는 쿼리 입력</li>
<li>Retriever (검색기): 전처리된 Vector Store에서 유사도 검색을 통해 가장 유사한 문서 청크 검색</li>
<li>Pre-Process</li>
<li>document upload</li>
<li>text chunk split: 문서를 검색 가능한 단위로 분할</li>
<li>embedding: 텍스트를 숫자 벡터로 변환</li>
<li>vector store (DB)에 embedding된 벡터를 DB에 저장, 매번 검색할때마다 임베딩을 하면 비용이 증가하기 때문에 벡터 스토어에 저장된 벡터와 쿼리의 벡터를 비교하여 유사도가 높은 벡터를 찾아오는 과정</li>
<li>검색(Retrieval): 보통 유사도 검색으로 코사인 유사도와 같은 방법으로 쿼리와 유사한 문서 청크 검색하여 검색 결과를 찾아오는 과정</li>
<li>prompt engineering: 검색 결과를 포함한 프롬프트 구성</li>
<li>LLM</li>
<li>answer: LLM이 최종 답변 생성</li>
</ol>
<ul>
<li>이 고유의 RAG를 만들어주는 것이 중요하지만 매우 고되고 어려운 과정이다. 내가 구현하려고 하는 답변 기능이 안되는 이유는 정말 수백가지에 달하기 때문이다.</li>
<li>하지만, 분명한건 RAG를 잘 적용하여 원하는 기능을 구현하는 사례들이 많이 나오고 있고 효과적인 방법론들이 존재한다:</li>
<li>고급 RAG 기법들
<ul>
<li>코사인 유사도 최적화: 벡터 검색 정확도 개선</li>
<li>HyDE Retrieval: 가상 문서 생성을 통한 검색 성능 향상</li>
<li>FT Embedding: 도메인 특화 임베딩 모델 파인튜닝</li>
<li>Chunk Embedding 실험: 최적 청킹 전략 탐색</li>
<li>Reranking: 검색 결과 재순위화</li>
<li>Classification Step: 쿼리 유형 분류를 통한 검색 최적화</li>
<li>Prompt Engineering: 효과적인 프롬프트 설계</li>
<li>Tool Use: 외부 도구 활용 확장</li>
<li>Query Expansion: 쿼리 확장 및 개선</li>
</ul></li>
</ul>
</section>
</section>
<section id="rag-구현-난이도" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="rag-구현-난이도"><span class="header-section-number">1.4</span> RAG 구현 난이도</h2>
<p>RAG 구현은 사실상 LLM을 Tuning하는 것과 같다.</p>
<p><strong>LLM Tuning 방법 난이도 비교:</strong> - <strong>Prompt Engineering</strong> (매우 쉬움): 프롬프트만 수정하여 성능 개선 - <strong>RAG</strong> (쉬움): 외부 지식 소스 연결하여 답변 품질 향상 - <strong>PEFT</strong> (어려움): Parameter-Efficient Fine-Tuning 적용 - <strong>Full Fine Tuning</strong> (매우 어려움): 전체 모델 파라미터 재학습</p>
<p><strong>RAG의 장점:</strong> - 상대적으로 구현 난이도가 낮음 - 기존 모델 파라미터 수정 불필요 - 지식 업데이트가 용이함 - 비용 효율적인 성능 개선 방법</p>
</section>
<section id="rag-구현-방법" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="rag-구현-방법"><span class="header-section-number">1.5</span> RAG 구현 방법</h2>
<section id="기본-rag-파이프라인-구축" class="level3" data-number="1.5.1">
<h3 data-number="1.5.1" class="anchored" data-anchor-id="기본-rag-파이프라인-구축"><span class="header-section-number">1.5.1</span> 기본 RAG 파이프라인 구축</h3>
<p><strong>문서 처리:</strong> - 다양한 형식(PDF, DOCX, TXT, HTML) 문서 로딩 - 텍스트 추출 및 전처리 - 의미 있는 단위로 청킹 분할</p>
<p><strong>벡터화 및 저장:</strong> - OpenAI Embeddings 또는 오픈소스 임베딩 모델 사용 - FAISS, Chroma, Pinecone 등 벡터 데이터베이스 구축 - 효율적인 유사도 검색 인덱스 생성</p>
</section>
<section id="검색-시스템-구현" class="level3" data-number="1.5.2">
<h3 data-number="1.5.2" class="anchored" data-anchor-id="검색-시스템-구현"><span class="header-section-number">1.5.2</span> 검색 시스템 구현</h3>
<p><strong>검색 전략:</strong> - 코사인 유사도 기반 벡터 검색 - 키워드 기반 하이브리드 검색 - 의미적 유사도와 키워드 매칭 결합</p>
<p><strong>검색 최적화:</strong> - Top-K 검색 결과 개수 조정 - 검색 임계값(threshold) 설정 - 문서 메타데이터 활용 필터링</p>
</section>
<section id="프롬프트-엔지니어링" class="level3" data-number="1.5.3">
<h3 data-number="1.5.3" class="anchored" data-anchor-id="프롬프트-엔지니어링"><span class="header-section-number">1.5.3</span> 프롬프트 엔지니어링</h3>
<p><strong>프롬프트 구조:</strong> - 시스템 메시지: 역할 및 지침 명시 - 컨텍스트: 검색된 문서 내용 포함 - 질문: 사용자 쿼리 - 답변 형식: 원하는 출력 형태 지정</p>
<p><strong>프롬프트 개선:</strong> - Few-shot 예시 추가 - 체인 오브 생각(Chain of Thought) 적용 - 답변 검증 및 출처 표기 요구</p>
</section>
<section id="평가-및-개선" class="level3" data-number="1.5.4">
<h3 data-number="1.5.4" class="anchored" data-anchor-id="평가-및-개선"><span class="header-section-number">1.5.4</span> 평가 및 개선</h3>
<p><strong>성능 평가:</strong> - 답변 정확도 측정 - 검색 정밀도(Precision) 및 재현율(Recall) - 사용자 만족도 조사</p>
<p><strong>지속적 개선:</strong> - A/B 테스트를 통한 파라미터 최적화 - 사용자 피드백 기반 모델 업데이트 - 새로운 문서 데이터 정기 추가</p>
</section>
</section>
</section>
<section id="lang-chain-소개" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Lang Chain 소개</h1>
<section id="langchain이란" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="langchain이란"><span class="header-section-number">2.1</span> LangChain이란?</h2>
<ul>
<li><strong>정의</strong>: LLM(Large Language Model) 기반 애플리케이션 개발을 위한 오픈소스 프레임워크</li>
<li><strong>주요 목적</strong>: 복잡한 LLM 애플리케이션을 쉽게 구축할 수 있도록 지원</li>
</ul>
</section>
<section id="langchain의-핵심-기능" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="langchain의-핵심-기능"><span class="header-section-number">2.2</span> LangChain의 핵심 기능</h2>
<ul>
<li><strong>체인(Chain)</strong>: 여러 컴포넌트를 연결하여 복잡한 워크플로우 구성</li>
<li><strong>프롬프트 템플릿</strong>: 동적으로 프롬프트 생성 및 관리</li>
<li><strong>메모리</strong>: 대화 히스토리 및 컨텍스트 유지</li>
<li><strong>에이전트</strong>: 도구 사용 및 의사결정 자동화</li>
<li><strong>문서 로더</strong>: 다양한 형식의 문서 처리</li>
<li><strong>벡터 스토어</strong>: 임베딩 기반 검색 시스템</li>
</ul>
</section>
<section id="langchain-사용-사례" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="langchain-사용-사례"><span class="header-section-number">2.3</span> LangChain 사용 사례</h2>
<ul>
<li><strong>챗봇</strong>: 문맥을 이해하는 대화형 AI 시스템</li>
<li><strong>문서 QA</strong>: 문서 기반 질의응답 시스템<br>
</li>
<li><strong>데이터 분석</strong>: 자연어로 데이터 분석 수행</li>
<li><strong>코드 생성</strong>: 자연어 명령으로 코드 자동 생성</li>
<li><strong>RAG 시스템</strong>: 검색 기반 답변 생성 시스템</li>
</ul>


</section>
</section>

 ]]></description>
  <category>RAG</category>
  <guid>kk3225.netlify.app/docs/blog/posts/RAG/00-Intro/1.intro_rag.html</guid>
  <pubDate>Sat, 31 May 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>개발 환경의 숨은 암초, PATH 환경변수 오염</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Engineering/Conda/path_pollution.html</link>
  <description><![CDATA[ 




<section id="들어가며-개발자를-괴롭히는-path-문제" class="level2">
<h2 class="anchored" data-anchor-id="들어가며-개발자를-괴롭히는-path-문제">들어가며: 개발자를 괴롭히는 PATH 문제</h2>
<ul>
<li>나는 생화학, 수학, 통계 전공을 한터라 컴퓨터 공학을 전공하는 것이 아니었기 때문에 환경변수를 관리하지 않고 업무를 했고 그 결과 누적된 문제들이 얽혀 프로그램 오류를 찾아내는데 많은 시간을 소비하였다.</li>
<li>개발 환경을 설정하다 보면 예상치 못한 문제에 직면하게 된다. 특히 여러 도구와 언어를 함께 사용할 때, PATH 환경변수 오염은 마치 숨은 암초처럼 개발자를 괴롭힌다.</li>
<li>이 글에서는 복잡하게 꼬여버린 PATH 환경변수 문제의 진단부터 해결, 그리고 예방까지의 과정을 상세히 공유하고자 한다.</li>
<li><code>'conda.bat' is not recognized</code>, <code>reticulate 오류</code>, <code>Quarto 렌더링 실패</code> 등 겉보기엔 서로 다른 문제들이 사실은 하나의 거대한 PATH 오염에서 비롯된 것임을 밝혀내는 여정을 함께 따라가보자.</li>
</ul>
</section>
<section id="문제-상황-총체적-난국-오염된-path" class="level2">
<h2 class="anchored" data-anchor-id="문제-상황-총체적-난국-오염된-path">문제 상황: 총체적 난국, 오염된 PATH</h2>
<p>모든 문제의 시작은 처참하게 오염된 PATH 환경변수였다. 마치 뒤죽박죽 엉킨 실타래처럼, PATH는 다음과 같은 심각한 문제들을 안고 있었다.</p>
<section id="치명적인-경로-손상" class="level3">
<h3 class="anchored" data-anchor-id="치명적인-경로-손상">치명적인 경로 손상</h3>
<p>가장 심각한 문제는 Conda 환경 경로를 포함한 여러 경로가 완전히 깨져버린 것이다.</p>
<ul>
<li><code>miniconda3\\envs\\blog</code> 가 <code>miniconda3vlog</code> 로</li>
<li><code>mingw-w64\\bin</code> 가 <code>mingw-w6in</code> 로</li>
<li><code>usr\\bin</code> 가 <code>usin</code> 로</li>
<li><code>Library\\bin</code> 가 <code>Librarin</code> 로</li>
</ul>
<p>이러한 손상은 시스템이 정상적으로 실행 파일을 찾는 것을 불가능하게 만들었다.</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 예시: Git Bash에서 확인한 깨진 PATH의 일부</span></span>
<span id="cb1-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Users\\kmkim\\AppData\\Local\\miniconda3vlog</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">;</span>                           <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 깨진 경로 (envs\\blog → vlog)</span></span>
<span id="cb1-3"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Users\\kmkim\\AppData\\Local\\miniconda3vlog\\Library\\mingw-w6in</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">;</span>        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 심각하게 깨진 경로 (mingw-w64\\bin → mingw-w6in)</span></span>
<span id="cb1-4"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Users\\kmkim\\AppData\\Local\\miniconda3vlog\\Library\\usin</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">;</span>              <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 깨진 경로 (usr\\bin → usin)</span></span>
<span id="cb1-5"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Users\\kmkim\\AppData\\Local\\miniconda3vlog\\Librarin</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">;</span>                  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 깨진 경로 (Library\\bin → Librarin)</span></span>
<span id="cb1-6"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Users\\kmkim\\AppData\\Local\\miniconda3vlog\\Scripts</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">;</span>                   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 깨진 경로</span></span>
<span id="cb1-7"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Users\\kmkim\\AppData\\Local\\miniconda3vloin</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">;</span>                          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 완전히 깨진 경로</span></span></code></pre></div>
</section>
<section id="끝없는-경로-중복" class="level3">
<h3 class="anchored" data-anchor-id="끝없는-경로-중복">끝없는 경로 중복</h3>
<p>마치 복사-붙여넣기를 반복한 듯, 동일한 경로가 5번에서 10번 이상 중복되어 PATH를 극도로 길고 비효율적으로 만들었다.</p>
<ul>
<li>PowerShell 관련 경로는 10번 이상 반복</li>
<li>ffmpeg, MySQL, R tools 등 거의 모든 경로가 중복</li>
</ul>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 예시: 중복된 경로들</span></span>
<span id="cb2-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\ffmpeg</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">;</span>                                                             <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ⚠️ 중복 (시스템/사용자 모두 존재)</span></span>
<span id="cb2-3"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\ffmpeg\\</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">;</span>                                                            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 슬래시 중복</span></span>
<span id="cb2-4"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Program</span> Files<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\\</span>PowerShell<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\\</span>7<span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">;</span>                                         <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ⚠️ 중복</span></span>
<span id="cb2-5"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\\Program</span> Files<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\\</span>PowerShell<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\\</span>7<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\\</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">;</span>                                        <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ❌ 슬래시 중복</span></span>
<span id="cb2-6"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ... 기타 수많은 중복 경로 ...</span></span></code></pre></div>
</section>
<section id="일관성-없는-슬래시-사용" class="level3">
<h3 class="anchored" data-anchor-id="일관성-없는-슬래시-사용">일관성 없는 슬래시 사용</h3>
<p>경로 마지막에 슬래시(<code>/</code> 또는 <code>\\</code>)가 있거나 없는 경우가 혼재하여, 같은 경로가 다른 것으로 인식될 여지를 남겼다.</p>
<ul>
<li><code>C:\\path</code> 와 <code>C:\\path\\</code> 가 동시에 존재</li>
</ul>
</section>
<section id="사용자-path와-시스템-path의-혼란" class="level3">
<h3 class="anchored" data-anchor-id="사용자-path와-시스템-path의-혼란">사용자 PATH와 시스템 PATH의 혼란</h3>
<p>개인용 도구의 경로가 시스템 전체에 적용되는 시스템 PATH에 섞여 있었고, 그 반대의 경우도 존재하여 관리를 어렵게 만들었다.</p>
</section>
</section>
<section id="해결-과정-path-대청소" class="level2">
<h2 class="anchored" data-anchor-id="해결-과정-path-대청소">해결 과정: PATH 대청소</h2>
<p>엉망진창이 된 PATH를 정상으로 되돌리기 위한 대청소 작전은 다음과 같이 진행되었다.</p>
<section id="단계-path-현황-파악" class="level3">
<h3 class="anchored" data-anchor-id="단계-path-현황-파악">1단계: PATH 현황 파악</h3>
<p>가장 먼저 현재 PATH 상태를 정확히 파악하는 것이 중요했다.</p>
<div class="sourceCode" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">where</span> python  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Python 실행 파일 위치 확인</span></span>
<span id="cb3-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">where</span> conda   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># Conda 실행 파일 위치 확인</span></span>
<span id="cb3-3"><span class="bu" style="color: null;
background-color: null;
font-style: inherit;">echo</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">$PATH</span>    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># (Git Bash 등에서) 전체 PATH 문자열 확인</span></span></code></pre></div>
<p>PowerShell에서는 다음과 같이 사용자 PATH와 시스템 PATH를 각각 확인할 수 있다.</p>
<div class="sourceCode" id="cb4" style="background: #f1f3f5;"><pre class="sourceCode powershell code-with-copy"><code class="sourceCode powershell"><span id="cb4-1"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 사용자 PATH (개인 도구 및 설정)</span></span>
<span id="cb4-2"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>Environment<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]::</span>GetEnvironmentVariable<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Path"</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"User"</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span>
<span id="cb4-3"></span>
<span id="cb4-4"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># 시스템 PATH (모든 사용자 및 시스템 전역 도구)</span></span>
<span id="cb4-5"><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">[</span>Environment<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">]::</span>GetEnvironmentVariable<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">(</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Path"</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">,</span> <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Machine"</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">)</span></span></code></pre></div>
</section>
<section id="단계-사용자-path와-시스템-path-분리-및-재정렬" class="level3">
<h3 class="anchored" data-anchor-id="단계-사용자-path와-시스템-path-분리-및-재정렬">2단계: 사용자 PATH와 시스템 PATH 분리 및 재정렬</h3>
<p>진단 결과를 바탕으로, 각 경로의 성격에 맞게 사용자 PATH와 시스템 PATH로 명확히 분리했다.</p>
<ul>
<li><strong>사용자 PATH</strong>: 개인적으로 설치한 프로그램(Conda, VS Code, Quarto 등) 및 사용자별 도구</li>
<li><strong>시스템 PATH</strong>: Windows 기본 구성 요소, 모든 사용자에게 필요한 프로그램(Git, PowerShell 등)</li>
</ul>
</section>
<section id="단계-오류-수정-및-중복-제거" class="level3">
<h3 class="anchored" data-anchor-id="단계-오류-수정-및-중복-제거">3단계: 오류 수정 및 중복 제거</h3>
<ul>
<li><strong>깨진 경로 복구</strong>: <code>miniconda3vlog</code> 와 같이 손상된 부분을 원래의 <code>miniconda3\\envs\\blog\\Scripts</code> 등으로 수정했다.</li>
<li><strong>중복 경로 통합</strong>: 반복되는 경로들을 하나만 남기고 모두 제거했다. 슬래시 유무로 인한 중복도 통일했다.</li>
<li><strong>불필요한 경로 삭제</strong>: 예를 들어 Java JDK의 <code>bin\\server</code> 같이 실제 실행에 필요 없는 하위 경로를 제거했다.</li>
</ul>
</section>
<section id="단계-conda-환경-우선순위-조정" class="level3">
<h3 class="anchored" data-anchor-id="단계-conda-환경-우선순위-조정">4단계: Conda 환경 우선순위 조정</h3>
<p>여러 Python/Conda 환경이 존재할 때, 특정 프로젝트(예: <code>blog</code>)의 환경이 기본 Conda 환경보다 우선적으로 인식되도록 PATH 순서를 조정했다.</p>
<div class="sourceCode" id="cb5" style="background: #f1f3f5;"><pre class="sourceCode diff code-with-copy"><code class="sourceCode diff"><span id="cb5-1"># 수정 전 (일반 Conda가 우선될 수 있음)</span>
<span id="cb5-2">C:\Users\kmkim\AppData\Local\miniconda3\Scripts</span>
<span id="cb5-3">C:\Users\kmkim\AppData\Local\miniconda3\envs\blog\Scripts</span>
<span id="cb5-4"></span>
<span id="cb5-5"># 수정 후 (blog 환경 스크립트 최우선)</span>
<span id="cb5-6"><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">+ C:\Users\kmkim\AppData\Local\miniconda3\envs\blog\Scripts</span></span>
<span id="cb5-7">  C:\Users\kmkim\AppData\Local\miniconda3\Scripts</span>
<span id="cb5-8">  C:\Users\kmkim\AppData\Local\miniconda3\condabin</span>
<span id="cb5-9">  C:\Users\kmkim\AppData\Local\miniconda3</span></code></pre></div>
</section>
</section>
<section id="개선-후-평화를-되찾은-path" class="level2">
<h2 class="anchored" data-anchor-id="개선-후-평화를-되찾은-path">개선 후: 평화를 되찾은 PATH</h2>
<p>대대적인 정리 작업 끝에, PATH는 다음과 같이 깔끔하게 정돈되었다.</p>
<section id="사용자-path-개인-도구" class="level3">
<h3 class="anchored" data-anchor-id="사용자-path-개인-도구">사용자 PATH (개인 도구)</h3>
<div class="sourceCode" id="cb6" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\miniconda3\envs\blog\Scripts</span>  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ 최우선 (특정 Conda 환경)</span></span>
<span id="cb6-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\miniconda3\Scripts</span>            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ 일반 Conda 스크립트</span></span>
<span id="cb6-3"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\miniconda3\condabin</span>          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Conda 실행 파일 경로</span></span>
<span id="cb6-4"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\miniconda3</span>                   <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Conda 기본 경로</span></span>
<span id="cb6-5"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\Programs\Quarto\bin</span>         <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Quarto</span></span>
<span id="cb6-6"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\Programs\Microsoft</span> VS Code<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\b</span>in <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ VS Code</span></span>
<span id="cb6-7"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\Programs\cursor\resources\app\bin</span> <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Cursor</span></span>
<span id="cb6-8"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\scoop\shims</span>                                <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Scoop 패키지</span></span>
<span id="cb6-9"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Users\kmkim\AppData\Local\Microsoft\WindowsApps</span>       <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Windows Store 앱</span></span>
<span id="cb6-10"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\ffmpeg</span>                                                 <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ 사용자 ffmpeg</span></span>
<span id="cb6-11"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\R\rtools43\usr\bin</span>                                    <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ R 도구</span></span></code></pre></div>
</section>
<section id="시스템-path-전역-도구" class="level3">
<h3 class="anchored" data-anchor-id="시스템-path-전역-도구">시스템 PATH (전역 도구)</h3>
<div class="sourceCode" id="cb7" style="background: #f1f3f5;"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Windows\system32</span>                                       <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Windows 기본</span></span>
<span id="cb7-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Windows</span>                                               <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Windows 기본</span></span>
<span id="cb7-3"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Windows\System32\Wbem</span>                                <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ WMI</span></span>
<span id="cb7-4"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Windows\System32\WindowsPowerShell\v1.0</span>             <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ 구 PowerShell</span></span>
<span id="cb7-5"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Windows\System32\OpenSSH</span>                            <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ SSH</span></span>
<span id="cb7-6"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Program</span> Files<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\P</span>owerShell<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\7</span>                          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ 신 PowerShell</span></span>
<span id="cb7-7"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Program</span> Files<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\G</span>it<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\c</span>md                               <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Git</span></span>
<span id="cb7-8"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\ProgramData\chocolatey\bin</span>                          <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Chocolatey</span></span>
<span id="cb7-9"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Program</span> Files<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\J</span>ava<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\o</span>penjdk-23.0.1_windows-x64_bin<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\j</span>dk-23.0.1<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\b</span>in <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Java</span></span>
<span id="cb7-10"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Program</span> Files<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\M</span>ATLAB<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\R</span>2022b<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\b</span>in                     <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ MATLAB</span></span>
<span id="cb7-11"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">C:\Program</span> Files <span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">(</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">x86</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">)</span><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">\Microsoft</span> SDKs<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\A</span>zure<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\C</span>LI2<span class="dt" style="color: #AD0000;
background-color: null;
font-style: inherit;">\w</span>bin  <span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;"># ✅ Azure CLI</span></span></code></pre></div>
</section>
</section>
<section id="개선-효과-숫자로-보는-변화" class="level2">
<h2 class="anchored" data-anchor-id="개선-효과-숫자로-보는-변화">개선 효과: 숫자로 보는 변화</h2>
<table class="caption-top table">
<thead>
<tr class="header">
<th>항목</th>
<th>개선 전</th>
<th>개선 후</th>
<th>개선율</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>총 PATH 항목 수</strong></td>
<td>~80개</td>
<td>~20개</td>
<td><strong>75% 감소</strong></td>
</tr>
<tr class="even">
<td><strong>중복 제거</strong></td>
<td>대량 중복</td>
<td>중복 없음</td>
<td><strong>100% 해결</strong></td>
</tr>
<tr class="odd">
<td><strong>깨진 경로</strong></td>
<td>5개 이상</td>
<td>0개</td>
<td><strong>100% 해결</strong></td>
</tr>
<tr class="even">
<td><strong>Python 인식</strong></td>
<td>실패</td>
<td>성공</td>
<td><strong>✅ 해결</strong></td>
</tr>
<tr class="odd">
<td><strong>Quarto 렌더링</strong></td>
<td>실패</td>
<td>성공</td>
<td><strong>✅ 해결</strong></td>
</tr>
</tbody>
</table>
</section>
<section id="최종-결과-평화로운-개발-환경" class="level2">
<h2 class="anchored" data-anchor-id="최종-결과-평화로운-개발-환경">최종 결과: 평화로운 개발 환경</h2>
<p>PATH 정리가 완료되자, 이전에 발생했던 모든 문제들이 거짓말처럼 사라졌다.</p>
<p><strong>이전</strong>: - <code>'conda.bat' is not recognized as an internal or external command...</code> - <code>Reticulate: Python N/A</code> - <code>Quarto failed to render (exit code: N)</code></p>
<p><strong>현재</strong>: - <code>conda activate blog</code> (정상 작동) - <code>python --version</code> (원하는 버전 출력) - <code>quarto preview</code> (성공적인 문서 미리보기)</p>
</section>
<section id="주요-오염-원인-분석" class="level2">
<h2 class="anchored" data-anchor-id="주요-오염-원인-분석">주요 오염 원인 분석</h2>
<p>이러한 대규모 PATH 오염은 왜 발생했을까? 몇 가지 가능한 원인들을 추정해볼 수 있다.</p>
<ol type="1">
<li><p><strong>설치 프로그램의 무분별한 PATH 수정</strong>: 일부 프로그램 설치 시, 기존 PATH를 정확히 파싱하지 못하거나, 잘못된 형식으로 경로를 추가/덮어쓰면서 문제가 누적될 수 있다. <code>bash     # 문제 패턴 예시     C:\Users\kmkim\AppData\Local\miniconda3vlog  # ← 'envs\blog'가 'vlog'로 깨짐     C:\R\rtools43\\usr\bin\                      # ← 백슬래시 중복</code></p></li>
<li><p><strong>빈번한 프로그램 설치/제거/업데이트</strong>: 다양한 버전의 Java, Python/Conda, PowerShell 등을 설치하고 제거하는 과정에서 PATH 항목이 정리되지 않고 계속 누적되어 중복과 꼬임을 유발한다.</p></li>
<li><p><strong>Conda 환경 관리 중 오류</strong>: Conda 환경을 생성하거나 삭제하는 도중 프로세스가 중단되거나, 특정 환경(예: 한글 경로)에서 인코딩 문제가 발생하면 PATH가 손상될 수 있다. <code>bash     # 정상적이라면: C:\...\miniconda3\envs\blog     # 실제 발생: C:\...\miniconda3vlog, C:\...\miniconda3\Library\usin 등</code></p></li>
<li><p><strong>Windows PATH 길이 제한 (구버전)</strong>: 과거 Windows 버전에서는 PATH 문자열의 최대 길이가 약 2048자로 제한되었다. 경로가 과도하게 길어지면 잘리면서 중간 부분이 손상될 수 있다.</p></li>
<li><p><strong>다양한 개발 도구의 독립적인 PATH 수정</strong>: MATLAB, R, Python, Java, Git, VS Code, Quarto 등 수많은 개발 도구들이 각자의 방식으로 PATH를 수정하면서 예기치 않은 충돌이나 꼬임이 발생할 수 있다.</p></li>
</ol>
</section>
<section id="예방-조치-건강한-path-유지를-위한-습관" class="level2">
<h2 class="anchored" data-anchor-id="예방-조치-건강한-path-유지를-위한-습관">예방 조치: 건강한 PATH 유지를 위한 습관</h2>
<p>향후 유사한 문제를 예방하기 위해 다음과 같은 습관을 들이는 것이 좋다.</p>
<ol type="1">
<li><p><strong>중요 작업 전 PATH 백업</strong>: 새로운 개발 도구를 설치하거나 환경 설정을 크게 변경하기 전에는 현재 PATH 상태를 백업한다. <code>powershell     $env:PATH | Out-File path_backup_YYYYMMDD.txt</code></p></li>
<li><p><strong>설치 프로그램 사용 시 신중함 유지</strong>:</p>
<ul>
<li>한 번에 하나의 프로그램만 설치하고, 설치 후 PATH 변경 사항 및 정상 작동 여부를 확인한다.</li>
<li>가능하다면 “Add to PATH” 옵션을 해제하고 수동으로 필요한 경로만 추가하는 것을 고려한다.</li>
<li>설치 후에는 시스템을 재부팅하여 변경사항이 완전히 적용되도록 한다.</li>
</ul></li>
<li><p><strong>정기적인 PATH 점검 및 정리</strong>: 주기적으로 PATH를 점검하여 불필요하거나 중복된 경로, 깨진 경로가 있는지 확인하고 정리한다. <code>powershell     # PowerShell에서 중복 없는 정렬된 PATH 목록 확인     $env:PATH -split ';' | Sort-Object | Get-Unique</code></p></li>
</ol>
</section>
<section id="교훈-모든-것은-path로-통한다" class="level2">
<h2 class="anchored" data-anchor-id="교훈-모든-것은-path로-통한다">교훈: 모든 것은 PATH로 통한다</h2>
<p>이번 PATH 오염 사태를 통해 얻은 교훈은 다음과 같다.</p>
<ul>
<li><strong>환경변수 오염은 소리 없는 암살자</strong>: 눈에 잘 보이지 않지만 시스템 전반의 안정성과 프로그램 작동에 치명적인 영향을 미칠 수 있다.</li>
<li><strong>PATH 순서의 중요성</strong>: 시스템은 PATH에 등록된 순서대로 실행 파일을 찾는다. 원하는 버전이나 환경의 도구가 먼저 실행되도록 순서를 올바르게 설정해야 한다.</li>
<li><strong>사용자 PATH와 시스템 PATH의 명확한 분리</strong>: 역할에 맞게 경로를 분리해야 충돌을 예방하고 관리가 용이해진다.</li>
<li><strong>복잡한 개발 스택일수록 PATH 관리는 필수</strong>: 특히 Quarto, R, Python처럼 여러 언어와 도구가 연동되는 환경에서는 깨끗하고 정확한 PATH 설정이 무엇보다 중요하다.</li>
</ul>
<p>결국, 겉으로 드러난 수많은 오류 메시지들은 “근본 원인”인 PATH 오염이 해결되자 모두 사라졌다. 복잡한 문제일수록 기본으로 돌아가 시스템의 가장 기초적인 설정부터 점검하는 자세가 필요함을 다시 한번 깨닫게 되었다.</p>


</section>

 ]]></description>
  <category>Engineering</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Engineering/Conda/path_pollution.html</guid>
  <pubDate>Wed, 30 Apr 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>데이터 플랫폼 리소스 계획 및 구현</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Engineering/data_engineering/2.IaaS.html</link>
  <description><![CDATA[ 




<section id="azure-sql을-사용하여-iaas-솔루션-배포" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="azure-sql을-사용하여-iaas-솔루션-배포"><span class="header-section-number">1</span> Azure SQL을 사용하여 IaaS 솔루션 배포</h2>
<section id="introduction" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">1.1</span> <a href="https://learn.microsoft.com/en-us/training/modules/deploy-iaas-solutions-with-azure-sql/1-introduction">Introduction</a></h3>
<p>데이터베이스 시스템의 성능 최적화를 위한 주요 고려사항:</p>
<ul>
<li>데이터베이스 워크로드 성능 보장
<ul>
<li>가상 머신의 적절한 크기 선택이 필수적
<ul>
<li>CPU, 메모리, IOPS 등 리소스 요구사항 분석</li>
<li>워크로드 특성에 맞는 VM 시리즈 선택</li>
</ul></li>
<li>스토리지 구성의 최적화
<ul>
<li>Premium SSD, Ultra Disk 등 적절한 스토리지 타입 선택</li>
<li>데이터, 로그, 템프DB 파일의 효율적인 배치</li>
</ul></li>
<li>네트워크 설정 최적화
<ul>
<li>대역폭 요구사항에 맞는 네트워크 구성</li>
<li>보안 및 접근성 고려</li>
</ul></li>
</ul></li>
<li>고가용성 구성
<ul>
<li>비즈니스 요구사항에 맞는 가용성 수준 결정</li>
<li>Always On 가용성 그룹, 장애 조치 클러스터 등 적절한 솔루션 선택</li>
<li>백업 및 복구 전략 수립</li>
</ul></li>
<li>Azure VM에서의 SQL Server 배포 이점
<ul>
<li>기존 온프레미스 환경의 손쉬운 클라우드 마이그레이션</li>
<li>최소한의 아키텍처 변경으로 신속한 전환 가능</li>
<li>기존 라이선스 및 구성의 재사용 가능</li>
</ul></li>
<li>성공적인 마이그레이션을 위한 핵심 요소
<ul>
<li>상세한 마이그레이션 계획 수립</li>
<li>적절한 배포 옵션 선택</li>
<li>철저한 테스트 및 검증 절차</li>
</ul></li>
</ul>
<section id="자유도의-차이-iaas자유도가-높음-vs-paas자유도가-중간-vs-saas자유도가-낮음" class="level4">
<h4 class="anchored" data-anchor-id="자유도의-차이-iaas자유도가-높음-vs-paas자유도가-중간-vs-saas자유도가-낮음">자유도의 차이: IaaS(자유도가 높음) vs PaaS(자유도가 중간) vs SaaS(자유도가 낮음)</h4>
<ul>
<li>Software as a Service (SaaS)
<ul>
<li><strong>관리 수준</strong>: 완전 관리형으로 모든 것이 서비스 제공업체에 의해 관리됨</li>
<li><strong>유지보수</strong>: 서비스 제공업체가 모든 유지보수 담당</li>
<li><strong>확장성</strong>: 자동 확장, 사용자는 구독 수준만 선택</li>
<li><strong>비용</strong>: 구독 기반 과금, 사용량에 따른 요금제</li>
<li><strong>유연성</strong>: 매우 제한적, 제공되는 기능만 사용 가능</li>
<li><strong>적합 사례</strong>: 표준화된 소프트웨어 필요 시 (예: Office 365, Salesforce)</li>
</ul></li>
<li>Azure SQL Database (PaaS)
<ul>
<li><strong>관리 수준</strong>: 완전 관리형 서비스로 Microsoft가 OS, 하드웨어, 백업, 고가용성 등을 관리</li>
<li><strong>유지보수</strong>: 자동 패치 및 업그레이드</li>
<li><strong>확장성</strong>: 자동 확장 기능 지원</li>
<li><strong>비용</strong>: 사용한 리소스에 따라 비용 지불, 일반적으로 관리 오버헤드가 적음</li>
<li><strong>제한사항</strong>: 일부 고급 SQL Server 기능 사용 불가(CLR, SQL Agent 등)</li>
<li><strong>적합 사례</strong>: 새 애플리케이션 개발, 관리 오버헤드 최소화가 필요한 경우</li>
</ul></li>
<li>IaaS SQL Server (Azure VM)
<ul>
<li><strong>관리 수준</strong>: 셀프 관리형으로 사용자가 OS, 소프트웨어 업데이트, 백업 등 직접 관리</li>
<li><strong>유지보수</strong>: 수동 패치 및 업그레이드</li>
<li><strong>확장성</strong>: 수동 확장, VM 크기 변경 필요</li>
<li><strong>비용</strong>: VM 인프라에 대한 비용 지불, 관리 오버헤드가 더 많음</li>
<li><strong>유연성</strong>: 모든 SQL Server 기능 사용 가능(SSAS, SSIS, SSRS 등)</li>
<li><strong>적합 사례</strong>: 기존 온프레미스 SQL Server 마이그레이션, 특정 버전/기능 필요 시</li>
</ul></li>
<li>주요 차이점
<ul>
<li><strong>제어 수준</strong>: IaaS는 더 많은 제어를 제공하지만 더 많은 관리 책임이 따름</li>
<li><strong>호환성</strong>: IaaS는 온프레미스 SQL Server와 100% 호환, PaaS는 일부 제한</li>
<li><strong>운영 비용</strong>: PaaS는 일반적으로 운영 비용이 더 낮음</li>
</ul></li>
</ul>
</section>
</section>
<section id="azure에서-sql-server를-배포하기-위한-iaas-옵션-설명" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="azure에서-sql-server를-배포하기-위한-iaas-옵션-설명"><span class="header-section-number">1.2</span> <a href="https://learn.microsoft.com/en-us/training/modules/deploy-iaas-solutions-with-azure-sql/2-explain-iaas-options-deploy-azure">Azure에서 SQL Server를 배포하기 위한 IaaS 옵션 설명</a></h3>
<ul>
<li><p>Azure VM에서 SQL Server를 실행해야 하는 주요 시나리오들:</p>
<ol type="1">
<li>이전 버전의 SQL Server가 필요한 경우</li>
</ol>
<ul>
<li>일부 애플리케이션은 특정 이전 버전의 SQL Server에서만 작동</li>
<li>공급업체가 지원하는 특정 SQL Server 버전을 사용해야 하는 경우</li>
<li>이런 경우 VM에 원하는 버전을 직접 설치하여 실행하는 것이 가장 좋은 방법</li>
</ul>
<ol start="2" type="1">
<li>여러 SQL Server 서비스를 함께 사용해야 하는 경우</li>
</ol>
<ul>
<li>SQL Server 데이터베이스 엔진과 함께 Analysis Services(분석 서비스)나 Integration Services(통합 서비스), Reporting Services(보고 서비스)를 같이 사용해야 할 때</li>
<li>이들을 한 VM에서 함께 실행하면 라이선스 비용을 절약할 수 있음</li>
<li>Azure에서 일부 서비스는 PaaS로 제공되지만, 비용 효율성을 위해 VM에서 함께 실행하는 것이 유리할 수 있음</li>
</ul>
<ol start="3" type="1">
<li>애플리케이션 호환성 문제가 있는 경우</li>
</ol>
<ul>
<li>일부 애플리케이션은 여러 데이터베이스 간의 쿼리(교차 데이터베이스 쿼리)가 필요</li>
<li>Azure SQL Database는 이를 지원하지 않아 VM 사용이 필요</li>
<li>데이터베이스와 다른 서비스들이 특별한 방식으로 함께 동작해야 하는 경우</li>
</ul></li>
<li><p>IaaS(Infrastructure as a Service)의 장점과 특징:</p>
<ul>
<li>관리자의 세밀한 시스템 제어
<ul>
<li>Azure가 서버 하드웨어와 네트워크를 관리하지만, 관리자는 다음을 직접 제어 가능:
<ul>
<li>가상 스토리지 설정</li>
<li>가상 네트워크 구성</li>
<li>SQL Server 설치 및 설정</li>
<li>추가 소프트웨어 설치</li>
</ul></li>
</ul></li>
<li>인프라 구성의 높은 자유도
<ul>
<li>OS 레벨부터 완전한 제어 가능</li>
<li>커스텀 설정 및 튜닝의 자유로움</li>
</ul></li>
<li>세부적인 구성 계획의 중요성
<ul>
<li>성능 요구사항에 맞는 리소스 할당</li>
<li>확장성을 고려한 아키텍처 설계</li>
<li>비용 효율적인 리소스 사용 계획</li>
</ul></li>
</ul></li>
</ul>
<section id="azure-서비스-control-granularity제어-정밀도-비교" class="level4">
<h4 class="anchored" data-anchor-id="azure-서비스-control-granularity제어-정밀도-비교">Azure 서비스 Control Granularity(제어 정밀도) 비교</h4>
<ul>
<li>IaaS, PaaS, SaaS의 제어 수준 차이
<ul>
<li>IaaS: 가장 높은 제어 수준 제공</li>
<li>PaaS: 중간 수준의 제어 제공</li>
<li>SaaS: 가장 제한된 제어 수준</li>
</ul></li>
<li>각 서비스 별 관리 책임
<ul>
<li>SaaS: 사용자는 보안과 데이터 관리만 담당</li>
<li>PaaS: 클라우드 제공업체가 OS와 기본 소프트웨어 관리</li>
<li>IaaS: 사용자가 OS 패치, 네트워크, 스토리지 구성 등 대부분 관리</li>
</ul></li>
<li>Azure IaaS에서의 책임 분담
<ul>
<li>Microsoft 담당:
<ul>
<li>물리적 서버</li>
<li>스토리지</li>
<li>물리적 네트워킹</li>
</ul></li>
<li>사용자 담당:
<ul>
<li>OS 관리</li>
<li>SQL Server 인스턴스 구성</li>
<li>추가 소프트웨어 설치/관리</li>
</ul></li>
</ul></li>
<li>IaaS가 필요한 특수 상황
<ul>
<li>특정 SQL Server/Windows 버전 조합이 필요한 경우</li>
<li>SQL Server와 함께 추가 소프트웨어 설치가 필요한 경우</li>
<li>CLR, 복제 등 특수 기능 사용이 필요한 경우</li>
<li>기존 Active Directory 인증이 필요한 경우</li>
<li>OS 직접 접근이 필요한 애플리케이션 운영 시</li>
</ul></li>
<li>IaaS의 장점
<ul>
<li>높은 유연성과 제어 가능성</li>
<li>기존 온프레미스 환경과 유사한 구성 가능</li>
<li>클라우드의 이점과 기존 기능의 동시 활용</li>
<li>특수한 요구사항 수용 가능</li>
</ul></li>
</ul>
</section>
<section id="sql-server-iaas-agent-extensionsql-server-iaas-에이전트-확장" class="level4">
<h4 class="anchored" data-anchor-id="sql-server-iaas-agent-extensionsql-server-iaas-에이전트-확장">SQL Server IaaS Agent Extension(SQL Server IaaS 에이전트 확장)</h4>
<ul>
<li>Azure Marketplace에서 SQL Server VM을 배포할 때, 프로세스의 일부로 IaaS Agent Extension이 설치된다.</li>
<li>확장(Extension)은 VM 배포 후 실행되는 코드로, 일반적으로 배포 후 구성을 수행한다.</li>
<li>예를 들어 백신 소프트웨어 설치나 Windows 기능 활성화 등이 있다.</li>
<li>SQL Server IaaS Agent Extension은 관리 부담을 줄일 수 있는 다음과 같은 주요 기능을 제공한다:
<ul>
<li>자동 백업</li>
<li>자동 패치 적용</li>
<li>Azure Key Vault 통합</li>
<li>Microsoft Defender for Cloud 통합</li>
<li>포털에서 디스크 사용량 확인</li>
<li>유연한 라이선싱</li>
<li>유연한 버전/에디션 선택</li>
<li>SQL 모범 사례 평가</li>
</ul></li>
</ul>
<p>이러한 기능 외에도, 이 확장을 통해 SQL Server의 구성 및 스토리지 사용량 정보를 확인할 수 있다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="kk3225.netlify.app/images/azure/IaaS Agent Extension.PNG" class="img-fluid figure-img"></p>
<figcaption>IaaS Agent Extension</figcaption>
</figure>
</div>
</section>
<section id="sql-server-라이선싱-모델" class="level4">
<h4 class="anchored" data-anchor-id="sql-server-라이선싱-모델">SQL Server 라이선싱 모델</h4>
<ul>
<li>Azure VM에서 SQL Server 라이선스 사용 방법은 크게 두 가지</li>
</ul>
<ol type="1">
<li>종량제(Pay as you Go) 방식
<ul>
<li>Azure Marketplace에서 SQL Server가 설치된 VM 이미지 사용</li>
<li>사용한 시간만큼 VM 비용 + SQL Server 라이선스 비용 지불</li>
</ul></li>
<li>기존 라이선스 사용(BYOL) 방식
<ul>
<li>Software Assurance(SA) 프로그램 참여 고객만 가능</li>
<li>기존 보유한 SQL Server 라이선스를 Azure VM에 적용</li>
<li>VM 구현 후 10일 이내에 Microsoft에 라이선스 사용 보고 필요</li>
<li>SQL Server를 직접 설치하거나 커스텀 이미지 업로드 가능</li>
</ul></li>
</ol>
<p>비용 절감을 위한 추가 옵션: - Windows Server 라이선스도 기존 것 사용 가능 (Azure Hybrid Benefit) - VM을 1-3년 예약 구매 시 추가 할인 - 선불 결제 없이 월별 청구 가능 - 장기 사용 예정인 대형 VM에 특히 유리</p>
</section>
<section id="azure-vm-제품군-종류" class="level4">
<h4 class="anchored" data-anchor-id="azure-vm-제품군-종류">Azure VM 제품군 종류</h4>
<p>Azure VM은 다양한 제품군(시리즈)을 제공하며, 각각 특정 용도에 최적화되어 있다.</p>
<ol type="1">
<li>범용(General Purpose)
<ul>
<li>CPU와 메모리의 균형잡힌 구성</li>
<li>테스트/개발 환경, 소/중규모 DB 서버, 중소 트래픽 웹서버에 적합</li>
</ul></li>
<li>컴퓨팅 최적화(Compute Optimized)
<ul>
<li>높은 CPU 대 메모리 비율</li>
<li>중규모 웹서버, 네트워크 어플라이언스, 배치 처리에 적합</li>
<li>기본적인 머신러닝 워크로드 지원</li>
</ul></li>
<li>메모리 최적화(Memory Optimized)
<ul>
<li>높은 메모리 대 CPU 비율 (최대 4TB RAM)</li>
<li>대부분의 데이터베이스 워크로드에 적합</li>
</ul></li>
<li>스토리지 최적화(Storage Optimized)
<ul>
<li>고속 로컬 NVMe 임시 스토리지 제공</li>
<li>Cassandra 등 스케일아웃 데이터 워크로드에 적합</li>
<li>SQL Server 사용 시 Always On 가용성 그룹 등 데이터 보호 구성 필요</li>
</ul></li>
<li>GPU 최적화
<ul>
<li>비디오 렌더링/처리</li>
<li>GPU 기반 대규모 병렬 머신러닝 워크로드에 적합</li>
</ul></li>
<li>FPGA 가속
<ul>
<li>컴퓨팅 집약적 워크로드용</li>
<li>높은 스토리지 처리량과 네트워크 대역폭 제공</li>
</ul></li>
<li>고성능 컴퓨팅(HPC)
<ul>
<li>수천 개 CPU 코어로 수평 확장 가능</li>
<li>RDMA 네트워킹을 통한 낮은 지연시간 제공</li>
</ul></li>
</ol>
<ul>
<li>VM 크기 선택 방법
<ul>
<li>Azure 포털의 VM 생성 블레이드에서 ‘모든 크기 보기’ 선택</li>
<li>각 크기별 상세 정보 확인 가능:
<ul>
<li>vCPU 수</li>
<li>RAM 용량</li>
<li>데이터 디스크 수</li>
<li>최대 IOPS</li>
<li>임시 스토리지 용량</li>
<li>프리미엄 스토리지 지원 여부</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="azure-marketplace" class="level4">
<h4 class="anchored" data-anchor-id="azure-marketplace">Azure Marketplace</h4>
<p>Azure Marketplace는 Azure에서 제공하는 리소스 스토어로, 미리 만들어진 템플릿을 사용해 쉽게 리소스를 생성할 수 있다.</p>
<ul>
<li>주요 특징:
<ul>
<li>간단한 설정: 기본 정보만 입력하면 빠르게 리소스 생성 가능</li>
<li>빠른 구축: 몇 분 안에 리소스 사용 가능</li>
<li>다양한 옵션: SQL Server, Windows Server 등 다양한 제품 제공</li>
<li>사전 구성: OLTP, Data Warehouse 등 용도에 맞는 설정 제공</li>
</ul></li>
<li>장점
<ul>
<li>쉽고 빠른 시작 가능</li>
<li>직관적인 인터페이스</li>
<li>상세 설정 없이도 사용 가능</li>
</ul></li>
<li>단점
<ul>
<li>반복 작업이 어려움</li>
<li>자동화하기 불편함</li>
</ul></li>
</ul>
</section>
<section id="sql-server-configuration" class="level4">
<h4 class="anchored" data-anchor-id="sql-server-configuration">SQL Server configuration</h4>
<p>Azure VM에서 SQL Server를 설치할 때 다음과 같은 기본적인 설정들을 할 수 있다:</p>
<ul>
<li>보안 설정: 방화벽 규칙, 접근 권한 등을 설정</li>
<li>네트워크 설정: 가상 네트워크, 서브넷 등을 구성<br>
</li>
<li>SQL 인증: 사용자 계정과 비밀번호 설정</li>
<li>SQL 인스턴스: 데이터베이스 엔진 설정</li>
</ul>
</section>
</section>
<section id="understand-hybrid-scenarios" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="understand-hybrid-scenarios"><span class="header-section-number">1.3</span> <a href="https://learn.microsoft.com/en-us/training/modules/deploy-iaas-solutions-with-azure-sql/3-understand-hybrid-scenarios">Understand hybrid scenarios</a></h3>
<ul>
<li>하이브리드 인프라의 필요성
<ul>
<li>온프레미스/로컬 데이터센터의 SQL Server 인프라 투자 활용 가능</li>
<li>클라우드와 온프레미스의 장점을 모두 활용 가능</li>
<li>운영 복원력 향상과 비용 절감 효과</li>
</ul></li>
<li>하이브리드 인프라의 장점
<ul>
<li>클라우드 전환에 신중한 조직을 위한 좋은 시작점</li>
<li>물리적/가상화된 SQL Server 온프레미스 배포를 클라우드로 확장 가능</li>
<li>온프레미스와 클라우드 서비스의 상호 보완적 운영</li>
<li>IaaS 서비스(스토리지, SQL Server VM 등) 활용 가능</li>
</ul></li>
<li>하이브리드 구현 범위
<ul>
<li>온프레미스와 클라우드 간 하이브리드</li>
<li>여러 클라우드 서비스 간 하이브리드 구현 가능</li>
<li>다양한 SQL Server 하이브리드 시나리오 적용 가능</li>
</ul></li>
</ul>
<section id="sql-server를-위한-하이브리드-시나리오" class="level4">
<h4 class="anchored" data-anchor-id="sql-server를-위한-하이브리드-시나리오">SQL Server를 위한 하이브리드 시나리오</h4>
<p>SQL Server를 위한 하이브리드 솔루션을 배포할 때 고려할 수 있는 몇 가지 전략</p>
</section>
<section id="재해-복구" class="level4">
<h4 class="anchored" data-anchor-id="재해-복구">재해 복구</h4>
<p>재해 복구는 SQL Server를 하이브리드로 운영할 때 가장 많이 사용되는 방식</p>
<ul>
<li>주요 특징
<ul>
<li>재난 상황에서도 비즈니스 연속성 보장</li>
<li>여러 데이터 센터에 분산 배치 가능</li>
<li>Azure VM을 활용해 비용 효율적인 DR 구축</li>
</ul></li>
<li>운영 방식
<ul>
<li>일상적인 처리는 온프레미스 서버 사용</li>
<li>재해 발생 시 Azure로 전환(장애 조치)</li>
<li>여러 지역에 걸쳐 백업 가능</li>
</ul></li>
</ul>
</section>
<section id="sql-server-백업" class="level4">
<h4 class="anchored" data-anchor-id="sql-server-백업">SQL Server 백업</h4>
<p>SQL Server의 데이터를 안전하게 보관하기 위한 백업 전략</p>
<ul>
<li>백업 방식
<ul>
<li>Azure Storage에 직접 백업 (URL 사용)</li>
<li>Azure 파일 공유 활용 (SMB 프로토콜)</li>
</ul></li>
<li>주요 이점
<ul>
<li>현장 백업 실패 시에도 데이터 보호</li>
<li>Azure VM에서 백업 데이터 복원 테스트 가능</li>
<li>클라우드의 안정적인 스토리지 활용</li>
</ul></li>
</ul>
</section>
<section id="azure-arc-지원-sql-server" class="level4">
<h4 class="anchored" data-anchor-id="azure-arc-지원-sql-server">Azure Arc 지원 SQL Server</h4>
<p>여러 환경의 SQL Server를 Azure에서 통합 관리할 수 있게 해주는 서비스</p>
<ul>
<li>지원 환경
<ul>
<li>온프레미스</li>
<li>데이터 센터</li>
<li>엣지 환경</li>
<li>멀티클라우드</li>
</ul></li>
<li>주요 기능
<ul>
<li>모든 SQL Server 배포 현황 파악</li>
<li>구성/사용 패턴/보안 평가</li>
<li>실시간 보안 경고</li>
<li>취약점 보고</li>
</ul></li>
</ul>
</section>
<section id="보안-고려사항" class="level4">
<h4 class="anchored" data-anchor-id="보안-고려사항">보안 고려사항</h4>
<p>하이브리드 SQL 환경을 안전하게 운영하기 위한 보안 요소</p>
<ul>
<li>기본 요구사항
<ul>
<li>Active Directory와 DNS 설정 (온프레미스/Azure 모두)</li>
<li>안전한 양방향 통신 구축</li>
</ul></li>
<li>연결 방식
<ul>
<li>사이트 간(S2S) VPN</li>
<li>ExpressRoute</li>
</ul></li>
<li>ExpressRoute 특징
<ul>
<li>장점
<ul>
<li>최고 수준의 보안</li>
<li>최소 지연 시간</li>
<li>공용 인터넷과 분리된 전용 채널</li>
</ul></li>
<li>단점
<ul>
<li>높은 비용</li>
<li>멀티클라우드 환경에서 제한적 사용</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section id="explore-performance-and-security" class="level3" data-number="1.4">
<h3 data-number="1.4" class="anchored" data-anchor-id="explore-performance-and-security"><span class="header-section-number">1.4</span> <a href="https://learn.microsoft.com/en-us/training/modules/deploy-iaas-solutions-with-azure-sql/4-explore-performance-and-security">Explore performance and security</a></h3>
<ul>
<li>Azure 에코시스템은 Azure 가상 머신의 SQL Server 인스턴스에 대한 다양한 성능 및 보안 옵션을 제공한다</li>
<li>각 옵션은 워크로드의 용량 및 성능 요구사항을 충족하는 다양한 디스크 유형과 같은 기능을 제공한다.</li>
</ul>
<section id="스토리지-고려사항" class="level4">
<h4 class="anchored" data-anchor-id="스토리지-고려사항">스토리지 고려사항</h4>
<ul>
<li>SQL Server는 Azure VM이나 온프레미스 환경에서 모두 고성능을 위해 우수한 스토리지 성능이 필수적</li>
<li>Azure는 다양한 스토리지 솔루션을 제공하는데, SQL Server 워크로드는 주로 Azure 관리 디스크를 사용</li>
<li>Azure 관리 디스크는 VM에 제공되는 블록 수준 스토리지로, 높은 가용성과 확장성을 제공</li>
</ul>
<p>Azure 관리 디스크의 주요 특징:</p>
<ul>
<li>스토리지 유형
<ul>
<li>Blob, 파일, 큐, 테이블 등 다양한 유형 제공</li>
<li>SQL Server는 주로 관리 디스크 사용</li>
<li>장애 조치 클러스터는 파일 스토리지 사용 가능</li>
<li>백업은 blob 스토리지 활용</li>
</ul></li>
<li>관리 디스크의 장점
<ul>
<li>99.999%의 높은 가용성</li>
<li>지역당 구독당 최대 50,000개 VM 디스크 지원</li>
<li>가용성 집합/영역과의 통합으로 높은 복원력</li>
</ul></li>
<li>암호화 옵션
<ul>
<li>Azure 서버 측 암호화: 스토리지 서비스 레벨의 암호화</li>
<li>Azure 디스크 암호화: VM 내부의 OS/데이터 디스크 암호화</li>
<li>두 옵션 모두 Azure Key Vault 통합 지원</li>
</ul></li>
</ul>
<p>VM에 연결되는 디스크 유형:</p>
<ol type="1">
<li>운영 체제 디스크
<ul>
<li>부팅 볼륨 포함</li>
<li>Windows: C: 드라이브</li>
<li>Linux: /dev/sda1</li>
</ul></li>
<li>임시 디스크
<ul>
<li>임시 스토리지용</li>
<li>페이지/스왑 파일 등 비영구 데이터 저장</li>
<li>Windows: D:&nbsp;드라이브</li>
<li>Linux: /dev/sdb1</li>
<li>중요 데이터 저장 금지</li>
</ul></li>
<li>데이터 디스크
<ul>
<li>VM에 추가되는 관리 디스크</li>
<li>Windows: Storage Spaces로 풀링 가능</li>
<li>Linux: 논리 볼륨 관리로 풀링 가능</li>
<li>IOPS와 스토리지 용량 확장 가능</li>
</ul></li>
</ol>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 15%">
<col style="width: 20%">
<col style="width: 16%">
<col style="width: 17%">
<col style="width: 17%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Ultra Disk</th>
<th>Premium SSD v2</th>
<th>Premium SSD</th>
<th>Standard SSD</th>
<th>Standard HDD</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Disk type</td>
<td>SSD</td>
<td>SSD</td>
<td>SSD</td>
<td>SSD</td>
<td>HDD</td>
</tr>
<tr class="even">
<td>Best for</td>
<td>IO-intensive workloads</td>
<td>Performance-sensitive workloads</td>
<td>Performance-sensitive workloads</td>
<td>Lightweight workloads</td>
<td>Backups, non-critical workloads</td>
</tr>
<tr class="odd">
<td>Max disk size</td>
<td>65,536 GiB</td>
<td>64,000 GiB</td>
<td>32,767 GiB</td>
<td>32,767 GiB</td>
<td>32,767 GiB</td>
</tr>
<tr class="even">
<td>Max throughput</td>
<td>10,000 MB/s</td>
<td>1,200 MB/s</td>
<td>900 MB/s</td>
<td>750 MB/s</td>
<td>500 MB/s</td>
</tr>
<tr class="odd">
<td>Max IOPS</td>
<td>160,000</td>
<td>80,000</td>
<td>20,000</td>
<td>6,000</td>
<td>2,000</td>
</tr>
</tbody>
</table>
<p>Azure SQL Server의 스토리지 구성에 대한 모범 사례를 살펴보면, 성능 최적화를 위해 여러 디스크를 적절히 구성하는 것이 중요. 특히 IOPS와 스토리지 용량을 효과적으로 관리하기 위해서는 프리미엄 디스크를 풀링하여 사용하는 것이 권장됨</p>
<p>각 데이터 유형별 스토리지 구성 권장사항:</p>
<ul>
<li>데이터 파일
<ul>
<li>프리미엄 디스크의 자체 풀에 저장</li>
<li>읽기 캐싱 기능 활성화</li>
<li>높은 IOPS와 처리량 확보</li>
</ul></li>
<li>트랜잭션 로그 파일
<ul>
<li>별도의 디스크 풀에 저장</li>
<li>캐싱 기능 비활성화 (캐싱의 이점 없음)</li>
<li>안정적인 쓰기 성능 보장</li>
</ul></li>
<li>TempDB
<ul>
<li>두 가지 옵션 중 선택:
<ol type="1">
<li>자체 디스크 풀에 저장</li>
<li>VM의 임시 디스크 활용 (물리 서버와 직접 연결되어 낮은 지연시간 제공)</li>
</ol></li>
</ul></li>
</ul>
<p>성능 요구사항에 따른 디스크 선택: - 일반적인 워크로드: 프리미엄 SSD (밀리초 단위의 지연시간) - 미션 크리티컬 워크로드: Ultra SSD (더 낮은 지연시간 필요시)</p>
</section>
<section id="보안-고려사항-1" class="level4">
<h4 class="anchored" data-anchor-id="보안-고려사항-1">보안 고려사항</h4>
<p>Azure는 가상 머신에서 실행되는 SQL Server의 규정 준수 솔루션을 위해 다양한 보안 도구와 기능을 제공합니다.</p>
<p>주요 보안 도구:</p>
<ol type="1">
<li>SQL용 Microsoft Defender
<ul>
<li>취약성 평가 및 보안 경고 기능 제공</li>
<li>SQL Server 인스턴스와 데이터베이스의 잠재적 취약점 식별</li>
<li>보안 위험 감지 및 해결 방안 제시</li>
<li>보안 상태 모니터링 및 개선을 위한 실행 가능한 단계 제공</li>
</ul></li>
<li>Azure Security Center
<ul>
<li>통합 보안 관리 시스템</li>
<li>하이브리드 클라우드 워크로드 전반의 보안 상태 모니터링</li>
<li>공격 노출 감소 및 위협 대응 기능</li>
<li>보안 개선 기회 식별 및 제안</li>
</ul></li>
</ol>
</section>
<section id="성능-최적화-방안" class="level4">
<h4 class="anchored" data-anchor-id="성능-최적화-방안">성능 최적화 방안</h4>
<p>Azure VM의 SQL Server는 온프레미스 환경과 유사한 성능 최적화 기능을 제공합니다.</p>
<p>주요 성능 최적화 기능:</p>
<ol type="1">
<li>테이블 파티셔닝
<ul>
<li>대규모 테이블의 효율적 관리</li>
<li>쿼리 성능 향상</li>
<li>유지보수 작업 효율화</li>
</ul>
구현 단계:
<ul>
<li>파일 그룹 생성</li>
<li>파티션 함수 정의</li>
<li>파티션 스키마 생성</li>
<li>테이블 파티션 설정</li>
</ul></li>
<li>데이터 압축 압축 유형:
<ul>
<li>행 압축
<ul>
<li>기본적인 압축 방식</li>
<li>최소 저장 공간 사용</li>
<li>낮은 시스템 부하</li>
</ul></li>
<li>페이지 압축
<ul>
<li>행 압축 포함</li>
<li>접두사 압축과 사전 압축 기술 적용</li>
<li>높은 압축률 제공</li>
</ul></li>
<li>컬럼스토어 아카이브 압축
<ul>
<li>XPRESS 압축 알고리즘 사용</li>
<li>자주 접근하지 않는 보관 데이터에 적합</li>
<li>높은 CPU 사용률</li>
</ul></li>
</ul></li>
<li>추가 최적화 옵션
<ul>
<li>백업 압축 기능 활성화</li>
<li>즉각적인 파일 초기화 설정</li>
<li>데이터베이스 자동 증가 제한 설정</li>
<li>자동 축소/자동 닫기 기능 비활성화</li>
<li>시스템 데이터베이스 데이터 디스크 이전</li>
<li>로그 및 추적 파일 데이터 디스크 이전</li>
</ul></li>
</ol>
<pre><code>-- Partition function
CREATE PARTITION FUNCTION PartitionByMonth (datetime2)
    AS RANGE RIGHT
    -- The boundary values defined is the first day of each month, where the table will be partitioned into 13 partitions
    FOR VALUES ('20210101', '20210201', '20210301',
      '20210401', '20210501', '20210601', '20210701',
      '20210801', '20210901', '20211001', '20211101', 
      '20211201');

-- The partition scheme below will use the partition function created above, and assign each partition to a specific filegroup.
CREATE PARTITION SCHEME PartitionByMonthSch
    AS PARTITION PartitionByMonth
    TO (FILEGROUP1, FILEGROUP2, FILEGROUP3, FILEGROUP4,
        FILEGROUP5, FILEGROUP6, FILEGROUP7, FILEGROUP8,
        FILEGROUP9, FILEGROUP10, FILEGROUP11, FILEGROUP12);

-- Creates a partitioned table called Order that applies PartitionByMonthSch partition scheme to partition the OrderDate column  
CREATE TABLE Order ([Id] int PRIMARY KEY, OrderDate datetime2)  
    ON PartitionByMonthSch (OrderDate) ;  
GO
</code></pre>
</section>
<section id="데이터-압축" class="level4">
<h4 class="anchored" data-anchor-id="데이터-압축">데이터 압축</h4>
<p>SQL Server의 데이터 압축은 데이터베이스의 성능과 저장 공간을 최적화하는 중요한 기능입니다.</p>
<p>데이터 압축의 기본 구조: - SQL Server는 8KB 크기의 페이지 단위로 데이터를 저장 - 압축을 통해 한 페이지에 더 많은 데이터를 저장 가능</p>
<p>데이터 압축의 주요 효과: 1. 물리적 IO 감소 - 쿼리 실행 시 읽어야 할 페이지 수가 줄어듦 - 디스크 읽기/쓰기 작업이 감소</p>
<ol start="2" type="1">
<li>메모리 사용 효율성 향상
<ul>
<li>버퍼 풀의 메모리를 더 효율적으로 사용</li>
<li>동일한 메모리로 더 많은 데이터 처리 가능</li>
</ul></li>
</ol>
<p>데이터 압축의 주요 특징과 장단점은 다음과 같습니다:</p>
<ol type="1">
<li><p>주요 이점</p>
<ul>
<li>물리적 IO 감소</li>
<li>버퍼 풀의 효율적인 메모리 사용</li>
<li>저장 공간 절약</li>
<li>대부분의 경우 전반적인 성능 향상</li>
</ul></li>
<li><p>잠재적 단점</p>
<ul>
<li>CPU 사용량 증가</li>
<li>압축/해제 과정에서의 추가 처리 시간</li>
</ul></li>
<li><p>구현 특성</p>
<ul>
<li>개체 수준에서 구현 가능</li>
<li>개별 인덱스나 테이블 단위로 압축 가능</li>
<li>파티션 단위로도 압축 설정 가능</li>
<li>sp_estimate_data_compression_savings 프로시저로 압축 효과 예측 가능</li>
</ul></li>
<li><p>압축 유형별 특징</p>
<p>행 압축:</p>
<ul>
<li>기본적인 압축 방식으로 최소한의 시스템 부하</li>
<li>각 열의 값을 최소 필요 공간으로 저장</li>
<li>숫자 데이터는 가변 길이로 저장</li>
<li>고정 길이 문자열을 가변 길이로 변환</li>
</ul>
<p>페이지 압축:</p>
<ul>
<li>행 압축을 포함한 고급 압축 방식</li>
<li>접두사 압축으로 중복 데이터 제거</li>
<li>사전 압축으로 반복 값을 포인터로 대체</li>
<li>데이터 중복성이 높을수록 압축률 증가</li>
</ul>
<p>컬럼스토어 아카이브 압축:</p>
<ul>
<li>XPRESS 압축 알고리즘 사용</li>
<li>자주 접근하지 않는 보관용 데이터에 적합</li>
<li>높은 압축률 제공</li>
<li>CPU 사용량이 상대적으로 높음</li>
</ul></li>
</ol>
</section>
<section id="추가-옵션" class="level4">
<h4 class="anchored" data-anchor-id="추가-옵션">추가 옵션</h4>
<p>다음은 프로덕션 워크로드에 대해 고려해야 할 추가 SQL Server 기능 및 작업 목록:</p>
<ul>
<li>백업 압축 활성화</li>
<li>데이터 파일에 대한 즉각적인 파일 초기화 활성화</li>
<li>데이터베이스 자동 증가 제한</li>
<li>데이터베이스에 대한 자동 축소/자동 닫기 비활성화</li>
<li>시스템 데이터베이스를 포함한 모든 데이터베이스를 데이터 디스크로 이동</li>
<li>SQL Server 오류 로그 및 추적 파일 디렉터리를 데이터 디스크로 이동</li>
<li>최대 SQL Server 메모리 제한 설정</li>
<li>메모리의 페이지 잠금 활성화</li>
<li>OLTP 중심 환경을 위한 임시 워크로드 최적화 활성화</li>
<li>쿼리 스토어 활성화</li>
<li>DBCC CHECKDB, 인덱스 재구성, 인덱스 재구축 및 통계 업데이트 작업을 실행하도록 SQL Server Agent 작업 예약</li>
<li>트랜잭션 로그 파일의 상태 및 크기 모니터링 및 관리</li>
</ul>
</section>
</section>
</section>
<section id="explain-high-availability-and-disaster-recovery-options" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="explain-high-availability-and-disaster-recovery-options"><span class="header-section-number">2</span> <a href="https://learn.microsoft.com/en-us/training/modules/deploy-iaas-solutions-with-azure-sql/5-explain-high-availability-and-disaster-recovery-options">Explain high availability and disaster recovery options</a></h2>
<p>Azure 플랫폼의 고가용성 옵션:</p>
<ol type="1">
<li>기본 제공 고가용성
<ul>
<li>VM과 PaaS 워크로드에 기본적으로 제공</li>
</ul></li>
<li>추가 고가용성 옵션
<ul>
<li>가용성 영역(Availability Zones)</li>
<li>가용성 집합(Availability Sets)</li>
</ul></li>
<li>주요 보호 기능
<ul>
<li>계획된 유지보수 활동으로부터 보호</li>
<li>잠재적인 하드웨어 장애로부터 보호</li>
<li>더 높은 수준의 가용성 제공</li>
</ul></li>
</ol>
<section id="high-availability-options" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="high-availability-options"><span class="header-section-number">2.1</span> High availability options</h3>
<p>SQL Server 고가용성 솔루션의 Azure VM 지원:</p>
<ul>
<li>Azure 전용 솔루션
<ul>
<li>전체 HADR 시스템이 Azure에서 실행</li>
<li>완전한 클라우드 기반 운영 가능</li>
</ul></li>
<li>하이브리드 구성
<ul>
<li>일부는 Azure에서 실행</li>
<li>일부는 온프레미스에서 실행</li>
<li>유연한 구성 가능</li>
</ul></li>
<li>Azure 환경의 장점
<ul>
<li>예산에 맞춘 단계적 마이그레이션 가능</li>
<li>HADR 요구사항에 따른 유연한 구성</li>
<li>부분 또는 완전 마이그레이션 선택 가능</li>
</ul></li>
</ul>
<section id="availability-zones" class="level4">
<h4 class="anchored" data-anchor-id="availability-zones">Availability Zones</h4>
<section id="가용성-영역-개요" class="level5">
<h5 class="anchored" data-anchor-id="가용성-영역-개요">가용성 영역 개요</h5>
<ul>
<li>한 지역 내의 고유한 물리적 위치</li>
<li>각 영역은 독립적인 전원, 냉각, 네트워킹을 갖춘 데이터센터로 구성</li>
<li>지원되는 Azure 지역마다 3개의 가용성 영역 제공</li>
</ul>
</section>
<section id="가용성-영역-특징" class="level5">
<h5 class="anchored" data-anchor-id="가용성-영역-특징">가용성 영역 특징</h5>
<ul>
<li>VM 생성 시 배치할 영역 지정 가능</li>
<li>여러 VM을 다른 영역에 분산 배포하여 데이터센터 장애 대비</li>
<li>Microsoft는 한 번에 하나의 영역만 업데이트 (업데이트 도메인 사용)</li>
<li>VM 에코시스템을 3개 영역에 분산 가능</li>
</ul>
</section>
<section id="가용성-영역-장점" class="level5">
<h5 class="anchored" data-anchor-id="가용성-영역-장점">가용성 영역 장점</h5>
<ul>
<li>가동 시간 99.99% 보장 (연간 최대 52.60분 다운타임)</li>
<li>애플리케이션에 가장 높은 수준의 가용성 제공</li>
<li>docs.microsoft.com에서 지원 지역 확인 가능</li>
</ul>
</section>
<section id="가용성-영역-배포" class="level5">
<h5 class="anchored" data-anchor-id="가용성-영역-배포">가용성 영역 배포</h5>
<ul>
<li>Zone 1, 2, 3 중 선택하여 배포 가능</li>
<li>물리적 데이터센터의 논리적 표현</li>
<li>구독별로 Zone 번호가 다른 데이터센터를 나타낼 수 있음</li>
</ul>
</section>
<section id="사용-조건" class="level5">
<h5 class="anchored" data-anchor-id="사용-조건">사용 조건</h5>
<ul>
<li>해당 지역에서 가용성 영역 지원 필요</li>
<li>애플리케이션이 최소한의 영역 간 지연 시간 지원 필요</li>
</ul>
</section>
</section>
<section id="availability-sets" class="level4">
<h4 class="anchored" data-anchor-id="availability-sets">Availability Sets</h4>
<section id="가용성-집합-개요" class="level5">
<h5 class="anchored" data-anchor-id="가용성-집합-개요">가용성 집합 개요</h5>
<ul>
<li>가용성 영역과의 차이점
<ul>
<li>가용성 영역: 지역의 데이터 센터에 워크로드 분산</li>
<li>가용성 집합: 데이터 센터 내의 서버와 랙에 워크로드 분산</li>
</ul></li>
</ul>
</section>
<section id="주요-특징" class="level5">
<h5 class="anchored" data-anchor-id="주요-특징">주요 특징</h5>
<ul>
<li>VM 분산 배치 보장
<ul>
<li>Always On 가용성 그룹 멤버 VM들이 서로 다른 물리적 호스트에서 실행되도록 보장</li>
<li>Azure의 대부분 워크로드가 가상화되어 있어 효과적</li>
</ul></li>
</ul>
</section>
<section id="성능-및-사용-조건" class="level5">
<h5 class="anchored" data-anchor-id="성능-및-사용-조건">성능 및 사용 조건</h5>
<ul>
<li>가용성 보장
<ul>
<li>최대 99.95%의 가용성 제공</li>
</ul></li>
<li>사용 시나리오
<ul>
<li>가용성 영역을 사용할 수 없는 지역</li>
<li>애플리케이션이 영역 내 지연 시간을 허용할 수 없는 경우</li>
</ul></li>
</ul>
</section>
</section>
<section id="always-on-availability-groups-ag" class="level4">
<h4 class="anchored" data-anchor-id="always-on-availability-groups-ag">Always On availability groups (AG)</h4>
<ul>
<li>구현 범위
<ul>
<li>Azure 가상 머신에서 실행되는 두 개 이상(최대 9개)의 SQL Server 인스턴스 간</li>
<li>온프레미스 데이터 센터와 Azure 간 구현 가능</li>
</ul></li>
<li>작동 방식
<ul>
<li>데이터베이스 트랜잭션이 기본 복제본에 커밋</li>
<li>동기식 또는 비동기식으로 모든 보조 복제본으로 전송</li>
</ul></li>
<li>가용성 모드 선택 기준
<ul>
<li>서버 간 물리적 거리에 따라 결정</li>
<li>비동기식 가용성 모드 권장 상황:
<ul>
<li>워크로드가 낮은 지연 시간 요구</li>
<li>보조 복제본이 지리적으로 분산된 경우</li>
</ul></li>
<li>동기식 커밋 모드 권장 상황:
<ul>
<li>복제본이 동일한 Azure 지역 내 위치</li>
<li>애플리케이션이 일정 수준의 지연 시간 허용 가능</li>
</ul></li>
</ul></li>
<li>동기식 모드 특징
<ul>
<li>각 트랜잭션이 하나 이상의 보조 복제본에 커밋된 후 애플리케이션 진행</li>
</ul></li>
<li>장점
<ul>
<li>단일 가용성 그룹이 동기식과 비동기식 가용성 모드 모두 지원</li>
<li>고가용성과 재해 복구 동시 제공</li>
<li>장애 조치 단위는 데이터베이스 그룹(전체 인스턴스가 아님)</li>
</ul></li>
<li>재해 복구 기능
<ul>
<li>Azure 지역 전체에 걸쳐 최대 9개의 데이터베이스 복제본 구현 가능</li>
<li>분산 가용성 그룹을 통한 아키텍처 확장 가능</li>
<li>기본 지역 외 다른 위치에 데이터베이스 실행 가능한 복사본 보장</li>
<li>자연 재해와 인위적 재해로부터 데이터 생태계 보호</li>
</ul></li>
<li>구성 예시
<ul>
<li>Windows Server 장애 조치 클러스터에서 실행</li>
<li>하나의 기본 복제본과 4개의 보조 복제본 구성 가능</li>
<li>모든 복제본이 동기식이거나, 동기식과 비동기식 복제본 조합 가능</li>
<li>장애 조치 단위는 데이터베이스 그룹(인스턴스가 아님)</li>
<li>장애 조치 클러스터 인스턴스는 인스턴스 수준 HA 제공(재해 복구는 제공하지 않음)</li>
</ul></li>
</ul>
</section>
<section id="sql-server-failover-cluster-instances" class="level4">
<h4 class="anchored" data-anchor-id="sql-server-failover-cluster-instances">SQL Server Failover Cluster instances</h4>
<ul>
<li>SQL Server 장애 조치 클러스터 인스턴스(FCI) 개요
<ul>
<li>전체 인스턴스 보호를 위한 솔루션</li>
<li>단일 지역에서 전체 인스턴스에 대한 고가용성 제공</li>
<li>단독으로는 재해 복구 기능 제공하지 않음
<ul>
<li>가용성 그룹이나 로그 전달과 같은 기능과 결합 필요</li>
</ul></li>
<li>공유 스토리지 요구사항 존재
<ul>
<li>Azure에서 공유 파일 스토리지 사용 가능</li>
<li>Windows Server의 Storage Spaces Direct 활용 가능</li>
</ul></li>
</ul></li>
<li>Azure 환경에서의 FCI 고려사항
<ul>
<li>새로운 배포에서는 가용성 그룹이 선호됨
<ul>
<li>FCI의 공유 스토리지 요구사항이 배포 복잡성 증가</li>
</ul></li>
<li>온프레미스 솔루션 마이그레이션 시 FCI 필요 가능성
<ul>
<li>기존 애플리케이션 지원을 위한 요구사항 고려</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="disaster-recovery-options" class="level4">
<h4 class="anchored" data-anchor-id="disaster-recovery-options">Disaster Recovery options</h4>
<ul>
<li>Azure 플랫폼 기본 특성
<ul>
<li>기본적으로 99.9%의 가동 시간 제공</li>
<li>재해 발생 가능성 여전히 존재</li>
<li>애플리케이션 가동 시간에 영향을 미칠 수 있음</li>
</ul></li>
<li>재해 복구 계획의 중요성
<ul>
<li>마이그레이션 수행 시 적절한 계획 수립 필요</li>
<li>데이터 및 서비스 연속성 보장</li>
</ul></li>
<li>Azure의 SQL Server 보호 방법 (두 가지 구성 요소)
<ul>
<li>Azure 플랫폼 옵션
<ul>
<li>지역 복제 스토리지 (백업용)</li>
<li>Azure Site Recovery (포괄적인 재해 복구 솔루션)</li>
</ul></li>
<li>SQL Server 전용 기능
<ul>
<li>가용성 그룹(Availability Groups)</li>
<li>네이티브 백업 기능</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="native-sql-server-backups" class="level4">
<h4 class="anchored" data-anchor-id="native-sql-server-backups">Native SQL Server backups</h4>
<ul>
<li>백업의 중요성
<ul>
<li>모든 데이터베이스 관리자에게 있어 생명줄과 같은 역할</li>
<li>클라우드 솔루션에서도 동일하게 중요</li>
</ul></li>
<li>Azure VM의 SQL Server 백업 특징
<ul>
<li>백업 시기와 저장 위치에 대한 세밀한 제어 가능</li>
<li>SQL 에이전트 작업을 통한 Azure blob 스토리지 직접 백업 지원</li>
<li>URL을 통한 백업 연결 방식 제공</li>
</ul></li>
<li>Azure 스토리지 옵션
<ul>
<li>지역 중복 스토리지(GRS) 제공</li>
<li>읽기 액세스 지역 중복 스토리지(RA-GRS) 제공</li>
<li>지리적으로 분산된 환경에서 백업 파일 안전 보장</li>
</ul></li>
<li>자동화 옵션
<ul>
<li>Azure SQL VM 서비스 제공자를 통한 자동 백업 관리 가능</li>
<li>플랫폼 수준의 백업 자동화 지원</li>
</ul></li>
</ul>
</section>
<section id="azure-backup-for-sql-server" class="level4">
<h4 class="anchored" data-anchor-id="azure-backup-for-sql-server">Azure Backup for SQL Server</h4>
<ul>
<li>기본 구성 요소
<ul>
<li>가상 머신에 에이전트 설치 필요</li>
<li>SQL Server 데이터베이스의 자동 백업 관리</li>
<li>Azure 서비스와 에이전트 간 통신</li>
</ul></li>
<li>주요 기능
<ul>
<li>지정된 RPO/RTO 메트릭 충족 관리</li>
<li>백업 모니터링을 위한 중앙 집중식 인터페이스 제공</li>
<li>장기 데이터 보존 지원</li>
<li>자동화된 백업 관리 기능</li>
<li>추가적인 데이터 보호 기능</li>
</ul></li>
<li>비용 및 가치
<ul>
<li>직접 백업보다 높은 비용</li>
<li>SQL Server용 Azure 리소스 공급자보다 비용 증가</li>
<li>더 포괄적인 엔터프라이즈 백업 솔루션 제공</li>
<li>완벽한 백업 기능 세트 제공</li>
</ul></li>
</ul>
</section>
<section id="azure-site-recovery" class="level4">
<h4 class="anchored" data-anchor-id="azure-site-recovery">Azure Site Recovery</h4>
<ul>
<li>개요
<ul>
<li>Azure 가상 머신의 블록 수준 복제를 수행하는 저비용 솔루션</li>
<li>재해 복구 전략을 테스트하고 검증할 수 있는 다양한 기능 제공</li>
</ul></li>
<li>적합한 사용 환경
<ul>
<li>상태가 없는 환경(예: 웹 서버)에 가장 적합</li>
<li>트랜잭션 데이터베이스 가상 머신에는 덜 적합</li>
</ul></li>
<li>SQL Server와 함께 사용 시 고려사항
<ul>
<li>더 높은 복구 지점 설정 필요 (잠재적 데이터 손실 의미)</li>
<li>RTO(복구 시간 목표)가 본질적으로 RPO(복구 지점 목표)가 됨</li>
</ul></li>
<li>작동 프로세스
<ul>
<li>VM이 Azure Site Recovery에 등록</li>
<li>데이터가 캐시로 지속적으로 복제</li>
<li>캐시가 대상 스토리지 계정으로 복제</li>
<li>장애 조치(failover) 중에 가상 머신이 대상 환경에 추가</li>
</ul></li>
</ul>


</section>
</section>
</section>

 ]]></description>
  <category>Engineering</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Engineering/data_engineering/2.IaaS.html</guid>
  <pubDate>Wed, 02 Apr 2025 15:00:00 GMT</pubDate>
</item>
<item>
  <title>Azure 가상 머신의 SQL Server</title>
  <dc:creator>Kwangmin Kim</dc:creator>
  <link>kk3225.netlify.app/docs/blog/posts/Engineering/data_engineering/1.azure_server_based_db_management.html</link>
  <description><![CDATA[ 




<section id="microsoft-intelligent-data-platform-역할-설명" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="microsoft-intelligent-data-platform-역할-설명"><span class="header-section-number">1</span> <a href="https://learn.microsoft.com/ko-kr/training/modules/prepare-to-maintain-sql-databases-azure/2-describe-azure-data-platform-roles">Microsoft Intelligent Data Platform 역할 설명</a></h2>
<p>Microsoft는 클라우드(Microsoft Intelligent Data Platform 서비스 활용) 데이터 관련 업무를 위한 5가지 주요 역할을 정의하고 있다:</p>
<ol type="1">
<li>Azure 데이터베이스 관리자
<ul>
<li>Azure 데이터 서비스와 SQL Server 기반 데이터 플랫폼 솔루션 관리 (데이터 관리, 모니터링, 보안 및 개인정보 보호 설계)</li>
<li>T-SQL을 활용한 일상적인 운영 및 관리 작업 수행</li>
</ul></li>
<li>Azure 데이터 분석가
<ul>
<li>Microsoft Power BI를 사용</li>
<li>확장 가능한 데이터 모델을 설계 및 구축하고, 데이터를 정리 및 변환하며, 이해하기 쉬운 데이터 시각화</li>
</ul></li>
<li>Azure 데이터 분석가
<ul>
<li>Power BI를 활용한 데이터 모델링 및 시각화</li>
<li>데이터 정제/변환을 통한 비즈니스 인사이트 도출</li>
</ul></li>
<li>Azure 데이터 과학자
<ul>
<li>Azure Machine Learning 기반 ML 워크로드 구현</li>
<li>데이터 과학/머신러닝 지식 활용</li>
</ul></li>
<li>Azure 인공지능 엔지니어
<ul>
<li>Cognitive Services, ML, Knowledge Mining 활용</li>
<li>자연어처리, 음성, 컴퓨터 비전, 봇 등 AI 솔루션 구현</li>
</ul></li>
</ol>
</section>
<section id="azure-vm의-sql-server" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="azure-vm의-sql-server"><span class="header-section-number">2</span> <a href="https://learn.microsoft.com/ko-kr/training/modules/prepare-to-maintain-sql-databases-azure/3-understand-sql-server-azure-virtual-machine">Azure VM의 SQL Server</a></h2>
<section id="azure-가상-머신의-sql-server-특징-백업-고가용성" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="azure-가상-머신의-sql-server-특징-백업-고가용성"><span class="header-section-number">2.1</span> Azure 가상 머신의 SQL Server: 특징, 백업, 고가용성</h3>
<ul>
<li>Azure 가상 머신에서 실행되는 SQL Server(IaaS)는 온프레미스 SQL Server와 동등</li>
<li>가상 머신에서 SQL Server를 선택하는 주요 이유:</li>
</ul>
<ol type="1">
<li><strong>애플리케이션 호환성</strong>: 특정 버전의 SQL Server가 필요하거나 PaaS와 호환되지 않는 설치 요구사항이 있는 경우</li>
<li><strong>다양한 SQL Server 서비스 활용</strong>: SQL Server Analysis Services(SSAS), Integration Services(SSIS), Reporting Services(SSRS)를 데이터베이스 엔진과 함께 실행할 수 있음</li>
</ol>
</section>
<section id="백업-솔루션" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="백업-솔루션"><span class="header-section-number">2.2</span> 백업 솔루션</h3>
<p>최근 SQL Server 릴리스에서는 다음 두 가지 주요 백업 기능을 제공: - <strong>URL로 백업</strong>: Azure Blob Storage 서비스에 데이터베이스를 백업 * Azure Blob Storage란? * Blob (Binary Large Object): 이미지, 오디오, 비디오, 문서 등과 같은 대용량 비정형 데이터를 저장하는 데 사용되는 데이터 형식 * Azure의 클라우드 기반 스토리지 서비스 * 비교적 저렴한 비용으로 높은 가용성, 내구성, 확장성을 제공 * 데이터 암호화, 보안, 백업 등 다양한 기능 제공 * <strong>Azure Backup</strong>: SQL Server VM을 위한 포괄적인 엔터프라이즈 백업 솔루션</p>
</section>
<section id="배포-옵션" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="배포-옵션"><span class="header-section-number">2.3</span> 배포 옵션</h3>
<ul>
<li>Azure의 모든 리소스는 Azure Resource Manager를 통해 관리되고 배포</li>
<li>최종적으로 JSON 문서인 Azure Resource Manager 템플릿으로 변환됨</li>
<li>대규모 배포에는 선언적 접근 방식이 권장됨</li>
</ul>
</section>
<section id="azure-스토리지-개요" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="azure-스토리지-개요"><span class="header-section-number">2.4</span> Azure 스토리지 개요</h3>
<p>SQL Server 운영 환경에서는 다음 4가지 스토리지 유형 제공:</p>
<ul>
<li><strong>Standard HDD</strong>: 비용 절감을 위해 사용, 데이터베이스 백업에는 표준 스토리지를 사용</li>
<li><strong>Standard SSD</strong>: 비교적 빠른 속도와 비교적 저렴한 비용</li>
<li><strong>Premium SSD</strong>: 5-10ms 지연 시간</li>
<li><strong>Ultra Disk</strong>: 1-2ms 지연 시간(최적화 시 1ms 미만 가능)</li>
</ul>
</section>
<section id="azure의-high-availability" class="level3" data-number="2.5">
<h3 data-number="2.5" class="anchored" data-anchor-id="azure의-high-availability"><span class="header-section-number">2.5</span> Azure의 High Availability</h3>
<ul>
<li>Azure 플랫폼은 fault tolerance을 갖추고 있으며 서비스 중단과 일시적 오류로부터 빠르게 복구됨</li>
<li>Premium SSD 또는 Ultra Disk를 사용하는 단일 인스턴스 Azure 가상 머신의 경우 최소 99.9%(1년의 0.01%인 약 9시간 정도의 가동 중단 리스크)의 가동 시간을 보장</li>
<li>가용성 집합, 가용성 영역, 부하 분산 기술을 통해 high availability을 제공</li>
</ul>
</section>
<section id="azure-arc-지원-sql-server" class="level3" data-number="2.6">
<h3 data-number="2.6" class="anchored" data-anchor-id="azure-arc-지원-sql-server"><span class="header-section-number">2.6</span> Azure Arc 지원 SQL Server</h3>
<ul>
<li>Azure Arc는 Azure 관리 기능을 온프레미스, 다른 클라우드 또는 엣지에서 실행되는 SQL Server 인스턴스로 확장</li>
<li>Azure Arc를 통해 기존 SQL Server를 Azure로 이전하지 않고도 일관된 정책 적용, 규정 준수, Azure Monitor 및 Security Center 활용이 가능</li>
<li>중앙 집중식 관리, 자동 업데이트, 백업 및 복원, 재해 복구와 같은 고급 기능을 활용할 수 있으며, Azure의 머신러닝과 AI 기능도 기존 데이터에 적용 가능</li>
</ul>
</section>
</section>
<section id="클라우드-기반-azure-sql-database-설계" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="클라우드-기반-azure-sql-database-설계"><span class="header-section-number">3</span> <a href="https://learn.microsoft.com/ko-kr/training/modules/prepare-to-maintain-sql-databases-azure/4-design-azure-sql-database-for-cloud-native-applications">클라우드 기반 Azure SQL Database 설계</a></h2>
<p>Azure SQL Database는 PaaS(Platform as a Service) 형태로 제공되는 고확장성 데이터베이스 서비스로, 최소한의 유지 관리로 특정 워크로드에 최적화되어 있다. 개발자에게 유연성과 세분화된 배포 옵션을 제공하여 새로운 애플리케이션 개발에 적합하다.</p>
<section id="구매-모델" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="구매-모델"><span class="header-section-number">3.1</span> 구매 모델</h3>
<section id="vcore-기반-모델" class="level4">
<h4 class="anchored" data-anchor-id="vcore-기반-모델">1. vCore 기반 모델</h4>
<ul>
<li>컴퓨팅과 스토리지 리소스를 독립적으로 확장 가능</li>
<li>서비스 Tier:
<ul>
<li><strong>범용(General Purpose)</strong>: 덜 집약적인 작업용, 프로비저닝 및 서버리스 컴퓨팅 계층 제공</li>
<li><strong>비즈니스 크리티컬(Business Critical)</strong>: In-Memory OLTP, 읽기 전용 복제본, 로컬 SSD 지원
<ul>
<li>OLTP: In-Memory OLTP(Online Transaction Processing)는 Microsoft SQL Server에서 제공하는 메모리 최적화 기술</li>
<li>이 기술은 데이터베이스 테이블과 저장 프로시저를 메인 메모리(RAM)에 저장하여 디스크 I/O 작업을 최소화함으로써 트랜잭션 처리 성능을 크게 향상</li>
<li>주요 특징
<ul>
<li>데이터를 디스크가 아닌 메모리에 저장하여 액세스 속도 향상</li>
<li>락(lock)이나 래치(latch) 없는 동시성 제어 메커니즘으로 경합 감소</li>
<li>높은 처리량과 낮은 지연 시간이 필요한 트랜잭션 중심 애플리케이션에 적합</li>
</ul></li>
</ul></li>
<li><strong>하이퍼스케일(Hyperscale)</strong>: 수평적 확장 기능, 대규모 데이터 처리에 적합</li>
</ul></li>
</ul>
</section>
<section id="dtu-기반-모델" class="level4">
<h4 class="anchored" data-anchor-id="dtu-기반-모델">2. DTU 기반 모델</h4>
<ul>
<li>컴퓨팅과 스토리지가 DTU 수준에 종속
<ul>
<li>DTU(Database Transaction Unit): Azure SQL Database에서 사용하는 성능 측정 단위</li>
<li>Microsoft가 개발한 이 단위는 CPU, 메모리, 데이터 I/O 및 트랜잭션 로그 I/O의 혼합된 측정값으로, 데이터베이스 성능을 단일 값으로 표현</li>
<li>DTU 기반 구매 모델에서는 데이터베이스에 특정 DTU 레벨을 할당하며, 이 레벨은 해당 데이터베이스가 사용할 수 있는 컴퓨팅 및 스토리지 리소스의 양을 결정 (DTU 계층에 따라 성능과 비용이 증가)</li>
<li>이 모델은 vCore 모델과 달리 컴퓨팅과 스토리지가 함께 묶여 있어, 스토리지만 늘리고 싶어도 DTU 수준을 전체적으로 올려야 하는 단점이 있다.</li>
</ul></li>
<li>Basic, Standard, and Premium 세 가지 서비스 tier 제공</li>
<li>스토리지 한도 도달 시 컴퓨팅 사용률과 무관하게 DTU 증가 필요</li>
</ul>
</section>
</section>
<section id="서버리스-컴퓨팅" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="서버리스-컴퓨팅"><span class="header-section-number">3.2</span> 서버리스 컴퓨팅</h3>
<ul>
<li>자동 확장 및 일시 중지 기능을 제공하여 개발/테스트 환경의 비용 절감에 효과적</li>
<li>워크로드에 따라 동적으로 확장되며 비활성 상태일 때는 자동으로 일시 중지되어 스토리지 비용만 발생</li>
</ul>
</section>
<section id="배포-모델" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="배포-모델"><span class="header-section-number">3.3</span> 배포 모델</h3>
<section id="단일-데이터베이스" class="level4">
<h4 class="anchored" data-anchor-id="단일-데이터베이스">1.단일 데이터베이스</h4>
<ul>
<li>각 데이터베이스를 개별적으로 관리</li>
<li>동일 서버에 배포되어도 각 데이터베이스는 전용 리소스 보유</li>
<li>Azure 포털을 통한 리소스 모니터링 가능</li>
</ul>
</section>
<section id="탄력적-풀" class="level4">
<h4 class="anchored" data-anchor-id="탄력적-풀">2.탄력적 풀</h4>
<ul>
<li>여러 데이터베이스가 리소스를 공유하는 모델</li>
<li>개별 데이터베이스 스케일링이 불필요해 관리 용이</li>
<li>SaaS 애플리케이션에 비용 효율적</li>
<li>사용률이 낮은 멀티테넌트 환경에 적합</li>
</ul>
</section>
</section>
<section id="주요-기능" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="주요-기능"><span class="header-section-number">3.4</span> 주요 기능</h3>
<section id="네트워크-옵션" class="level4">
<h4 class="anchored" data-anchor-id="네트워크-옵션">네트워크 옵션</h4>
<p>방화벽 규칙, 가상 네트워크 엔드포인트, Private Link 등으로 액세스 제어가 가능</p>
</section>
<section id="백업-및-복원" class="level4">
<h4 class="anchored" data-anchor-id="백업-및-복원">백업 및 복원</h4>
<p>Azure는 SQL Database 및 SQL Managed Instance에 대한 원활한 백업 및 복원 기능을 제공</p>
<ul>
<li><strong>지속적 백업(seamless backup)</strong>: 정기적인 백업과 지역 중복 스토리지, 전체 백업은 매주 수행되고, 차등 백업은 12~24시간마다 수행되며, 트랜잭션 로그 백업은 5~10분마다 수행됨</li>
<li><strong>지역 복원(geo-restore)</strong>: 다른 지리적 지역으로 복원 가능, 덜 엄격한 재해 복구 시나리오에 특히 유용</li>
<li><strong>시점 복원(PITR, point-in-time restore)</strong>: 특정 시점 복원 가능, 1-35일 보존 기간 설정 가능, 실제로 지정하지 않으면 기본 구성은 7일</li>
<li><strong>장기 보존(LTR, long-term retention)</strong>: 최대 10년까지 보존 정책 설정, 이 옵션은 기본적으로 사용하지 않도록 설정</li>
</ul>
</section>
<section id="자동-튜닝" class="level4">
<h4 class="anchored" data-anchor-id="자동-튜닝">자동 튜닝</h4>
<p>머신러닝 기반으로 쿼리 성능을 자동 최적화 - 비용 많은 쿼리 식별 - 실행 계획 최적화 - 인덱스 추가/제거 기능</p>
</section>
<section id="탄력적-쿼리-및-작업" class="level4">
<h4 class="anchored" data-anchor-id="탄력적-쿼리-및-작업">탄력적 쿼리 및 작업</h4>
<ul>
<li>여러 데이터베이스에 걸친 쿼리 실행과 유지 관리 작업 자동화를 지원</li>
<li>여러 데이터베이스를 연결하는 T-SQL 쿼리를 실행 가능하고 이 기능은 변경할 수 없는 세 부분 및 네 부분으로 된 이름을 사용하는 애플리케이션에 유용</li>
<li>마이그레이션을 허용하기 때문에 이식성이 향상</li>
<li>다음 분할 전략을 지원
<ul>
<li>수직 분할: 데이터베이스 간 쿼리라고도 합니다. 데이터는 여러 데이터베이스 간에 세로로 분할 (컬럼 단위 분할도 가능).</li>
<li>가로 분할: 데이터는 여러 확장된 데이터베이스에 행을 분산하기 위해 수평(행또는 record 단위)으로 분할</li>
</ul></li>
</ul>
</section>
<section id="microsoft-fabric-통합" class="level4">
<h4 class="anchored" data-anchor-id="microsoft-fabric-통합">Microsoft Fabric 통합</h4>
<ul>
<li>Microsoft 생태계와 완벽하게 통합되어 데이터 워크플로 간소화, 협업 강화, 고급 분석 지원 등의 이점을 제공</li>
<li>Microsoft Fabric은 모든 데이터 및 분석 요구 사항을 위한 통합 플랫폼
<ul>
<li>Microsoft의 SaaS(Software as a Service) 분석 제품군</li>
<li>Power BI, Azure Synapse Analytics, Azure Data Factory 등의 Microsoft 서비스를 하나의 통합된 환경으로 결합</li>
</ul></li>
<li>주요 특징:
<ul>
<li>데이터 수집, 처리, 저장, 분석, 시각화를 위한 end-to-end 솔루션</li>
<li>공통 데이터 저장소인 OneLake를 중심으로 구축</li>
<li>다양한 워크로드 지원: 데이터 엔지니어링, 데이터 과학, 실시간 분석, BI 등</li>
<li>통합된 거버넌스 및 보안 모델</li>
<li>Microsoft 365와 긴밀한 통합</li>
<li>Fabric은 SQL Database와 같은 여러 데이터 서비스를 통합하여 조직이 데이터 사일로를 제거하고 더 효율적으로 데이터를 활용하도록 지원</li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="azure-sql-managed-instance" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="azure-sql-managed-instance"><span class="header-section-number">4</span> <a href="https://learn.microsoft.com/ko-kr/training/modules/prepare-to-maintain-sql-databases-azure/5-explore-azure-sql-database-managed-instance">Azure SQL Managed Instance</a></h2>
<p>Azure SQL Managed Instance는 Azure SQL Database와 많은 공통 코드를 공유하는 완전 관리형 PaaS 솔루션으로 SQL Server 잘 작동하는 완전 관리형 데이터베이스 서비스</p>
<section id="주요-이점" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="주요-이점"><span class="header-section-number">4.1</span> 주요 이점</h3>
<ul>
<li>자동 백업 및 패치</li>
<li>기본 제공 고가용성(99.99% 가동시간 보장, 년간 52분 가동 중단 시간 허용 리스크)</li>
<li>보안 및 성능 도구</li>
<li>통합 감사 기능</li>
<li>SQL Server 설치 및 패치 불필요로 유지 관리 감소</li>
</ul>
</section>
<section id="sql-database와의-차별점" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="sql-database와의-차별점"><span class="header-section-number">4.2</span> SQL Database와의 차별점</h3>
<p>SQL Database가 단일 데이터베이스 중심인 반면, SQL Managed Instance는 다음을 지원: - 데이터베이스 간 쿼리 - CLR(Common Language Runtime, 공통 언어 런타임) - 다양한 .NET 언어(C#, Visual Basic .NET 등)로 작성된 코드를 SQL Server 내에서 실행 가능 - 스토어드 프로시저, 트리거, 사용자 정의 함수, 사용자 정의 형식, 사용자 정의 집계 등을 .NET 언어로 작성 가능 - T-SQL로 구현하기 어려운 복잡한 비즈니스 로직, 문자열 처리, 수학 계산 등을 효율적으로 처리 가능 - T-SQL(Transact-SQL): Microsoft SQL Server에서 사용되는, SQL(Structured Query Language)의 확장 버전 - 외부 리소스(파일 시스템, 네트워크 등)에 접근하는 코드 실행 가능 - 시스템 데이터베이스 액세스 - SQL 에이전트 기능 - Microsoft SQL Server의 작업 자동화 서비스 - 작업 예약, 작업 모니터링, 작업 로깅 등 다양한 기능 제공</p>
</section>
<section id="하이브리드-라이선스-옵션" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="하이브리드-라이선스-옵션"><span class="header-section-number">4.3</span> 하이브리드 라이선스 옵션</h3>
<ul>
<li>Active Software Assurance가 있는 기존 라이선스를 활용해 PaaS(SQL Database 및 SQL Managed Instance) 비용 절감(최대 40%)
<ul>
<li>Enterprise Edition: 코어당 비즈니스 크리티컬 vCore 1개 또는 범용 vCore 8개</li>
<li>Standard Edition: 코어당 범용 vCore 1개</li>
</ul></li>
</ul>
</section>
<section id="connectivity-architecture" class="level3" data-number="4.4">
<h3 data-number="4.4" class="anchored" data-anchor-id="connectivity-architecture"><span class="header-section-number">4.4</span> Connectivity Architecture</h3>
<ul>
<li>SQL Managed Instance에 대한 연결은 TDS 엔드포인트를 통한 연결
<ul>
<li>TDS(Tabular Data Stream)는 Microsoft SQL Server 및 Sybase에서 클라이언트와 데이터베이스 서버 간의 통신에 사용되는 네트워크 프로토콜</li>
</ul></li>
<li>고가용성 방식으로 배포된 게이트웨이 구성 요소</li>
<li>자동화된 백업(지역 중복 및 자동 복제)</li>
<li>자동 장애 조치 그룹 지원</li>
</ul>
</section>
<section id="migration-options" class="level3" data-number="4.5">
<h3 data-number="4.5" class="anchored" data-anchor-id="migration-options"><span class="header-section-number">4.5</span> Migration Options</h3>
<ol type="1">
<li><strong>Log 재생 서비스</strong>: 온라인 마이그레이션, 세부 제어 가능</li>
<li><strong>Azure Data Studio 확장</strong>: 준비 상태 평가, 리소스 추천, 중소규모 DB에 적합</li>
<li><strong>Managed Instance 링크</strong>: 분산 가용성 그룹 사용, 즉시 데이터 복제</li>
<li><strong>네이티브 백업 및 복원</strong>: 간단한 마이그레이션 방법</li>
<li><strong>트랜잭션 복제</strong>: 대규모 DB의 온/오프라인 마이그레이션에 적합</li>
</ol>
</section>
<section id="machine-learning-services" class="level3" data-number="4.6">
<h3 data-number="4.6" class="anchored" data-anchor-id="machine-learning-services"><span class="header-section-number">4.6</span> Machine Learning Services</h3>
<ul>
<li>Python 및 R 패키지 지원</li>
<li>데이터 이동 없이 기계 학습 모델 학습 및 배포</li>
<li>T-SQL 저장 프로시저를 통한 모델 배포</li>
<li>scikit-learn, PyTorch, TensorFlow 등 오픈소스 라이브러리 지원</li>
<li>T-SQL PREDICT 함수로 예측 가속화</li>
<li><code>sp_configure 'external scripts enabled', 1;</code> 명령으로 활성화</li>
</ul>


</section>
</section>

 ]]></description>
  <category>Engineering</category>
  <guid>kk3225.netlify.app/docs/blog/posts/Engineering/data_engineering/1.azure_server_based_db_management.html</guid>
  <pubDate>Tue, 01 Apr 2025 15:00:00 GMT</pubDate>
</item>
</channel>
</rss>
