<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="AI Agent를 지속적으로 생산하는 플랫폼 구축 시 직면하는 저장소 전략 문제를 실증 데이터와 산업 사례를 기반으로 분석한다. Monorepo와 Multi-repo의 trade-off를 정량적으로 비교하고, 팀 역량과 프로젝트 단계를 고려한 최적의 전환 전략을 제시한다. Google, Uber, Airbnb 등의 실제 사례를 통해 공통 모듈 재사용률, 개발 속도, 기술 부채 관리 측면에서의 구체적인 근거를 제공하며, 안전하게 확장 가능한 플랫폼 아키텍처 설계 방법론을 다룬다.">

<title>Kwangmin Kim - AI Agent 플랫폼 저장소 전략: Monorepo에서 MSA로의 점진적 전환</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../../../">
<script src="../../../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - AI Agent 플랫폼 저장소 전략: Monorepo에서 MSA로의 점진적 전환">
<meta property="og:description" content="AI Agent를 지속적으로 생산하는 플랫폼 구축 시 직면하는 저장소 전략 문제를 실증 데이터와 산업 사례를 기반으로 분석한다. Monorepo와 Multi-repo의 trade-off를 정량적으로 비교하고, 팀 역량과 프로젝트 단계를 고려한 최적의 전환 전략을 제시한다. Google, Uber, Airbnb 등의 실제 사례를 통해 공통 모듈 재사용률, 개발 속도, 기술 부채 관리 측면에서의 구체적인 근거를 제공하며, 안전하게 확장 가능한 플랫폼 아키텍처 설계 방법론을 다룬다.">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Kwangmin Kim - AI Agent 플랫폼 저장소 전략: Monorepo에서 MSA로의 점진적 전환">
<meta name="twitter:description" content="AI Agent를 지속적으로 생산하는 플랫폼 구축 시 직면하는 저장소 전략 문제를 실증 데이터와 산업 사례를 기반으로 분석한다. Monorepo와 Multi-repo의 trade-off를 정량적으로 비교하고, 팀 역량과 프로젝트 단계를 고려한 최적의 전환 전략을 제시한다. Google, Uber, Airbnb 등의 실제 사례를 통해 공통 모듈 재사용률, 개발 속도, 기술 부채 관리 측면에서의 구체적인 근거를 제공하며, 안전하게 확장 가능한 플랫폼 아키텍처 설계 방법론을 다룬다.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">AI Agent 플랫폼 저장소 전략: Monorepo에서 MSA로의 점진적 전환</h1>
            <p class="subtitle lead">초기 개발부터 성숙 단계까지의 아키텍처 진화 전략</p>
                  <div>
        <div class="description">
          <p>AI Agent를 지속적으로 생산하는 플랫폼 구축 시 직면하는 저장소 전략 문제를 실증 데이터와 산업 사례를 기반으로 분석한다. Monorepo와 Multi-repo의 trade-off를 정량적으로 비교하고, 팀 역량과 프로젝트 단계를 고려한 최적의 전환 전략을 제시한다. Google, Uber, Airbnb 등의 실제 사례를 통해 공통 모듈 재사용률, 개발 속도, 기술 부채 관리 측면에서의 구체적인 근거를 제공하며, 안전하게 확장 가능한 플랫폼 아키텍처 설계 방법론을 다룬다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Software Architecture</div>
                <div class="quarto-category">Platform Engineering</div>
                <div class="quarto-category">AI Agent</div>
                <div class="quarto-category">System Design</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2026년 01월 28일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#배경" id="toc-배경" class="nav-link active" data-scroll-target="#배경"><span class="header-section-number">1</span> 배경</a></li>
  <li><a href="#프로젝트-현황-분석" id="toc-프로젝트-현황-분석" class="nav-link" data-scroll-target="#프로젝트-현황-분석"><span class="header-section-number">2</span> 프로젝트 현황 분석</a>
  <ul class="collapse">
  <li><a href="#현재-상태" id="toc-현재-상태" class="nav-link" data-scroll-target="#현재-상태"><span class="header-section-number">2.1</span> 현재 상태</a></li>
  <li><a href="#주요-agent-특성" id="toc-주요-agent-특성" class="nav-link" data-scroll-target="#주요-agent-특성"><span class="header-section-number">2.2</span> 주요 Agent 특성</a></li>
  </ul></li>
  <li><a href="#세-ai의-공통-권장사항-monorepo-시작" id="toc-세-ai의-공통-권장사항-monorepo-시작" class="nav-link" data-scroll-target="#세-ai의-공통-권장사항-monorepo-시작"><span class="header-section-number">3</span> 세 AI의 공통 권장사항: Monorepo 시작</a>
  <ul class="collapse">
  <li><a href="#핵심-결론" id="toc-핵심-결론" class="nav-link" data-scroll-target="#핵심-결론"><span class="header-section-number">3.1</span> 핵심 결론</a></li>
  <li><a href="#정량적-근거" id="toc-정량적-근거" class="nav-link" data-scroll-target="#정량적-근거"><span class="header-section-number">3.2</span> 정량적 근거</a></li>
  </ul></li>
  <li><a href="#세-ai의-차별화된-관점" id="toc-세-ai의-차별화된-관점" class="nav-link" data-scroll-target="#세-ai의-차별화된-관점"><span class="header-section-number">4</span> 세 AI의 차별화된 관점</a>
  <ul class="collapse">
  <li><a href="#gemini-비즈니스-및-거버넌스" id="toc-gemini-비즈니스-및-거버넌스" class="nav-link" data-scroll-target="#gemini-비즈니스-및-거버넌스"><span class="header-section-number">4.1</span> Gemini: 비즈니스 및 거버넌스</a></li>
  <li><a href="#chatgpt-실무-엔지니어링" id="toc-chatgpt-실무-엔지니어링" class="nav-link" data-scroll-target="#chatgpt-실무-엔지니어링"><span class="header-section-number">4.2</span> ChatGPT: 실무 엔지니어링</a></li>
  <li><a href="#claude-학술적실증적" id="toc-claude-학술적실증적" class="nav-link" data-scroll-target="#claude-학술적실증적"><span class="header-section-number">4.3</span> Claude: 학술적·실증적</a></li>
  </ul></li>
  <li><a href="#단계별-리스크-평가" id="toc-단계별-리스크-평가" class="nav-link" data-scroll-target="#단계별-리스크-평가"><span class="header-section-number">5</span> 단계별 리스크 평가</a>
  <ul class="collapse">
  <li><a href="#옵션-1-처음부터-multi-repo-msa" id="toc-옵션-1-처음부터-multi-repo-msa" class="nav-link" data-scroll-target="#옵션-1-처음부터-multi-repo-msa"><span class="header-section-number">5.1</span> 옵션 1: 처음부터 Multi-repo (MSA)</a></li>
  <li><a href="#옵션-2-monorepo-시작" id="toc-옵션-2-monorepo-시작" class="nav-link" data-scroll-target="#옵션-2-monorepo-시작"><span class="header-section-number">5.2</span> 옵션 2: Monorepo 시작</a></li>
  <li><a href="#옵션-3-monorepo-msa-점진적-전환" id="toc-옵션-3-monorepo-msa-점진적-전환" class="nav-link" data-scroll-target="#옵션-3-monorepo-msa-점진적-전환"><span class="header-section-number">5.3</span> 옵션 3: Monorepo → MSA 점진적 전환</a></li>
  </ul></li>
  <li><a href="#최종-권장-전략-monorepo-선택적-msa" id="toc-최종-권장-전략-monorepo-선택적-msa" class="nav-link" data-scroll-target="#최종-권장-전략-monorepo-선택적-msa"><span class="header-section-number">6</span> 최종 권장 전략: Monorepo → 선택적 MSA</a>
  <ul class="collapse">
  <li><a href="#명확한-근거" id="toc-명확한-근거" class="nav-link" data-scroll-target="#명확한-근거"><span class="header-section-number">6.1</span> 명확한 근거</a></li>
  <li><a href="#의사결정-체크리스트" id="toc-의사결정-체크리스트" class="nav-link" data-scroll-target="#의사결정-체크리스트"><span class="header-section-number">6.2</span> 의사결정 체크리스트</a></li>
  </ul></li>
  <li><a href="#구체적-실행-로드맵" id="toc-구체적-실행-로드맵" class="nav-link" data-scroll-target="#구체적-실행-로드맵"><span class="header-section-number">7</span> 구체적 실행 로드맵</a>
  <ul class="collapse">
  <li><a href="#phase-1-초기-구축-0-6개월-5개-agent" id="toc-phase-1-초기-구축-0-6개월-5개-agent" class="nav-link" data-scroll-target="#phase-1-초기-구축-0-6개월-5개-agent"><span class="header-section-number">7.1</span> Phase 1: 초기 구축 (0-6개월, ~5개 agent)</a></li>
  <li><a href="#phase-2-성장-단계-6-12개월-5-20개-agent" id="toc-phase-2-성장-단계-6-12개월-5-20개-agent" class="nav-link" data-scroll-target="#phase-2-성장-단계-6-12개월-5-20개-agent"><span class="header-section-number">7.2</span> Phase 2: 성장 단계 (6-12개월, 5-20개 agent)</a></li>
  <li><a href="#phase-3-성숙-단계-12개월-20-agent" id="toc-phase-3-성숙-단계-12개월-20-agent" class="nav-link" data-scroll-target="#phase-3-성숙-단계-12개월-20-agent"><span class="header-section-number">7.3</span> Phase 3: 성숙 단계 (12개월+, 20+ agent)</a></li>
  </ul></li>
  <li><a href="#반드시-피해야-할-실수" id="toc-반드시-피해야-할-실수" class="nav-link" data-scroll-target="#반드시-피해야-할-실수"><span class="header-section-number">8</span> 반드시 피해야 할 실수</a>
  <ul class="collapse">
  <li><a href="#하지-말아야-할-것" id="toc-하지-말아야-할-것" class="nav-link" data-scroll-target="#하지-말아야-할-것"><span class="header-section-number">8.1</span> 하지 말아야 할 것</a></li>
  <li><a href="#반드시-해야-할-것" id="toc-반드시-해야-할-것" class="nav-link" data-scroll-target="#반드시-해야-할-것"><span class="header-section-number">8.2</span> 반드시 해야 할 것</a></li>
  </ul></li>
  <li><a href="#사용자-그룹-분리와-저장소-전략" id="toc-사용자-그룹-분리와-저장소-전략" class="nav-link" data-scroll-target="#사용자-그룹-분리와-저장소-전략"><span class="header-section-number">9</span> 사용자 그룹 분리와 저장소 전략</a>
  <ul class="collapse">
  <li><a href="#사용자-그룹이-다를-때의-대응" id="toc-사용자-그룹이-다를-때의-대응" class="nav-link" data-scroll-target="#사용자-그룹이-다를-때의-대응"><span class="header-section-number">9.1</span> 사용자 그룹이 다를 때의 대응</a></li>
  <li><a href="#올바른-접근-shared-core-separated-edge" id="toc-올바른-접근-shared-core-separated-edge" class="nav-link" data-scroll-target="#올바른-접근-shared-core-separated-edge"><span class="header-section-number">9.2</span> 올바른 접근: Shared Core, Separated Edge</a></li>
  <li><a href="#왜-monorepo가-유리한가" id="toc-왜-monorepo가-유리한가" class="nav-link" data-scroll-target="#왜-monorepo가-유리한가"><span class="header-section-number">9.3</span> 왜 Monorepo가 유리한가</a></li>
  </ul></li>
  <li><a href="#지금-당장-시작할-것" id="toc-지금-당장-시작할-것" class="nav-link" data-scroll-target="#지금-당장-시작할-것"><span class="header-section-number">10</span> 지금 당장 시작할 것</a>
  <ul class="collapse">
  <li><a href="#즉시-실행-체크리스트" id="toc-즉시-실행-체크리스트" class="nav-link" data-scroll-target="#즉시-실행-체크리스트"><span class="header-section-number">10.1</span> 즉시 실행 체크리스트</a></li>
  <li><a href="#성공-기준" id="toc-성공-기준" class="nav-link" data-scroll-target="#성공-기준"><span class="header-section-number">10.2</span> 성공 기준</a></li>
  </ul></li>
  <li><a href="#결론" id="toc-결론" class="nav-link" data-scroll-target="#결론"><span class="header-section-number">11</span> 결론</a></li>
  <li><a href="#이-구조의-실질적인-장점" id="toc-이-구조의-실질적인-장점" class="nav-link" data-scroll-target="#이-구조의-실질적인-장점"><span class="header-section-number">12</span> 이 구조의 실질적인 장점</a>
  <ul class="collapse">
  <li><a href="#에이전트-양산-속도-scaffolding" id="toc-에이전트-양산-속도-scaffolding" class="nav-link" data-scroll-target="#에이전트-양산-속도-scaffolding"><span class="header-section-number">12.1</span> 에이전트 양산 속도 (Scaffolding)</a></li>
  <li><a href="#기술-부채-방지-single-source-of-truth" id="toc-기술-부채-방지-single-source-of-truth" class="nav-link" data-scroll-target="#기술-부채-방지-single-source-of-truth"><span class="header-section-number">12.2</span> 기술 부채 방지 (Single Source of Truth)</a></li>
  <li><a href="#일관된-인터페이스-agent-orchestration" id="toc-일관된-인터페이스-agent-orchestration" class="nav-link" data-scroll-target="#일관된-인터페이스-agent-orchestration"><span class="header-section-number">12.3</span> 일관된 인터페이스 (Agent Orchestration)</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="배경" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="배경"><span class="header-section-number">1</span> 배경</h2>
<p>AI Agent를 도메인별, 기능별로 지속적으로 생산하는 플랫폼을 구축할 때 가장 먼저 실무적으로 직면하는 설계 결정은 저장소(repository) 전략이다.<br>
하나의 플랫폼 저장소 안에 모든 agent를 하위 폴더로 관리할 것인가(Monorepo), 아니면 도메인별로 독립된 저장소를 생성할 것인가(Multi-repo)?</p>
<p>이 질문은 단순히 코드를 어디에 저장할지의 문제가 아니다.<br>
배포 파이프라인, 의존성 관리, 공통 모듈 재사용, 팀 협업 방식, 그리고 장기적인 기술 부채 관리까지 모든 것에 영향을 미치는 전략적 선택이다.</p>
<p>특히 다음과 같은 상황에서는 이 선택이 더욱 중요하다:</p>
<ul>
<li><strong>프로젝트 초창기</strong>: POC가 완료되고 본격적인 개발이 시작되는 단계<br>
</li>
<li><strong>공통 모듈 비중 높음</strong>: 로깅, 모니터링, LLM 인터페이스 등 공통 SDK 개발 필요<br>
</li>
<li><strong>장기 로드맵 존재</strong>: Docker + Kubernetes 기반 확장성 있는 아키텍처 지향</li>
</ul>
<p>글쓴이는 컴퓨터 공학 출신이 아닌 Data Scientist로서, 해당 내용의 지식이 부족하여 세 가지 주요 AI 서비스(Gemini, ChatGPT, Claude)와의 대화를 통해 글쓴이가 도출한 인사이트를 종합 및 요약하고, 실증 데이터와 산업 사례를 바탕으로 최적의 저장소 전략을 소개한다.</p>
</section>
<section id="프로젝트-현황-분석" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="프로젝트-현황-분석"><span class="header-section-number">2</span> 프로젝트 현황 분석</h2>
<section id="현재-상태" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="현재-상태"><span class="header-section-number">2.1</span> 현재 상태</h3>
<p><strong>개발 단계</strong><br>
- POC 완료: 데이터 표준화 QnA chatbot, 데이터 표준화 도우미 agent 구현<br>
- 즉시 추가 예정: 코드베이스 분석 agent<br>
- 향후 계획: 도메인별 agent 지속 확장 (agent 양산 플랫폼)</p>
<p><strong>팀 구성 및 제약사항</strong><br>
- PM(Data Scientist 출신)이 플랫폼 아키텍처 설계 주도<br>
- 리더급 백엔드 엔지니어 부재<br>
- 개발자들의 시스템 설계 및 비즈니스 고려 능력 제한</p>
<p><strong>기술적 요구사항</strong><br>
- 공통 모듈 필요성 높음: SDK, 로그 분석 기능, 모니터링<br>
- 장기 로드맵: Docker + Kubernetes 기반 컨테이너 오케스트레이션<br>
- 각 agent의 성능 모니터링 및 관리 필요</p>
</section>
<section id="주요-agent-특성" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="주요-agent-특성"><span class="header-section-number">2.2</span> 주요 Agent 특성</h3>
<p><strong>지식 QnA Chatbot</strong><br>
- 문서 기반 여러 도메인 지식 응답<br>
- 여러 agent 통합 가능성 존재 (다른 agent를 백엔드에서 호출)<br>
- 사용자층: 혼합 (임원 및 여러 부서 공통 사용)</p>
<p><strong>데이터 표준화 Agent</strong><br>
- 공통 모듈 생성 가능성 매우 높음<br>
- 여러 agent로 확장 예상 (스키마 분석, 매핑, 검증 등)<br>
- 사용자층: 데이터 관리자, 현업 담당자, 데이터 오너</p>
<p><strong>코드베이스 분석 Agent</strong><br>
- 공통 모듈 생성 가능성 매우 높음<br>
- 여러 agent로 확장 예상 (AST 파싱, 의존성 분석, 리팩토링 제안 등)<br>
- 사용자층: 개발자, 연구원, 기획자</p>
<p>이 세 가지 agent는 공통적으로 <strong>높은 공통 모듈 재사용 가능성</strong>과 <strong>agent 간 협업 시나리오</strong>를 가지고 있다.</p>
</section>
</section>
<section id="세-ai의-공통-권장사항-monorepo-시작" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="세-ai의-공통-권장사항-monorepo-시작"><span class="header-section-number">3</span> 세 AI의 공통 권장사항: Monorepo 시작</h2>
<p>Gemini, ChatGPT, Claude 세 AI 서비스 모두 동일한 결론에 도달했다.</p>
<section id="핵심-결론" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="핵심-결론"><span class="header-section-number">3.1</span> 핵심 결론</h3>
<p><strong>초기에는 Monorepo 구조로 시작</strong><br>
- Gemini: “모노레포 구조 강력히 추천”<br>
- ChatGPT: “지금은 단일 repo 고도화시 도메인별 폴더”<br>
- Claude: “Monorepo 구조를 강력히 권장”</p>
<p><strong>공통 모듈의 중요성 강조</strong><br>
모든 AI가 LLM 인터페이스, 프롬프트 템플릿, 평가 프레임워크 등 공통 라이브러리 재사용이 핵심임을 지적했다.<br>
보통 기준 코드 재사용률은 30-70%에 달하는 것이 잘 설계된 플랫폼이다.</p>
<p><strong>점진적 분리 전략 제안</strong><br>
처음부터 멀티레포로 시작하는 것은 비효율적이다.<br>
성숙 단계에서 필요시 선택적으로 분리하는 것이 안전하다.</p>
<p><strong>공통 인프라 설계 우선</strong><br>
- BaseAgent 인터페이스 정의<br>
- Agent manifest/config 구조 표준화<br>
- 통합 CI/CD 파이프라인 구축</p>
</section>
<section id="정량적-근거" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="정량적-근거"><span class="header-section-number">3.2</span> 정량적 근거</h3>
<p>Claude가 제시한 산업 사례 데이터:</p>
<p><strong>Google의 연구 (Potvin &amp; Levenberg, 2016)</strong><br>
- 20억 줄 코드를 단일 저장소 관리<br>
- 코드 재사용률 35% 향상<br>
- 리팩토링 비용 60% 감소</p>
<p><strong>Microsoft의 측정 결과</strong><br>
- Monorepo 전환 후 빌드 일관성 관련 버그 42% 감소<br>
- 의존성 충돌 발생률 78% 감소</p>
<p><strong>Uber의 Michelangelo 플랫폼</strong><br>
- 100+ ML 모델을 Monorepo로 관리<br>
- 공통 모듈 재사용률 평균 67%<br>
- Feature engineering pipeline 재사용률 89%</p>
<p><strong>Airbnb의 ML 플랫폼</strong><br>
- 초기 Polyrepo에서 공통 코드 중복으로 버그 전파 문제 발생<br>
- Monorepo 전환 후 새 도메인 agent 개발 시간 40% 단축</p>
</section>
</section>
<section id="세-ai의-차별화된-관점" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="세-ai의-차별화된-관점"><span class="header-section-number">4</span> 세 AI의 차별화된 관점</h2>
<p>각 AI는 서로 다른 관점에서 문제를 바라보았다.</p>
<section id="gemini-비즈니스-및-거버넌스" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="gemini-비즈니스-및-거버넌스"><span class="header-section-number">4.1</span> Gemini: 비즈니스 및 거버넌스</h3>
<p><strong>핵심 메시지</strong><br>
“지적 자산을 공유하는 플랫폼이라면 지식의 뿌리는 공유해야 한다”</p>
<p><strong>주요 개념</strong></p>
<p><strong>도메인 주도 설계(DDD, Domain Driven Design)</strong><br>
* 복잡한 비즈니스 로직을 도메인별로 분리하여 관리하는 설계 방법론이다.<br>
* 각 도메인별로 main agent(데이터 표준화, 코드 분석)를 독립적인 도메인으로 정의하고, 하위 agent들을 둘 수 있으며 도메인 전문가의 언어로 소프트웨어를 모델링한다.<br>
* 이를 통해 비즈니스 요구사항과 기술 구현 간의 간극을 줄일 수 있다.</p>
<p><strong>Bounded Context</strong><br>
* DDD에서 특정 도메인 모델이 적용되는 명확한 경계를 의미한다.<br>
* 데이터 표준화 업무의 맥락(스키마, 규칙, 검증)과 코드 분석의 맥락(AST, 의존성, 리팩토링)은 서로 다른 Bounded Context에 속한다.<br>
* 이러한 경계를 명확히 하면 각 도메인이 독립적으로 진화할 수 있으면서도, 필요시 통합이 용이하다.</p>
<p><strong>Multi-tenancy</strong><br>
* 하나의 플랫폼에서 여러 사용자 그룹(tenant)을 격리하여 서비스하는 아키텍처 패턴이다.<br>
* 데이터 관리자와 개발자라는 서로 다른 사용자 그룹이 동일한 플랫폼을 사용하지만, 각각 다른 agent와 기능에 접근한다.<br>
* 코드는 공유하되 배포와 접근 권한을 분리하여 보안과 효율성을 동시에 확보한다.</p>
<p><strong>Micro-frontend</strong><br>
* 프론트엔드를 독립적인 기능 단위로 분리하여 개발하는 아키텍처 패턴이다.<br>
* 데이터 표준화 UI, 코드 분석 UI, QnA chatbot UI를 각각 독립적으로 개발하고 배포할 수 있다.<br>
* 이를 통해 사용자 그룹별로 최적화된 경험을 제공하면서도, 공통 플랫폼의 이점을 유지한다.</p>
<p><strong>Ubiquitous Language</strong><br>
* 도메인 전문가와 개발자가 공통으로 사용하는 비즈니스 용어 체계다.<br>
* BT(생물학·진단 기술)와 IT 간의 용어 차이를 해소하기 위해, 모든 팀원이 동일한 용어로 소통한다.<br>
* 예: “데이터 표준화”를 “schema normalization”이 아닌 비즈니스 용어 그대로 사용</p>
<p><strong>지식 흐름 설계</strong><br>
* 데이터 표준화 agent와 코드분석 agent가 생산한 지식이 QnA chatbot의 데이터 소스가 되는 선순환 구조가 이상적이다.<br>
* 각 agent가 생성한 문서, 규칙, 분석 결과는 벡터 DB에 저장되어, QnA chatbot이 RAG 방식으로 검색하여 답변에 활용한다.<br>
* 이는 단순한 기술 플랫폼을 넘어 조직의 지식 생태계를 구축하는 접근이다.</p>
</section>
<section id="chatgpt-실무-엔지니어링" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="chatgpt-실무-엔지니어링"><span class="header-section-number">4.2</span> ChatGPT: 실무 엔지니어링</h3>
<p><strong>핵심 메시지</strong><br>
“Core 분리 + Product 단위 repo 하이브리드 전략”</p>
<p><strong>실용적 접근</strong><br>
- Agent 인터페이스 강제의 중요성 강조<br>
- “이 agent는 제품인가 실험인가” 구분 필요<br>
- Agent marketplace 런타임 개념 도입</p>
<p><strong>하이브리드 구조 제안</strong></p>
<pre><code>agent-platform-core/          # Monorepo (핵심 플랫폼)
  ├── core/
  ├── shared/
  └── infra/

knowledge-qna-service/        # 독립 repo (공용 서비스)
data-standardization-product/ # 독립 repo (특정 사용자군)
code-analysis-product/        # 독립 repo (특정 사용자군)</code></pre>
<p>지식 QnA chatbot은 제품이면서 동시에 “agent marketplace의 런타임” 역할을 한다.</p>
</section>
<section id="claude-학술적실증적" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="claude-학술적실증적"><span class="header-section-number">4.3</span> Claude: 학술적·실증적</h3>
<p><strong>핵심 메시지</strong><br>
“실증 데이터와 체계적 의사결정 프레임워크”</p>
<p><strong>학술적 접근</strong><br>
- 논문 및 산업 사례 인용 (Google, Microsoft, Uber, Airbnb)<br>
- 정량적 메트릭 제시 (재사용률 67%, 버그 42% 감소)<br>
- 체크리스트 기반 의사결정 도구 제공</p>
<p><strong>불확실성 영역 명시</strong><br>
- 팀 규모에 따른 영향<br>
- 릴리스 주기 차이<br>
- AI agent 특화 연구 부족 인정</p>
<p><strong>측정 가능한 비교표</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>기준</th>
<th>Monorepo</th>
<th>Polyrepo</th>
<th>근거</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>공통 모듈 중복</td>
<td>0%</td>
<td>45-60%</td>
<td>Airbnb 측정</td>
</tr>
<tr class="even">
<td>Agent 통합 테스트</td>
<td>가능</td>
<td>매우 어려움</td>
<td>3개 저장소 동기화 필요</td>
</tr>
<tr class="odd">
<td>새 Agent 추가 시간</td>
<td>2-3시간</td>
<td>1-2일</td>
<td>Uber 측정</td>
</tr>
<tr class="even">
<td>의존성 버전 충돌</td>
<td>없음</td>
<td>높음 (70%+)</td>
<td>LangChain, OpenAI SDK</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="단계별-리스크-평가" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="단계별-리스크-평가"><span class="header-section-number">5</span> 단계별 리스크 평가</h2>
<section id="옵션-1-처음부터-multi-repo-msa" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="옵션-1-처음부터-multi-repo-msa"><span class="header-section-number">5.1</span> 옵션 1: 처음부터 Multi-repo (MSA)</h3>
<p><strong>치명적 리스크</strong><br>
리더급 엔지니어 부재 상황에서 MSA 복잡도를 감당할 수 없다.<br>
마이크로서비스 아키텍처는 높은 운영 성숙도와 인프라 자동화를 요구한다.</p>
<p><strong>기술적 문제</strong><br>
- 공통 모듈 중복 구현 → 기술 부채 급증<br>
- 버전 불일치로 인한 런타임 에러 위험<br>
- 초기 개발 속도 저하 (새 agent 추가 시간 2-3배)<br>
- 통합 테스트 불가능 (agent 조합 시나리오 검증 어려움)</p>
<p><strong>운영 복잡도</strong><br>
- 여러 저장소 간 CI/CD 조율 필요<br>
- 공통 라이브러리 변경 시 모든 저장소에 PR 생성<br>
- 보안 패치 누락 위험 3.2배 증가 (Snyk 보고서, 2022)</p>
</section>
<section id="옵션-2-monorepo-시작" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="옵션-2-monorepo-시작"><span class="header-section-number">5.2</span> 옵션 2: Monorepo 시작</h3>
<p><strong>낮은 리스크</strong><br>
단순한 구조로 현재 팀 역량에 적합하다.<br>
하나의 저장소에서 모든 agent를 관리하므로 학습 곡선이 완만하다.</p>
<p><strong>기술적 이점</strong><br>
- 공통 모듈 재사용으로 개발 속도 향상<br>
- 통합 테스트 및 버전 관리 용이<br>
- 원자적 변경(Atomic changes) 가능: 공통 라이브러리 수정 시 모든 agent 동시 업데이트</p>
<p><strong>중간 리스크</strong><br>
프로젝트 성장 시 저장소 크기와 빌드 시간 증가 가능성<br>
하지만 Nx, Turborepo 같은 도구로 해결 가능</p>
</section>
<section id="옵션-3-monorepo-msa-점진적-전환" class="level3" data-number="5.3">
<h3 data-number="5.3" class="anchored" data-anchor-id="옵션-3-monorepo-msa-점진적-전환"><span class="header-section-number">5.3</span> 옵션 3: Monorepo → MSA 점진적 전환</h3>
<p><strong>최적 리스크 관리</strong><br>
초기 단순성과 미래 확장성을 동시에 확보한다.<br>
비즈니스 변화에 유연하게 대응 가능하다.</p>
<p><strong>전환 시점 판단 기준</strong><br>
다음 중 2개 이상 충족 시 분리 고민:<br>
- [ ] 특정 도메인의 릴리스 주기가 다른 agent와 완전히 다름<br>
- [ ] 특정 agent만 외부 고객에게 배포 필요<br>
- [ ] 팀이 도메인별로 명확히 분리됨 (각 5명 이상)<br>
- [ ] Core 변경 없이 도메인만 독립 발전 가능</p>
<p><strong>전환 비용</strong><br>
필요시에만 선택적 분리하므로 과도한 엔지니어링 방지<br>
Core를 pip 패키지로 배포하면 전환이 상대적으로 수월</p>
</section>
</section>
<section id="최종-권장-전략-monorepo-선택적-msa" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="최종-권장-전략-monorepo-선택적-msa"><span class="header-section-number">6</span> 최종 권장 전략: Monorepo → 선택적 MSA</h2>
<p>현재 상황에서 <strong>옵션 3번이 유일한 정답</strong>이다.</p>
<section id="명확한-근거" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="명확한-근거"><span class="header-section-number">6.1</span> 명확한 근거</h3>
<p><strong>팀 역량 현실</strong><br>
리더급 백엔드 엔지니어 부재 → 복잡한 MSA는 위험<br>
Monorepo는 관리가 단순하고 학습 곡선이 낮음</p>
<p><strong>프로젝트 단계</strong><br>
POC 직후 초창기 → 구조 실험과 빠른 반복 필요<br>
Monorepo에서 agent 추가 비용이 매우 낮음 (2-3시간)</p>
<p><strong>공통 모듈 비중</strong><br>
매우 높음 (SDK, 로그 분석, 공통 인프라)<br>
공통 모듈 재사용률이 30% 이상이면 Monorepo가 유리</p>
<p><strong>Agent 특성</strong><br>
서로 조합 가능성 높음 (QnA가 다른 agent 호출)<br>
Agent 간 통신 프로토콜 표준화 필요 → Monorepo에서 강제 가능</p>
<p><strong>실증 데이터 뒷받침</strong><br>
Google, Uber, Airbnb 사례 모두 초기 Monorepo에서 시작<br>
성공적인 플랫폼들은 Monorepo → 선택적 분리 경로를 따름</p>
</section>
<section id="의사결정-체크리스트" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="의사결정-체크리스트"><span class="header-section-number">6.2</span> 의사결정 체크리스트</h3>
<p>현재 상황에 적용:</p>
<ul>
<li>✅ 공통 모듈 재사용 &gt;30%? → <strong>YES</strong> (SDK, 로깅, 공통 인프라)<br>
</li>
<li>✅ Agent 간 협업 가능성? → <strong>YES</strong> (QnA가 다른 agent 호출)<br>
</li>
<li>✅ 단일 팀 관리? → <strong>YES</strong><br>
</li>
<li>✅ 통합 테스트 필요? → <strong>YES</strong><br>
</li>
<li>✅ 초기 개발 속도 중요? → <strong>YES</strong> (POC 직후)<br>
</li>
<li>✅ 리더급 엔지니어 부재? → <strong>YES</strong> (복잡한 MSA 위험)</li>
</ul>
<p><strong>결과: 6/6 항목이 Monorepo 선호 → Monorepo 시작이 명확한 답</strong></p>
</section>
</section>
<section id="구체적-실행-로드맵" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="구체적-실행-로드맵"><span class="header-section-number">7</span> 구체적 실행 로드맵</h2>
<section id="phase-1-초기-구축-0-6개월-5개-agent" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="phase-1-초기-구축-0-6개월-5개-agent"><span class="header-section-number">7.1</span> Phase 1: 초기 구축 (0-6개월, ~5개 agent)</h3>
<p><strong>기본 구조</strong></p>
<pre><code>agent-platform/                # Monorepo
├── core/                      # 플랫폼 코어
│   ├── agent/
│   │   ├── base_agent.py     # 모든 agent의 부모 클래스
│   │   ├── lifecycle.py
│   │   └── orchestrator.py
│   ├── llm/
│   │   ├── clients/          # OpenAI, Anthropic 래퍼
│   │   ├── prompt_engine.py
│   │   └── context_manager.py
│   ├── memory/
│   ├── tools/
│   └── evaluation/
│
├── agents/                    # 도메인별 agent
│   ├── knowledge_qna/
│   │   ├── src/
│   │   ├── prompts/
│   │   └── tests/
│   ├── data_standardization/
│   │   ├── src/
│   │   ├── rules/
│   │   └── tests/
│   └── codebase_analysis/
│       ├── src/
│       ├── parsers/
│       └── tests/
│
├── shared/                    # 공통 모듈 (SDK)
│   ├── logging/              # 로그 분석 기능
│   ├── monitoring/           # 성능 모니터링
│   ├── document_processing/
│   └── vector_store/
│
├── infra/
│   ├── docker/
│   ├── k8s/                  # 미래 대비
│   └── ci_cd/
│
└── pyproject.toml            # 단일 의존성 관리</code></pre>
<p><strong>핵심 설계 원칙</strong></p>
<ol type="1">
<li><strong>Agent 간 직접 의존 금지</strong><br>
각 agent는 <code>core</code>만 참조한다. Agent 간 직접 import를 금지한다.</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># ❌ 절대 금지</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="im">from</span> agents.data_standardization <span class="im">import</span> Standardizer</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co"># ✅ 반드시 이렇게</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="im">from</span> core.agent <span class="im">import</span> AgentRegistry</span>
<span id="cb3-6"><a href="#cb3-6"></a>standardizer <span class="op">=</span> AgentRegistry.get(<span class="st">"data_standardization"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li><strong>공통 인터페이스 강제</strong><br>
모든 agent는 BaseAgent를 상속해야 한다.</li>
</ol>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># shared/base/agent.py</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="im">from</span> abc <span class="im">import</span> ABC, abstractmethod</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="im">from</span> typing <span class="im">import</span> Dict, Any</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">class</span> BaseAgent(ABC):</span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="co">"""모든 agent가 상속해야 하는 기본 클래스"""</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    </span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="at">@abstractmethod</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="kw">def</span> process(<span class="va">self</span>, <span class="bu">input</span>: Dict[<span class="bu">str</span>, Any]) <span class="op">-&gt;</span> Dict[<span class="bu">str</span>, Any]:</span>
<span id="cb4-10"><a href="#cb4-10"></a>        <span class="co">"""표준화된 입출력 인터페이스"""</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>        <span class="cf">pass</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>    </span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="at">@abstractmethod</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>    <span class="kw">def</span> evaluate(<span class="va">self</span>, ground_truth: Any, prediction: Any) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb4-15"><a href="#cb4-15"></a>        <span class="co">"""공통 평가 프레임워크"""</span></span>
<span id="cb4-16"><a href="#cb4-16"></a>        <span class="cf">pass</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="3" type="1">
<li><strong>Manifest 기반 관리</strong><br>
각 agent는 설정 파일을 보유한다.</li>
</ol>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource yaml number-lines code-with-copy"><code class="sourceCode yaml"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># agents/data_standardization/manifest.yaml</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="fu">name</span><span class="kw">:</span><span class="at"> data_standardization_agent</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">"1.0.0"</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="fu">domain</span><span class="kw">:</span><span class="at"> data_standardization</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="fu">inputs</span><span class="kw">:</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="at">  </span><span class="kw">-</span><span class="at"> raw_schema</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="fu">outputs</span><span class="kw">:</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="at">  </span><span class="kw">-</span><span class="at"> normalized_schema</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="fu">tools</span><span class="kw">:</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="at">  </span><span class="kw">-</span><span class="at"> regex_tool</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="at">  </span><span class="kw">-</span><span class="at"> schema_store</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="fu">dependencies</span><span class="kw">:</span></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="at">  </span><span class="kw">-</span><span class="at"> core.llm&gt;=1.0.0</span></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="at">  </span><span class="kw">-</span><span class="at"> shared.logging&gt;=1.0.0</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>도구 선택</strong><br>
- Python: <code>Poetry</code> (의존성 관리)<br>
- Build tool: <code>Nx</code> (선택적, agent 5개 초과 시)<br>
- CI/CD: GitHub Actions (변경된 agent만 테스트)<br>
- 컨테이너: Docker Compose (로컬 개발), Kubernetes 준비</p>
<p><strong>공통 모듈 예상 목록</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>모듈</th>
<th>재사용률</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>llm/</code></td>
<td>~100%</td>
<td>LLM API 호출, 프롬프트 템플릿 엔진</td>
</tr>
<tr class="even">
<td><code>document_processing/</code></td>
<td>~80%</td>
<td>문서 파싱 (PDF, Docx, 코드)</td>
</tr>
<tr class="odd">
<td><code>vector_store/</code></td>
<td>~90%</td>
<td>RAG 인프라, 임베딩, 검색</td>
</tr>
<tr class="even">
<td><code>validation/</code></td>
<td>~70%</td>
<td>출력 검증, 품질 체크</td>
</tr>
<tr class="odd">
<td><code>evaluation/</code></td>
<td>~100%</td>
<td>성능 평가, 벤치마크</td>
</tr>
<tr class="even">
<td><code>logging/</code></td>
<td>~100%</td>
<td>구조화된 로깅, 분석</td>
</tr>
<tr class="odd">
<td><code>monitoring/</code></td>
<td>~100%</td>
<td>메트릭 수집, 대시보드</td>
</tr>
</tbody>
</table>
</section>
<section id="phase-2-성장-단계-6-12개월-5-20개-agent" class="level3" data-number="7.2">
<h3 data-number="7.2" class="anchored" data-anchor-id="phase-2-성장-단계-6-12개월-5-20개-agent"><span class="header-section-number">7.2</span> Phase 2: 성장 단계 (6-12개월, 5-20개 agent)</h3>
<p><strong>분리 신호 감지</strong></p>
<p>다음 중 <strong>2개 이상</strong> 충족 시 선택적 분리 고민:</p>
<ul class="task-list">
<li><label><input type="checkbox">특정 도메인의 릴리스 주기가 다른 agent와 완전히 다름<br>
</label></li>
<li><label><input type="checkbox">특정 agent만 외부 고객에게 배포 필요<br>
</label></li>
<li><label><input type="checkbox">팀이 도메인별로 명확히 분리됨 (각 5명 이상)<br>
</label></li>
<li><label><input type="checkbox">Core 변경 없이 도메인만 독립 발전 가능</label></li>
</ul>
<p><strong>하이브리드 구조 전환</strong></p>
<pre><code>agent-platform-core/          # Monorepo (핵심 플랫폼)
  ├── core/
  ├── shared/
  └── infra/

knowledge-qna-service/        # 독립 repo (공용 서비스)
  ├── agents/
  ├── ui/
  └── api/

data-standardization-product/ # 독립 repo (특정 사용자군)
code-analysis-product/        # 독립 repo (특정 사용자군)</code></pre>
<p><strong>전환 전략</strong><br>
1. Core를 pip 패키지로 배포 (<code>agent-platform-core==1.0.0</code>)<br>
2. 독립 repo는 core에 의존 (<code>requirements.txt</code>에 명시)<br>
3. 공통 모듈은 계속 core에서 관리<br>
4. 변경 영향도 추적 시스템 구축 (어떤 agent가 영향받는지 자동 파악)</p>
<p><strong>배포 분리 예시</strong></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource yaml number-lines code-with-copy"><code class="sourceCode yaml"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># k8s/data-std-deployment.yaml</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> apps/v1</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Deployment</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> data-std-agent</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="at">  </span><span class="fu">replicas</span><span class="kw">:</span><span class="at"> </span><span class="dv">3</span></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="at">  </span><span class="fu">template</span><span class="kw">:</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="at">    </span><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="at">      </span><span class="fu">containers</span><span class="kw">:</span></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> agent</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="at">        </span><span class="fu">image</span><span class="kw">:</span><span class="at"> agent-platform-core:1.0.0</span><span class="co">  # 동일한 base image</span></span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="at">        </span><span class="fu">command</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="st">"python"</span><span class="kw">,</span><span class="at"> </span><span class="st">"-m"</span><span class="kw">,</span><span class="at"> </span><span class="st">"agents.data_standardization"</span><span class="kw">]</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="at">        </span><span class="fu">env</span><span class="kw">:</span></span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="at">        </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> AGENT_TYPE</span></span>
<span id="cb7-16"><a href="#cb7-16"></a><span class="at">          </span><span class="fu">value</span><span class="kw">:</span><span class="at"> </span><span class="st">"data_standardization"</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="phase-3-성숙-단계-12개월-20-agent" class="level3" data-number="7.3">
<h3 data-number="7.3" class="anchored" data-anchor-id="phase-3-성숙-단계-12개월-20-agent"><span class="header-section-number">7.3</span> Phase 3: 성숙 단계 (12개월+, 20+ agent)</h3>
<p><strong>완전 MSA 전환 고려</strong> (필요시)<br>
- Agent별 독립 배포 파이프라인<br>
- Service mesh (Istio 등) 도입<br>
- Agent marketplace 플랫폼화<br>
- 각 agent의 SLA 독립 관리</p>
<p><strong>단, 이 시점에도</strong><br>
- Core 플랫폼은 Monorepo 유지<br>
- 공통 SDK는 패키지 레지스트리로 관리<br>
- 표준 인터페이스 강제 유지</p>
</section>
</section>
<section id="반드시-피해야-할-실수" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="반드시-피해야-할-실수"><span class="header-section-number">8</span> 반드시 피해야 할 실수</h2>
<section id="하지-말아야-할-것" class="level3" data-number="8.1">
<h3 data-number="8.1" class="anchored" data-anchor-id="하지-말아야-할-것"><span class="header-section-number">8.1</span> 하지 말아야 할 것</h3>
<p><strong>처음부터 멀티레포 구조로 시작</strong><br>
근거: 팀 역량 부족 + 공통 모듈 중복 → 개발 속도 50% 저하<br>
Claude의 측정 데이터: Polyrepo에서 공통 코드 45-60% 중복</p>
<p><strong>Agent 간 직접 import</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># ❌ 절대 금지</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="im">from</span> agents.data_standardization <span class="im">import</span> Standardizer</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co"># ✅ 반드시 이렇게</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="im">from</span> core.agent <span class="im">import</span> AgentRegistry</span>
<span id="cb8-6"><a href="#cb8-6"></a>standardizer <span class="op">=</span> AgentRegistry.get(<span class="st">"data_standardization"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이렇게 하지 않으면 나중에 repo 분리가 불가능하다.</p>
<p><strong>도구 없이 Monorepo 방치</strong><br>
Nx 또는 최소한 pre-commit hook 필수<br>
변경 영향도 분석 없이 코드 수정 시 예상치 못한 버그 발생</p>
<p><strong>버전 관리 소홀</strong><br>
공통 라이브러리 breaking change 발생 시 모든 agent 영향<br>
Semantic versioning + Changelog 필수</p>
</section>
<section id="반드시-해야-할-것" class="level3" data-number="8.2">
<h3 data-number="8.2" class="anchored" data-anchor-id="반드시-해야-할-것"><span class="header-section-number">8.2</span> 반드시 해야 할 것</h3>
<p><strong>BaseAgent 인터페이스 초반에 확정</strong><br>
한번 정의하면 변경이 어려우므로 신중하게 설계<br>
입출력 스키마, 에러 처리, 로깅 규칙 포함</p>
<p><strong>Agent manifest 파일 (YAML) 필수화</strong><br>
각 agent의 의존성, 버전, 설명을 명시적으로 관리<br>
자동화된 문서 생성 가능</p>
<p><strong>통합 테스트 자동화</strong><br>
Agent 조합 시나리오 검증 필수<br>
QnA chatbot이 다른 agent를 호출하는 경우 통합 테스트 없이는 배포 불가</p>
<p><strong>공통 모듈 변경 시 영향 범위 자동 확인</strong></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource yaml number-lines code-with-copy"><code class="sourceCode yaml"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># .github/workflows/ci.yml</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="fu">name</span><span class="kw">:</span><span class="at"> Test Affected Agents</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="fu">on</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="at">push</span><span class="kw">]</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="fu">jobs</span><span class="kw">:</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="at">  </span><span class="fu">test</span><span class="kw">:</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="at">    </span><span class="fu">runs-on</span><span class="kw">:</span><span class="at"> ubuntu-latest</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="at">    </span><span class="fu">steps</span><span class="kw">:</span></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">uses</span><span class="kw">:</span><span class="at"> actions/checkout@v2</span></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Detect changed modules</span></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="at">        </span><span class="fu">id</span><span class="kw">:</span><span class="at"> changes</span></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="fu">        run</span><span class="kw">: </span><span class="ch">|</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>          # core/ 또는 shared/ 변경 시 모든 agent 테스트</span>
<span id="cb9-13"><a href="#cb9-13"></a>          if git diff --name-only HEAD~1 | grep -E '^(core|shared)/'; then</span>
<span id="cb9-14"><a href="#cb9-14"></a>            echo "affected=all" &gt;&gt; $GITHUB_OUTPUT</span>
<span id="cb9-15"><a href="#cb9-15"></a>          else</span>
<span id="cb9-16"><a href="#cb9-16"></a>            # 특정 agent만 변경 시 해당 agent만 테스트</span>
<span id="cb9-17"><a href="#cb9-17"></a>            echo "affected=$(git diff --name-only HEAD~1 | grep agents/ | cut -d'/' -f2 | sort -u)" &gt;&gt; $GITHUB_OUTPUT</span>
<span id="cb9-18"><a href="#cb9-18"></a>          fi</span>
<span id="cb9-19"><a href="#cb9-19"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> Run tests</span></span>
<span id="cb9-20"><a href="#cb9-20"></a><span class="at">        </span><span class="fu">run</span><span class="kw">:</span><span class="at"> pytest agents/${{ steps.changes.outputs.affected }}</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="사용자-그룹-분리와-저장소-전략" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="사용자-그룹-분리와-저장소-전략"><span class="header-section-number">9</span> 사용자 그룹 분리와 저장소 전략</h2>
<section id="사용자-그룹이-다를-때의-대응" class="level3" data-number="9.1">
<h3 data-number="9.1" class="anchored" data-anchor-id="사용자-그룹이-다를-때의-대응"><span class="header-section-number">9.1</span> 사용자 그룹이 다를 때의 대응</h3>
<p>데이터 표준화 agent의 사용자(데이터 관리자)와 코드분석 agent의 사용자(개발자)가 다르다.<br>
지식 QnA chatbot은 두 그룹 모두 사용하는 혼합 서비스다.</p>
<p><strong>중요: 사용자 그룹 분리는 저장소를 분리할 이유가 되지 않는다.</strong></p>
</section>
<section id="올바른-접근-shared-core-separated-edge" class="level3" data-number="9.2">
<h3 data-number="9.2" class="anchored" data-anchor-id="올바른-접근-shared-core-separated-edge"><span class="header-section-number">9.2</span> 올바른 접근: Shared Core, Separated Edge</h3>
<p><strong>백엔드 (Logic Layer)</strong><br>
- Core API: LLM 연동, 인증, 공통 DB 접근<br>
- Agent Logic: 각 agent 전용 프롬프트 및 도구<br>
- 모두 동일한 Monorepo에 존재</p>
<p><strong>프론트엔드 (Interface Layer)</strong><br>
- 사용자 진입점만 분리<br>
- 데이터 표준화 Portal: 대시보드 형태<br>
- 코드 분석 IDE Plugin/Portal: 코드 뷰어 중심<br>
- 통합 QnA Widget: 어디서든 호출 가능</p>
<p><strong>배포 및 접근 제어 분리</strong></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource nginx number-lines code-with-copy"><code class="sourceCode"><span id="cb10-1"><a href="#cb10-1"></a># API Gateway 설정 예시</span>
<span id="cb10-2"><a href="#cb10-2"></a>location /api/data-std {</span>
<span id="cb10-3"><a href="#cb10-3"></a>    # 데이터 관리자 그룹만 접근</span>
<span id="cb10-4"><a href="#cb10-4"></a>    auth_request /auth/validate-data-admin;</span>
<span id="cb10-5"><a href="#cb10-5"></a>    proxy_pass http://data-std-service:8000;</span>
<span id="cb10-6"><a href="#cb10-6"></a>}</span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a>location /api/code-analysis {</span>
<span id="cb10-9"><a href="#cb10-9"></a>    # 개발자 그룹만 접근</span>
<span id="cb10-10"><a href="#cb10-10"></a>    auth_request /auth/validate-developer;</span>
<span id="cb10-11"><a href="#cb10-11"></a>    proxy_pass http://code-analysis-service:8000;</span>
<span id="cb10-12"><a href="#cb10-12"></a>}</span>
<span id="cb10-13"><a href="#cb10-13"></a></span>
<span id="cb10-14"><a href="#cb10-14"></a>location /api/knowledge-qna {</span>
<span id="cb10-15"><a href="#cb10-15"></a>    # 두 그룹 모두 접근 가능</span>
<span id="cb10-16"><a href="#cb10-16"></a>    auth_request /auth/validate-any-group;</span>
<span id="cb10-17"><a href="#cb10-17"></a>    proxy_pass http://knowledge-qna-service:8000;</span>
<span id="cb10-18"><a href="#cb10-18"></a>}</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="왜-monorepo가-유리한가" class="level3" data-number="9.3">
<h3 data-number="9.3" class="anchored" data-anchor-id="왜-monorepo가-유리한가"><span class="header-section-number">9.3</span> 왜 Monorepo가 유리한가</h3>
<p><strong>공통 인증/권한 로직 단일 구현</strong><br>
보안 일관성 유지. 권한 버그가 발생하면 한 곳만 수정.</p>
<p><strong>배포 단위만 분리하여 서비스 격리</strong><br>
Kubernetes에서 다른 클러스터에 배포 가능<br>
하지만 코드는 같은 저장소에서 관리</p>
<p><strong>API Gateway로 사용자 그룹별 라우팅</strong><br>
네트워크 레벨에서 격리하므로 코드 격리 불필요</p>
<p><strong>Polyrepo 선택 시 문제점</strong><br>
- 공통 모듈 60% 재사용 불가능 → 중복 구현<br>
- 보안 패치를 3곳에서 따로 적용 → 누락 위험<br>
- 지식 QnA의 혼합 서비스 구현 복잡도 폭발</p>
</section>
</section>
<section id="지금-당장-시작할-것" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="지금-당장-시작할-것"><span class="header-section-number">10</span> 지금 당장 시작할 것</h2>
<section id="즉시-실행-체크리스트" class="level3" data-number="10.1">
<h3 data-number="10.1" class="anchored" data-anchor-id="즉시-실행-체크리스트"><span class="header-section-number">10.1</span> 즉시 실행 체크리스트</h3>
<p><strong>오늘</strong><br>
- [ ] Monorepo 기본 구조 생성 (위 Phase 1 구조 참고)<br>
- [ ] <code>core/agent/base_agent.py</code> 스켈레톤 작성<br>
- [ ] <code>pyproject.toml</code> 초기 설정</p>
<p><strong>이번 주</strong><br>
- [ ] BaseAgent 인터페이스 설계 완료<br>
- [ ] 기존 POC agent 3개를 Monorepo로 마이그레이션<br>
- [ ] Agent manifest 템플릿 작성<br>
- [ ] 간단한 통합 테스트 작성</p>
<p><strong>이번 달</strong><br>
- [ ] 공통 SDK 초안 구현 (로깅, 모니터링)<br>
- [ ] CI/CD 파이프라인 구축 (변경된 agent만 테스트)<br>
- [ ] 첫 번째 공통 모듈 배포 (LLM 인터페이스)<br>
- [ ] 코드베이스 분석 agent 추가</p>
<p><strong>3개월 후</strong><br>
- [ ] Agent 5-10개 시점에서 Phase 2 전환 여부 재평가<br>
- [ ] 빌드 시간 측정 (필요시 Nx 도입)<br>
- [ ] 팀 피드백 수집 및 구조 조정</p>
</section>
<section id="성공-기준" class="level3" data-number="10.2">
<h3 data-number="10.2" class="anchored" data-anchor-id="성공-기준"><span class="header-section-number">10.2</span> 성공 기준</h3>
<p><strong>정량적 지표</strong><br>
- 새 agent 추가 시간: 2-3일 이내 (공통 모듈 재사용 덕분)<br>
- 공통 모듈 재사용률: 30% 이상<br>
- 통합 테스트 커버리지: 80% 이상<br>
- 빌드 시간: 10분 이내 (agent 10개 기준)</p>
<p><strong>정성적 지표</strong><br>
- 팀원들이 다른 agent의 코드를 쉽게 참고 가능<br>
- 공통 라이브러리 변경 시 영향 범위 명확히 파악<br>
- 새로운 개발자가 1주일 내 첫 agent 추가 가능</p>
</section>
</section>
<section id="결론" class="level2" data-number="11">
<h2 data-number="11" class="anchored" data-anchor-id="결론"><span class="header-section-number">11</span> 결론</h2>
<p>AI Agent 플랫폼의 저장소 전략은 팀 역량, 프로젝트 단계, 공통 모듈 비중을 종합적으로 고려해야 한다.</p>
<p><strong>현재 상황에서의 최적해</strong><br>
Monorepo로 시작하여 필요시 선택적으로 MSA로 전환하는 점진적 전략이 유일한 정답이다.</p>
<p><strong>핵심 원칙</strong><br>
“사용자 기준으로 제품을 나누고, 기술 기준으로 core를 공유한다.”</p>
<p><strong>실증 데이터 기반 결론</strong><br>
Google, Microsoft, Uber, Airbnb 등 성공적인 플랫폼들은 모두 동일한 경로를 따랐다.<br>
초기 Monorepo → 성숙 단계 선택적 분리</p>
<p><strong>위험 최소화 전략</strong><br>
리더급 엔지니어가 부재한 상황에서 복잡한 MSA는 위험하다.<br>
단순한 구조로 시작하여 점진적으로 복잡도를 높여가는 것이 안전하다.</p>
<p><strong>장기적 관점</strong><br>
Monorepo에서 MSA로의 전환은 가능하지만, 역방향은 거의 불가능하다.<br>
따라서 초기에는 보수적으로 Monorepo를 선택하고, 필요성이 명확해지면 분리하는 것이 현명하다.</p>
<p>이 전략을 따르면 개발 속도를 유지하면서도 장기적인 확장성을 확보할 수 있다. │ │ ├── tech-support/ │ │ └── bio-domain/ │ ├── standardization/ # 데이터 표준화 관련 에이전트 그룹 │ │ ├── db-matcher/ │ │ └── schema-generator/ │ └── analyzer/ # 코드/알고리즘 분석 그룹 │ ├── algo-describer/ │ └── legacy-refactor/ ├── platform-api/ # 에이전트들을 총괄하는 게이트웨이 및 관리 UI └── tests/ # 통합 테스트</p>
</section>
<section id="이-구조의-실질적인-장점" class="level2" data-number="12">
<h2 data-number="12" class="anchored" data-anchor-id="이-구조의-실질적인-장점"><span class="header-section-number">12</span> 이 구조의 실질적인 장점</h2>
<section id="에이전트-양산-속도-scaffolding" class="level3" data-number="12.1">
<h3 data-number="12.1" class="anchored" data-anchor-id="에이전트-양산-속도-scaffolding"><span class="header-section-number">12.1</span> 에이전트 양산 속도 (Scaffolding)</h3>
<p>새로운 에이전트(예: 실험 데이터 분석 Agent)가 필요할 때, 밑바닥부터 만드는 것이 아니라 <code>libs/</code>에 있는 <code>core-llm</code>과 <code>rag-engine</code>을 가져와서 <strong>프롬프트와 특정 도메인 데이터만 연결</strong>하면 며칠 만에 뚝딱 만들어낼 수 있다.</p>
</section>
<section id="기술-부채-방지-single-source-of-truth" class="level3" data-number="12.2">
<h3 data-number="12.2" class="anchored" data-anchor-id="기술-부채-방지-single-source-of-truth"><span class="header-section-number">12.2</span> 기술 부채 방지 (Single Source of Truth)</h3>
<p>예를 들어, 씨젠의 <strong>데이터 표준 정책이 변경</strong>되었다고 가정.</p>
<ul>
<li><strong>멀티레포라면:</strong> 10개의 에이전트 저장소에 들어가서 코드를 일일이 수정</li>
<li><strong>모노레포라면:</strong> <code>libs/seegene-db-standard</code> 한 곳만 수정하면 이를 참조하는 모든 에이전트에 즉시 적용</li>
</ul>
</section>
<section id="일관된-인터페이스-agent-orchestration" class="level3" data-number="12.3">
<h3 data-number="12.3" class="anchored" data-anchor-id="일관된-인터페이스-agent-orchestration"><span class="header-section-number">12.3</span> 일관된 인터페이스 (Agent Orchestration)</h3>
<p>플랫폼의 목표가 여러 에이전트를 관리하는 것이라면, 각 에이전트는 동일한 입출력 규격(Interface)을 가져야 한다. 모노레포에서는 <code>interfaces/</code> 폴더를 통해 모든 에이전트가 따라야 할 규약을 강제하기 매우 쉽다.</p>


</section>
</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>