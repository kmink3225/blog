<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="PostgreSQL DB Container 띄우기와 Connection &amp; Hook 설정하기">

<title>Kwangmin Kim - Connection &amp; Hook</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../../">
<script src="../../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - Connection &amp; Hook">
<meta property="og:description" content="PostgreSQL DB Container 띄우기와 Connection &amp; Hook 설정하기">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Kwangmin Kim - Connection &amp; Hook">
<meta name="twitter:description" content="PostgreSQL DB Container 띄우기와 Connection &amp; Hook 설정하기">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">Connection &amp; Hook</h1>
            <p class="subtitle lead">docker_compose.yaml 해석, Postgres Container 올리기, Connection, Hook, bulk_load(), Custom Hook, More Providers, Connection Type</p>
                  <div>
        <div class="description">
          <p>PostgreSQL DB Container 띄우기와 Connection &amp; Hook 설정하기</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Engineering</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2023년 05월 01일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#go-to-blog-content-list" id="toc-go-to-blog-content-list" class="nav-link active" data-scroll-target="#go-to-blog-content-list"><span class="header-section-number">7</span> Go to Blog Content List</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<ul class="nav nav-pills" id="language-tab" role="tablist">
<li class="nav-item" role="presentation">
<button class="nav-link active" id="Korean-tab" data-bs-toggle="tab" data-bs-target="#Korean" type="button" role="tab" aria-controls="Korean" aria-selected="true">
Korean
</button>
</li>
<li class="nav-item" role="presentation">
<button class="nav-link" id="English-tab" data-bs-toggle="tab" data-bs-target="#English" type="button" role="tab" aria-controls="knitr" aria-selected="false">
English
</button>
</li>
<div class="tab-content" id="language-tabcontent">

<div id="Korean" class="tab-pane fade show active" role="tabpanel" aria-labelledby="Korean-tab">
<section id="goal" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Goal</h1>
<ul>
<li>posgres DB를 container로 띄우기</li>
<li>airflow의 connection &amp; hook 설정</li>
</ul>
</section>
<section id="docker-compose-interpretation" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Docker Compose Interpretation</h1>
<p>Docker Compose를 사용하면 이러한 다중 컨테이너 환경을 간편하게 구성하고 관리할 수 있다.</p>
<ul>
<li>목적
<ul>
<li>1 개 이상의 도커 컨테이너 생성시 스크립트 하나로 컨테이너들의 설정을 관리할 수 있도록 해주는 Docker 의 기능 중 하나</li>
<li>각 각의 container 설정 관리 뿐만 아니라 containers간의 연관관계 및 dependency까지 설정할 수 있다.</li>
<li>일부 containers를 같은 network에서 띄워지는지도 설정할 수 있는 network 설정도 할 수 있다.</li>
</ul></li>
<li>설정 파일
<ul>
<li>Docker Compose는 <code>docker-compose.yml</code>이라는 YAML 파일을 사용하여 서비스, 네트워크, 볼륨 등을 정의. 이 파일에는 애플리케이션을 구성하는 모든 컨테이너와 그 설정이 포함됨.</li>
</ul></li>
<li>기능
<ul>
<li>간편한 관리
<ul>
<li><code>docker-compose up</code> 명령어 한 번으로 모든 서비스를 시작하고, <code>docker-compose down</code> 명령어로 모두 종료할 수 있다. 이는 복잡한 컨테이너 관리를 단순화한다.</li>
</ul></li>
<li>일관성 유지
<ul>
<li>Docker Compose를 사용하면 개발, 테스팅, 프로덕션 환경에서 동일한 환경을 재현할 수 있어 일관성을 유지.</li>
</ul></li>
<li>다중 컨테이너 조정
<ul>
<li>여러 컨테이너 간의 의존성과 순서를 관리할 수 있어, 올바른 순서로 서비스가 시작되고 종료된다.</li>
</ul></li>
<li>개발 효율성 증가
<ul>
<li>개발 과정에서 빠른 반복과 변경이 가능하며, 변경 사항을 쉽게 적용하고 테스트할 수 있다.</li>
</ul></li>
<li>큰 규모의 프로덕션 환경에서는 Kubernetes와 같은 보다 복잡한 오케스트레이션 도구가 종종 사용된다.<br>
</li>
</ul></li>
<li>작성방법
<ul>
<li>모든 설정은 <code>docker_compose.yaml</code> 파일에 컨테이너들의 설정 내용을 입력</li>
</ul></li>
<li>docker compose service 시작
<ul>
<li><code>docker_compose.yaml</code> 파일이 있는 위치에서 sudo docker compose up 명령 입력하면 docker_compose.yaml에 있는 모든 설정이 적용된다.</li>
<li>기본적으로 Docker 서비스가 설치되어 있어야 함</li>
</ul></li>
<li>docker compose.yaml 파일의 구성
<ul>
<li>yaml 파일은 json 이나 xml 과 같이 <strong>key, value 가 중첩적으로 구성되며 계층적인 구조</strong>를 가진다. 파이썬처럼 들여쓰기 문법을 사용함. 들여쓰기 잘못하면 오류남.</li>
<li>다시 말해서, json 이나 xml은 파이썬의 dictionary 같이 nested {key:value} structure로 작성할 수 있다.</li>
</ul></li>
<li>docker_compose.yaml 파일의 <strong>1 Level</strong> 내용</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1"></a><span class="an">version:</span><span class="co"> '3.8' # yaml 파일의 버전 정보 옵션</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="an">x-airflow-common:</span><span class="co"> # 'x-': Extention Fields(각 서비스 항목에 또는 container에  공통 적용될 항목들 정의)</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="an">services:</span><span class="co"> # 컨테이너로 실행할 서비스 정의로 가장 신경써서 적어야할 부분</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="an">volumes:</span><span class="co">  # 컨테이너에 할당할 volume 정의</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="an">networks:</span><span class="co"> # 컨테이너에 연결할 network 정의. 초기에는 level1에 networks 항목이 정의되어 있지 않아 정의해줘야함</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><p>위의 내용에서 key값은 version, x-airflow-common, services, volumes, networks</p></li>
<li><p>networks: containers에 IP나 network정보를 할당해주기 위해 작성하는 항목</p></li>
<li><p>x-airflow-common: 공통 지정할 항목을 <code>&amp;</code>를 붙여서 지정</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb2-1"><a href="#cb2-1"></a>x-airflow-common</span>
<span id="cb2-2"><a href="#cb2-2"></a>    &amp;airflow-common # 공통 지정 parameters 정의: image, environment, depends_on</span>
<span id="cb2-3"><a href="#cb2-3"></a>    image: ${AIRFLOW_IMAGE:-apache/airflow:2.5.2}</span>
<span id="cb2-4"><a href="#cb2-4"></a>    environment</span>
<span id="cb2-5"><a href="#cb2-5"></a>        &amp;airflow-common-env</span>
<span id="cb2-6"><a href="#cb2-6"></a>        AIRFLOW__CORE__DEFAULT_TIMEZONE: 'Asia/Seoul'</span>
<span id="cb2-7"><a href="#cb2-7"></a>        AIRFLOW__CORE__EXECUTOR: CeleryExecutor</span>
<span id="cb2-8"><a href="#cb2-8"></a>        AIRFLOW__DATABASE__SQL_ALCHEMY_CONN: postgresql+psycopg2://airflow:airflow@postgres/airflow</span>
<span id="cb2-9"><a href="#cb2-9"></a>    depends_on # containers 실행 순서를 결정</span>
<span id="cb2-10"><a href="#cb2-10"></a>        &amp;airflow-common-depends-on # 공통 지정 parameters 정의: redis, postgres</span>
<span id="cb2-11"><a href="#cb2-11"></a>        redis:</span>
<span id="cb2-12"><a href="#cb2-12"></a>            condition: service_healthy</span>
<span id="cb2-13"><a href="#cb2-13"></a>        postgres:</span>
<span id="cb2-14"><a href="#cb2-14"></a>            condition: service_healthy</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>&amp;airflow-common는 image, environment, depends_on 인수를 미리 가지고 있음</li>
<li>공통 지정 항목1: &amp;airflow-common
<ul>
<li>변수 또는 parameter: image, environment, depends_on</li>
</ul></li>
<li>공통 지정 항목2: &amp;airflow-common-env
<ul>
<li>변수 또는 parameter: AIRFLOW__CORE__DEFAULT_TIMEZONE, AIRFLOW__CORE__EXECUTOR, AIRFLOW__DATABASE__SQL_ALCHEMY_CONN</li>
</ul></li>
<li>공통 지정 항목3: &amp;airflow-common-depends-on
<ul>
<li>변수 또는 parameter: redis, postgres</li>
</ul></li>
<li>후차적인 스크립트에서 &amp;airflow-common 를 호출 하면 아래의 내용이 모두 호출 됨</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb3-1"><a href="#cb3-1"></a>&amp;airflow-common # 공통 지정 parameters 정의: image, environment, depends_on</span>
<span id="cb3-2"><a href="#cb3-2"></a>image: ${AIRFLOW_IMAGE:-apache/airflow:2.5.2}</span>
<span id="cb3-3"><a href="#cb3-3"></a>environment</span>
<span id="cb3-4"><a href="#cb3-4"></a>    &amp;airflow-common-env</span>
<span id="cb3-5"><a href="#cb3-5"></a>    AIRFLOW__CORE__DEFAULT_TIMEZONE: 'Asia/Seoul'</span>
<span id="cb3-6"><a href="#cb3-6"></a>    AIRFLOW__CORE__EXECUTOR: CeleryExecutor</span>
<span id="cb3-7"><a href="#cb3-7"></a>    AIRFLOW__DATABASE__SQL_ALCHEMY_CONN: postgresql+psycopg2://airflow:airflow@postgres/airflow</span>
<span id="cb3-8"><a href="#cb3-8"></a>depends_on # containers 실행 순서를 결정</span>
<span id="cb3-9"><a href="#cb3-9"></a>    &amp;airflow-common-depends-on # 공통 지정 parameters 정의: redis, postgres</span>
<span id="cb3-10"><a href="#cb3-10"></a>    redis:</span>
<span id="cb3-11"><a href="#cb3-11"></a>        condition: service_healthy</span>
<span id="cb3-12"><a href="#cb3-12"></a>    postgres:</span>
<span id="cb3-13"><a href="#cb3-13"></a>        condition: service_healthy</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>services: 컨테이너로 올릴(실행할) 서비스 지정</p>
<ul>
<li>airflow-webserver key</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb4-1"><a href="#cb4-1"></a>  airflow-webserver:</span>
<span id="cb4-2"><a href="#cb4-2"></a>    &lt;&lt;: *airflow-common #&lt;&lt; 붙여서 공통 지정 항목 (image, environment, depends_on) 호출 </span>
<span id="cb4-3"><a href="#cb4-3"></a>    command: webserver</span>
<span id="cb4-4"><a href="#cb4-4"></a>    ports:</span>
<span id="cb4-5"><a href="#cb4-5"></a>      - "8080:8080"</span>
<span id="cb4-6"><a href="#cb4-6"></a>    healthcheck:</span>
<span id="cb4-7"><a href="#cb4-7"></a>      test: ["CMD", "curl", "--fail", "http://localhost:8080/health"]</span>
<span id="cb4-8"><a href="#cb4-8"></a>      interval: 10s</span>
<span id="cb4-9"><a href="#cb4-9"></a>      timeout: 10s</span>
<span id="cb4-10"><a href="#cb4-10"></a>      retries: 5</span>
<span id="cb4-11"><a href="#cb4-11"></a>      start_period: 30s</span>
<span id="cb4-12"><a href="#cb4-12"></a>    restart: always</span>
<span id="cb4-13"><a href="#cb4-13"></a>    depends_on: #위에서 &lt;&lt;: *airflow-common 때문에 depends on이 있지만 한번 더 설정하게 되면 앞에 있는 depends_on은 무시됨</span>
<span id="cb4-14"><a href="#cb4-14"></a>      &lt;&lt;: *airflow-common-depends-on # *airflow-common의 depends-on 호출 (redis, postgres)</span>
<span id="cb4-15"><a href="#cb4-15"></a>      airflow-init:</span>
<span id="cb4-16"><a href="#cb4-16"></a>        condition: service_completed_successfully</span>
<span id="cb4-17"><a href="#cb4-17"></a>    networks:</span>
<span id="cb4-18"><a href="#cb4-18"></a>      network_custom:</span>
<span id="cb4-19"><a href="#cb4-19"></a>        ipv4_address: 172.28.0.6</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>default postgres 서비스 말고 새로 지정할 postgres 서비스. 초기의 docker_compose.yaml파일에서는 없음</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb5-1"><a href="#cb5-1"></a><span class="an">services:</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>   postgres:</span>
<span id="cb5-3"><a href="#cb5-3"></a>     image: postgres:13</span>
<span id="cb5-4"><a href="#cb5-4"></a>     environment:</span>
<span id="cb5-5"><a href="#cb5-5"></a>       POSTGRES_USER: airflow</span>
<span id="cb5-6"><a href="#cb5-6"></a>       POSTGRES_PASSWORD: airflow</span>
<span id="cb5-7"><a href="#cb5-7"></a>       POSTGRES_DB: airflow</span>
<span id="cb5-8"><a href="#cb5-8"></a>     volumes:</span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="ss">       - </span>postgres-db-volume:/var/lib/postgresql/data</span>
<span id="cb5-10"><a href="#cb5-10"></a>     healthcheck:</span>
<span id="cb5-11"><a href="#cb5-11"></a>       test: <span class="co">[</span><span class="ot">"CMD", "pg_isready", "-U", "airflow"</span><span class="co">]</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>       interval: 10s</span>
<span id="cb5-13"><a href="#cb5-13"></a>       retries: 5</span>
<span id="cb5-14"><a href="#cb5-14"></a>       start_period: 5s</span>
<span id="cb5-15"><a href="#cb5-15"></a>    ports</span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="ss">        - </span>5432:5432</span>
<span id="cb5-17"><a href="#cb5-17"></a>     restart: always</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><code>image: postgres:13</code> 은 image는 postgre:13 버전의 image를 쓴다는 것이고 이 image가 local에 있으면 그대로 쓰고 없으면 인터넷에서 download됨.</li>
<li><code>environment:</code> 는 postgres OS에 설정할 환경 변수들</li>
<li><code>volumes:</code> container와 연결할 local file system 경로를 의미
<ul>
<li><code>postgres-db-volume:/var/lib/postgresql/data</code> <code>:</code>을 기준으로 왼쪽이 local file system의 경로 오른쪽이 연결할 container의 directory. 이 과정을 <strong>mount</strong> 시켰다라고 말함</li>
<li><code>postgres-db-volume</code> 문서 제일 하단에 미리 만들어져 있음</li>
<li>container가 실행되었다가 (띄어졌다가) 꺼지면 (내려지면) 안에 있는 data들이 모두 사라지기 때문에 mount시키는 것이 필요함. 특히, DB container는 mount가 잘 됐는지 확인해야함</li>
<li><code>postgres-db-volume:/var/lib/postgresql/data</code>는 postgresql의 data가 저장되는 directory를 local file system으로 연결시켜 놓은 것<br>
</li>
</ul></li>
<li><code>healthcheck:</code> container가 상태 꺼졌는지 켜졌는지 확인</li>
<li><code>ports</code>: container에 접속하기 위해 공개할 port를 명시
<ul>
<li><code>5432:5432</code> <code>:</code> 을 기준으로 왼쪽이 local에서 web에 접속할 port 번호고 오른쪽이 service가 갖고 있는 port번호. 다시 말해서, wsl 시스템안에 여러 컨테이너들이 있고 그 중 postgres 이미지가 깔려 있다면 postgres는 5432 port를 가지고 있는 상태이다. postgres 이미지에 접근하려면 wsl의 port를 통해서 접근해야하는데 그 wsl의 port가 5432로 지정된 것을 의미한다.</li>
<li>원래 <code>docker-compose.yaml</code> 파일 최초 다운로드시 없는 항목이다. 추가해줘야 함.</li>
</ul></li>
<li><code>restart: always</code> container가 죽으면 언제 새로 띄워주겠냐는 것이고 always니까 항상 새로 띄워줌</li>
<li>redis</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb6-1"><a href="#cb6-1"></a>  redis:</span>
<span id="cb6-2"><a href="#cb6-2"></a>    image: redis:latest</span>
<span id="cb6-3"><a href="#cb6-3"></a>    expose:</span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ss">      - </span>6379</span>
<span id="cb6-5"><a href="#cb6-5"></a>    healthcheck:</span>
<span id="cb6-6"><a href="#cb6-6"></a>      test: <span class="co">[</span><span class="ot">"CMD", "redis-cli", "ping"</span><span class="co">]</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>      interval: 10s</span>
<span id="cb6-8"><a href="#cb6-8"></a>      timeout: 30s</span>
<span id="cb6-9"><a href="#cb6-9"></a>      retries: 50</span>
<span id="cb6-10"><a href="#cb6-10"></a>      start_period: 30s</span>
<span id="cb6-11"><a href="#cb6-11"></a>    restart: always</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><code>expose: 6379</code> 이것 역시 port번호인데 외부와 연결될 때 사용되는 게 아니라 내부 다른 containers와 연결시 사용되는 port번호로 expose parameter로 공개 설정한다.</li>
<li>airflow-webserver</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb7-1"><a href="#cb7-1"></a>  airflow-webserver:</span>
<span id="cb7-2"><a href="#cb7-2"></a>    &lt;&lt;: *airflow-common # &amp;airflow-common의 공통 지정 parameters 호출: image, environment, depends_on</span>
<span id="cb7-3"><a href="#cb7-3"></a>    command: webserver # container를 띄울 때 실행할 명령어</span>
<span id="cb7-4"><a href="#cb7-4"></a>    ports:</span>
<span id="cb7-5"><a href="#cb7-5"></a>      - "8080:8080"</span>
<span id="cb7-6"><a href="#cb7-6"></a>    healthcheck:</span>
<span id="cb7-7"><a href="#cb7-7"></a>      test: ["CMD", "curl", "--fail", "http://localhost:8080/health"]</span>
<span id="cb7-8"><a href="#cb7-8"></a>      interval: 30s</span>
<span id="cb7-9"><a href="#cb7-9"></a>      timeout: 10s</span>
<span id="cb7-10"><a href="#cb7-10"></a>      retries: 5</span>
<span id="cb7-11"><a href="#cb7-11"></a>      start_period: 30s</span>
<span id="cb7-12"><a href="#cb7-12"></a>    restart: always</span>
<span id="cb7-13"><a href="#cb7-13"></a>    depends_on: # 2번째 depends_on 선언이 되어 호출된 (&lt;&lt;: *airflow-common) &amp;airflow-common의 depends_on 의 내용은 무시된다.</span>
<span id="cb7-14"><a href="#cb7-14"></a>      &lt;&lt;: *airflow-common-depends-on # 공통 지정 parameters 호출: redis, postgres</span>
<span id="cb7-15"><a href="#cb7-15"></a>      airflow-init:</span>
<span id="cb7-16"><a href="#cb7-16"></a>        condition: service_completed_successfully</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>services: 1-level (x-airflow-common 같은 level)
<ul>
<li>airflow-webserver, airflow-scheduler, redis, postgres 등이 같은 level의 서비스 항목으로 열거 된다.</li>
</ul></li>
<li>depends_on: containers를 띄우는 (실행하는) 순서를 설정하는 부분으로 위의 예시는
<ul>
<li>redis, postgres, airflow-init을 띄우고 나서 airflow-webserver를 띄우겠다는 것.</li>
<li>[redis, postgres, airflow-init]&gt;&gt;airflow-webserver</li>
</ul></li>
<li>airflow-scheduler: <strong>1-level</strong></li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb8-1"><a href="#cb8-1"></a>  airflow-scheduler: # 1-level</span>
<span id="cb8-2"><a href="#cb8-2"></a>       &lt;&lt;: *airflow-common</span>
<span id="cb8-3"><a href="#cb8-3"></a>       command: scheduler</span>
<span id="cb8-4"><a href="#cb8-4"></a>       healthcheck:</span>
<span id="cb8-5"><a href="#cb8-5"></a>         test: ["CMD", "curl", "--fail", "http://localhost:8974/health"]</span>
<span id="cb8-6"><a href="#cb8-6"></a>         interval: 30s</span>
<span id="cb8-7"><a href="#cb8-7"></a>         timeout: 10s</span>
<span id="cb8-8"><a href="#cb8-8"></a>         retries: 5</span>
<span id="cb8-9"><a href="#cb8-9"></a>         start_period: 30s</span>
<span id="cb8-10"><a href="#cb8-10"></a>       restart: always</span>
<span id="cb8-11"><a href="#cb8-11"></a>       depends_on:</span>
<span id="cb8-12"><a href="#cb8-12"></a>         &lt;&lt;: *airflow-common-depends-on</span>
<span id="cb8-13"><a href="#cb8-13"></a>         airflow-init:</span>
<span id="cb8-14"><a href="#cb8-14"></a>           condition: service_completed_successfully</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>volumes: 컨테이너와 연결하기 위한 볼륨 (공간) 정보 ```markdown volumns: postgree-db-volume: #새로 만들 볼륨 이름</p>
<p>```</p>
<ul>
<li>볼륨에 대한 정보 확인하기
<ol type="1">
<li>볼륨 리스트 보기 : <code>sudo docker volume ls</code> (현재 만들어진 volumes 리스트와 volumne_id가 보임)</li>
<li>볼륨 상세 보기 : <code>sudo docker volume inspect {volume_id}</code></li>
</ol></li>
</ul></li>
<li><p>networks: 컨테이너의 network 정보 구성</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb9-1"><a href="#cb9-1"></a><span class="an">networks:</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co">    network_custom: # 새로 만들 네트워크 이름</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="co">        driver: bridge</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co">        ipam:</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="co">            driver: default</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="co">            config:</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="co">                - subnet : 172.18.0.0/16 # 네트워크 IP의 주소값이 2^16 개, host가 가질 IP의 주소값은 2^16-2 만큼을 할당할 수 있다.</span></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="co">                  gateway: 172.18.0.1</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><p>config:</p>
<ul>
<li>subnet : 172.18.0.0/16</li>
<li>gateway: 172.18.0.1</li>
</ul>
<p>:::{.callout-note} 여기서 언급된 “172.18.0.0/16”은 CIDR (Classless Inter-Domain Routing) 표기법을 사용한 네트워크 주소이다. 이 표기법은 IP 네트워크를 어떻게 분할하고 주소를 할당할 것인지 정의한다.</p>
<p>“172.18.0.0/16”에서 “/16”은 네트워크 마스크의 길이를 나타낸다. 이는 전체 32비트 IPv4 주소 중 상위 16비트가 네트워크 주소를 위해 사용되고, 나머지 하위 16비트가 호스트 주소를 위해 사용됨을 의미한다.</p>
<p>네트워크 주소의 수: “/16” 네트워크 마스크는 2^16, 즉 65,536개의 가능한 호스트 주소를 제공한다. 이는 네트워크의 첫 번째 주소 (172.18.0.0)부터 마지막 주소 (172.18.255.255)까지를 포함한다.</p>
<p>호스트가 사용할 수 있는 주소 수: 실제 호스트가 사용할 수 있는 IP 주소는 이론상 65,536개에서 2개를 뺀 65,534개이다. 이는 네트워크 주소 (172.18.0.0)와 브로드캐스트 주소 (172.18.255.255)가 호스트 할당에 사용되지 않기 때문이다.</p>
<p>네트워크 주소 (여기서는 172.18.0.0): 네트워크 부분은 호스트를 식별하는데 사용되는 부분이 아닌 네트워크 자체를 식별하는데 사용되는 부분. 브로드캐스트 주소 (여기서는 172.18.255.255): 네트워크 내의 모든 호스트에 데이터를 전송하는 데 사용됨.</p>
<p>이러한 설정에서는 네트워크 IP의 주소값이 2^16 (또는 65536) 개로 할당된다.</p>
<p>따라서, 이 설정에서 Docker는 172.18.0.1부터 172.18.255.254까지의 IP 주소 범위를 갖는 네트워크를 생성하며, 이 범위 내의 IP 주소를 컨테이너에 할당할 수 있는데, 그것이 2^16-2이다.</p>
<p>참고로 네트워크 IP 주소는 클래스별로 사설 IP대역을 만들어놨음. A: 10.0.0.0 ~ 10.255.255.255 B: 172.16.0.0 ~ 172.31.255.255 C: 192.168.0.0 ~ 192.168.255.255</p>
<p>B클래스의 네트워크 주소 bit는 16비트이다. 호스트 주소 bit도 16비트. :::</p></li>
<li><p>네트워크에 대한 정보 확인하기</p>
<ol type="1">
<li>네트워크 리스트 보기 : <code>sudo docker network ls</code></li>
<li>네트워크 상세 보기 : <code>sudo docker network inspect {network_id}</code></li>
</ol></li>
</ul></li>
</ul>
</section>
<section id="postgres-컨테이너-올리기" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Postgres 컨테이너 올리기</h1>
<section id="postgress-컨테이너-추가하기" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="postgress-컨테이너-추가하기"><span class="header-section-number">3.1</span> Postgress 컨테이너 추가하기</h2>
<ul>
<li>postgres_custom 이라는 이름의 컨테이너 서비스 추가하기</li>
<li>networks를 만들어 컨테이너에 고정 IP 할당</li>
<li>DBeaver로 postgres DB에 접속</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb10-1"><a href="#cb10-1"></a><span class="an">services:</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>  postgres_custom:</span>
<span id="cb10-3"><a href="#cb10-3"></a>    image: postgres:13</span>
<span id="cb10-4"><a href="#cb10-4"></a>    environment:</span>
<span id="cb10-5"><a href="#cb10-5"></a>      POSTGRES_USER: kmkim</span>
<span id="cb10-6"><a href="#cb10-6"></a>      POSTGRES_PASSWORD: kmkim</span>
<span id="cb10-7"><a href="#cb10-7"></a>      POSTGRES_DB: kmkim</span>
<span id="cb10-8"><a href="#cb10-8"></a>      TZ: Asia/Seoul</span>
<span id="cb10-9"><a href="#cb10-9"></a>    volumes:</span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="ss">      - </span>postgres-custom-db-volume:/var/lib/postgresql/data</span>
<span id="cb10-11"><a href="#cb10-11"></a>    ports:</span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="ss">      - </span>5432:5432</span>
<span id="cb10-13"><a href="#cb10-13"></a>    networks:</span>
<span id="cb10-14"><a href="#cb10-14"></a>      network_custom: # 밑에서 정의한 network_custom 을 쓰겠다는 의미</span>
<span id="cb10-15"><a href="#cb10-15"></a>        ipv4_address: 172.28.0.3 # 할당된 IP</span>
<span id="cb10-16"><a href="#cb10-16"></a></span>
<span id="cb10-17"><a href="#cb10-17"></a>networks:</span>
<span id="cb10-18"><a href="#cb10-18"></a>  network_custom: </span>
<span id="cb10-19"><a href="#cb10-19"></a>    driver: bridge</span>
<span id="cb10-20"><a href="#cb10-20"></a>    ipam:</span>
<span id="cb10-21"><a href="#cb10-21"></a>        driver: default</span>
<span id="cb10-22"><a href="#cb10-22"></a>        config:</span>
<span id="cb10-23"><a href="#cb10-23"></a><span class="ss">            - </span>subnet: 172.28.0.0/16 # 네트 워크 ID 주소 밑에 16개/host id 주소 밑에 16개를 할당하겠다는 의미</span>
<span id="cb10-24"><a href="#cb10-24"></a>              gateway: 172.28.0.1 # default 네트워크 (172.18.0.0)가 쓰고 있지 않은 서브넷으로 구성</span>
<span id="cb10-25"><a href="#cb10-25"></a>volumes:</span>
<span id="cb10-26"><a href="#cb10-26"></a>  postgres-db-volume:</span>
<span id="cb10-27"><a href="#cb10-27"></a>  postgres-custom-db-volume: #wsl의 어느 path에 mapping이 되어 있는지 확인할 것</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="컨테이너-고정-ip-할당하기" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="컨테이너-고정-ip-할당하기"><span class="header-section-number">3.2</span> 컨테이너 고정 IP 할당하기</h2>
<ul>
<li>기본적으로 컨테이너들은 유동 IP를 지니며 (재기동시 IP 변경 가능)</li>
<li>postgres DB에 접속하려면 고정 IP 필요</li>
<li>고정 IP를 할당하려면 networks를 만들어서 할당해야 함.</li>
<li>networks 를 지정하지 않은 컨테이너들(airflow를 설치하면서 기본적으로 설치되는 containers)은 default network에 묶이게 됨</li>
<li>따라서 동일 네트워크에 두고 싶은 컨테이너들은 모두 동일 netwworks 할당 필요</li>
<li>기존 containers와 custom container를 모두 custom networks를 바라보게 지정 필요</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb11-1"><a href="#cb11-1"></a><span class="an">networks:</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>  network_custom: </span>
<span id="cb11-3"><a href="#cb11-3"></a>    driver: bridge</span>
<span id="cb11-4"><a href="#cb11-4"></a>    ipam:</span>
<span id="cb11-5"><a href="#cb11-5"></a>        driver: default</span>
<span id="cb11-6"><a href="#cb11-6"></a>        config:</span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="ss">            - </span>subnet: 172.28.0.0/16 # 네트 워크 ID 주소 밑에 16개/host id 주소 밑에 16개를 할당하겠다는 의미</span>
<span id="cb11-8"><a href="#cb11-8"></a>              gateway: 172.28.0.1 # default 네트워크 (172.18.0.0)가 쓰고 있지 않은 서브넷으로 구성</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><p>Postgres_custom 컨테이너 뿐만 아니라 다른 컨테이너에도 network_custom 할당하고 IP 부여</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb12-1"><a href="#cb12-1"></a><span class="an">postgres_custom:</span><span class="co">  # 172.28.0.3</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="an">postgres:</span><span class="co">  # 172.28.0.3 +  포트 노출 설정:(5431:5432)</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="an">redis:</span><span class="co"> # 172.28.0.5</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="an">airflow-webserver:</span><span class="co"> # 172.28.0.6</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="an">airflow-scheduler:</span><span class="co"> # 172.28.0.7</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="an">airflow-worker:</span><span class="co"> # 172.28.0.8</span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="an">airflow-triggerer:</span><span class="co"> # 172.28.0.9</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="an">airflow-init:</span><span class="co"> # 172.28.0.10</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>postgres: # airflow가 기본 메타DB로 쓰고 있는 postgress 컨테이너에 포트 번호 5431로 노출</li>
</ul></li>
<li><p>networks에 172.28.xxx.xxx 같이 172.28 대역을 준 이유</p>
<ul>
<li>아래와 같이 <code>sudo docker ps</code> 를 실행해 container list를 보고 container id를 확인 하여 <code>sudo docker inspect {container_id}</code> or <code>sudo docker inspect b739a3494646</code> 실행해보면 다음과 같은 정보를 볼 수 있다.</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb13-1"><a href="#cb13-1"></a> "NetworkSettings": {</span>
<span id="cb13-2"><a href="#cb13-2"></a>          "Bridge": "",</span>
<span id="cb13-3"><a href="#cb13-3"></a>          "SandboxID": "b1bda217ebe565bfcf64b3c52e7fbf47032821894db5d97ef9f8f85db5ee57d3",            "HairpinMode": false,</span>
<span id="cb13-4"><a href="#cb13-4"></a>          "LinkLocalIPv6Address": "",</span>
<span id="cb13-5"><a href="#cb13-5"></a>          "LinkLocalIPv6PrefixLen": 0,</span>
<span id="cb13-6"><a href="#cb13-6"></a>          "Ports": {},</span>
<span id="cb13-7"><a href="#cb13-7"></a>          "SandboxKey": "/var/run/docker/netns/b1bda217ebe5",</span>
<span id="cb13-8"><a href="#cb13-8"></a>          "SecondaryIPAddresses": null,</span>
<span id="cb13-9"><a href="#cb13-9"></a>          "SecondaryIPv6Addresses": null,</span>
<span id="cb13-10"><a href="#cb13-10"></a>          "EndpointID": "",</span>
<span id="cb13-11"><a href="#cb13-11"></a>          "Gateway": "", # custom-network로 지정해주기전엔 여기 172.19.0.1 로 되어 있었음</span>
<span id="cb13-12"><a href="#cb13-12"></a>          "GlobalIPv6Address": "",</span>
<span id="cb13-13"><a href="#cb13-13"></a>          "GlobalIPv6PrefixLen": 0,</span>
<span id="cb13-14"><a href="#cb13-14"></a>          "IPAddress": "", # custom-network로 지정해주기전엔 여기 172.19.0.6 로 되어 있었음</span>
<span id="cb13-15"><a href="#cb13-15"></a>          "IPPrefixLen": 0,</span>
<span id="cb13-16"><a href="#cb13-16"></a>          "IPv6Gateway": "",</span>
<span id="cb13-17"><a href="#cb13-17"></a>          "MacAddress": "",</span>
<span id="cb13-18"><a href="#cb13-18"></a>          "Networks": {</span>
<span id="cb13-19"><a href="#cb13-19"></a>              "airflow_network_custom": {</span>
<span id="cb13-20"><a href="#cb13-20"></a>                  "IPAMConfig": {</span>
<span id="cb13-21"><a href="#cb13-21"></a>                      "IPv4Address": "172.28.0.8"</span>
<span id="cb13-22"><a href="#cb13-22"></a>                  },</span>
<span id="cb13-23"><a href="#cb13-23"></a>                  "Links": null,</span>
<span id="cb13-24"><a href="#cb13-24"></a>                  "Aliases": [</span>
<span id="cb13-25"><a href="#cb13-25"></a>                      "airflow-airflow-worker-1",</span>
<span id="cb13-26"><a href="#cb13-26"></a>                      "airflow-worker",</span>
<span id="cb13-27"><a href="#cb13-27"></a>                      "b739a3494646"</span>
<span id="cb13-28"><a href="#cb13-28"></a>                  ],</span>
<span id="cb13-29"><a href="#cb13-29"></a>                  "NetworkID": "eb43aaa125bcf1aac0fd512057de947abafd9397dd0d51cf7f49582c8c7d5eb9",</span>
<span id="cb13-30"><a href="#cb13-30"></a>                  "EndpointID": "",</span>
<span id="cb13-31"><a href="#cb13-31"></a>                  "Gateway": "",</span>
<span id="cb13-32"><a href="#cb13-32"></a>                  "IPAddress": "",</span>
<span id="cb13-33"><a href="#cb13-33"></a>                  "IPPrefixLen": 0,</span>
<span id="cb13-34"><a href="#cb13-34"></a>                  "IPv6Gateway": "",</span>
<span id="cb13-35"><a href="#cb13-35"></a>                  "GlobalIPv6Address": "",</span>
<span id="cb13-36"><a href="#cb13-36"></a>                  "GlobalIPv6PrefixLen": 0,</span>
<span id="cb13-37"><a href="#cb13-37"></a>                  "MacAddress": "",</span>
<span id="cb13-38"><a href="#cb13-38"></a>                  "DriverOpts": null</span>
<span id="cb13-39"><a href="#cb13-39"></a>              }</span>
<span id="cb13-40"><a href="#cb13-40"></a>          }</span>
<span id="cb13-41"><a href="#cb13-41"></a>      }</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>현재 설치되어 있는 networks list 보기 : <code>sudo docker network ls</code></li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb14-1"><a href="#cb14-1"></a>NETWORK ID     NAME                     DRIVER    SCOPE</span>
<span id="cb14-2"><a href="#cb14-2"></a>260163833c67   airflow_default          bridge    local</span>
<span id="cb14-3"><a href="#cb14-3"></a>eb43aaa125bc   airflow_network_custom   bridge    local</span>
<span id="cb14-4"><a href="#cb14-4"></a>1543a7e87603   bridge                   bridge    local</span>
<span id="cb14-5"><a href="#cb14-5"></a>9d0e4a4e52ce   host                     host      local</span>
<span id="cb14-6"><a href="#cb14-6"></a>5c1f555d034f   none                     null      local</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>worker container는 “NetworkID”: “eb43aaa125bcf1aac0fd512057de947abafd9397dd0d51cf7f49582c8c7d5eb9” 에서 앞 부분이 eb43aaa125bc 이기 때문에 airflow_network_custom을 사용하는 것을 볼 수 있다. (networks 지정 전에는 default에 있음)</li>
<li>원래 default network는 IP를 172.19.xxx.xxx 대역을 쓰기 때문에 networkd대역을 만들때는 179.19대역은 피해야 한다. network custom에서는 안전하게 172.29.xxx.xxx IP 주소가 충돌이 되지 않도록 29로 설정한다.</li>
</ul></li>
<li><p>Volume 현황 보기 : <code>sudo docker volume ls</code></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb15-1"><a href="#cb15-1"></a>DRIVER    VOLUME NAME</span>
<span id="cb15-2"><a href="#cb15-2"></a>local     1e0ab35524a66be9d849f574436e148479f9af7dd76c763cd4dac2ac147aba3c # docker가 알아서 만든 volume</span>
<span id="cb15-3"><a href="#cb15-3"></a>local     2f2593b44a32b1474400a100216ccc0e9658b99b1cc0c83ad993bc3bb387d4ba # docker가 알아서 만든 volume </span>
<span id="cb15-4"><a href="#cb15-4"></a>local     4ae485474d6168c4b62c3bd6ba1b6cd130576d49e733314f3802e36ad34f47a2 # docker가 알아서 만든 volume</span>
<span id="cb15-5"><a href="#cb15-5"></a>local     4b80894138e5d2ed6b8d5a99723ac747e4325d215e04a81e7ec6254581758109 # docker가 알아서 만든 volume</span>
<span id="cb15-6"><a href="#cb15-6"></a>local     8bec2d1d658ea13617520f12f1d73981ee2cb7740bee4f3b10ce0aa1e565d0ee # docker가 알아서 만든 volume</span>
<span id="cb15-7"><a href="#cb15-7"></a>local     91a25038cbe4cec1757bb4ccb35b7a91d73000dfa501c45aa9ebebba351f4882 # docker가 알아서 만든 volume</span>
<span id="cb15-8"><a href="#cb15-8"></a>local     0315bc7a7513fc0480ae1b220b3f3022d1df134f21c31a3b05282960ea58b820 # docker가 알아서 만든 volume</span>
<span id="cb15-9"><a href="#cb15-9"></a>local     884de047d72dc84fcf02c7f2dba0c3c5ca6e4d2ef2eb7c2f471be32740ca6949 # docker가 알아서 만든 volume</span>
<span id="cb15-10"><a href="#cb15-10"></a>local     7300ab83ca5c136dbd95e2d969e5d7d8e09c285c169aaf7789d396d12a940b7a # docker가 알아서 만든 volume</span>
<span id="cb15-11"><a href="#cb15-11"></a>local     9619310c2f4f3e281b2bd49626cb7ffb157b97946e25bc2d84ea6a27b3842d7e # docker가 알아서 만든 volume</span>
<span id="cb15-12"><a href="#cb15-12"></a>local     94856658cd6a9ba830bdfd39a73fcf6737cdf82707454c3da2ea6f59c1599ce2 # docker가 알아서 만든 volume</span>
<span id="cb15-13"><a href="#cb15-13"></a>local     a9f0f6f5f1f4b83a4c1af47aef4ff8f0692cd21eed9db9cde77b08538ccd55a3 # docker가 알아서 만든 volume</span>
<span id="cb15-14"><a href="#cb15-14"></a>local     a97aa8ddd6bf1224517f37eaeee7425dbfcce1b144ec5c0f3a5bcab47cb80f69 # docker가 알아서 만든 volume</span>
<span id="cb15-15"><a href="#cb15-15"></a>local     ac91a112c4c03b110775e6ff6cdf8ae774f0376836501f96eb95130594038ec9 # docker가 알아서 만든 volume</span>
<span id="cb15-16"><a href="#cb15-16"></a>local     airflow_postgres-custom-db-volume # 내가 만든 volume</span>
<span id="cb15-17"><a href="#cb15-17"></a>local     airflow_postgres-db-volume # airflow가 postgres container를 실행하면서 만들었던 metaDB를 위한 volume</span>
<span id="cb15-18"><a href="#cb15-18"></a>local     b3b8ab88bbaa69adc798f5fbeebe75dd4d4e47843e9e2861922193695e614926 # docker가 알아서 만든 volume </span>
<span id="cb15-19"><a href="#cb15-19"></a>local     b41f5d39b0778ca5efdc714a54ae103503cb8a96778cd9bdd19ecf5857e92e85 # docker가 알아서 만든 volume</span>
<span id="cb15-20"><a href="#cb15-20"></a>local     c5c7439b17427b11aceee49239ed8f3f4805a9c531cf8a3673a635b2f17cc3ec # docker가 알아서 만든 volume</span>
<span id="cb15-21"><a href="#cb15-21"></a>local     d31b1c160d8127fab58d1585a44b62498c4f0ae5c42962d68cd725cffe9fdd2d # docker가 알아서 만든 volume</span>
<span id="cb15-22"><a href="#cb15-22"></a>local     f928be82c57a041a2e02e43b81e6e1280b00c71b39a12bb05ff9a1dd9d1ddb32 # docker가 알아서 만든 volume</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>volume detail 보기 : <code>sudo docker volume inspect airflow_postgres-custom-db-volume</code></li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb16-1"><a href="#cb16-1"></a>[</span>
<span id="cb16-2"><a href="#cb16-2"></a>  {</span>
<span id="cb16-3"><a href="#cb16-3"></a>      "CreatedAt": "2023-07-01T10:38:26+09:00",</span>
<span id="cb16-4"><a href="#cb16-4"></a>      "Driver": "local",</span>
<span id="cb16-5"><a href="#cb16-5"></a>      "Labels": {</span>
<span id="cb16-6"><a href="#cb16-6"></a>          "com.docker.compose.project": "airflow",</span>
<span id="cb16-7"><a href="#cb16-7"></a>          "com.docker.compose.version": "2.18.1",</span>
<span id="cb16-8"><a href="#cb16-8"></a>          "com.docker.compose.volume": "postgres-custom-db-volume"</span>
<span id="cb16-9"><a href="#cb16-9"></a>      },</span>
<span id="cb16-10"><a href="#cb16-10"></a>      "Mountpoint": "/var/lib/docker/volumes/airflow_postgres-custom-db-volume/_data",</span>
<span id="cb16-11"><a href="#cb16-11"></a>      "Name": "airflow_postgres-custom-db-volume",</span>
<span id="cb16-12"><a href="#cb16-12"></a>      "Options": null,</span>
<span id="cb16-13"><a href="#cb16-13"></a>      "Scope": "local"</span>
<span id="cb16-14"><a href="#cb16-14"></a>  }</span>
<span id="cb16-15"><a href="#cb16-15"></a>]</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>volume의 위치: “/var/lib/docker/volumes/airflow_postgres-custom-db-volume/_data”
<ul>
<li><code>sudo ls /var/lib/docker/volumes/airflow_postgres-custom-db-volume/_data</code> 실행하면 postgres container가 쓰고있는 file list를 확인할 수 있다.</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb17-1"><a href="#cb17-1"></a>PG_VERSION  global        pg_dynshmem  pg_ident.conf  pg_multixact  pg_replslot  pg_snapshots  pg_stat_tmp  pg_tblspc    pg_wal   postgresql.auto.conf  postmaster.opts   base  pg_commit_ts  pg_hba.conf  pg_logical     pg_notify     pg_serial    pg_stat       pg_subtrans  pg_twophase  pg_xact  postgresql.conf       postmaster.pid</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<h2 id="db-접속하기" data-number="3.3" class="anchored"><span class="header-section-number">3.3</span> DB 접속하기</h2></li>
</ul></li>
<li><p><a href="https://dbeaver.io/">Dbeaver 설치 https://dbeaver.io/</a></p></li>
<li><p>community versiono 설치하면 됨 &gt;&gt; windows installer download 받아 설치</p></li>
</ul>
<section id="dbeaver에-postgres-연결" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="dbeaver에-postgres-연결"><span class="header-section-number">3.3.1</span> DBeaver에 Postgres 연결</h3>
<p><img src="../../../../../images/airflow/postgres_install1.PNG" class="img-fluid" alt="New Database Connection"> <img src="../../../../../images/airflow/postgres_install2.PNG" class="img-fluid" alt="Postgres Connection"></p>
<ul>
<li>3번: localhost 자체가 local의 wsl을 의미하기 때문에 그대로 놔두면 됨</li>
<li>4번: port는 docker_compose.yaml에 설정된 port번호 자동으로 입력되서 나옴</li>
<li>5번: kmkim (docker_compose.yaml 설정대로 바꿔야함)</li>
<li>6번: kmkim (docker_compose.yaml 설정대로 바꿔야함)</li>
</ul>
</section>
<section id="airflow-metadb-연결" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="airflow-metadb-연결"><span class="header-section-number">3.3.2</span> Airflow metaDB 연결</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../../../../images/airflow/airflow_metadb_connection.PNG" class="img-fluid figure-img"></p>
<figcaption>Airflow MetaDB Connection</figcaption>
</figure>
</div>
<ul>
<li>1번: docker_compose.yaml 설정대로 5431이 나옴</li>
<li>2번: database 이름은 airflow</li>
<li>3번: username은 airflow</li>
<li>4번: password는 airflow</li>
</ul>
</section>
</section>
</section>
<section id="connection-hook" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Connection &amp; Hook</h1>
<section id="postgres에-데이터-insert" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="postgres에-데이터-insert"><span class="header-section-number">4.1</span> Postgres에 데이터 insert</h2>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb18-1"><a href="#cb18-1"></a>from airflow import DAG</span>
<span id="cb18-2"><a href="#cb18-2"></a>import pendulum</span>
<span id="cb18-3"><a href="#cb18-3"></a>from airflow.operators.python import PythonOperator</span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a>with DAG(</span>
<span id="cb18-6"><a href="#cb18-6"></a>    dag_id='dags_python_with_postgres',</span>
<span id="cb18-7"><a href="#cb18-7"></a>    start_date=pendulum.datetime(2023,4,1, tz='Asia/Seoul'),</span>
<span id="cb18-8"><a href="#cb18-8"></a>    schedule=None,</span>
<span id="cb18-9"><a href="#cb18-9"></a>    catchup=False</span>
<span id="cb18-10"><a href="#cb18-10"></a>) as dag:</span>
<span id="cb18-11"><a href="#cb18-11"></a></span>
<span id="cb18-12"><a href="#cb18-12"></a><span class="in">    </span></span>
<span id="cb18-13"><a href="#cb18-13"></a><span class="in">    def insrt_postgres(ip, port, dbname, user, passwd, **kwargs):</span></span>
<span id="cb18-14"><a href="#cb18-14"></a><span class="in">        import psycopg2 # postgres DB에 접속해서 sql query 를 날리고 결과를 가지고 올수있게 해주는 library</span></span>
<span id="cb18-15"><a href="#cb18-15"></a><span class="in">        from contextlib import closing</span></span>
<span id="cb18-16"><a href="#cb18-16"></a></span>
<span id="cb18-17"><a href="#cb18-17"></a><span class="in">        with closing(psycopg2.connect(host=ip, dbname=dbname, user=user, password=passwd, port=int(port))) as conn:</span></span>
<span id="cb18-18"><a href="#cb18-18"></a><span class="in">            with closing(conn.cursor()) as cursor:</span></span>
<span id="cb18-19"><a href="#cb18-19"></a><span class="in">                dag_id = kwargs.get('ti').dag_id</span></span>
<span id="cb18-20"><a href="#cb18-20"></a><span class="in">                task_id = kwargs.get('ti').task_id</span></span>
<span id="cb18-21"><a href="#cb18-21"></a><span class="in">                run_id = kwargs.get('ti').run_id</span></span>
<span id="cb18-22"><a href="#cb18-22"></a><span class="in">                msg = 'insrt 수행'</span></span>
<span id="cb18-23"><a href="#cb18-23"></a><span class="in">                sql = 'insert into py_opr_drct_insrt values (%s,%s,%s,%s);'</span></span>
<span id="cb18-24"><a href="#cb18-24"></a><span class="in">                cursor.execute(sql,(dag_id,task_id,run_id,msg))</span></span>
<span id="cb18-25"><a href="#cb18-25"></a><span class="in">                conn.commit()</span></span>
<span id="cb18-26"><a href="#cb18-26"></a></span>
<span id="cb18-27"><a href="#cb18-27"></a><span class="in">    insrt_postgres = PythonOperator(</span></span>
<span id="cb18-28"><a href="#cb18-28"></a><span class="in">        task_id='insrt_postgres',</span></span>
<span id="cb18-29"><a href="#cb18-29"></a><span class="in">        python_callable=insrt_postgres,</span></span>
<span id="cb18-30"><a href="#cb18-30"></a><span class="in">        op_args=['172.28.0.3', '5432', 'hjkim', 'hjkim', 'hjkim']</span></span>
<span id="cb18-31"><a href="#cb18-31"></a><span class="in">    )</span></span>
<span id="cb18-32"><a href="#cb18-32"></a><span class="in">        </span></span>
<span id="cb18-33"><a href="#cb18-33"></a><span class="in">    insrt_postgres</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><p><code>psycopg2.connect(host=ip, dbname=dbname, user=user, password=passwd, port=int(port))</code> : DB server와의 연결 (Session)</p>
<ul>
<li>session: TCP/IP 기반의 connection</li>
</ul></li>
<li><p><code>closing()</code> 은 <code>psycopg2.connect()</code> 객체를 닫아주는 역할</p>
<ul>
<li>예를 들어, <code>with() as ~</code> statement없이 DB server에 연결하는 명령어는 다음과 같다</li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb19-1"><a href="#cb19-1"></a>conn = psycopg2.connect()</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="in">~~~</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="in">conn.close()</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>여기서 <code>conn.close()</code>의 기능을 하는 명령어가 <code>closing()</code> 이다</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb20-1"><a href="#cb20-1"></a>with closing(psycopg2.connect(...)) as conn:</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>conn session (con object)에서 sql을 이용한 구체적인 query 내용은 두 번째 with문에서 기술</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb21-1"><a href="#cb21-1"></a> with closing(conn.cursor()) as cursor:</span>
<span id="cb21-2"><a href="#cb21-2"></a>              dag_id = kwargs.get('ti').dag_id # task instance object 에서 dag_id (property) 호출</span>
<span id="cb21-3"><a href="#cb21-3"></a>              task_id = kwargs.get('ti').task_id # task instance object 에서 task_id (property) 호출</span>
<span id="cb21-4"><a href="#cb21-4"></a>              run_id = kwargs.get('ti').run_id # task instance object 에서 run_id (property) 호출</span>
<span id="cb21-5"><a href="#cb21-5"></a>              msg = 'insrt 수행'</span>
<span id="cb21-6"><a href="#cb21-6"></a>              sql = 'insert into py_opr_drct_insrt values (%s,%s,%s,%s);' </span>
<span id="cb21-7"><a href="#cb21-7"></a>              cursor.execute(sql,(dag_id,task_id,run_id,msg)) # 실제 sql 실행하는 부분</span>
<span id="cb21-8"><a href="#cb21-8"></a>              conn.commit()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>cursor: client <span class="math inline">\(\xleftrightarrow{\text{cursor}}\)</span> DB server. client(python로직을 호출하는 worker container)와 DB서버(container) 사이의 session(client와 DB 서버와의 connection 역할)안에서 client에서 query를 날리고 DB서버로부터 결과를 가져와주는 object. 이 cursor에서 sql 수행. 그러므로 cursor (=conn.cursor())가 없으면 query 수행을 못함</li>
<li><code>cursor.execute(sql,(dag_id,task_id,run_id,msg))</code>: 실제 sql 실행하는 부분</li>
<li><code>py_opr_drct_insrt</code> : 테이블 이름</li>
<li><code>values (%s,%s,%s,%s)</code> 4개의 값 binding: <code>dag_id</code>, <code>task_id</code>, <code>run_id</code>, <code>msg</code>. 즉, <code>cursor.execute(sql,(dag_id,task_id,run_id,msg))</code>의 dag_id,task_id,run_id,msg 과 연결</li>
</ul></li>
<li><p>conn이 끝나면 첫 번째 with문의 closing()이 session을 닫아줌</p></li>
<li><p>위의 코드가 아래의 코드와 같은 내용임</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb22-1"><a href="#cb22-1"></a>conn=psycopg2.connect(...)</span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="in">~~~</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="in">conn.close()</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>task 수행</p></li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb23-1"><a href="#cb23-1"></a>  insrt_postgres = PythonOperator(</span>
<span id="cb23-2"><a href="#cb23-2"></a>        task_id='insrt_postgres',</span>
<span id="cb23-3"><a href="#cb23-3"></a>        python_callable=insrt_postgres,</span>
<span id="cb23-4"><a href="#cb23-4"></a>        op_args=<span class="co">[</span><span class="ot">'172.28.0.3', '5432', 'hjkim', 'hjkim', 'hjkim'</span><span class="co">]</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>    )</span>
<span id="cb23-6"><a href="#cb23-6"></a>        </span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="in">    insrt_postgres</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><code>def insrt_postgres(ip, port, dbname, user, passwd, **kwargs)</code> 에서 보듯이
<ul>
<li>ip = ‘172.28.0.3’</li>
<li>port = ‘5422’</li>
<li>dbname = ‘hjkim’</li>
<li>passwd = ‘hjkim’</li>
<li>**kwargs = NULL</li>
</ul></li>
<li>postgres DB에 table 만들기
<ul>
<li>DBeaver Open &gt;&gt; kmkim databse 우클릭&gt;&gt; SQL editor &gt;&gt; New SQL Script &gt;&gt; <code>py_opr_drct_insrt</code> table 생성</li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb24-1"><a href="#cb24-1"></a>create table py_opr_drct_insrt(</span>
<span id="cb24-2"><a href="#cb24-2"></a>  dag_id varchar(100),</span>
<span id="cb24-3"><a href="#cb24-3"></a>  task_id varchar(100),</span>
<span id="cb24-4"><a href="#cb24-4"></a>  run_id varchar(100),</span>
<span id="cb24-5"><a href="#cb24-5"></a>  msg text # 가변길이 type</span>
<span id="cb24-6"><a href="#cb24-6"></a>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>table 확인: kmkim &gt;&gt; Databases &gt;&gt; Schemas &gt;&gt; public</li>
</ul></li>
<li>DAG full example</li>
</ul>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource mardkown number-lines code-with-copy"><code class="sourceCode"><span id="cb25-1"><a href="#cb25-1"></a>from airflow import DAG</span>
<span id="cb25-2"><a href="#cb25-2"></a>import pendulum</span>
<span id="cb25-3"><a href="#cb25-3"></a>from airflow.operators.python import PythonOperator</span>
<span id="cb25-4"><a href="#cb25-4"></a></span>
<span id="cb25-5"><a href="#cb25-5"></a>with DAG(</span>
<span id="cb25-6"><a href="#cb25-6"></a>    dag_id='dags_python_with_postgres',</span>
<span id="cb25-7"><a href="#cb25-7"></a>    start_date=pendulum.datetime(2023,4,1, tz='Asia/Seoul'),</span>
<span id="cb25-8"><a href="#cb25-8"></a>    schedule=None,</span>
<span id="cb25-9"><a href="#cb25-9"></a>    catchup=False</span>
<span id="cb25-10"><a href="#cb25-10"></a>) as dag:</span>
<span id="cb25-11"><a href="#cb25-11"></a></span>
<span id="cb25-12"><a href="#cb25-12"></a>    </span>
<span id="cb25-13"><a href="#cb25-13"></a>    def insrt_postgres(ip, port, dbname, user, passwd, **kwargs):</span>
<span id="cb25-14"><a href="#cb25-14"></a>        import psycopg2</span>
<span id="cb25-15"><a href="#cb25-15"></a>        from contextlib import closing</span>
<span id="cb25-16"><a href="#cb25-16"></a></span>
<span id="cb25-17"><a href="#cb25-17"></a>        with closing(psycopg2.connect(host=ip, dbname=dbname, user=user, password=passwd, port=int(port))) as conn:</span>
<span id="cb25-18"><a href="#cb25-18"></a>            with closing(conn.cursor()) as cursor:</span>
<span id="cb25-19"><a href="#cb25-19"></a>                dag_id = kwargs.get('ti').dag_id</span>
<span id="cb25-20"><a href="#cb25-20"></a>                task_id = kwargs.get('ti').task_id</span>
<span id="cb25-21"><a href="#cb25-21"></a>                run_id = kwargs.get('ti').run_id</span>
<span id="cb25-22"><a href="#cb25-22"></a>                msg = 'insrt 수행'</span>
<span id="cb25-23"><a href="#cb25-23"></a>                sql = 'insert into py_opr_drct_insrt values (%s,%s,%s,%s);'</span>
<span id="cb25-24"><a href="#cb25-24"></a>                cursor.execute(sql,(dag_id,task_id,run_id,msg))</span>
<span id="cb25-25"><a href="#cb25-25"></a>                conn.commit()</span>
<span id="cb25-26"><a href="#cb25-26"></a></span>
<span id="cb25-27"><a href="#cb25-27"></a>    insrt_postgres = PythonOperator(</span>
<span id="cb25-28"><a href="#cb25-28"></a>        task_id='insrt_postgres',</span>
<span id="cb25-29"><a href="#cb25-29"></a>        python_callable=insrt_postgres,</span>
<span id="cb25-30"><a href="#cb25-30"></a>        op_args=['172.28.0.3', '5432', 'hjkim', 'hjkim', 'hjkim']</span>
<span id="cb25-31"><a href="#cb25-31"></a>    )</span>
<span id="cb25-32"><a href="#cb25-32"></a>        </span>
<span id="cb25-33"><a href="#cb25-33"></a>    insrt_postgres</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="문제점-및-해결방법" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="문제점-및-해결방법"><span class="header-section-number">4.2</span> 문제점 및 해결방법</h2>
<ul>
<li>문제점
<ul>
<li>접속정보 노출: postgres DB에 대한 User, Password 등
<ul>
<li>DAG을 열어볼 수 있는 사람이나 github에 접속할 수 있는 사람은 모두 볼 수 있음</li>
</ul></li>
<li>접속정보 변경시 대응 어려움
<ul>
<li>만약 직접 접속하는 DAG이 수백개라면?</li>
</ul></li>
</ul></li>
<li>해결 방법
<ul>
<li>Variable 이용 (User, Password 등을 Variable에 등록하고 꺼내오기) - 번거롭기 때문에 권장하는 방식은 아님</li>
<li>Hook 이용 (Variable 등록 필요없음)</li>
</ul></li>
</ul>
</section>
<section id="connection과-hook의-개념" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="connection과-hook의-개념"><span class="header-section-number">4.3</span> Connection과 Hook의 개념</h2>
<ul>
<li>Connection
<ul>
<li>Airflow UI 화면에서 등록한 커넥션 정보</li>
</ul></li>
<li>Hook의 개념
<ul>
<li>Airflow에서 외부 솔루션의 기능을 사용할 수 있도록 미리 구현된 메서드를 가진 클래스</li>
</ul></li>
<li>Hook의 특징
<ul>
<li>Connection 정보를 통해 생성되는 객체로 Hook을 사용하기 위해선 먼저 connection을 등록해야한다.
<ul>
<li>접속정보를 Connection을 통해 받아오므로 접속정보가 코드상 노출되지 않음</li>
</ul></li>
<li>특정 솔루션을 다룰 수 있는 메서드가 구현되어 있음.</li>
<li>operator나 sensor와는 달리 Hook은 task를 만들어내지 못하므로 Custom operator 안에서나 Python operator 내 함수에서 사용됨</li>
</ul></li>
</ul>
</section>
<section id="connection-등록" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="connection-등록"><span class="header-section-number">4.4</span> Connection 등록</h2>
<ul>
<li>airflow web ui &gt;&gt; admin &gt;&gt; connections &gt;&gt; plus button &gt;&gt;</li>
</ul>
<table class="table">
<thead>
<tr class="header">
<th>Connection_id</th>
<th style="text-align: left;">conn-db-postgres-custom</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Connection_type</td>
<td style="text-align: left;">postgres</td>
</tr>
<tr class="even">
<td>Host</td>
<td style="text-align: left;">172.28.0.3</td>
</tr>
<tr class="odd">
<td>Schema</td>
<td style="text-align: left;">kmkim</td>
</tr>
<tr class="even">
<td>Login</td>
<td style="text-align: left;">kmkim</td>
</tr>
<tr class="odd">
<td>Password</td>
<td style="text-align: left;">kmkim</td>
</tr>
<tr class="even">
<td>Port</td>
<td style="text-align: left;">5432</td>
</tr>
</tbody>
</table>
</section>
<section id="postgres-hook-명세-보기" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="postgres-hook-명세-보기"><span class="header-section-number">4.5</span> Postgres Hook 명세 보기</h2>
<ul>
<li><a href="https://airflow.apache.org/docs/apache-airflow-providers-postgres/5.4.0/_modules/airflow/providers/postgres/hooks/postgres.html#PostgresHook.get_conn">airflow web service &gt;&gt; Providers &gt;&gt; apache.airflow.providers.postgres &gt;&gt; Python API &gt;&gt; airflow.providers.postgres.hooks.postgres &gt;&gt; get_conn() &gt;&gt; [source] &gt;&gt; def get_conn(self)</a></li>
<li>제공하는 함수의 source code를 잘 관찰하고 custom object(custom operator, custom sensor, custom hook 등)를 만드는 것에 익숙해져야 airflow를 잘 활용할 수 있다.</li>
</ul>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb26-1"><a href="#cb26-1"></a>def get_conn(self) -&gt; connection:</span>
<span id="cb26-2"><a href="#cb26-2"></a>        """Establishes a connection to a postgres database."""</span>
<span id="cb26-3"><a href="#cb26-3"></a>        conn_id = getattr(self, self.conn_name_attr)</span>
<span id="cb26-4"><a href="#cb26-4"></a>        conn = deepcopy(self.connection or self.get_connection(conn_id))</span>
<span id="cb26-5"><a href="#cb26-5"></a></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="in">        # check for authentication via AWS IAM</span></span>
<span id="cb26-7"><a href="#cb26-7"></a><span class="in">        if conn.extra_dejson.get("iam", False):</span></span>
<span id="cb26-8"><a href="#cb26-8"></a><span class="in">            conn.login, conn.password, conn.port = self.get_iam_token(conn)</span></span>
<span id="cb26-9"><a href="#cb26-9"></a></span>
<span id="cb26-10"><a href="#cb26-10"></a><span class="in">        conn_args = dict(</span></span>
<span id="cb26-11"><a href="#cb26-11"></a><span class="in">            host=conn.host,</span></span>
<span id="cb26-12"><a href="#cb26-12"></a><span class="in">            user=conn.login,</span></span>
<span id="cb26-13"><a href="#cb26-13"></a><span class="in">            password=conn.password,</span></span>
<span id="cb26-14"><a href="#cb26-14"></a><span class="in">            dbname=self.database or conn.schema,</span></span>
<span id="cb26-15"><a href="#cb26-15"></a><span class="in">            port=conn.port,</span></span>
<span id="cb26-16"><a href="#cb26-16"></a><span class="in">        )</span></span>
<span id="cb26-17"><a href="#cb26-17"></a><span class="in">        raw_cursor = conn.extra_dejson.get("cursor", False)</span></span>
<span id="cb26-18"><a href="#cb26-18"></a><span class="in">        if raw_cursor:</span></span>
<span id="cb26-19"><a href="#cb26-19"></a><span class="in">            conn_args["cursor_factory"] = self._get_cursor(raw_cursor)</span></span>
<span id="cb26-20"><a href="#cb26-20"></a></span>
<span id="cb26-21"><a href="#cb26-21"></a><span class="in">        for arg_name, arg_val in conn.extra_dejson.items():</span></span>
<span id="cb26-22"><a href="#cb26-22"></a><span class="in">            if arg_name not in [</span></span>
<span id="cb26-23"><a href="#cb26-23"></a><span class="in">                "iam",</span></span>
<span id="cb26-24"><a href="#cb26-24"></a><span class="in">                "redshift",</span></span>
<span id="cb26-25"><a href="#cb26-25"></a><span class="in">                "cursor",</span></span>
<span id="cb26-26"><a href="#cb26-26"></a><span class="in">                "cluster-identifier",</span></span>
<span id="cb26-27"><a href="#cb26-27"></a><span class="in">                "aws_conn_id",</span></span>
<span id="cb26-28"><a href="#cb26-28"></a><span class="in">            ]:</span></span>
<span id="cb26-29"><a href="#cb26-29"></a><span class="in">                conn_args[arg_name] = arg_val</span></span>
<span id="cb26-30"><a href="#cb26-30"></a></span>
<span id="cb26-31"><a href="#cb26-31"></a><span class="in">        self.conn = psycopg2.connect(**conn_args)</span></span>
<span id="cb26-32"><a href="#cb26-32"></a><span class="in">        return self.conn</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><code>conn = deepcopy(self.connection or self.get_connection(conn_id))</code> 를 보면 hook 클래스의 get_connection() method를 이용해 airflow web ui에서 입력했던 connection 입력값을 찾아내서 연결시켜줌</li>
</ul>
</section>
<section id="hook-이용하여-postgres-insert" class="level2" data-number="4.6">
<h2 data-number="4.6" class="anchored" data-anchor-id="hook-이용하여-postgres-insert"><span class="header-section-number">4.6</span> Hook 이용하여 Postgres Insert</h2>
<div class="columns">
<div class="column" style="width:50%;">
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb27-1"><a href="#cb27-1"></a>from airflow import DAG</span>
<span id="cb27-2"><a href="#cb27-2"></a>import pendulum</span>
<span id="cb27-3"><a href="#cb27-3"></a>from airflow.operators.python import PythonOperator</span>
<span id="cb27-4"><a href="#cb27-4"></a></span>
<span id="cb27-5"><a href="#cb27-5"></a>with DAG(</span>
<span id="cb27-6"><a href="#cb27-6"></a>    dag_id='dags_python_with_postgres',</span>
<span id="cb27-7"><a href="#cb27-7"></a>    start_date=pendulum.datetime(2023,4,1, tz='Asia/Seoul'),</span>
<span id="cb27-8"><a href="#cb27-8"></a>    schedule=None,</span>
<span id="cb27-9"><a href="#cb27-9"></a>    catchup=False</span>
<span id="cb27-10"><a href="#cb27-10"></a>) as dag:</span>
<span id="cb27-11"><a href="#cb27-11"></a></span>
<span id="cb27-12"><a href="#cb27-12"></a><span class="in">    </span></span>
<span id="cb27-13"><a href="#cb27-13"></a><span class="in">    def insrt_postgres(ip, port, dbname, user, passwd, **kwargs):</span></span>
<span id="cb27-14"><a href="#cb27-14"></a><span class="in">        import psycopg2</span></span>
<span id="cb27-15"><a href="#cb27-15"></a><span class="in">        from contextlib import closing</span></span>
<span id="cb27-16"><a href="#cb27-16"></a></span>
<span id="cb27-17"><a href="#cb27-17"></a><span class="in">        with closing(psycopg2.connect(host=ip, dbname=dbname, user=user, password=passwd, port=int(port))) as conn:</span></span>
<span id="cb27-18"><a href="#cb27-18"></a><span class="in">            with closing(conn.cursor()) as cursor:</span></span>
<span id="cb27-19"><a href="#cb27-19"></a><span class="in">                dag_id = kwargs.get('ti').dag_id</span></span>
<span id="cb27-20"><a href="#cb27-20"></a><span class="in">                task_id = kwargs.get('ti').task_id</span></span>
<span id="cb27-21"><a href="#cb27-21"></a><span class="in">                run_id = kwargs.get('ti').run_id</span></span>
<span id="cb27-22"><a href="#cb27-22"></a><span class="in">                msg = 'insrt 수행'</span></span>
<span id="cb27-23"><a href="#cb27-23"></a><span class="in">                sql = 'insert into py_opr_drct_insrt values (%s,%s,%s,%s);'</span></span>
<span id="cb27-24"><a href="#cb27-24"></a><span class="in">                cursor.execute(sql,(dag_id,task_id,run_id,msg))</span></span>
<span id="cb27-25"><a href="#cb27-25"></a><span class="in">                conn.commit()</span></span>
<span id="cb27-26"><a href="#cb27-26"></a></span>
<span id="cb27-27"><a href="#cb27-27"></a><span class="in">    insrt_postgres = PythonOperator(</span></span>
<span id="cb27-28"><a href="#cb27-28"></a><span class="in">        task_id='insrt_postgres',</span></span>
<span id="cb27-29"><a href="#cb27-29"></a><span class="in">        python_callable=insrt_postgres,</span></span>
<span id="cb27-30"><a href="#cb27-30"></a><span class="in">        op_args=['172.28.0.3', '5432', 'kmkim', 'kmkim', 'kmkim']</span></span>
<span id="cb27-31"><a href="#cb27-31"></a><span class="in">    )</span></span>
<span id="cb27-32"><a href="#cb27-32"></a><span class="in">        </span></span>
<span id="cb27-33"><a href="#cb27-33"></a><span class="in">    insrt_postgres</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div><div class="column" style="width:50%;">
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb28-1"><a href="#cb28-1"></a>from airflow import DAG</span>
<span id="cb28-2"><a href="#cb28-2"></a>import pendulum</span>
<span id="cb28-3"><a href="#cb28-3"></a>from airflow.operators.python import PythonOperator</span>
<span id="cb28-4"><a href="#cb28-4"></a></span>
<span id="cb28-5"><a href="#cb28-5"></a>with DAG(</span>
<span id="cb28-6"><a href="#cb28-6"></a>        dag_id='dags_python_with_postgres_hook',</span>
<span id="cb28-7"><a href="#cb28-7"></a>        start_date=pendulum.datetime(2023, 4, 1, tz='Asia/Seoul'),</span>
<span id="cb28-8"><a href="#cb28-8"></a>        schedule=None,</span>
<span id="cb28-9"><a href="#cb28-9"></a>        catchup=False</span>
<span id="cb28-10"><a href="#cb28-10"></a>) as dag:</span>
<span id="cb28-11"><a href="#cb28-11"></a>    def insrt_postgres(postgres_conn_id, **kwargs):</span>
<span id="cb28-12"><a href="#cb28-12"></a>        from airflow.providers.postgres.hooks.postgres import PostgresHook</span>
<span id="cb28-13"><a href="#cb28-13"></a>        from contextlib import closing</span>
<span id="cb28-14"><a href="#cb28-14"></a>        </span>
<span id="cb28-15"><a href="#cb28-15"></a><span class="in">        postgres_hook = PostgresHook(postgres_conn_id)</span></span>
<span id="cb28-16"><a href="#cb28-16"></a><span class="in">        with closing(postgres_hook.get_conn()) as conn:</span></span>
<span id="cb28-17"><a href="#cb28-17"></a><span class="in">            with closing(conn.cursor()) as cursor:</span></span>
<span id="cb28-18"><a href="#cb28-18"></a><span class="in">                dag_id = kwargs.get('ti').dag_id</span></span>
<span id="cb28-19"><a href="#cb28-19"></a><span class="in">                task_id = kwargs.get('ti').task_id</span></span>
<span id="cb28-20"><a href="#cb28-20"></a><span class="in">                run_id = kwargs.get('ti').run_id</span></span>
<span id="cb28-21"><a href="#cb28-21"></a><span class="in">                msg = 'hook insrt 수행'</span></span>
<span id="cb28-22"><a href="#cb28-22"></a><span class="in">                sql = 'insert into py_opr_drct_insrt values (%s,%s,%s,%s);'</span></span>
<span id="cb28-23"><a href="#cb28-23"></a><span class="in">                cursor.execute(sql, (dag_id, task_id, run_id, msg))</span></span>
<span id="cb28-24"><a href="#cb28-24"></a><span class="in">                conn.commit()</span></span>
<span id="cb28-25"><a href="#cb28-25"></a></span>
<span id="cb28-26"><a href="#cb28-26"></a><span class="in">    insrt_postgres_with_hook = PythonOperator(</span></span>
<span id="cb28-27"><a href="#cb28-27"></a><span class="in">        task_id='insrt_postgres_with_hook',</span></span>
<span id="cb28-28"><a href="#cb28-28"></a><span class="in">        python_callable=insrt_postgres,</span></span>
<span id="cb28-29"><a href="#cb28-29"></a><span class="in">        op_kwargs={'postgres_conn_id':'conn-db-postgres-custom'}</span></span>
<span id="cb28-30"><a href="#cb28-30"></a><span class="in">    )</span></span>
<span id="cb28-31"><a href="#cb28-31"></a><span class="in">    insrt_postgres_with_hook</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<ul>
<li>왼쪽과 오른쪽 <code>conn</code> 객체와 <code>cursor</code>는 사실상 같음. 단지 만들어지는 과정만 달라짐.</li>
<li><code>op_args=['172.28.0.3', '5432', 'kmkim', 'kmkim', 'kmkim']</code> 와 같은 보안 사항이 오른 쪽 코드에서는 <code>op_kwargs={'postgres_conn_id':'conn-db-postgres-custom'}</code> 가려지게 된다.</li>
</ul>
</section>
</section>
<section id="postgres-hook-으로-bulk_load-하기" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Postgres Hook 으로 bulk_load 하기</h1>
<ul>
<li>bulk_load: Hook은 특정 solution을 제어할 수 있도록 method</li>
</ul>
<section id="postgres-hook-명세-보기-1" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="postgres-hook-명세-보기-1"><span class="header-section-number">5.1</span> Postgres Hook 명세 보기</h2>
<ul>
<li><a href="https://airflow.apache.org/docs/apache-airflow-providers-postgres/5.4.0/_modules/airflow/providers/postgres/hooks/postgres.html#PostgresHook.bulk_load">airflow web service &gt;&gt; Providers &gt;&gt; apache.airflow.providers.postgres &gt;&gt; Python API &gt;&gt; airflow.providers.postgres.hooks.postgres &gt;&gt; def bulk_load(self, temp_file)[source]</a></li>
<li>bulk_load(): Loads a tab-delimited file into a database table. 설명이 불충분하여 다음과 같은 사항을 확인할 수 없다.
<ul>
<li>꼭 delimiter가 tab이어야 하는지?</li>
<li>temp_file에 header가 있으면 header가 있는 상태로 data를 올려도 되는지?</li>
<li>DB table이 없으면 만들어지면서 올라가는지? 아니면 사전에 만들어 놔야하는지?</li>
<li>table에 기존 data가 있다면 truncate되면서 올라가는지? append되면서 올라가는지?</li>
<li>parameter는 구체적으로 어떻게 입력해야하는지?</li>
</ul></li>
<li>bulk_load() 의 명세서를 확인해야 한다. (source code)</li>
</ul>
<div class="sourceCode" id="cb29"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb29-1"><a href="#cb29-1"></a><span class="co">[</span><span class="ot">docs</span><span class="co">]</span>    def bulk_load(self, table: str, tmp_file: str) -&gt; None:</span>
<span id="cb29-2"><a href="#cb29-2"></a>        """Loads a tab-delimited file into a database table"""</span>
<span id="cb29-3"><a href="#cb29-3"></a>        self.copy_expert(f"COPY {table} FROM STDIN", tmp_file)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><p><code>copy_expert()</code>: postgres hook class가 갖고 있는 method</p></li>
<li><p>self.copy_expert(f”COPY {table} FROM STDIN”, tmp_file)</p></li>
</ul>
<div class="sourceCode" id="cb30"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb30-1"><a href="#cb30-1"></a><span class="co">[</span><span class="ot">docs</span><span class="co">]</span>    def copy_expert(self, sql: str, filename: str) -&gt; None:</span>
<span id="cb30-2"><a href="#cb30-2"></a>        """</span>
<span id="cb30-3"><a href="#cb30-3"></a>        Executes SQL using psycopg2 copy_expert method.</span>
<span id="cb30-4"><a href="#cb30-4"></a>        Necessary to execute COPY command without access to a superuser.</span>
<span id="cb30-5"><a href="#cb30-5"></a></span>
<span id="cb30-6"><a href="#cb30-6"></a><span class="in">        Note: if this method is called with a "COPY FROM" statement and</span></span>
<span id="cb30-7"><a href="#cb30-7"></a><span class="in">        the specified input file does not exist, it creates an empty</span></span>
<span id="cb30-8"><a href="#cb30-8"></a><span class="in">        file and no data is loaded, but the operation succeeds.</span></span>
<span id="cb30-9"><a href="#cb30-9"></a><span class="in">        So if users want to be aware when the input file does not exist,</span></span>
<span id="cb30-10"><a href="#cb30-10"></a><span class="in">        they have to check its existence by themselves.</span></span>
<span id="cb30-11"><a href="#cb30-11"></a><span class="in">        """</span></span>
<span id="cb30-12"><a href="#cb30-12"></a><span class="in">        self.log.info("Running copy expert: %s, filename: %s", sql, filename)</span></span>
<span id="cb30-13"><a href="#cb30-13"></a><span class="in">        if not os.path.isfile(filename):</span></span>
<span id="cb30-14"><a href="#cb30-14"></a><span class="in">            with open(filename, "w"):</span></span>
<span id="cb30-15"><a href="#cb30-15"></a><span class="in">                pass</span></span>
<span id="cb30-16"><a href="#cb30-16"></a></span>
<span id="cb30-17"><a href="#cb30-17"></a><span class="in">        with open(filename, "r+") as file:</span></span>
<span id="cb30-18"><a href="#cb30-18"></a><span class="in">            with closing(self.get_conn()) as conn:</span></span>
<span id="cb30-19"><a href="#cb30-19"></a><span class="in">                with closing(conn.cursor()) as cur:</span></span>
<span id="cb30-20"><a href="#cb30-20"></a><span class="in">                    cur.copy_expert(sql, file)</span></span>
<span id="cb30-21"><a href="#cb30-21"></a><span class="in">                    file.truncate(file.tell())</span></span>
<span id="cb30-22"><a href="#cb30-22"></a><span class="in">                    conn.commit()</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><code>closing(self.get_conn()) as conn:</code> &gt;&gt; <code>with closing(conn.cursor()) as cur:</code>
<ul>
<li><code>get.conn() &gt;&gt; cursor()</code> 결국 postgres의 cursor로 postgres가 원래 갖고있는 copy_export() method를 이용</li>
<li>그럼 postgres의 copy_export()의 source code를 확인해 봐야함. <a href="https://www.psycopg.org/docs/cursor.html">google psycopg2 cursor.copy_expert</a></li>
</ul>
<div class="sourceCode" id="cb31"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb31-1"><a href="#cb31-1"></a>copy_expert(sql, file, size=8192)</span>
<span id="cb31-2"><a href="#cb31-2"></a>  Submit a user-composed COPY statement. The method is useful to handle all the parameters that PostgreSQL makes available (see COPY command documentation).</span>
<span id="cb31-3"><a href="#cb31-3"></a></span>
<span id="cb31-4"><a href="#cb31-4"></a>  Parameters:</span>
<span id="cb31-5"><a href="#cb31-5"></a>  sql – the COPY statement to execute.</span>
<span id="cb31-6"><a href="#cb31-6"></a></span>
<span id="cb31-7"><a href="#cb31-7"></a>  file – a file-like object to read or write (according to sql).</span>
<span id="cb31-8"><a href="#cb31-8"></a></span>
<span id="cb31-9"><a href="#cb31-9"></a>  size – size of the read buffer to be used in COPY FROM.</span>
<span id="cb31-10"><a href="#cb31-10"></a></span>
<span id="cb31-11"><a href="#cb31-11"></a>  The sql statement should be in the form COPY table TO STDOUT to export table to the file object passed as argument or COPY table FROM STDIN to import the content of the file object into table. If you need to compose a COPY statement dynamically (because table, fields, or query parameters are in Python variables) you may use the objects provided by the psycopg2.sql module.</span>
<span id="cb31-12"><a href="#cb31-12"></a></span>
<span id="cb31-13"><a href="#cb31-13"></a>  file must be a readable file-like object (as required by copy_from()) for sql statement COPY ... FROM STDIN or a writable one (as required by copy_to()) for COPY ... TO STDOUT.</span>
<span id="cb31-14"><a href="#cb31-14"></a></span>
<span id="cb31-15"><a href="#cb31-15"></a>  Example:</span>
<span id="cb31-16"><a href="#cb31-16"></a></span>
<span id="cb31-17"><a href="#cb31-17"></a>  <span class="at">&gt;&gt;&gt; cur.copy_expert("COPY test TO STDOUT WITH CSV HEADER", sys.stdout)</span></span>
<span id="cb31-18"><a href="#cb31-18"></a><span class="at">  id,num,data</span></span>
<span id="cb31-19"><a href="#cb31-19"></a><span class="at">  1,100,abc'def</span></span>
<span id="cb31-20"><a href="#cb31-20"></a><span class="at">  2,,dada</span></span>
<span id="cb31-21"><a href="#cb31-21"></a><span class="at">  ...</span></span>
<span id="cb31-22"><a href="#cb31-22"></a><span class="at">  New in version 2.0.6.</span></span>
<span id="cb31-23"><a href="#cb31-23"></a></span>
<span id="cb31-24"><a href="#cb31-24"></a>  Changed in version 2.4: files implementing the io.TextIOBase interface are dealt with using Unicode data instead of bytes.</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>이것이 가장 세부적인 정보로 나머지 정보는 troubleshooting으로 파악해야한다.
<ul>
<li>꼭 delimiter가 tab이어야 하는지? troubleshooting으로 확인해야함</li>
<li>temp_file에 header가 있으면 header가 있는 상태로 data를 올려도 되는지? troubleshooting으로 확인해야함</li>
<li>DB table이 없으면 만들어지면서 올라가는지? 아니면 사전에 만들어 놔야하는지? troubleshooting으로 확인해야함</li>
<li>table에 기존 data가 있다면 truncate되면서 올라가는지? troubleshooting으로 확인해야함</li>
</ul></li>
</ul></li>
<li>trouble shooting 할 DAG</li>
</ul>
<div class="sourceCode" id="cb32"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb32-1"><a href="#cb32-1"></a>from airflow import DAG</span>
<span id="cb32-2"><a href="#cb32-2"></a>import pendulum</span>
<span id="cb32-3"><a href="#cb32-3"></a>from airflow.operators.python import PythonOperator</span>
<span id="cb32-4"><a href="#cb32-4"></a>from airflow.providers.postgres.hooks.postgres import PostgresHook</span>
<span id="cb32-5"><a href="#cb32-5"></a></span>
<span id="cb32-6"><a href="#cb32-6"></a>with DAG(</span>
<span id="cb32-7"><a href="#cb32-7"></a>        dag_id='dags_python_with_postgres_hook_bulk_load',</span>
<span id="cb32-8"><a href="#cb32-8"></a>        start_date=pendulum.datetime(2023, 4, 1, tz='Asia/Seoul'),</span>
<span id="cb32-9"><a href="#cb32-9"></a>        schedule='0 7 * * *', # 서울시 공공데이터를 API를 통해 불러들이(dags_seoul_api_corona.py)는 시간이 7시</span>
<span id="cb32-10"><a href="#cb32-10"></a>        catchup=False</span>
<span id="cb32-11"><a href="#cb32-11"></a>) as dag:</span>
<span id="cb32-12"><a href="#cb32-12"></a>    def insrt_postgres(postgres_conn_id, tbl_nm, file_nm, **kwargs):</span>
<span id="cb32-13"><a href="#cb32-13"></a>        postgres_hook = PostgresHook(postgres_conn_id)</span>
<span id="cb32-14"><a href="#cb32-14"></a>        postgres_hook.bulk_load(tbl_nm, file_nm)</span>
<span id="cb32-15"><a href="#cb32-15"></a></span>
<span id="cb32-16"><a href="#cb32-16"></a><span class="in">    insrt_postgres = PythonOperator(</span></span>
<span id="cb32-17"><a href="#cb32-17"></a><span class="in">        task_id='insrt_postgres',</span></span>
<span id="cb32-18"><a href="#cb32-18"></a><span class="in">        python_callable=insrt_postgres,</span></span>
<span id="cb32-19"><a href="#cb32-19"></a><span class="in">        op_kwargs={'postgres_conn_id': 'conn-db-postgres-custom',</span></span>
<span id="cb32-20"><a href="#cb32-20"></a><span class="in">                   'tbl_nm':'TbCorona19CountStatus_bulk1',</span></span>
<span id="cb32-21"><a href="#cb32-21"></a><span class="in">                   'file_nm':'/opt/airflow/files/TbCorona19CountStatus/{{data_interval_end.in_timezone("Asia/Seoul") | ds_nodash}}/TbCorona19CountStatus.csv'}</span></span>
<span id="cb32-22"><a href="#cb32-22"></a><span class="in">    )</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><p>op_kwargs={‘postgres_conn_id’: ‘conn-db-postgres-custom’, ‘tbl_nm’:‘TbCorona19CountStatus_bulk1’, ‘file_nm’:‘/opt/airflow/files/TbCorona19CountStatus/{{data_interval_end.in_timezone(“Asia/Seoul”) | ds_nodash}}/TbCorona19CountStatus.csv’} 는 dags_seoul_api_corona.py 의 tb_corona19_count_status task의 path와 file_name 인수로 부터 가져온다.</p>
<p>tb_corona19_count_status = SeoulApiToCsvOperator( task_id=‘tb_corona19_count_status’, dataset_nm=‘TbCorona19CountStatus’, <strong>path</strong>=‘/opt/airflow/files/TbCorona19CountStatus/{{data_interval_end.in_timezone(“Asia/Seoul”) | ds_nodash }}’, <strong>file_name</strong>=‘TbCorona19CountStatus.csv’ )</p></li>
<li><p>troubleshooting</p>
<ul>
<li>table이 사전에 만들어지지 않아도 되는지? 현재 DB에는 TbCorona19CountStatus_bulk1 table이 없음 <img src="../../../../../images/airflow/postgress_hook_bulk_load_method.PNG" class="img-fluid"></li>
<li>실행 결과 log 에서 table이 없다는 에러 메세지 뜸. table 만들어 주면 됨</li>
<li>table만들어서 한번 더 task 실행하면 comma delimiter 인식 오류가 나기 떄문에 tab delimiter로 바꿔줘야한다.
<ul>
<li>dags_seoul_api_corona.py 로 부터 받은 TbCorona19CountStatus.csv 파일을 열어 <code>,</code>를 tab으로 바꿔준다</li>
</ul>
<div class="sourceCode" id="cb33"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb33-1"><a href="#cb33-1"></a>vi TbCorona19CountStatus.csv</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li>vi editor
<ul>
<li><code>: %s/,/\t/g</code> <code>,</code>를 <code>\t</code>으로 바꿔줌. 여기서 g는 global하게 적용하겠다는 의미</li>
</ul></li>
<li>51번째 line에 에러 발생: <code>\M</code> 이라는 특수 문자가 있음
<ul>
<li><code>\M</code> 윈도우와 리눅스 간의 줄넘김 차이 때문에 발생
<ul>
<li>윈도우: enter key = CR (Carriage Return-한줄에서 왼쪽 끝으로 밀어주는것이 CR) + LF (Line Feed-다음 줄에 입력을 하도록 종이를 한줄 밀어주는 것 LF)</li>
<li>DOS/Windows 계열에서는 엔터를 CR+LF(<code>\r\n</code>) 으로 처리하고</li>
<li>Unix/Linux 계열에서는 엔터를 LF(<code>\n</code>)으로 처리하고</li>
<li>MAC 계열에서는 엔터를 CR(<code>\r</code>)로 처리한다고 한다</li>
<li>윈도우 환경에서 입력된 값이 리눅스로 넘어오게 될 때 CR+LF와 같은 불일치 값이 있으면 <code>^M</code> 또는 <code>\M</code> 로 표시됨</li>
</ul></li>
<li>51번째 record 지워서 해결</li>
</ul></li>
<li>airflow 상 errors는 더이상 발생하지 않지만 DB를 확인했을 때 첫번째 row에 column명이 들어간것을 확인되었다. 그래서 CSV상에 column값을 지워줘야한다는 것을 알 수 있다.</li>
</ul></li>
</ul>
</section>
<section id="bulk_load-문제점-개선방안" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="bulk_load-문제점-개선방안"><span class="header-section-number">5.2</span> Bulk_load 문제점 &amp; 개선방안</h2>
<ul>
<li>문제점
<ul>
<li>Load 가능한 Delimiter는 Tab으로 고정되어 있음</li>
<li>Header까지 포함해서 업로드됨</li>
<li>특수문자로 인해 파싱이 안될 경우 에러 발생</li>
</ul></li>
<li>개선방안
<ul>
<li>Custom Hook 을 만들어서 Delimiter 유형을 입력받게 하고</li>
<li>Header 포함 여부를 선택하게끔 하며</li>
<li>특수문자를 제거하는 로직을 추가 후</li>
<li>sqlalchemy(python에서 DB 작업을 편리하게 해주는 library)를 이용하여 Load 한다면? 그리고 테이블을 생성하면서 업로드할 수 있도록 한다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="custom-hook-으로-bulk_load-하기" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Custom Hook 으로 bulk_load 하기</h1>
<section id="basehook-명세-보기" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="basehook-명세-보기"><span class="header-section-number">6.1</span> BaseHook 명세 보기</h2>
<ul>
<li>Custom Hook은 BaseHook을 상속해서 작성</li>
<li><a href="https://airflow.apache.org/docs/apache-airflow/stable/_api/airflow/hooks/base/index.html#airflow.hooks.base.BaseHook">Airflow Docs에서 Basehook Source Code</a></li>
<li>BaseHook class의 methods
<ul>
<li>[docs] def get_connection(cls, conn_id: str) -&gt; Connection:
<ul>
<li>airflow 상에서 만들었던 connection_id : user name, password, IP, Port 의 정보를 담고있는 object return</li>
</ul></li>
<li>[docs] def get_connections(cls, conn_id: str) -&gt; list[Connection]:
<ul>
<li>will be deprecated. Use get_connection()</li>
</ul></li>
<li>[docs] def get_conn(self) -&gt; Any: # 이 함수를 쓰려면 상속받아서 구현할 때 get_conn() 함수를 구현해야함</li>
<li>[docs] def get_hook(cls, conn_id: str) -&gt; BaseHook:</li>
<li>[docs] def get_connection_form_widgets(cls) -&gt; dict[str, Any]: (안중요)</li>
<li>[docs] def get_ui_field_behaviour(cls) -&gt; dict[str, Any]: (안중요)</li>
</ul></li>
<li>위의 method 중 get_conn()을 제외하곤 모든 method에 데코레이터 <code>@classmethod</code> 있음
<ul>
<li><p>python있는 method 종류로 class method 라 하고 class method 는 class를 객체화 시키지 않고도 바로 호출할 수 있음</p></li>
<li><p>예를 들어, 다음과 같은 방식으로 class method 호출 안해도 됨</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb34-1"><a href="#cb34-1"></a>import BaseHook</span>
<span id="cb34-2"><a href="#cb34-2"></a>a=BaseHook()</span>
<span id="cb34-3"><a href="#cb34-3"></a>a.get_connection(conn_id)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>바로 호출 해도됨</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb35-1"><a href="#cb35-1"></a>import BaseHook</span>
<span id="cb35-2"><a href="#cb35-2"></a>BaseHook.get_connection(conn_id)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul></li>
</ul>
</section>
<section id="custom-hook-개발" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="custom-hook-개발"><span class="header-section-number">6.2</span> Custom Hook 개발</h2>
<ul>
<li>해야할 일
<ul>
<li>get_conn 메서드 구현하기
<ul>
<li>DB 와의 연결 세션 객체인 conn 을 리턴하도록 구현</li>
<li>주의: get_connection() vs get_conn()
<ul>
<li>get_connection(): Airflow 에서 등록한 Connection 정보를 담은 conn을 return</li>
<li>get_conn(): postgres와의 연결하는 session 객체를 return</li>
<li>BaseHook 의 추상 메서드 , 자식 클래스에서 구현 필요</li>
</ul></li>
</ul></li>
<li>bulk_load 메서드 구현하기
<ul>
<li>입맛대로 만들기: custom_postgres_hook.py</li>
</ul>
<div class="sourceCode" id="cb36"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb36-1"><a href="#cb36-1"></a>from airflow.hooks.base import BaseHook</span>
<span id="cb36-2"><a href="#cb36-2"></a>import psycopg2</span>
<span id="cb36-3"><a href="#cb36-3"></a>import pandas as pd</span>
<span id="cb36-4"><a href="#cb36-4"></a></span>
<span id="cb36-5"><a href="#cb36-5"></a>class CustomPostgresHook(BaseHook):</span>
<span id="cb36-6"><a href="#cb36-6"></a></span>
<span id="cb36-7"><a href="#cb36-7"></a><span class="in">    # 생성자</span></span>
<span id="cb36-8"><a href="#cb36-8"></a><span class="in">    def __init__(self, postgres_conn_id, **kwargs): # 입력은 하나만: postgres_conn_id</span></span>
<span id="cb36-9"><a href="#cb36-9"></a><span class="in">        self.postgres_conn_id = postgres_conn_id</span></span>
<span id="cb36-10"><a href="#cb36-10"></a></span>
<span id="cb36-11"><a href="#cb36-11"></a><span class="in">    def get_conn(self):</span></span>
<span id="cb36-12"><a href="#cb36-12"></a><span class="in">        airflow_conn = BaseHook.get_connection(self.postgres_conn_id) #class method라 바로 호출</span></span>
<span id="cb36-13"><a href="#cb36-13"></a><span class="in">        # 아래의 보안 정보들이 hook을 통해서 노출되지 않고 접근 가능</span></span>
<span id="cb36-14"><a href="#cb36-14"></a><span class="in">        self.host = airflow_conn.host</span></span>
<span id="cb36-15"><a href="#cb36-15"></a><span class="in">        self.user = airflow_conn.login</span></span>
<span id="cb36-16"><a href="#cb36-16"></a><span class="in">        self.password = airflow_conn.password</span></span>
<span id="cb36-17"><a href="#cb36-17"></a><span class="in">        self.dbname = airflow_conn.schema</span></span>
<span id="cb36-18"><a href="#cb36-18"></a><span class="in">        self.port = airflow_conn.port</span></span>
<span id="cb36-19"><a href="#cb36-19"></a></span>
<span id="cb36-20"><a href="#cb36-20"></a><span class="in">        # postgres DB 연결: session object를 return</span></span>
<span id="cb36-21"><a href="#cb36-21"></a><span class="in">        self.postgres_conn = psycopg2.connect(host=self.host, user=self.user, password=self.password, dbname=self.dbname, port=self.port)</span></span>
<span id="cb36-22"><a href="#cb36-22"></a><span class="in">        return self.postgres_conn</span></span>
<span id="cb36-23"><a href="#cb36-23"></a></span>
<span id="cb36-24"><a href="#cb36-24"></a><span class="in">    def bulk_load(self, table_name, file_name, delimiter: str, is_header: bool, is_replace: bool):</span></span>
<span id="cb36-25"><a href="#cb36-25"></a></span>
<span id="cb36-26"><a href="#cb36-26"></a><span class="in">        from sqlalchemy import create_engine</span></span>
<span id="cb36-27"><a href="#cb36-27"></a></span>
<span id="cb36-28"><a href="#cb36-28"></a><span class="in">        self.log.info('적재 대상파일:' + file_name)</span></span>
<span id="cb36-29"><a href="#cb36-29"></a><span class="in">        self.log.info('테이블 :' + table_name)</span></span>
<span id="cb36-30"><a href="#cb36-30"></a><span class="in">        self.get_conn()</span></span>
<span id="cb36-31"><a href="#cb36-31"></a><span class="in">        header = 0 if is_header else None                       # is_header = True면 0, False면 None</span></span>
<span id="cb36-32"><a href="#cb36-32"></a><span class="in">        if_exists = 'replace' if is_replace else 'append'       # is_replace = True면 replace, False면 append</span></span>
<span id="cb36-33"><a href="#cb36-33"></a><span class="in">        file_df = pd.read_csv(file_name, header=header, delimiter=delimiter)</span></span>
<span id="cb36-34"><a href="#cb36-34"></a></span>
<span id="cb36-35"><a href="#cb36-35"></a><span class="in">        for col in file_df.columns:                             </span></span>
<span id="cb36-36"><a href="#cb36-36"></a><span class="in">            try:</span></span>
<span id="cb36-37"><a href="#cb36-37"></a><span class="in">                # string 문자열이 아닐 경우 continue</span></span>
<span id="cb36-38"><a href="#cb36-38"></a><span class="in">                file_df[col] = file_df[col].str.replace('\r\n','')      # 줄넘김 및 ^M 제거</span></span>
<span id="cb36-39"><a href="#cb36-39"></a><span class="in">                self.log.info(f'{table_name}.{col}: 개행문자 제거')</span></span>
<span id="cb36-40"><a href="#cb36-40"></a><span class="in">            except:</span></span>
<span id="cb36-41"><a href="#cb36-41"></a><span class="in">                continue </span></span>
<span id="cb36-42"><a href="#cb36-42"></a></span>
<span id="cb36-43"><a href="#cb36-43"></a><span class="in">        self.log.info('적재 건수:' + str(len(file_df)))</span></span>
<span id="cb36-44"><a href="#cb36-44"></a><span class="in">        uri = f'postgresql://{self.user}:{self.password}@{self.host}/{self.dbname}'</span></span>
<span id="cb36-45"><a href="#cb36-45"></a><span class="in">        engine = create_engine(uri)</span></span>
<span id="cb36-46"><a href="#cb36-46"></a><span class="in">        file_df.to_sql(name=table_name,</span></span>
<span id="cb36-47"><a href="#cb36-47"></a><span class="in">                            con=engine,</span></span>
<span id="cb36-48"><a href="#cb36-48"></a><span class="in">                            schema='public',</span></span>
<span id="cb36-49"><a href="#cb36-49"></a><span class="in">                            if_exists=if_exists,</span></span>
<span id="cb36-50"><a href="#cb36-50"></a><span class="in">                            index=False</span></span>
<span id="cb36-51"><a href="#cb36-51"></a><span class="in">                        )</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>여기서 <code>airflow_conn = BaseHook.get_connection(self.postgres_conn_id) #class method라 바로 호출</code> 와 <code>self.postgres_conn = psycopg2.connect(host=self.host, user=self.user, password=self.password, dbname=self.dbname, port=self.port)</code> 다른 종류의 conn 객체를 return한다.</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="providers-더-보기" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="providers-더-보기"><span class="header-section-number">6.3</span> Providers 더 보기</h2>
<ul>
<li>현재 설치되어 있는 Providers 패키지 확인
<ul>
<li>웹의 Admin Providers 에서 확인 가능</li>
</ul></li>
<li><a href="https://airflow.apache.org/docs/apache-airflow-providers/">설치 가능한 Providers 더 보기</a> &gt;&gt; Apache Airflow 2 is built in modular way. The “Core” of Apache Airflow provides core scheduler functionality which allow you to write some basic tasks, but the capabilities of Apache Airflow can be extended by installing additional packages, called providers.
<ul>
<li>providers package를 설치하면 다른 솔루션을 연동할 수 있도록 확장성을 제공</li>
<li>The full list of community managed providers is available at <a href="https://airflow.apache.org/docs/#providers-packages-docs-apache-airflow-providers-index-html">Providers Index</a>.
<ul>
<li>Providers packages:
<ul>
<li><a href="https://airflow.apache.org/docs/apache-airflow-providers-apache-hive/stable/_api/airflow/providers/apache/hive/hooks/hive/index.html">Apache Hive</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="connection-type-추가하기" class="level2" data-number="6.4">
<h2 data-number="6.4" class="anchored" data-anchor-id="connection-type-추가하기"><span class="header-section-number">6.4</span> Connection Type 추가하기</h2>
<ul>
<li><p>Airflow Connection type 목록에 있는 대상은 이미 패키지 설치가 된 Providers 이며 Admin&gt;&gt;Providers 목록에서 설치된 대상 확인 가능</p></li>
<li><p>만약 Hive 에 대한 커넥션을 추가하고 싶은데 Airflow Connection type 목록에 Hive가 없다면 관련된 package를 설치하여 본인이 직접 추가해야함</p>
<ul>
<li>Provider 검색, py 라이브러리 설치 목록 확인하여 <code>pip install [pkg name]</code> 실행
<ul>
<li>주의사항: 윈도우와 wsl2에 package를 설치하는게 아니라 airflow containers에 설치해줘야 함
<ul>
<li>scheduler</li>
<li>worker</li>
<li>webserver</li>
<li>triggerer</li>
</ul></li>
<li>하지만, 각 각의 container에다가 pkg를 설치해주면 container가 꺼지게 되면 지워지게 됨</li>
<li>그래서, custom한 docker image를 만들어야 함
<ul>
<li>Airflow 이미지 Extend 방법으로 custom image 만들기
<ul>
<li>base image 에다가 custom image (pip install 및 다른 여러가지 layers) 추가</li>
<li>즉, custom image = base image + layer1 (library 호출) +layer2 (pip install pkgs)+ <span class="math inline">\(\ldots\)</span></li>
<li>이런 방식의 custom image는 layer가 많아질 수록 무거워져 overhead 가 커지는 약점이 있다.</li>
</ul></li>
<li>애초에 base image 자체를 custom image 로 만드는 법
<ul>
<li>extend의 약점인 overhead를 어느 정도 줄일 수 있지만 개발하는데 시간이 걸림</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><p><a href="https://airflow.apache.org/docs/docker-stack/build.html">Airflow 이미지 Extend 방법 &amp; custom image 만드는 법 확인</a></p>
<ul>
<li>이미지 Extend vs Custom 이미지 생성</li>
</ul>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 26%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>Comparison</th>
<th>image extend</th>
<th style="text-align: left;">Custom Image Creation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>간단히 생성 가능</td>
<td>O</td>
<td style="text-align: left;">X (많은 source codes 필요)</td>
</tr>
<tr class="even">
<td>빌드 시간</td>
<td>짧음 (5분 이내)</td>
<td style="text-align: left;">상대적으로 긺</td>
</tr>
<tr class="odd">
<td>크기 최적화된 이미지</td>
<td>X</td>
<td style="text-align: left;">O (약 20% 정도 사이즈 감소)</td>
</tr>
<tr class="even">
<td>폐쇄망에서 구성 가능</td>
<td>X (인터넷이 되어야함)</td>
<td style="text-align: left;">O</td>
</tr>
</tbody>
</table></li>
<li><p>Airflow web에 connection type 추가하는 steps</p>
<ul>
<li>이미지 extend를 위한 Dockerfile 만들기<br>
:::: {.columns}</li>
</ul>
<div class="column" style="width:50%;">
<div class="sourceCode" id="cb37"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb37-1"><a href="#cb37-1"></a>#&gt; cd; cd airflow</span>
<span id="cb37-2"><a href="#cb37-2"></a>#&gt; mkdir -p custom_image/airflow</span>
<span id="cb37-3"><a href="#cb37-3"></a>#&gt; cd custom_image/airflow</span>
<span id="cb37-4"><a href="#cb37-4"></a>#&gt; vi Dockerfile</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="column" style="width:50%;">
<div class="sourceCode" id="cb38"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb38-1"><a href="#cb38-1"></a>FROM apache/airflow:2.5.1 #base image 지정</span>
<span id="cb38-2"><a href="#cb38-2"></a>USER root #root user</span>
<span id="cb38-3"><a href="#cb38-3"></a>RUN apt get update \</span>
<span id="cb38-4"><a href="#cb38-4"></a>  &amp;&amp; apt-get install -y --no-install-recommends \</span>
<span id="cb38-5"><a href="#cb38-5"></a>    gcc \ #library 1 for installing hdfs</span>
<span id="cb38-6"><a href="#cb38-6"></a>    heimdal-dev \ #library 2 for installing hdfs</span>
<span id="cb38-7"><a href="#cb38-7"></a>    g++ \ #library 3</span>
<span id="cb38-8"><a href="#cb38-8"></a>    libsasl2-dev \ #library 4</span>
<span id="cb38-9"><a href="#cb38-9"></a>  &amp;&amp; apt-get autoremove -yqq -purge \</span>
<span id="cb38-10"><a href="#cb38-10"></a>  &amp;&amp; apt-get clean \</span>
<span id="cb38-11"><a href="#cb38-11"></a>  &amp;&amp; rm -rf /var/lib/apt/lists/*</span>
<span id="cb38-12"><a href="#cb38-12"></a>USER airflow</span>
<span id="cb38-13"><a href="#cb38-13"></a>RUN pip install \</span>
<span id="cb38-14"><a href="#cb38-14"></a>  apache airflow providers apache hdfs \</span>
<span id="cb38-15"><a href="#cb38-15"></a>  apache airflow providers apache hive</span>
<span id="cb38-16"><a href="#cb38-16"></a>RUN pip uninstall -y argparse</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>::::</p>
<ul>
<li>Docker 이미지 생성하기</li>
</ul>
<div class="sourceCode" id="cb39"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb39-1"><a href="#cb39-1"></a>#&gt; pwd </span>
<span id="cb39-2"><a href="#cb39-2"></a>#&gt; cd /home/hjkim/airflow/custom_image/airflow #Dockerfile 만든 경로</span>
<span id="cb39-3"><a href="#cb39-3"></a>#&gt; sudo docker build -t {image_name} . #.: 현재 디렉토리</span>
<span id="cb39-4"><a href="#cb39-4"></a>예) #&gt; sudo docker build -t airflow_custom .</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>error message</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb40-1"><a href="#cb40-1"></a>kmkim@K100230201051:~/airflow/custom_image/airflow$ sudo docker build -t airflow_custom .</span>
<span id="cb40-2"><a href="#cb40-2"></a></span>
<span id="cb40-3"><a href="#cb40-3"></a>failed to fetch metadata: fork/exec /usr/local/lib/docker/cli-plugins/docker-buildx: no such file or directory</span>
<span id="cb40-4"><a href="#cb40-4"></a></span>
<span id="cb40-5"><a href="#cb40-5"></a>DEPRECATED: The legacy builder is deprecated and will be removed in a future release.</span>
<span id="cb40-6"><a href="#cb40-6"></a>            Install the buildx component to build images with BuildKit:</span>
<span id="cb40-7"><a href="#cb40-7"></a>            https://docs.docker.com/go/buildx/</span>
<span id="cb40-8"><a href="#cb40-8"></a></span>
<span id="cb40-9"><a href="#cb40-9"></a>Sending build context to Docker daemon  2.048kB</span>
<span id="cb40-10"><a href="#cb40-10"></a>Step 1/6 : FROM apache/airflow:2.6.1</span>
<span id="cb40-11"><a href="#cb40-11"></a> ---&gt; 52c34708e903</span>
<span id="cb40-12"><a href="#cb40-12"></a>Step 2/6 : USER root #root user</span>
<span id="cb40-13"><a href="#cb40-13"></a> ---&gt; Running in c3fe7d498d62</span>
<span id="cb40-14"><a href="#cb40-14"></a>Removing intermediate container c3fe7d498d62</span>
<span id="cb40-15"><a href="#cb40-15"></a> ---&gt; d216e5376f4e</span>
<span id="cb40-16"><a href="#cb40-16"></a>Step 3/6 : RUN apt get update   &amp;&amp; apt-get install -y --no-install-recommends     gcc     heimdal-dev     g++     libsasl2-dev     heimdal-dev   &amp;&amp; apt-get autoremove -yqq -purge   &amp;&amp; apt-get clean   &amp;&amp; rm -rf /var/lib/apt/lists/*</span>
<span id="cb40-17"><a href="#cb40-17"></a> ---&gt; Running in 8238d95b680a</span>
<span id="cb40-18"><a href="#cb40-18"></a>unable to find user root #root user: no matching entries in passwd file</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>Docker 이미지 확인</li>
</ul>
<div class="sourceCode" id="cb41"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb41-1"><a href="#cb41-1"></a>#&gt; sudo docker image ls</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>docker-compose.yaml 수정하기</li>
</ul>
<div class="sourceCode" id="cb42"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb42-1"><a href="#cb42-1"></a>#&gt; cd</span>
<span id="cb42-2"><a href="#cb42-2"></a>#&gt; vi docker-compose.yaml</span>
<span id="cb42-3"><a href="#cb42-3"></a></span>
<span id="cb42-4"><a href="#cb42-4"></a>version: '3.8'</span>
<span id="cb42-5"><a href="#cb42-5"></a>x-airflow-common:</span>
<span id="cb42-6"><a href="#cb42-6"></a>  &amp;airflow-common</span>
<span id="cb42-7"><a href="#cb42-7"></a><span class="fu"># In order to add …</span></span>
<span id="cb42-8"><a href="#cb42-8"></a>  image: {image_name} #새로 만든 docker image 이름 넣을 것</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>docker compose (재) 기동</li>
<li>Connection Type 에 추가 확인
<ul>
<li>HDFS, Hive Client Wrapper, Hive Metastore Thrift, Hive Server 2 Thrift</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
</div>
<div id="English" class="tab-pane fade" role="tabpanel" aria-labelledby="English-tab">

</div>
<section id="go-to-blog-content-list" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Go to Blog Content List</h1>
<p><a href="../../content_list.qmd">Blog Content List</a><br>
<a href="../../Engineering/guide_map/index.qmd">Engineering Content List</a></p>


</section>

</div></ul></main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="./docs/comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>