<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>중간 단계의 상태(State) 수동 업데이트 – Kwangmin Kim</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../../">
<script src="../../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../../../styles.css">
<meta property="og:title" content="중간 단계의 상태(State) 수동 업데이트 – Kwangmin Kim">
<meta property="og:description" content="blog">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="중간 단계의 상태(State) 수동 업데이트 – Kwangmin Kim">
<meta name="twitter:description" content="blog">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">중간 단계의 상태(State) 수동 업데이트</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#사람의-개입-human-in-the-loop" id="toc-사람의-개입-human-in-the-loop" class="nav-link active" data-scroll-target="#사람의-개입-human-in-the-loop"><span class="header-section-number">1</span> 사람의 개입 (Human-in-the-loop)</a>
  <ul class="collapse">
  <li><a href="#stategraph의-update_state-메서드" id="toc-stategraph의-update_state-메서드" class="nav-link" data-scroll-target="#stategraph의-update_state-메서드"><span class="header-section-number">1.1</span> StateGraph의 <code>update_state</code> 메서드</a></li>
  </ul></li>
  <li><a href="#interrupt-후-메시지-상태-업데이트---이어서-진행" id="toc-interrupt-후-메시지-상태-업데이트---이어서-진행" class="nav-link" data-scroll-target="#interrupt-후-메시지-상태-업데이트---이어서-진행"><span class="header-section-number">2</span> Interrupt 후 메시지 상태 업데이트 - 이어서 진행</a></li>
  <li><a href="#지난-스냅샷의-결과-수정-및-replay" id="toc-지난-스냅샷의-결과-수정-및-replay" class="nav-link" data-scroll-target="#지난-스냅샷의-결과-수정-및-replay"><span class="header-section-number">3</span> 지난 스냅샷의 결과 수정 및 Replay</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>LangGraph는 <strong>중간 단계의 상태를 수동으로 업데이트</strong> 할 수 있는 방안을 제공하고 있습니다.</p>
<p>상태를 업데이트하면 <strong>에이전트의 행동을 수정하여 경로를 제어</strong> 할 수 있으며, 심지어 과거를 수정할 수도 있습니다.</p>
<p>이 기능은 <strong>에이전트의 실수를 수정</strong> 하거나, <strong>대체 경로를 탐색</strong> 하거나, 특정 목표에 따라 <strong>에이전트의 동작을 변경</strong> 할 때 특히 유용합니다.</p>
<ul>
<li>참고: 본 튜토리얼에서 사용하는 에이전트는 이전 튜토리얼과 동일한 그래프를 정의합니다.</li>
</ul>
<div id="de9d9d8d" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># API 키를 환경변수로 관리하기 위한 설정 파일</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">from</span> dotenv <span class="im">import</span> load_dotenv</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co"># API 키 정보 로드</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>load_dotenv()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>True</code></pre>
</div>
</div>
<div id="6b5c6228" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># LangSmith 추적을 설정합니다. https://smith.langchain.com</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co"># !pip install -qU langchain-teddynote</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="im">from</span> langchain_teddynote <span class="im">import</span> logging</span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co"># 프로젝트 이름을 입력합니다.</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>logging.langsmith(<span class="st">"CH17-LangGraph-Modules"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>LangSmith 추적을 시작합니다.
[프로젝트명]
CH17-LangGraph-Modules</code></pre>
</div>
</div>
<div id="e5d857b9" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="im">from</span> typing <span class="im">import</span> Annotated</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="im">from</span> typing_extensions <span class="im">import</span> TypedDict</span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="im">from</span> langchain_teddynote.tools.tavily <span class="im">import</span> TavilySearch</span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="im">from</span> langchain_openai <span class="im">import</span> ChatOpenAI</span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="im">from</span> langgraph.checkpoint.memory <span class="im">import</span> MemorySaver</span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="im">from</span> langgraph.graph <span class="im">import</span> StateGraph, START, END</span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="im">from</span> langgraph.graph.message <span class="im">import</span> add_messages</span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="im">from</span> langgraph.prebuilt <span class="im">import</span> ToolNode, tools_condition</span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="im">from</span> langchain_teddynote.graphs <span class="im">import</span> visualize_graph</span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="co">########## 1. 상태 정의 ##########</span></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="co"># 상태 정의</span></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="kw">class</span> State(TypedDict):</span>
<span id="cb5-16"><a href="#cb5-16"></a>    <span class="co"># 메시지 목록 주석 추가</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>    messages: Annotated[<span class="bu">list</span>, add_messages]</span>
<span id="cb5-18"><a href="#cb5-18"></a></span>
<span id="cb5-19"><a href="#cb5-19"></a></span>
<span id="cb5-20"><a href="#cb5-20"></a><span class="co">########## 2. 도구 정의 및 바인딩 ##########</span></span>
<span id="cb5-21"><a href="#cb5-21"></a><span class="co"># 도구 초기화</span></span>
<span id="cb5-22"><a href="#cb5-22"></a>tool <span class="op">=</span> TavilySearch(max_results<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb5-23"><a href="#cb5-23"></a></span>
<span id="cb5-24"><a href="#cb5-24"></a><span class="co"># 도구 목록 정의</span></span>
<span id="cb5-25"><a href="#cb5-25"></a>tools <span class="op">=</span> [tool]</span>
<span id="cb5-26"><a href="#cb5-26"></a></span>
<span id="cb5-27"><a href="#cb5-27"></a><span class="co"># LLM 초기화</span></span>
<span id="cb5-28"><a href="#cb5-28"></a>llm <span class="op">=</span> ChatOpenAI(model<span class="op">=</span><span class="st">"gpt-4o-mini"</span>)</span>
<span id="cb5-29"><a href="#cb5-29"></a></span>
<span id="cb5-30"><a href="#cb5-30"></a><span class="co"># 도구와 LLM 결합</span></span>
<span id="cb5-31"><a href="#cb5-31"></a>llm_with_tools <span class="op">=</span> llm.bind_tools(tools)</span>
<span id="cb5-32"><a href="#cb5-32"></a></span>
<span id="cb5-33"><a href="#cb5-33"></a></span>
<span id="cb5-34"><a href="#cb5-34"></a><span class="co">########## 3. 노드 추가 ##########</span></span>
<span id="cb5-35"><a href="#cb5-35"></a><span class="co"># 챗봇 함수 정의</span></span>
<span id="cb5-36"><a href="#cb5-36"></a><span class="kw">def</span> chatbot(state: State):</span>
<span id="cb5-37"><a href="#cb5-37"></a>    <span class="co"># 메시지 호출 및 반환</span></span>
<span id="cb5-38"><a href="#cb5-38"></a>    <span class="cf">return</span> {<span class="st">"messages"</span>: [llm_with_tools.invoke(state[<span class="st">"messages"</span>])]}</span>
<span id="cb5-39"><a href="#cb5-39"></a></span>
<span id="cb5-40"><a href="#cb5-40"></a></span>
<span id="cb5-41"><a href="#cb5-41"></a><span class="co"># 상태 그래프 생성</span></span>
<span id="cb5-42"><a href="#cb5-42"></a>graph_builder <span class="op">=</span> StateGraph(State)</span>
<span id="cb5-43"><a href="#cb5-43"></a></span>
<span id="cb5-44"><a href="#cb5-44"></a><span class="co"># 챗봇 노드 추가</span></span>
<span id="cb5-45"><a href="#cb5-45"></a>graph_builder.add_node(<span class="st">"chatbot"</span>, chatbot)</span>
<span id="cb5-46"><a href="#cb5-46"></a></span>
<span id="cb5-47"><a href="#cb5-47"></a></span>
<span id="cb5-48"><a href="#cb5-48"></a><span class="co"># 도구 노드 생성 및 추가</span></span>
<span id="cb5-49"><a href="#cb5-49"></a>tool_node <span class="op">=</span> ToolNode(tools<span class="op">=</span>tools)</span>
<span id="cb5-50"><a href="#cb5-50"></a></span>
<span id="cb5-51"><a href="#cb5-51"></a><span class="co"># 도구 노드 추가</span></span>
<span id="cb5-52"><a href="#cb5-52"></a>graph_builder.add_node(<span class="st">"tools"</span>, tool_node)</span>
<span id="cb5-53"><a href="#cb5-53"></a></span>
<span id="cb5-54"><a href="#cb5-54"></a><span class="co"># 조건부 엣지</span></span>
<span id="cb5-55"><a href="#cb5-55"></a>graph_builder.add_conditional_edges(</span>
<span id="cb5-56"><a href="#cb5-56"></a>    <span class="st">"chatbot"</span>,</span>
<span id="cb5-57"><a href="#cb5-57"></a>    tools_condition,</span>
<span id="cb5-58"><a href="#cb5-58"></a>)</span>
<span id="cb5-59"><a href="#cb5-59"></a></span>
<span id="cb5-60"><a href="#cb5-60"></a><span class="co">########## 4. 엣지 추가 ##########</span></span>
<span id="cb5-61"><a href="#cb5-61"></a></span>
<span id="cb5-62"><a href="#cb5-62"></a><span class="co"># tools &gt; chatbot</span></span>
<span id="cb5-63"><a href="#cb5-63"></a>graph_builder.add_edge(<span class="st">"tools"</span>, <span class="st">"chatbot"</span>)</span>
<span id="cb5-64"><a href="#cb5-64"></a></span>
<span id="cb5-65"><a href="#cb5-65"></a><span class="co"># START &gt; chatbot</span></span>
<span id="cb5-66"><a href="#cb5-66"></a>graph_builder.add_edge(START, <span class="st">"chatbot"</span>)</span>
<span id="cb5-67"><a href="#cb5-67"></a></span>
<span id="cb5-68"><a href="#cb5-68"></a><span class="co"># chatbot &gt; </span><span class="re">END</span></span>
<span id="cb5-69"><a href="#cb5-69"></a>graph_builder.add_edge(<span class="st">"chatbot"</span>, END)</span>
<span id="cb5-70"><a href="#cb5-70"></a></span>
<span id="cb5-71"><a href="#cb5-71"></a><span class="co">########## 5. 그래프 컴파일 ##########</span></span>
<span id="cb5-72"><a href="#cb5-72"></a><span class="co"># 메모리 저장소 초기화</span></span>
<span id="cb5-73"><a href="#cb5-73"></a>memory <span class="op">=</span> MemorySaver()</span>
<span id="cb5-74"><a href="#cb5-74"></a></span>
<span id="cb5-75"><a href="#cb5-75"></a><span class="co"># 그래프 빌더 컴파일</span></span>
<span id="cb5-76"><a href="#cb5-76"></a>graph <span class="op">=</span> graph_builder.<span class="bu">compile</span>(checkpointer<span class="op">=</span>memory)</span>
<span id="cb5-77"><a href="#cb5-77"></a></span>
<span id="cb5-78"><a href="#cb5-78"></a><span class="co">########## 6. 그래프 시각화 ##########</span></span>
<span id="cb5-79"><a href="#cb5-79"></a><span class="co"># 그래프 시각화</span></span>
<span id="cb5-80"><a href="#cb5-80"></a>visualize_graph(graph)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07-LangGraph-Manual-State-Update_files/figure-html/cell-4-output-1.jpeg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="d0b61953" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="im">from</span> langchain_core.runnables <span class="im">import</span> RunnableConfig</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co"># 질문</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>question <span class="op">=</span> <span class="st">"LangGraph 가 무엇인지 조사하여 알려주세요!"</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co"># 초기 입력 상태를 정의</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="bu">input</span> <span class="op">=</span> State(messages<span class="op">=</span>[(<span class="st">"user"</span>, question)])</span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="co"># config 설정</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>config <span class="op">=</span> RunnableConfig(</span>
<span id="cb6-11"><a href="#cb6-11"></a>    configurable<span class="op">=</span>{<span class="st">"thread_id"</span>: <span class="st">"1"</span>},  <span class="co"># 스레드 ID 설정</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>우선 채널목록을 출력하여 <strong>interrupt_before</strong> 와 <strong>interrupt_after</strong> 를 적용할 수 있는 목록을 출력합니다.</p>
<div id="005ec550" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># 그래프 채널 목록 출력</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="bu">list</span>(graph.channels)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>['messages',
 '__start__',
 'chatbot',
 'tools',
 'start:chatbot',
 'branch:chatbot:tools_condition:chatbot',
 'branch:chatbot:tools_condition:tools']</code></pre>
</div>
</div>
<div id="cf1b5314" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># 그래프 스트림 호출</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>events <span class="op">=</span> graph.stream(</span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="bu">input</span><span class="op">=</span><span class="bu">input</span>, config<span class="op">=</span>config, interrupt_before<span class="op">=</span>[<span class="st">"tools"</span>], stream_mode<span class="op">=</span><span class="st">"values"</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>)</span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="co"># 이벤트 반복 처리</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb9-8"><a href="#cb9-8"></a>    <span class="co"># 메시지가 이벤트에 포함된 경우</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>    <span class="cf">if</span> <span class="st">"messages"</span> <span class="kw">in</span> event:</span>
<span id="cb9-10"><a href="#cb9-10"></a>        <span class="co"># 마지막 메시지의 예쁜 출력</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>        event[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>].pretty_print()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>================================ Human Message =================================

LangGraph 가 무엇인지 조사하여 알려주세요!
================================== Ai Message ==================================
Tool Calls:
  tavily_web_search (call_uAZwKKbpIcMsKKOHI6aFIMty)
 Call ID: call_uAZwKKbpIcMsKKOHI6aFIMty
  Args:
    query: LangGraph</code></pre>
</div>
</div>
<p>현재 단계는 <code>ToolNode</code> 에 의해 중단되었습니다.</p>
<p>가장 최근 메시지를 확인하면 <code>ToolNode</code> 가 검색을 수행하기 전 <code>query</code> 를 포함하고 있음을 알 수 있습니다.</p>
<p>여기서는 <code>query</code> 가 단순하게 <code>LangGraph</code> 라는 단어만을 포함하고 있습니다. (기존의 질문은 <code>"LangGraph 가 무엇인지 조사하여 알려주세요!"</code> 였습니다.)</p>
<p>당연하게도, 웹 검색 결과가 우리가 원하는 결과와 다를 수 있습니다.</p>
<div id="731587a0" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># 그래프 상태 스냅샷 생성</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>snapshot <span class="op">=</span> graph.get_state(config)</span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co"># 가장 최근 메시지 추출</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>last_message <span class="op">=</span> snapshot.values[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="co"># 메시지 출력</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>last_message.pretty_print()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>================================== Ai Message ==================================
Tool Calls:
  tavily_web_search (call_uAZwKKbpIcMsKKOHI6aFIMty)
 Call ID: call_uAZwKKbpIcMsKKOHI6aFIMty
  Args:
    query: LangGraph</code></pre>
</div>
</div>
<section id="사람의-개입-human-in-the-loop" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="사람의-개입-human-in-the-loop"><span class="header-section-number">1</span> 사람의 개입 (Human-in-the-loop)</h2>
<ul>
<li><code>TavilySearch</code> 도구에서 <strong>검색 결과</strong> 를 수정</li>
</ul>
<p>우리는 종종 <code>ToolMessage</code> 의 결과가 마음에 들지 않는 경우가 있습니다.</p>
<p>특히, 웹 검색하여 얻은 답변은 얼마든지 잘못된 정보가 포함될 수 있고, 이는 곧 챗봇의 답변에도 영향을 미칠 수 있습니다.</p>
<p>만약, 사람이 중간에 개입하여 웹 검색 도구인 <code>Tavily Tool</code> 의 검색 결과인 <code>ToolMessage</code> 를 수정하여 LLM 에게 전달하고 싶다면 어떻게 해야 할까요?</p>
<p><img src="./image/langgraph-01.png" class="img-fluid"></p>
<p>아래는 원래의 웹 검색 결과와는 조금 다른 수정한 가상의 웹 검색 결과를 만들어 보았습니다</p>
<div id="0d8efa7d" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a>modified_search_result <span class="op">=</span> <span class="st">"""[수정된 웹 검색 결과] </span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="st">LangGraph는 상태 기반의 다중 액터 애플리케이션을 LLM을 활용해 구축할 수 있도록 지원합니다.</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="st">LangGraph는 사이클 흐름, 제어 가능성, 지속성, 클라우드 배포 기능을 제공하는 오픈 소스 라이브러리입니다.</span></span>
<span id="cb13-4"><a href="#cb13-4"></a></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="st">자세한 튜토리얼은 [LangGraph 튜토리얼](https://langchain-ai.github.io/langgraph/tutorials/) 과</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="st">테디노트의 [랭체인 한국어 튜토리얼](https://wikidocs.net/233785) 을 참고하세요."""</span></span>
<span id="cb13-7"><a href="#cb13-7"></a></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="bu">print</span>(modified_search_result)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[수정된 웹 검색 결과] 
LangGraph는 상태 기반의 다중 액터 애플리케이션을 LLM을 활용해 구축할 수 있도록 지원합니다.
LangGraph는 사이클 흐름, 제어 가능성, 지속성, 클라우드 배포 기능을 제공하는 오픈 소스 라이브러리입니다.

자세한 튜토리얼은 [LangGraph 튜토리얼](https://langchain-ai.github.io/langgraph/tutorials/) 과
테디노트의 [랭체인 한국어 튜토리얼](https://wikidocs.net/233785) 을 참고하세요.</code></pre>
</div>
</div>
<p>다음으로는 수정한 검색 결과를 <code>ToolMessage</code> 에 주입합니다.</p>
<p><strong>중요</strong></p>
<ul>
<li>여기서 메시지를 수정하려면 수정하고자 하는 Message 와 일치하는 <code>tool_call_id</code> 를 지정해야 합니다.</li>
</ul>
<div id="52368d6e" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="co"># 수정하고자 하는 `ToolMessage` 의 `tool_call_id` 추출</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>tool_call_id <span class="op">=</span> last_message.tool_calls[<span class="dv">0</span>][<span class="st">"id"</span>]</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="bu">print</span>(tool_call_id)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>call_uAZwKKbpIcMsKKOHI6aFIMty</code></pre>
</div>
</div>
<div id="1acabaac" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="im">from</span> langchain_core.messages <span class="im">import</span> AIMessage, ToolMessage</span>
<span id="cb17-2"><a href="#cb17-2"></a></span>
<span id="cb17-3"><a href="#cb17-3"></a>new_messages <span class="op">=</span> [</span>
<span id="cb17-4"><a href="#cb17-4"></a>    <span class="co"># LLM API의 도구 호출과 일치하는 ToolMessage 필요</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>    ToolMessage(</span>
<span id="cb17-6"><a href="#cb17-6"></a>        content<span class="op">=</span>modified_search_result,</span>
<span id="cb17-7"><a href="#cb17-7"></a>        tool_call_id<span class="op">=</span>tool_call_id,</span>
<span id="cb17-8"><a href="#cb17-8"></a>    ),</span>
<span id="cb17-9"><a href="#cb17-9"></a>    <span class="co"># LLM의 응답에 직접적으로 내용 추가</span></span>
<span id="cb17-10"><a href="#cb17-10"></a>    <span class="co"># AIMessage(content=modified_search_result),</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>]</span>
<span id="cb17-12"><a href="#cb17-12"></a></span>
<span id="cb17-13"><a href="#cb17-13"></a>new_messages[<span class="op">-</span><span class="dv">1</span>].pretty_print()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>================================= Tool Message =================================

[수정된 웹 검색 결과] 
LangGraph는 상태 기반의 다중 액터 애플리케이션을 LLM을 활용해 구축할 수 있도록 지원합니다.
LangGraph는 사이클 흐름, 제어 가능성, 지속성, 클라우드 배포 기능을 제공하는 오픈 소스 라이브러리입니다.

자세한 튜토리얼은 [LangGraph 튜토리얼](https://langchain-ai.github.io/langgraph/tutorials/) 과
테디노트의 [랭체인 한국어 튜토리얼](https://wikidocs.net/233785) 을 참고하세요.</code></pre>
</div>
</div>
<section id="stategraph의-update_state-메서드" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="stategraph의-update_state-메서드"><span class="header-section-number">1.1</span> StateGraph의 <code>update_state</code> 메서드</h3>
<p><code>update_state</code> 메서드는 주어진 값으로 그래프의 상태를 업데이트합니다. 이 메서드는 마치 <code>as_node</code>에서 값이 온 것처럼 동작합니다.</p>
<p><strong>매개변수</strong></p>
<ul>
<li><code>config</code> (RunnableConfig): 실행 구성</li>
<li><code>values</code> (Optional[Union[dict[str, Any], Any]]): 업데이트할 값들</li>
<li><code>as_node</code> (Optional[str]): 값의 출처로 간주할 노드 이름. 기본값은 None</li>
</ul>
<p><strong>반환값</strong></p>
<ul>
<li>RunnableConfig</li>
</ul>
<p><strong>주요 기능</strong></p>
<ol type="1">
<li>체크포인터를 통해 이전 상태를 로드하고 새로운 상태를 저장합니다.</li>
<li>서브그래프에 대한 상태 업데이트를 처리합니다.</li>
<li><code>as_node</code>가 지정되지 않은 경우, 마지막으로 상태를 업데이트한 노드를 찾습니다.</li>
<li>지정된 노드의 writer들을 실행하여 상태를 업데이트합니다.</li>
<li>업데이트된 상태를 체크포인트에 저장합니다.</li>
</ol>
<p><strong>주요 로직</strong></p>
<ol type="1">
<li>체크포인터를 확인하고, 없으면 ValueError를 발생시킵니다.</li>
<li>서브그래프에 대한 업데이트인 경우, 해당 서브그래프의 <code>update_state</code> 메서드를 호출합니다.</li>
<li>이전 체크포인트를 로드하고, 필요한 경우 <code>as_node</code>를 결정합니다.</li>
<li>지정된 노드의 writer들을 사용하여 상태를 업데이트합니다.</li>
<li>업데이트된 상태를 새로운 체크포인트로 저장합니다.</li>
</ol>
<p><strong>참고</strong></p>
<ul>
<li>이 메서드는 그래프의 상태를 수동으로 업데이트할 때 사용됩니다.</li>
<li>체크포인터를 사용하여 상태의 버전 관리와 지속성을 보장합니다.</li>
<li><code>as_node</code>를 지정하지 않으면 자동으로 결정되지만, 모호한 경우 오류가 발생할 수 있습니다.</li>
<li>상태 업데이트 중 SharedValues에 쓰기 작업은 허용되지 않습니다.</li>
</ul>
<div id="15691b8c" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a>graph.update_state(</span>
<span id="cb19-2"><a href="#cb19-2"></a>    <span class="co"># 업데이트할 상태 지정</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    config,</span>
<span id="cb19-4"><a href="#cb19-4"></a>    <span class="co"># 제공할 업데이트된 값. `State`의 메시지는 "추가 전용"으로 기존 상태에 추가됨</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>    {<span class="st">"messages"</span>: new_messages},</span>
<span id="cb19-6"><a href="#cb19-6"></a>    as_node<span class="op">=</span><span class="st">"tools"</span>,</span>
<span id="cb19-7"><a href="#cb19-7"></a>)</span>
<span id="cb19-8"><a href="#cb19-8"></a></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="bu">print</span>(<span class="st">"(최근 1개의 메시지 출력)</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb19-10"><a href="#cb19-10"></a><span class="bu">print</span>(graph.get_state(config).values[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>])</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>(최근 1개의 메시지 출력)

content='[수정된 웹 검색 결과] \nLangGraph는 상태 기반의 다중 액터 애플리케이션을 LLM을 활용해 구축할 수 있도록 지원합니다.\nLangGraph는 사이클 흐름, 제어 가능성, 지속성, 클라우드 배포 기능을 제공하는 오픈 소스 라이브러리입니다.\n\n자세한 튜토리얼은 [LangGraph 튜토리얼](https://langchain-ai.github.io/langgraph/tutorials/) 과\n테디노트의 [랭체인 한국어 튜토리얼](https://wikidocs.net/233785) 을 참고하세요.' id='7eb0cf12-f253-44a8-b0f4-c2cbb718c172' tool_call_id='call_uAZwKKbpIcMsKKOHI6aFIMty'</code></pre>
</div>
</div>
<p>이제 그래프가 완성되었습니다.</p>
<p>최종 응답 메시지를 제공했기 때문입니다!</p>
<p>상태 업데이트는 그래프 단계를 시뮬레이션하므로, 해당하는 <code>traces</code>도 생성합니다.</p>
<p><code>messages</code>를 사전 정의된 <code>add_messages</code> 함수로 <code>Annotated</code> 처리했습니다. (이는 그래프에 기존 목록을 직접 덮어쓰지 않고 항상 값을 추가합니다.)</p>
<p>동일한 논리가 여기에도 적용되어, <code>update_state</code>에 전달된 메시지가 동일한 방식으로 메시지가 추가하게 됩니다.</p>
<p><code>update_state</code> 함수는 마치 그래프의 노드 중 하나인 것처럼 작동합니다! 기본적으로 업데이트 작업은 마지막으로 실행된 노드를 사용하지만, 아래에서 수동으로 지정할 수 있습니다. 업데이트를 추가하고 그래프에 “chatbot”에서 온 것처럼 처리하도록 지시해 봅시다.</p>
<div id="3a4c1fbb" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a>snapshot <span class="op">=</span> graph.get_state(config)</span>
<span id="cb21-2"><a href="#cb21-2"></a>snapshot.<span class="bu">next</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>('chatbot',)</code></pre>
</div>
</div>
<div id="36223336" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a><span class="co"># `None`는 현재 상태에 아무것도 추가하지 않음</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>events <span class="op">=</span> graph.stream(<span class="va">None</span>, config, stream_mode<span class="op">=</span><span class="st">"values"</span>)</span>
<span id="cb23-3"><a href="#cb23-3"></a></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="co"># 이벤트 반복 처리</span></span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb23-6"><a href="#cb23-6"></a>    <span class="co"># 메시지가 이벤트에 포함된 경우</span></span>
<span id="cb23-7"><a href="#cb23-7"></a>    <span class="cf">if</span> <span class="st">"messages"</span> <span class="kw">in</span> event:</span>
<span id="cb23-8"><a href="#cb23-8"></a>        <span class="co"># 마지막 메시지의 예쁜 출력</span></span>
<span id="cb23-9"><a href="#cb23-9"></a>        event[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>].pretty_print()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>================================= Tool Message =================================

[수정된 웹 검색 결과] 
LangGraph는 상태 기반의 다중 액터 애플리케이션을 LLM을 활용해 구축할 수 있도록 지원합니다.
LangGraph는 사이클 흐름, 제어 가능성, 지속성, 클라우드 배포 기능을 제공하는 오픈 소스 라이브러리입니다.

자세한 튜토리얼은 [LangGraph 튜토리얼](https://langchain-ai.github.io/langgraph/tutorials/) 과
테디노트의 [랭체인 한국어 튜토리얼](https://wikidocs.net/233785) 을 참고하세요.
================================== Ai Message ==================================

LangGraph는 상태 기반의 다중 액터 애플리케이션을 대형 언어 모델(LLM)을 활용하여 구축할 수 있도록 지원하는 오픈 소스 라이브러리입니다. 이 라이브러리는 사이클 흐름, 제어 가능성, 지속성 및 클라우드 배포 기능을 제공하여 개발자들이 복잡한 애플리케이션을 보다 쉽게 개발할 수 있게 돕습니다.

자세한 튜토리얼은 [LangGraph 튜토리얼](https://langchain-ai.github.io/langgraph/tutorials/)과 테디노트의 [랭체인 한국어 튜토리얼](https://wikidocs.net/233785)에서 확인할 수 있습니다.</code></pre>
</div>
</div>
<p>아래는 최종 답변의 상태도 수정하고자 할 경우 사용할 수 있는 코드입니다.</p>
<div id="0889cbf7" class="cell">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a><span class="co"># 이 함수가 작동할 노드 지정. 이 노드가 방금 실행된 것처럼 자동으로 처리 계속</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="co"># graph.update_state(</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="co">#     config,</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="co">#     {</span></span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="co">#         "messages": [</span></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="co">#             AIMessage(content="마지막으로 최종 메시지를 추가하여 마무리 합니다.")</span></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="co">#         ]</span></span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="co">#     },</span></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="co">#     as_node="chatbot",</span></span>
<span id="cb25-10"><a href="#cb25-10"></a><span class="co"># )</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>그럼, 그래프를 시각화하고 전체 출력을 확인해 보겠습니다.</p>
<div id="458ada94" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a><span class="im">from</span> langchain_teddynote.graphs <span class="im">import</span> visualize_graph</span>
<span id="cb26-2"><a href="#cb26-2"></a></span>
<span id="cb26-3"><a href="#cb26-3"></a>visualize_graph(graph)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="07-LangGraph-Manual-State-Update_files/figure-html/cell-16-output-1.jpeg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>현재 상태를 이전과 같이 점검하여 체크포인트가 수동 업데이트를 반영하는지 확인합니다.</p>
<div id="b2d31c27" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a><span class="co"># 그래프 상태 스냅샷 생성</span></span>
<span id="cb27-2"><a href="#cb27-2"></a>snapshot <span class="op">=</span> graph.get_state(config)</span>
<span id="cb27-3"><a href="#cb27-3"></a></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="co"># 최근 세 개의 메시지 출력</span></span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="cf">for</span> message <span class="kw">in</span> snapshot.values[<span class="st">"messages"</span>]:</span>
<span id="cb27-6"><a href="#cb27-6"></a>    message.pretty_print()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>================================ Human Message =================================

LangGraph 가 무엇인지 조사하여 알려주세요!
================================== Ai Message ==================================
Tool Calls:
  tavily_web_search (call_uAZwKKbpIcMsKKOHI6aFIMty)
 Call ID: call_uAZwKKbpIcMsKKOHI6aFIMty
  Args:
    query: LangGraph
================================= Tool Message =================================

[수정된 웹 검색 결과] 
LangGraph는 상태 기반의 다중 액터 애플리케이션을 LLM을 활용해 구축할 수 있도록 지원합니다.
LangGraph는 사이클 흐름, 제어 가능성, 지속성, 클라우드 배포 기능을 제공하는 오픈 소스 라이브러리입니다.

자세한 튜토리얼은 [LangGraph 튜토리얼](https://langchain-ai.github.io/langgraph/tutorials/) 과
테디노트의 [랭체인 한국어 튜토리얼](https://wikidocs.net/233785) 을 참고하세요.
================================== Ai Message ==================================

LangGraph는 상태 기반의 다중 액터 애플리케이션을 대형 언어 모델(LLM)을 활용하여 구축할 수 있도록 지원하는 오픈 소스 라이브러리입니다. 이 라이브러리는 사이클 흐름, 제어 가능성, 지속성 및 클라우드 배포 기능을 제공하여 개발자들이 복잡한 애플리케이션을 보다 쉽게 개발할 수 있게 돕습니다.

자세한 튜토리얼은 [LangGraph 튜토리얼](https://langchain-ai.github.io/langgraph/tutorials/)과 테디노트의 [랭체인 한국어 튜토리얼](https://wikidocs.net/233785)에서 확인할 수 있습니다.</code></pre>
</div>
</div>
<p>진행할 다음 노드가 있는지 확인합니다. <code>()</code> 가 비어 있는 것으로 확인할 수 있습니다. 즉, 모든 과정이 정상적으로 진행되었음을 알 수 있습니다.</p>
<div id="c6ea87c0" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a><span class="co"># 다음 상태 출력</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="bu">print</span>(snapshot.<span class="bu">next</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>()</code></pre>
</div>
</div>
</section>
</section>
<section id="interrupt-후-메시지-상태-업데이트---이어서-진행" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="interrupt-후-메시지-상태-업데이트---이어서-진행"><span class="header-section-number">2</span> Interrupt 후 메시지 상태 업데이트 - 이어서 진행</h2>
<ul>
<li><code>TavilySearch</code> 도구에서 <strong>검색 쿼리</strong> 를 수정</li>
</ul>
<p>이번에는 다음 노드로 진행하기 전 interrupt 를 발생시켜 중단하고, 상태(State) 를 갱신한 뒤 이어서 진행하는 방법을 살펴보겠습니다.</p>
<p>먼저, 새로운 <code>thread_id</code> 를 생성합니다.</p>
<p>여기서는 랜덤한 해시값을 생성하는 <code>generate_random_hash</code> 함수를 사용합니다.</p>
<div id="5c7fe37d" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1"></a><span class="im">from</span> langchain_teddynote.graphs <span class="im">import</span> generate_random_hash</span>
<span id="cb31-2"><a href="#cb31-2"></a></span>
<span id="cb31-3"><a href="#cb31-3"></a>thread_id <span class="op">=</span> generate_random_hash()</span>
<span id="cb31-4"><a href="#cb31-4"></a><span class="bu">print</span>(<span class="ss">f"thread_id: </span><span class="sc">{</span>thread_id<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-5"><a href="#cb31-5"></a></span>
<span id="cb31-6"><a href="#cb31-6"></a>question <span class="op">=</span> <span class="st">"LangGraph 에 대해서 배워보고 싶습니다. 유용한 자료를 추천해 주세요!"</span></span>
<span id="cb31-7"><a href="#cb31-7"></a></span>
<span id="cb31-8"><a href="#cb31-8"></a><span class="co"># 초기 입력 상태를 정의</span></span>
<span id="cb31-9"><a href="#cb31-9"></a><span class="bu">input</span> <span class="op">=</span> State(messages<span class="op">=</span>[(<span class="st">"user"</span>, question)])</span>
<span id="cb31-10"><a href="#cb31-10"></a></span>
<span id="cb31-11"><a href="#cb31-11"></a><span class="co"># 새로운 config 생성</span></span>
<span id="cb31-12"><a href="#cb31-12"></a>config <span class="op">=</span> {<span class="st">"configurable"</span>: {<span class="st">"thread_id"</span>: thread_id}}</span>
<span id="cb31-13"><a href="#cb31-13"></a></span>
<span id="cb31-14"><a href="#cb31-14"></a>events <span class="op">=</span> graph.stream(</span>
<span id="cb31-15"><a href="#cb31-15"></a>    <span class="bu">input</span><span class="op">=</span><span class="bu">input</span>,</span>
<span id="cb31-16"><a href="#cb31-16"></a>    config<span class="op">=</span>config,</span>
<span id="cb31-17"><a href="#cb31-17"></a>    interrupt_before<span class="op">=</span>[<span class="st">"tools"</span>],</span>
<span id="cb31-18"><a href="#cb31-18"></a>    stream_mode<span class="op">=</span><span class="st">"values"</span>,</span>
<span id="cb31-19"><a href="#cb31-19"></a>)</span>
<span id="cb31-20"><a href="#cb31-20"></a><span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb31-21"><a href="#cb31-21"></a>    <span class="cf">if</span> <span class="st">"messages"</span> <span class="kw">in</span> event:</span>
<span id="cb31-22"><a href="#cb31-22"></a>        event[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>].pretty_print()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>thread_id: 6c95af
================================ Human Message =================================

LangGraph 에 대해서 배워보고 싶습니다. 유용한 자료를 추천해 주세요!
================================== Ai Message ==================================
Tool Calls:
  tavily_web_search (call_xJVDxiPGNJcHmErUMrCEMxdF)
 Call ID: call_xJVDxiPGNJcHmErUMrCEMxdF
  Args:
    query: LangGraph 소개 및 자료</code></pre>
</div>
</div>
<p>다음으로, 에이전트를 위한 도구 호출을 업데이트해 보겠습니다.</p>
<p>먼저 <code>Message ID</code> 를 가져옵니다.</p>
<div id="72d210f5" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1"></a><span class="co"># config 를 복사</span></span>
<span id="cb33-2"><a href="#cb33-2"></a>config_copy <span class="op">=</span> config.copy()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="2bac7050" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1"></a><span class="im">from</span> langchain_core.messages <span class="im">import</span> AIMessage</span>
<span id="cb34-2"><a href="#cb34-2"></a></span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="co"># 스냅샷 상태 가져오기</span></span>
<span id="cb34-4"><a href="#cb34-4"></a>snapshot <span class="op">=</span> graph.get_state(config)</span>
<span id="cb34-5"><a href="#cb34-5"></a></span>
<span id="cb34-6"><a href="#cb34-6"></a><span class="co"># messages 의 마지막 메시지 가져오기</span></span>
<span id="cb34-7"><a href="#cb34-7"></a>existing_message <span class="op">=</span> snapshot.values[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb34-8"><a href="#cb34-8"></a></span>
<span id="cb34-9"><a href="#cb34-9"></a><span class="co"># 메시지 ID 출력</span></span>
<span id="cb34-10"><a href="#cb34-10"></a><span class="bu">print</span>(<span class="st">"Message ID"</span>, existing_message.<span class="bu">id</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Message ID run-f78c69ba-6403-45dc-b355-28a2b326471e-0</code></pre>
</div>
</div>
<p>마지막 메시지는 <code>tavily_web_search</code> 도구 호출과 관련된 메시지 입니다.</p>
<p>주요 속성은 다음과 같습니다.</p>
<ul>
<li><code>name</code>: 도구의 이름</li>
<li><code>args</code>: 검색 쿼리</li>
<li><code>id</code>: 도구 호출 ID</li>
<li><code>type</code>: 도구 호출 유형(tool_call)</li>
</ul>
<div id="64c27714" class="cell" data-execution_count="22">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1"></a><span class="co"># 첫 번째 도구 호출 출력</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="bu">print</span>(existing_message.tool_calls[<span class="dv">0</span>])</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>{'name': 'tavily_web_search', 'args': {'query': 'LangGraph 소개 및 자료'}, 'id': 'call_xJVDxiPGNJcHmErUMrCEMxdF', 'type': 'tool_call'}</code></pre>
</div>
</div>
<p>위의 속성 값 중 <code>args</code> 의 <code>query</code> 를 업데이트 해 보겠습니다.</p>
<p>기존의 <code>existing_message</code> 를 복사하여 새로운 도구인 <code>new_tool_call</code> 을 생성합니다.</p>
<p><code>copy()</code> 메서드를 사용하여 복사하였기 때문에 모든 속성 값이 복사됩니다.</p>
<p>그런 다음, <code>query</code> 매개변수에 원하는 <strong>검색 쿼리</strong> 를 입력합니다.</p>
<p><strong>중요</strong></p>
<ul>
<li><code>id</code> 는 기존 메시지의 <code>id</code> 를 그대로 사용합니다. (<code>id</code> 가 달라지면 message 리듀서가 동작하여 메시지를 갱신하지 않고, 추가하게 됩니다.)</li>
</ul>
<div id="97b66610" class="cell" data-execution_count="23">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1"></a><span class="co"># tool_calls 를 복사하여 새로운 도구 호출 생성</span></span>
<span id="cb38-2"><a href="#cb38-2"></a>new_tool_call <span class="op">=</span> existing_message.tool_calls[<span class="dv">0</span>].copy()</span>
<span id="cb38-3"><a href="#cb38-3"></a></span>
<span id="cb38-4"><a href="#cb38-4"></a><span class="co"># 쿼리 매개변수 업데이트(갱신)</span></span>
<span id="cb38-5"><a href="#cb38-5"></a>new_tool_call[<span class="st">"args"</span>] <span class="op">=</span> {<span class="st">"query"</span>: <span class="st">"LangGraph site:teddylee777.github.io"</span>}</span>
<span id="cb38-6"><a href="#cb38-6"></a>new_tool_call</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>{'name': 'tavily_web_search',
 'args': {'query': 'LangGraph site:teddylee777.github.io'},
 'id': 'call_xJVDxiPGNJcHmErUMrCEMxdF',
 'type': 'tool_call'}</code></pre>
</div>
</div>
<div id="8891040b" class="cell" data-execution_count="25">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1"></a><span class="co"># AIMessage 생성</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>new_message <span class="op">=</span> AIMessage(</span>
<span id="cb40-3"><a href="#cb40-3"></a>    content<span class="op">=</span>existing_message.content,</span>
<span id="cb40-4"><a href="#cb40-4"></a>    tool_calls<span class="op">=</span>[new_tool_call],</span>
<span id="cb40-5"><a href="#cb40-5"></a>    <span class="co"># 중요! ID는 메시지를 상태에 추가하는 대신 교체하는 방법</span></span>
<span id="cb40-6"><a href="#cb40-6"></a>    <span class="bu">id</span><span class="op">=</span>existing_message.<span class="bu">id</span>,</span>
<span id="cb40-7"><a href="#cb40-7"></a>)</span>
<span id="cb40-8"><a href="#cb40-8"></a></span>
<span id="cb40-9"><a href="#cb40-9"></a><span class="bu">print</span>(new_message.<span class="bu">id</span>)</span>
<span id="cb40-10"><a href="#cb40-10"></a></span>
<span id="cb40-11"><a href="#cb40-11"></a><span class="co"># 수정한 메시지 출력</span></span>
<span id="cb40-12"><a href="#cb40-12"></a>new_message.pretty_print()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>run-f78c69ba-6403-45dc-b355-28a2b326471e-0
================================== Ai Message ==================================
Tool Calls:
  tavily_web_search (call_xJVDxiPGNJcHmErUMrCEMxdF)
 Call ID: call_xJVDxiPGNJcHmErUMrCEMxdF
  Args:
    query: LangGraph site:teddylee777.github.io</code></pre>
</div>
</div>
<p>검색 쿼리가 갱신된 것을 확인할 수 있습니다.</p>
<div id="7dbb6442" class="cell" data-execution_count="26">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1"></a><span class="co"># 업데이트된 도구 호출 출력</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="bu">print</span>(new_message.tool_calls[<span class="dv">0</span>])</span>
<span id="cb42-3"><a href="#cb42-3"></a></span>
<span id="cb42-4"><a href="#cb42-4"></a><span class="co"># 메시지 ID 출력</span></span>
<span id="cb42-5"><a href="#cb42-5"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Message ID"</span>, new_message.<span class="bu">id</span>)</span>
<span id="cb42-6"><a href="#cb42-6"></a></span>
<span id="cb42-7"><a href="#cb42-7"></a><span class="co"># 상태 업데이트</span></span>
<span id="cb42-8"><a href="#cb42-8"></a>graph.update_state(config, {<span class="st">"messages"</span>: [new_message]})</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>{'name': 'tavily_web_search', 'args': {'query': 'LangGraph site:teddylee777.github.io'}, 'id': 'call_xJVDxiPGNJcHmErUMrCEMxdF', 'type': 'tool_call'}

Message ID run-f78c69ba-6403-45dc-b355-28a2b326471e-0</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>{'configurable': {'thread_id': '6c95af',
  'checkpoint_ns': '',
  'checkpoint_id': '1ef99e9c-a81a-63e6-8002-84fbc4bcb50a'}}</code></pre>
</div>
</div>
<p>업데이트된 마지막 message 의 <code>tool_calls</code> 를 확인합니다.</p>
<ul>
<li><code>args</code> 의 <code>query</code> 가 수정된 것을 확인할 수 있습니다.</li>
</ul>
<div id="f9dbecb3" class="cell" data-execution_count="27">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1"></a><span class="co"># 마지막 메시지의 도구 호출 가져오기</span></span>
<span id="cb45-2"><a href="#cb45-2"></a>graph.get_state(config).values[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>].tool_calls</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="27">
<pre><code>[{'name': 'tavily_web_search',
  'args': {'query': 'LangGraph site:teddylee777.github.io'},
  'id': 'call_xJVDxiPGNJcHmErUMrCEMxdF',
  'type': 'tool_call'}]</code></pre>
</div>
</div>
<p>기존 검색어인 <strong>“LangGraph”</strong> 대신 변경된 검색 쿼리인 <strong>“LangGraph site:teddylee777.github.io”</strong> 로 검색되는 것을 확인할 수 있습니다.</p>
<p>기존 설정과 <code>None</code> 입력을 사용하여 그래프 이어서 스트리밍 합니다.</p>
<div id="80be43c4" class="cell" data-execution_count="28">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1"></a><span class="co"># 그래프 스트림에서 이벤트 수신</span></span>
<span id="cb47-2"><a href="#cb47-2"></a>events <span class="op">=</span> graph.stream(<span class="va">None</span>, config, stream_mode<span class="op">=</span><span class="st">"values"</span>)</span>
<span id="cb47-3"><a href="#cb47-3"></a></span>
<span id="cb47-4"><a href="#cb47-4"></a><span class="co"># 각 이벤트에 대한 처리</span></span>
<span id="cb47-5"><a href="#cb47-5"></a><span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb47-6"><a href="#cb47-6"></a>    <span class="co"># 메시지가 있는 경우 마지막 메시지 출력</span></span>
<span id="cb47-7"><a href="#cb47-7"></a>    <span class="cf">if</span> <span class="st">"messages"</span> <span class="kw">in</span> event:</span>
<span id="cb47-8"><a href="#cb47-8"></a>        event[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>].pretty_print()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>================================== Ai Message ==================================
Tool Calls:
  tavily_web_search (call_xJVDxiPGNJcHmErUMrCEMxdF)
 Call ID: call_xJVDxiPGNJcHmErUMrCEMxdF
  Args:
    query: LangGraph site:teddylee777.github.io
================================= Tool Message =================================
Name: tavily_web_search

["&lt;document&gt;&lt;title&gt;LangGraph - Multi-Agent Collaboration(다중 협업 ... - 테디노트&lt;/title&gt;&lt;url&gt;https://teddylee777.github.io/langgraph/langgraph-multi-agent-collaboration/&lt;/url&gt;&lt;content&gt;LangGraph 라이브러리가 출시하게 된 가장 큰 이유는 \\\"복잡한 문제들은 단일 AI 에이전트만으로 해결하기 어렵다\\\" 라는 문장에서 시작합니다. 이 글에서는 LangGraph의 다중 에이전트 협업을 통해 이러한 문제들을 효과적으로 해결하는 방법을 소개합니다.&lt;/content&gt;&lt;raw&gt;🔥알림🔥\n① 테디노트 유튜브 -\n구경하러 가기!\n② LangChain 한국어 튜토리얼\n바로가기 👀\n③ 랭체인 노트 무료 전자책(wikidocs)\n바로가기 🙌\n④ RAG 비법노트 LangChain 강의오픈\n바로가기 🙌\n⑤ 서울대 PyTorch 딥러닝 강의\n바로가기 🙌\nLangGraph - Multi-Agent Collaboration(다중 협업 에이전트) 로 복잡한 테스크를 수행하는 LLM 어플리케이션 제작\n2024년 01월 29일\n26 분 소요\nLangChain 에서 야심차게 LangGraph 를 새롭게 출시하였습니다. LangGraph 라이브러리가 출시하게 된 가장 큰 이유는 “복잡한 문제들은 단일 AI 에이전트만으로 해결하기 어렵다” 라는 문장에서 시작합니다.\n이 글에서는 LangGraph의 다중 에이전트 협업을 통해 이러한 문제들을 효과적으로 해결하는 방법을 소개합니다. 특히, LangGraph를 활용한 새로운 접근법을 중점적으로 다룹니다.\nReference\n본 튜토리얼은 LangGraph 튜토리얼 노트북 파일을 참조하여 작성하였습니다.\n실습파일\n요약\n주요내용\n튜토리얼 영상\n기본 다중 에이전트 협업\n단일 에이전트는 일반적으로 단일 도메인 내에서 소수의 도구를 사용하여 효과적으로 작동할 수 있지만, gpt-4와 같은 강력한 모델을 사용하더라도 많은 도구를 사용하는 데에는 덜 효과적일 수 있습니다.\n복잡한 작업에 접근하는 한 가지 방법은 ‘나누고 정복하기(divide-and-conquer)’ 접근법입니다. 각 작업이나 도메인에 대해 전문화된 에이전트를 만들고 작업을 올바른 ‘전문가’에게 라우팅합니다.\n이 노트북은 Wu 등이 작성한 논문 AutoGen: 다중 에이전트 대화를 통한 차세대 LLM 애플리케이션 가능하게 하기에서 영감을 받아 LangGraph를 사용하여 이를 수행하는 한 가지 방법을 보여줍니다.\n결과적으로 생성된 그래프는 다음 다이어그램과 같은 모습일 것입니다.\n필요한 패키지를 설치합니다.\npython-dotenv 라이브러리를 사용하여 환경 변수에서 토큰 정보를 로드합니다.\n이 라이브러리는 .env 파일에 저장된 환경 변수를 읽어와서 Python 프로그램에서 사용할 수 있게 해줍니다. load_dotenv 함수를 호출하여 .env 파일의 내용을 로드합니다.\n_set_if_undefined는 환경 변수가 설정되어 있지 않을 경우 사용자로부터 해당 환경 변수의 값을 입력받아 설정하는 역할을 합니다. 이 함수는 OPENAI_API_KEY, LANGCHAIN_API_KEY, TAVILY_API_KEY 세 개의 API 키에 대해 환경 변수가 설정되어 있는지 확인하고, 없을 경우 사용자에게 입력을 요청합니다.\n또한, LangSmith 추적 기능을 활성화하고 프로젝트 이름을 ‘Multi-agent Collaboration’으로 설정합니다.\n에이전트 생성\ncreate_agent는 AI 에이전트를 생성하는 데 사용됩니다. 이 에이전트는 다른 AI 보조자들과 협력하여 제공된 도구들을 사용해 질문에 대한 답변을 진행합니다. 에이전트는 최종 답변을 할 수 있는 경우 응답 앞에 ‘FINAL ANSWER’라고 표시하여 팀이 작업을 멈출 수 있도록 합니다.\ncreate_agent 함수는 llm, tools, system_message 세 개의 매개변수를 받으며, 각 도구의 이름을 포함한 프롬프트를 생성하여 에이전트에게 전달합니다.\nformat_tool_to_openai_function 함수는 도구를 OpenAI 함수 형식으로 변환하는 데 사용되며, ChatPromptTemplate.from_messages는 에이전트에게 전달될 메시지 템플릿을 생성합니다. 마지막으로, 생성된 프롬프트는 llm.bind_functions을 통해 에이전트의 기능과 결합됩니다.\nTool(도구) 정의\n우리의 에이전트들이 미래에 사용할 몇 가지 도구들을 정의할 것입니다\n함수 python_repl은 주어진 파이썬 코드를 실행하고 그 결과를 반환합니다. 이 함수는 tool 데코레이터로 장식되어 있으며, 사용자가 제공한 코드를 PythonREPL 인스턴스를 통해 실행합니다.\n실행 결과는 표준 출력으로 반환되며, 실행 중 발생한 예외는 오류 메시지와 함께 반환됩니다. 사용자는 print(...) 함수를 사용하여 값을 출력할 수 있습니다.\n이 함수는 차트 생성과 같은 작업에 사용될 수 있습니다.\n그래프 생성\n이제 우리는 도구를 정의하고 몇 가지 헬퍼 함수를 만들었으므로, 아래에서 개별 에이전트를 생성하고 LangGraph를 사용하여 서로 통신하는 방법을 알려줄 것입니다.\n상태 정의\n우리는 먼저 그래프의 상태를 정의합니다. 이것은 가장 최근의 발신자를 추적하는 키와 함께 메시지의 리스트일 것입니다.\n이 코드는 langchain 라이브러리를 사용하여 AI 에이전트와 상호작용하는 그래프 기반의 시스템을 구축하기 위한 준비 작업을 포함하고 있습니다.\nAgentState 클래스는 에이전트의 상태를 나타내며, messages는 BaseMessage 객체의 시퀀스로 구성되며, sender는 메시지를 보낸 사람의 식별자를 나타냅니다.\nAnnotated와 operator.add를 사용하여 messages 필드에 메시지를 추가할 수 있는 기능을 제공합니다.\n에이전트 노드 정의하기\n이제 노드를 정의할 필요가 있습니다. 먼저, 에이전트들을 위한 노드를 정의합시다.\n함수 agent_node는 주어진 에이전트의 상태를 처리하고, 결과 메시지와 발신자 정보를 포함하는 딕셔너리를 반환합니다. FunctionMessage 인스턴스인 경우에는 특별한 처리를 하지 않고, 그렇지 않은 경우에는 HumanMessage 인스턴스로 변환합니다.\nChatOpenAI 클래스의 인스턴스 llm은 모델 gpt-4-1106-preview를 사용하여 생성됩니다.\nresearch_agent와 chart_agent는 각각 연구자와 차트 생성기를 위한 에이전트를 생성하며, 이들은 llm을 사용하고 특정 도구(tavily_tool, python_repl)와 시스템 메시지를 설정합니다. research_node와 chart_node는 functools.partial을 사용하여 agent_node 함수에 필요한 인자를 미리 설정한 콜백 함수를 생성합니다.\nTool Node (도구 노드) 정의\n우리는 이제 도구를 실행하는 노드를 정의합니다\ntool_node는 상태 객체를 받아 마지막 메시지에서 도구 호출을 추출하고, 해당 도구를 실행한 후 결과를 FunctionMessage 형태로 반환합니다.\n이 함수는 ToolExecutor 인스턴스를 사용하여 도구를 실행하며, 실행 결과는 새로운 메시지 리스트에 추가되어 반환됩니다.\n단일 인자 입력은 값으로 직접 전달되며, 복수 인자의 경우 ToolInvocation 객체를 통해 전달됩니다.\n에지 로직 정의\n에이전트의 결과에 따라 무엇을 할지 결정하는 데 필요한 일부 에지 로직을 정의할 수 있습니다.\nrouter는 상태 정보를 받아서 다음 단계를 결정합니다. 상태 정보에서 마지막 메시지를 확인하고, 이 메시지에 특정 키워드가 포함되어 있는지에 따라 다음 단계를 반환합니다.\n만약 마지막 메시지의 additional_kwargs에 function_call이 포함되어 있다면, 이전 에이전트가 도구를 호출한 것으로 간주하고 \"call_tool\"을 반환합니다. 만약 마지막 메시지의 내용에 \"FINAL ANSWER\"가 포함되어 있다면, 작업이 완료되었다고 판단하고 \"end\"를 반환합니다. 그렇지 않으면 작업을 계속 진행해야 하므로 \"continue\"를 반환합니다.\n그래프 정의하기\n이제 모든 것을 종합하여 그래프를 정의할 수 있습니다!\nStateGraph 클래스를 사용하여 상태 기반 워크플로우를 구성합니다.\nAgentState를 기반으로 StateGraph 객체를 생성하고, add_node 메서드를 사용하여 여러 노드(Researcher, Chart Generator, call_tool)를 추가합니다.\nadd_conditional_edges 메서드를 통해 조건부 엣지를 추가하여, 각 노드가 특정 조건에 따라 다른 노드로 이동할 수 있도록 합니다. 예를 들어, Researcher 노드는 router 함수의 결과에 따라 Chart Generator 또는 call_tool로 이동하거나 워크플로우를 종료할 수 있습니다. call_tool 노드는 sender 필드를 기반으로 원래 호출한 노드로 돌아갑니다.\n마지막으로 set_entry_point 메서드로 시작점을 Researcher로 설정하고, compile 메서드로 워크플로우 그래프를 컴파일합니다.\n호출\n그래프가 생성되었으니 이제 호출할 수 있습니다! 몇 가지 통계를 차트로 나타내도록 해봅시다.\n이 코드는 graph 객체의 stream 메소드를 사용하여 데이터를 스트리밍합니다.\nHumanMessage 객체를 사용하여 대한민국의 2018년부터 2022년까지의 출산율 데이터를 요청하고, 해당 데이터에 대한 그래프를 그리도록 요청합니다. 또한, 코드 실행이 완료되면 종료하도록 메시지에 포함되어 있습니다.\n스트림은 최대 200번의 재귀 호출로 제한됩니다.\n라이선스\n태그:\nAutoGen,\nLangChain,\nLangGraph,\nLLM,\nPython,\n그래프 기반 시스템,\n노드,\n다중 에이전트,\n데이터 스트리밍,\n딥러닝,\n랭체인,\n머신러닝,\n멀티에이전트,\n상태 정의,\n에지 로직,\n협업,\n호출\n카테고리:\nlanggraph\n업데이트: 2024년 01월 29일\n참고\npoetry 의 거의 모든것 (튜토리얼)\n2024년 03월 30일\n5 분 소요\nPython 개발에 있어서 poetry는 매우 강력한 도구로, 프로젝트의 의존성 관리와 패키지 배포를 간소화하는 데 큰 도움을 줍니다. 지금부터 poetry 활용 튜토리얼을 살펴 보겠습니다.\nLangGraph Retrieval Agent를 활용한 동적 문서 검색 및 처리\n2024년 03월 06일\n10 분 소요\nLangGraph Retrieval Agent는 언어 처리, AI 모델 통합, 데이터베이스 관리, 그래프 기반 데이터 처리 등 다양한 기능을 제공하여 언어 기반 AI 애플리케이션 개발에 필수적인 도구입니다.\n[Assistants API] Code Interpreter, Retrieval, Functions 활용법\n2024년 02월 13일\n35 분 소요\nOpenAI의 새로운 Assistants API는 대화와 더불어 강력한 도구 접근성을 제공합니다. 본 튜토리얼은 OpenAI Assistants API를 활용하는 내용을 다룹니다. 특히, Assistant API 가 제공하는 도구인 Code Interpreter, Retrieval...\n[LangChain] 에이전트(Agent)와 도구(tools)를 활용한 지능형 검색 시스템 구축 가이드\n2024년 02월 09일\n41 분 소요\n이 글에서는 LangChain 의 Agent 프레임워크를 활용하여 복잡한 검색과 데이터 처리 작업을 수행하는 방법을 소개합니다. LangSmith 를 사용하여 Agent의 추론 단계를 추적합니다. Agent가 활용할 검색 도구(Tavily Search), PDF 기반 검색 리트리버...&lt;/raw&gt;&lt;/document&gt;", "&lt;document&gt;&lt;title&gt;랭체인(langchain) + PDF 문서요약, Map-Reduce (7) - 테디노트&lt;/title&gt;&lt;url&gt;https://teddylee777.github.io/langchain/langchain-tutorial-07/&lt;/url&gt;&lt;content&gt;LangGraph Retrieval Agent를 활용한 동적 문서 검색 및 처리 2024년 03월 06일 10 분 소요 LangGraph Retrieval Agent는 언어 처리, AI 모델 통합, 데이터베이스 관리, 그래프 기반 데이터 처리 등 다양한 기능을 제공하여 언어 기반 AI 애플리케이션 개발에 필수적인 도구입니다.&lt;/content&gt;&lt;raw&gt;🔥알림🔥\n① 테디노트 유튜브 -\n구경하러 가기!\n② LangChain 한국어 튜토리얼\n바로가기 👀\n③ 랭체인 노트 무료 전자책(wikidocs)\n바로가기 🙌\n랭체인(langchain) + PDF 문서요약, Map-Reduce (7)\n2023년 10월 06일\n11 분 소요\n이번 포스팅에서는 랭체인(LangChain) 을 활용하여 PDF 문서를 로드하고, 문서의 내용을 요약 하는 방법에 대해 알아보겠습니다.\n이번 튜토리얼에서는 langchain 의 PyPDFLoader 를 활용한 PDF 문서의 텍스트 데이터를 불러오는 방법에 대해 다룹니다.\n또한, 긴 PDF 문서를 쪼개서 요약 및 통합하는 Map-Reduce 방식의 요약 방식에 대해 깊게 다루도록 하겠습니다. Map-Reduce 방식은 LLM의 제한적인 토큰 사이즈를 입력으로 받는 구조적 문제를 해결하는 방법론이기 때문에 비단 요약 뿐만아니라 그 밖에 확장된 테스크에도 적용이 가능합니다.\n✔️ (이전글) LangChain 튜토리얼\n🌱 환경설정\n🔥 PDF 기반 문서요약\n✔️ 문서요약 방식\nPDF 의 문서를 요약하는 방식에는 문서의 크기에 따라 2가지 방식으로 나누어 볼 수 있습니다.\nStuff: 전체 문서의 내용을 모두 프롬프트의 입력으로 대입합니다. 전체 문서의 내용이 LLM 모델의 최대토큰 허용 크기보다 작은 경우, 이 방식을 선택할 수 있습니다.\nMap-Reduce: 전체 문서의 내용을 쪼개서 여러의 부분 세트로 나눈 뒤, 나눈 내용을 프롬프트의 입력을 나누어 대입합니다. 예를 들어, PDF 문서가 100장으로 구성이 되어 있고, 100장 분량의 내용을 프롬프트의 입력으로 한 번에 넣을 수 없으므로, 20장씩 5개의 세트로 나눈 뒤 5번의 프롬프트 입력 후 결과로 나온 5개의 요약본을 통합하는 작업을 진행합니다.\nStuff 방식은 코드가 간결하지만, 현실적으로 잘 사용하게 되지 않습니다. 일반적인 PDF 문서의 전체 길이가 LLM 모델의 최대토큰 허용 크기보다 큰 경우가 대다수의 경우이기 때문입니다. 따라서, 이번 튜토리얼에서는 Map-Reduce 방식에 대해 자세히 다루며, Stuff 방식은 여기 에서 참고하실 수 있습니다.\n📍 흐름\n흐름도\n위의 흐름도를 보면서 PDF 문서를 요약하는 흐름에 대해서 정리해 보겠습니다.\n① 문서 로드\n먼저, langchain 의 PDF 문서의 로드를 도와주는 PDF Loader 를 활용하여 문서를 로드합니다. langchain에서는 다양한 PDF Loader 를 제공하며, 대표적인 예시로는 PyPDFLoader, PyMuPDFLoader, UnstructuredPDFLoader 등이 있습니다.\n여기서 문서를 로드한다는 의미는 PDF 문서의 내용을 긁어와 String 형태로 가져오는 것을 의미하며 정확하게는 Document 객체안에 page_content 속성으로 로드합니다. PDF 로드시 각종 메타데이터로 함께 로드합니다.\nPyPDFLoader 사용하여 PDF를 로드하고, 각 문서가 페이지 내용과 페이지 번호를 포함한 메타데이터를 포함하는 문서의 배열로 만듭니다.\n② 문서 분할\n문서의 내용이 긴 경우, 문서 전체의 내용을 프롬프트의 입력으로 넣을 수 없으므로 문서를 분할하는 작업을 선행합니다.\n문서 분할은 토큰갯수에 따라 분할할 수 있으며, 대표적으로 많이 사용되는 모듈은 CharacterTextSplitter, RecursiveCharacterTextSplitter 등이 있습니다.\n아래는 가장 단순한 방법인 CharacterTextSplitter 를 활용하여 문서를 분할한 예시 입니다.\n이 방법은 문자(기본적으로 “\\n\\n”)를 기반으로 분할하며, 문자의 수(chunk_size)로 길이를 측정합니다.\n텍스트의 분할 방식: 단일 문자 기준\nchunk_size 의 측정 방식: 문자의 수로 측정\n③ 분할된 각 문서에 대한 요약 실행\n분할된 문서에 요약(summarization) 과 같은 테스크를 수행하는 것을 Map, 각 문서의 요약본을 하나로 통합하는 작업을 Reduce 라고 부릅니다. 즉, Map-Reduce 방식은 문서를 분할 - 요약 - 통합 을 수행하게 됩니다.\n그 중 Map 단계에서 수행할 프롬프트를 템플릿으로 정의하고 chain 을 생성해 보겠습니다.\n④ 각 문서의 요약본에 대한 통합\nReduce 단계는 이전 단계인 Map 단계에서 분할된 문서에 대한 요약본을 통합처리 하는 역할을 수행합니다.\nReduce 단계에서는 통합처리시 필요한 프롬프트를 정의합니다. 통합처리시 단순하게 전체 요약본 테스크를 수행할 수 도 있고, 요약본을 토대로 보고서, 이메일, 뉴스레터, 독서감상문 등의 다양한 테스크를 수행하도록 할 수 있습니다.\n아래는 통합 요약본을 작성하는 프롬프트 예시입니다.\ncombine_documents_chain 은 Reduce 작업을 수행하는 체인입니다.\nMap 단계에서 완성된 분할된 요약본이 StuffDocumentsChain 의 doc_summaries 입력으로 주입됩니다.\nReduceDocumentsChain 은 주입된 입력 값을 통합하는 작업을 수행합니다.\n⑤&nbsp;통합체인(Combined Chain) 생성\n통합체인 생성 단계에서는 이전에 정의한 Map 체인과 Reduce 체인을 연결하고, MapReduceDocumentsChain 객체를 통해 통합하는 단계입니다.\n🔥 전체코드\n이전 단계의 결과물인 문서의 통합요약본을 바탕으로 다음과 같은 추가 Task를 수행할 수 있습니다. 아래는 독서감상문 작성의 예시입니다.\n태그:\nChatGPT,\nChatOpenAI,\nGPT3.5,\nGPT4,\nlangchain,\nlangchain tutorial,\nOpenAI,\nPDF,\n뉴스레터,\n독서감상문,\n랭체인,\n랭체인 튜토리얼,\n문서요약,\n크롤링,\n회의록\n카테고리:\nlangchain\n업데이트: 2023년 10월 06일\n참고\npoetry 의 거의 모든것 (튜토리얼)\n2024년 03월 30일\n5 분 소요\nPython 개발에 있어서 poetry는 매우 강력한 도구로, 프로젝트의 의존성 관리와 패키지 배포를 간소화하는 데 큰 도움을 줍니다. 지금부터 poetry 활용 튜토리얼을 살펴 보겠습니다.\nLangGraph Retrieval Agent를 활용한 동적 문서 검색 및 처리\n2024년 03월 06일\n10 분 소요\nLangGraph Retrieval Agent는 언어 처리, AI 모델 통합, 데이터베이스 관리, 그래프 기반 데이터 처리 등 다양한 기능을 제공하여 언어 기반 AI 애플리케이션 개발에 필수적인 도구입니다.\n[Assistants API] Code Interpreter, Retrieval, Functions 활용법\n2024년 02월 13일\n35 분 소요\nOpenAI의 새로운 Assistants API는 대화와 더불어 강력한 도구 접근성을 제공합니다. 본 튜토리얼은 OpenAI Assistants API를 활용하는 내용을 다룹니다. 특히, Assistant API 가 제공하는 도구인 Code Interpreter, Retrieval...\n[LangChain] 에이전트(Agent)와 도구(tools)를 활용한 지능형 검색 시스템 구축 가이드\n2024년 02월 09일\n41 분 소요\n이 글에서는 LangChain 의 Agent 프레임워크를 활용하여 복잡한 검색과 데이터 처리 작업을 수행하는 방법을 소개합니다. LangSmith 를 사용하여 Agent의 추론 단계를 추적합니다. Agent가 활용할 검색 도구(Tavily Search), PDF 기반 검색 리트리버...&lt;/raw&gt;&lt;/document&gt;", "&lt;document&gt;&lt;title&gt;랭체인(langchain) + 정형데이터(CSV, Excel) - ChatGPT 기반 데이터분석 (4) - 테디노트&lt;/title&gt;&lt;url&gt;https://teddylee777.github.io/langchain/langchain-tutorial-04/&lt;/url&gt;&lt;content&gt;LangGraph Retrieval Agent를 활용한 동적 문서 검색 및 처리 2024년 03월 06일 10 분 소요 LangGraph Retrieval Agent는 언어 처리, AI 모델 통합, 데이터베이스 관리, 그래프 기반 데이터 처리 등 다양한 기능을 제공하여 언어 기반 AI 애플리케이션 개발에 필수적인 도구입니다.&lt;/content&gt;&lt;raw&gt;🔥알림🔥\n① 테디노트 유튜브 -\n구경하러 가기!\n② LangChain 한국어 튜토리얼\n바로가기 👀\n③ 랭체인 노트 무료 전자책(wikidocs)\n바로가기 🙌\n④ RAG 비법노트 LangChain 강의오픈\n바로가기 🙌\n⑤ 서울대 PyTorch 딥러닝 강의\n바로가기 🙌\n랭체인(langchain) + 정형데이터(CSV, Excel) - ChatGPT 기반 데이터분석 (4)\n2023년 10월 02일\n4 분 소요\n이번 포스팅에서는 랭체인(LangChain) 을 활용하여 정형데이터(CSV, Excel) 에 대한 ChatGPT 기반 질의응답을 통해 데이터 분석하는 방법 에 대해 알아보겠습니다.\n이번 튜토리얼에서는 langchain 의 create_pandas_dataframe_agent() 을 통해 에이전트를 생성한 뒤, 생성된 에이전트에 자연어로 데이터에 대한 질의 응답 을 통해 원하는 분석 결과를 도출하는 방법에 대해 다루겠습니다.\n한가지 흥미로운 사실은 자연어로 에이전트에 질문하면, 에이전트가 이를 pandas 문법을 변환하여 코드를 실행한 뒤, 결과를 다시 자연어로 반환해 준다는 점입니다. 에이전트가 답변을 도출하는 과정에서 실행한 pandas 코드도 확인 할 수 있습니다.\n✔️ (이전글) LangChain 튜토리얼\n🌱 환경설정\n라이브러리 설치\nOPENAI API KEY 를 설정합니다.\n🔥 데이터 로드\npandas를 활용하여 csv 파일을 DataFrame 으로 로드합니다.\n🔥 Pandas DataFrame Agent\n🔥 2개 이상의 DataFrame\n2개 이상의 데이터프레임에 기반한 LLM 기반 질의를 할 수 있습니다. 2개 이상의 데이터프레임 입력시 [] 로 묶어주면 됩니다.\n태그:\nChatGPT,\nChatOpenAI,\ncsv,\nexcel,\nGPT3.5,\nGPT4,\nlangchain,\nlangchain tutorial,\nOpenAI,\n데이터분석,\n랭체인,\n랭체인 튜토리얼\n카테고리:\nlangchain\n업데이트: 2023년 10월 02일\n참고\npoetry 의 거의 모든것 (튜토리얼)\n2024년 03월 30일\n5 분 소요\nPython 개발에 있어서 poetry는 매우 강력한 도구로, 프로젝트의 의존성 관리와 패키지 배포를 간소화하는 데 큰 도움을 줍니다. 지금부터 poetry 활용 튜토리얼을 살펴 보겠습니다.\nLangGraph Retrieval Agent를 활용한 동적 문서 검색 및 처리\n2024년 03월 06일\n10 분 소요\nLangGraph Retrieval Agent는 언어 처리, AI 모델 통합, 데이터베이스 관리, 그래프 기반 데이터 처리 등 다양한 기능을 제공하여 언어 기반 AI 애플리케이션 개발에 필수적인 도구입니다.\n[Assistants API] Code Interpreter, Retrieval, Functions 활용법\n2024년 02월 13일\n35 분 소요\nOpenAI의 새로운 Assistants API는 대화와 더불어 강력한 도구 접근성을 제공합니다. 본 튜토리얼은 OpenAI Assistants API를 활용하는 내용을 다룹니다. 특히, Assistant API 가 제공하는 도구인 Code Interpreter, Retrieval...\n[LangChain] 에이전트(Agent)와 도구(tools)를 활용한 지능형 검색 시스템 구축 가이드\n2024년 02월 09일\n41 분 소요\n이 글에서는 LangChain 의 Agent 프레임워크를 활용하여 복잡한 검색과 데이터 처리 작업을 수행하는 방법을 소개합니다. LangSmith 를 사용하여 Agent의 추론 단계를 추적합니다. Agent가 활용할 검색 도구(Tavily Search), PDF 기반 검색 리트리버...&lt;/raw&gt;&lt;/document&gt;"]
================================== Ai Message ==================================

LangGraph에 대해 더 알아보실 수 있는 유용한 자료는 다음과 같습니다:

1. **[LangGraph - Multi-Agent Collaboration](https://teddylee777.github.io/langgraph/langgraph-multi-agent-collaboration/)**  
   이 글에서는 LangGraph 라이브러리와 다중 에이전트 협업을 통해 복잡한 문제를 해결하는 방법을 소개합니다. 특히, 전문화된 에이전트를 만들어 작업을 효과적으로 분배하는 접근법에 대해 설명합니다.

2. **[LangGraph Retrieval Agent를 활용한 동적 문서 검색 및 처리](https://teddylee777.github.io/langchain/langchain-tutorial-07/)**  
   이 포스팅에서는 LangGraph Retrieval Agent를 사용하여 언어 처리 및 AI 모델 통합, 데이터베이스 관리 등 다양한 기능을 제공하는 방법에 대해 다룹니다.

3. **[랭체인 + 정형데이터](https://teddylee777.github.io/langchain/langchain-tutorial-04/)**  
   이 글에서는 LangChain을 활용하여 정형 데이터(CSV, Excel)에 대한 ChatGPT 기반 질의응답을 통해 데이터 분석하는 방법을 소개합니다. 에이전트를 생성하고 자연어로 질문하는 과정에 대한 설명이 포함되어 있습니다.

이 자료들을 통해 LangGraph의 기능 및 활용 방법에 대해 깊이 있게 이해하실 수 있을 것입니다.</code></pre>
</div>
</div>
<div id="df57c7da" class="cell" data-execution_count="29">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1"></a><span class="co"># 이벤트 스트림 생성</span></span>
<span id="cb49-2"><a href="#cb49-2"></a>events <span class="op">=</span> graph.stream(</span>
<span id="cb49-3"><a href="#cb49-3"></a>    {</span>
<span id="cb49-4"><a href="#cb49-4"></a>        <span class="st">"messages"</span>: (</span>
<span id="cb49-5"><a href="#cb49-5"></a>            <span class="st">"user"</span>,</span>
<span id="cb49-6"><a href="#cb49-6"></a>            <span class="st">"내가 지금까지 배운 내용에 대해서 매우 친절하고 정성스럽게 한국어로 답변해줘! 출처를 반드시 포함해줘!"</span>,</span>
<span id="cb49-7"><a href="#cb49-7"></a>        )</span>
<span id="cb49-8"><a href="#cb49-8"></a>    },</span>
<span id="cb49-9"><a href="#cb49-9"></a>    config,</span>
<span id="cb49-10"><a href="#cb49-10"></a>    stream_mode<span class="op">=</span><span class="st">"values"</span>,</span>
<span id="cb49-11"><a href="#cb49-11"></a>)</span>
<span id="cb49-12"><a href="#cb49-12"></a></span>
<span id="cb49-13"><a href="#cb49-13"></a><span class="co"># 메시지 이벤트 처리</span></span>
<span id="cb49-14"><a href="#cb49-14"></a><span class="cf">for</span> event <span class="kw">in</span> events:</span>
<span id="cb49-15"><a href="#cb49-15"></a>    <span class="cf">if</span> <span class="st">"messages"</span> <span class="kw">in</span> event:</span>
<span id="cb49-16"><a href="#cb49-16"></a>        <span class="co"># 마지막 메시지 출력</span></span>
<span id="cb49-17"><a href="#cb49-17"></a>        event[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>].pretty_print()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>================================ Human Message =================================

내가 지금까지 배운 내용에 대해서 매우 친절하고 정성스럽게 한국어로 답변해줘! 출처를 반드시 포함해줘!
================================== Ai Message ==================================

물론입니다! 지금까지 배운 내용을 친절하고 정성스럽게 요약해드리겠습니다.

---

### LangGraph 개요

LangGraph는 복잡한 문제를 해결하기 위해 다중 에이전트 협업을 가능하게 하는 라이브러리입니다. 이 라이브러리는 단일 AI 에이전트로는 해결하기 어려운 문제들을 나누고 정복하는 방식으로 접근합니다. 즉, 각 작업이나 도메인에 특화된 에이전트를 만들고, 이 에이전트들이 팀워크를 통해 문제를 해결하도록 합니다.

### 주요 기능

1. **다중 에이전트 협업**:
   - LangGraph는 여러 개의 AI 에이전트가 서로 협력하여 작업을 수행하도록 설계되었습니다. 각 에이전트는 특정 도메인이나 작업에 최적화되어 있어, 복잡한 문제를 효과적으로 해결할 수 있습니다.

2. **전문화된 에이전트 생성**:
   - 복잡한 작업에 대해 전문화된 에이전트를 만들어 작업을 올바른 전문가에게 라우팅합니다. 이를 통해 각 에이전트가 최적의 성능을 발휘할 수 있습니다.

3. **상태 기반 워크플로우**:
   - LangGraph는 상태 그래프를 사용하여 에이전트 간의 상호작용을 관리합니다. 각 에이전트의 상태를 정의하고, 메시지의 흐름을 추적하여 작업을 진행합니다.

4. **도구와 기능 통합**:
   - LangGraph는 다양한 도구와 기능을 통합하여 사용할 수 있습니다. 예를 들어, Python REPL 도구를 통해 코드를 실행하거나, 특정 작업을 수행할 수 있는 기능을 포함합니다.

### 활용 사례

- **문서 검색 및 처리**: LangGraph Retrieval Agent를 사용하여 언어 처리 및 데이터베이스 관리 등을 통해 동적인 문서 검색과 처리를 수행할 수 있습니다.
- **정형 데이터 분석**: CSV 또는 Excel 파일에 대한 질의응답을 통해 데이터 분석을 수행할 수 있으며, 자연어로 질문하면 에이전트가 이를 처리하여 결과를 반환합니다.

### 출처
- [LangGraph - Multi-Agent Collaboration](https://teddylee777.github.io/langgraph/langgraph-multi-agent-collaboration/)
- [LangGraph Retrieval Agent를 활용한 동적 문서 검색 및 처리](https://teddylee777.github.io/langchain/langchain-tutorial-07/)
- [랭체인 + 정형데이터](https://teddylee777.github.io/langchain/langchain-tutorial-04/)

---

이렇게 요약된 내용이 도움이 되길 바랍니다! 추가적인 질문이 있으시면 언제든지 말씀해 주세요.</code></pre>
</div>
</div>
<p>최종 상태에서 <code>messages</code> 의 마지막 메시지를 확인합니다. (이는 곧 최종 응답 메시지입니다.)</p>
<div id="f0e4a062" class="cell" data-execution_count="30">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1"></a>graph.get_state(config).values[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>].pretty_print()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>================================== Ai Message ==================================

물론입니다! 지금까지 배운 내용을 친절하고 정성스럽게 요약해드리겠습니다.

---

### LangGraph 개요

LangGraph는 복잡한 문제를 해결하기 위해 다중 에이전트 협업을 가능하게 하는 라이브러리입니다. 이 라이브러리는 단일 AI 에이전트로는 해결하기 어려운 문제들을 나누고 정복하는 방식으로 접근합니다. 즉, 각 작업이나 도메인에 특화된 에이전트를 만들고, 이 에이전트들이 팀워크를 통해 문제를 해결하도록 합니다.

### 주요 기능

1. **다중 에이전트 협업**:
   - LangGraph는 여러 개의 AI 에이전트가 서로 협력하여 작업을 수행하도록 설계되었습니다. 각 에이전트는 특정 도메인이나 작업에 최적화되어 있어, 복잡한 문제를 효과적으로 해결할 수 있습니다.

2. **전문화된 에이전트 생성**:
   - 복잡한 작업에 대해 전문화된 에이전트를 만들어 작업을 올바른 전문가에게 라우팅합니다. 이를 통해 각 에이전트가 최적의 성능을 발휘할 수 있습니다.

3. **상태 기반 워크플로우**:
   - LangGraph는 상태 그래프를 사용하여 에이전트 간의 상호작용을 관리합니다. 각 에이전트의 상태를 정의하고, 메시지의 흐름을 추적하여 작업을 진행합니다.

4. **도구와 기능 통합**:
   - LangGraph는 다양한 도구와 기능을 통합하여 사용할 수 있습니다. 예를 들어, Python REPL 도구를 통해 코드를 실행하거나, 특정 작업을 수행할 수 있는 기능을 포함합니다.

### 활용 사례

- **문서 검색 및 처리**: LangGraph Retrieval Agent를 사용하여 언어 처리 및 데이터베이스 관리 등을 통해 동적인 문서 검색과 처리를 수행할 수 있습니다.
- **정형 데이터 분석**: CSV 또는 Excel 파일에 대한 질의응답을 통해 데이터 분석을 수행할 수 있으며, 자연어로 질문하면 에이전트가 이를 처리하여 결과를 반환합니다.

### 출처
- [LangGraph - Multi-Agent Collaboration](https://teddylee777.github.io/langgraph/langgraph-multi-agent-collaboration/)
- [LangGraph Retrieval Agent를 활용한 동적 문서 검색 및 처리](https://teddylee777.github.io/langchain/langchain-tutorial-07/)
- [랭체인 + 정형데이터](https://teddylee777.github.io/langchain/langchain-tutorial-04/)

---

이렇게 요약된 내용이 도움이 되길 바랍니다! 추가적인 질문이 있으시면 언제든지 말씀해 주세요.</code></pre>
</div>
</div>
</section>
<section id="지난-스냅샷의-결과-수정-및-replay" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="지난-스냅샷의-결과-수정-및-replay"><span class="header-section-number">3</span> 지난 스냅샷의 결과 수정 및 Replay</h2>
<p>이번에는 지난 스냅샷의 결과를 수정하여 Replay 하는 방법을 살펴보겠습니다.</p>
<p>지난 스냅샷을 확인 후 특정 노드로 되돌아가, <strong>상태(State) 를 수정한 뒤 해당 노드부터 다시 진행</strong>합니다.</p>
<p>이를 Replay 라고 합니다.</p>
<p>먼저 지난 스냅샷의 상태를 가져옵니다.</p>
<div id="3eba0794" class="cell" data-execution_count="31">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1"></a>to_replay_state <span class="op">=</span> <span class="va">None</span></span>
<span id="cb53-2"><a href="#cb53-2"></a></span>
<span id="cb53-3"><a href="#cb53-3"></a><span class="co"># 상태 기록 가져오기</span></span>
<span id="cb53-4"><a href="#cb53-4"></a><span class="cf">for</span> state <span class="kw">in</span> graph.get_state_history(config):</span>
<span id="cb53-5"><a href="#cb53-5"></a></span>
<span id="cb53-6"><a href="#cb53-6"></a>    messages <span class="op">=</span> state.values[<span class="st">"messages"</span>]</span>
<span id="cb53-7"><a href="#cb53-7"></a></span>
<span id="cb53-8"><a href="#cb53-8"></a>    <span class="cf">if</span> <span class="bu">len</span>(messages) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb53-9"><a href="#cb53-9"></a>        <span class="bu">print</span>(state.values[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>].<span class="bu">id</span>)</span>
<span id="cb53-10"><a href="#cb53-10"></a>        <span class="co"># 메시지 수 및 다음 상태 출력</span></span>
<span id="cb53-11"><a href="#cb53-11"></a>        <span class="bu">print</span>(<span class="st">"메시지 수: "</span>, <span class="bu">len</span>(state.values[<span class="st">"messages"</span>]), <span class="st">"다음 노드: "</span>, state.<span class="bu">next</span>)</span>
<span id="cb53-12"><a href="#cb53-12"></a>        <span class="bu">print</span>(<span class="st">"-"</span> <span class="op">*</span> <span class="dv">80</span>)</span>
<span id="cb53-13"><a href="#cb53-13"></a>        <span class="co"># 특정 상태 선택 기준: 채팅 메시지 수</span></span>
<span id="cb53-14"><a href="#cb53-14"></a>        <span class="cf">if</span> <span class="bu">len</span>(state.values[<span class="st">"messages"</span>]) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb53-15"><a href="#cb53-15"></a>            <span class="co"># 특정 메시지 ID 선택</span></span>
<span id="cb53-16"><a href="#cb53-16"></a>            to_replay_state <span class="op">=</span> state</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>run-55afc5ee-6d63-4b11-b2a7-2835553e09d6-0
메시지 수:  6 다음 노드:  ()
--------------------------------------------------------------------------------
d45abb6b-b2c4-40f8-86ce-1038fc289d0f
메시지 수:  5 다음 노드:  ('chatbot',)
--------------------------------------------------------------------------------
run-af0f4be0-8950-4c29-b996-93e9332ca1d9-0
메시지 수:  4 다음 노드:  ('__start__',)
--------------------------------------------------------------------------------
run-af0f4be0-8950-4c29-b996-93e9332ca1d9-0
메시지 수:  4 다음 노드:  ()
--------------------------------------------------------------------------------
b599532c-fea7-4dac-918a-787264946d9b
메시지 수:  3 다음 노드:  ('chatbot',)
--------------------------------------------------------------------------------
run-f78c69ba-6403-45dc-b355-28a2b326471e-0
메시지 수:  2 다음 노드:  ('tools',)
--------------------------------------------------------------------------------
run-f78c69ba-6403-45dc-b355-28a2b326471e-0
메시지 수:  2 다음 노드:  ('tools',)
--------------------------------------------------------------------------------
a08330c9-456f-4cf3-b155-194afa04a353
메시지 수:  1 다음 노드:  ('chatbot',)
--------------------------------------------------------------------------------</code></pre>
</div>
</div>
<p>선택한 메시지의 내용을 확인합니다.</p>
<div id="0463ea52" class="cell" data-execution_count="32">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1"></a><span class="im">from</span> langchain_teddynote.messages <span class="im">import</span> display_message_tree</span>
<span id="cb55-2"><a href="#cb55-2"></a></span>
<span id="cb55-3"><a href="#cb55-3"></a><span class="co"># 선택한 메시지 가져오기</span></span>
<span id="cb55-4"><a href="#cb55-4"></a>existing_message <span class="op">=</span> to_replay_state.values[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb55-5"><a href="#cb55-5"></a></span>
<span id="cb55-6"><a href="#cb55-6"></a><span class="co"># 메시지 트리 출력</span></span>
<span id="cb55-7"><a href="#cb55-7"></a>display_message_tree(existing_message)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>    content: ""
    additional_kwargs:
        tool_calls:
            index [0]
                id: "call_xJVDxiPGNJcHmErUMrCEMxdF"
                function: {"arguments": "{"query":"LangGraph 소개 및 자료"}", "name": "tavily_web_search"}
                type: "function"
        refusal: None
    response_metadata:
        token_usage:
            completion_tokens: 21
            prompt_tokens: 97
            total_tokens: 118
            completion_tokens_details: {"audio_tokens": None, "reasoning_tokens": 0}
            prompt_tokens_details: {"audio_tokens": None, "cached_tokens": 0}
        model_name: "gpt-4o-mini-2024-07-18"
        system_fingerprint: "fp_0ba0d124f1"
        finish_reason: "tool_calls"
        logprobs: None
    type: "ai"
    name: None
    id: "run-f78c69ba-6403-45dc-b355-28a2b326471e-0"
    example: False
    tool_calls:
        index [0]
            name: "tavily_web_search"
            args: {"query": "LangGraph 소개 및 자료"}
            id: "call_xJVDxiPGNJcHmErUMrCEMxdF"
            type: "tool_call"
    invalid_tool_calls:
    usage_metadata:
        input_tokens: 97
        output_tokens: 21
        total_tokens: 118
        input_token_details: {"cache_read": 0}
        output_token_details: {"reasoning": 0}</code></pre>
</div>
</div>
<p>검색 쿼리를 업데이트 후 반영이 됐는지 확인합니다.</p>
<div id="7dbc1f15" class="cell" data-execution_count="33">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1"></a>tool_call <span class="op">=</span> existing_message.tool_calls[<span class="dv">0</span>].copy()</span>
<span id="cb57-2"><a href="#cb57-2"></a>tool_call[<span class="st">"args"</span>] <span class="op">=</span> {<span class="st">"query"</span>: <span class="st">"LangGraph human-in-the-loop workflow site:reddit.com"</span>}</span>
<span id="cb57-3"><a href="#cb57-3"></a>tool_call</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="33">
<pre><code>{'name': 'tavily_web_search',
 'args': {'query': 'LangGraph human-in-the-loop workflow site:reddit.com'},
 'id': 'call_xJVDxiPGNJcHmErUMrCEMxdF',
 'type': 'tool_call'}</code></pre>
</div>
</div>
<p>업데이트된 AIMessage 를 생성합니다.</p>
<div id="2656f8db" class="cell" data-execution_count="34">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1"></a><span class="co"># AIMessage 생성</span></span>
<span id="cb59-2"><a href="#cb59-2"></a>new_message <span class="op">=</span> AIMessage(</span>
<span id="cb59-3"><a href="#cb59-3"></a>    content<span class="op">=</span>existing_message.content,</span>
<span id="cb59-4"><a href="#cb59-4"></a>    tool_calls<span class="op">=</span>[tool_call],</span>
<span id="cb59-5"><a href="#cb59-5"></a>    <span class="co"># 중요! ID는 메시지를 상태에 추가하는 대신 교체하는 방법</span></span>
<span id="cb59-6"><a href="#cb59-6"></a>    <span class="bu">id</span><span class="op">=</span>existing_message.<span class="bu">id</span>,</span>
<span id="cb59-7"><a href="#cb59-7"></a>)</span>
<span id="cb59-8"><a href="#cb59-8"></a></span>
<span id="cb59-9"><a href="#cb59-9"></a><span class="co"># 수정한 메시지 출력</span></span>
<span id="cb59-10"><a href="#cb59-10"></a>new_message.tool_calls[<span class="dv">0</span>][<span class="st">"args"</span>]</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="34">
<pre><code>{'query': 'LangGraph human-in-the-loop workflow site:reddit.com'}</code></pre>
</div>
</div>
<p>아래는 업데이트가 되기 전의 메시지입니다.</p>
<div id="27eb7447" class="cell" data-execution_count="35">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1"></a><span class="co"># 업데이트 전 메시지 확인</span></span>
<span id="cb61-2"><a href="#cb61-2"></a>graph.get_state(to_replay_state.config).values[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>].tool_calls</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="35">
<pre><code>[{'name': 'tavily_web_search',
  'args': {'query': 'LangGraph 소개 및 자료'},
  'id': 'call_xJVDxiPGNJcHmErUMrCEMxdF',
  'type': 'tool_call'}]</code></pre>
</div>
</div>
<p><code>graph</code> 에 <code>update_state</code> 메서드를 사용하여 상태를 업데이트 합니다.</p>
<p>업데이트된 상태를 <code>updated_state</code> 에 저장합니다.</p>
<div id="41a6e114" class="cell" data-execution_count="36">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1"></a><span class="co"># 상태 업데이트</span></span>
<span id="cb63-2"><a href="#cb63-2"></a>updated_state <span class="op">=</span> graph.update_state(</span>
<span id="cb63-3"><a href="#cb63-3"></a>    to_replay_state.config,</span>
<span id="cb63-4"><a href="#cb63-4"></a>    {<span class="st">"messages"</span>: [new_message]},</span>
<span id="cb63-5"><a href="#cb63-5"></a>)</span>
<span id="cb63-6"><a href="#cb63-6"></a>updated_state</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="36">
<pre><code>{'configurable': {'thread_id': '6c95af',
  'checkpoint_ns': '',
  'checkpoint_id': '1ef99eb2-a7bb-6966-8002-a7b0cb3acc65'}}</code></pre>
</div>
</div>
<p>이제 업데이트된 상태를 스트리밍 합니다. 여기서 입력은 <code>None</code> 으로 주어 Replay 합니다.</p>
<div id="fe04786b" class="cell" data-execution_count="37">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1"></a><span class="co"># config 에는 updated_state 를 전달합니다. 이는 임의로 갱신한 상태를 전달하는 것입니다.</span></span>
<span id="cb65-2"><a href="#cb65-2"></a><span class="cf">for</span> event <span class="kw">in</span> graph.stream(<span class="va">None</span>, updated_state, stream_mode<span class="op">=</span><span class="st">"values"</span>):</span>
<span id="cb65-3"><a href="#cb65-3"></a>    <span class="co"># 메시지가 이벤트에 포함된 경우</span></span>
<span id="cb65-4"><a href="#cb65-4"></a>    <span class="cf">if</span> <span class="st">"messages"</span> <span class="kw">in</span> event:</span>
<span id="cb65-5"><a href="#cb65-5"></a>        <span class="co"># 마지막 메시지 출력</span></span>
<span id="cb65-6"><a href="#cb65-6"></a>        event[<span class="st">"messages"</span>][<span class="op">-</span><span class="dv">1</span>].pretty_print()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>================================== Ai Message ==================================
Tool Calls:
  tavily_web_search (call_xJVDxiPGNJcHmErUMrCEMxdF)
 Call ID: call_xJVDxiPGNJcHmErUMrCEMxdF
  Args:
    query: LangGraph human-in-the-loop workflow site:reddit.com
================================= Tool Message =================================
Name: tavily_web_search

["&lt;document&gt;&lt;title&gt;Insights and Learnings from Building a Complex Multi-Agent System&lt;/title&gt;&lt;url&gt;https://www.reddit.com/r/LangChain/comments/1byz3lr/insights_and_learnings_from_building_a_complex/&lt;/url&gt;&lt;content&gt;For the chatbot, Chainlit provides everything we need, except background processing. Let's use that. Langchain and LCEL are both flexible and unify the interfaces with the LLMs. We'll need a rather complicated agent workflow, in fact, multiple ones. LangGraph is more flexible than crew.ai or autogen.&lt;/content&gt;&lt;/document&gt;", "&lt;document&gt;&lt;title&gt;Tool-calling agents: Human approval before tool invocation?&lt;/title&gt;&lt;url&gt;https://www.reddit.com/r/LangChain/comments/1ci3m0k/toolcalling_agents_human_approval_before_tool/&lt;/url&gt;&lt;content&gt;Thank you. I've seen both of those examples before - the \\\"human-in-the-loop\\\" uses a linear chain (rather than agents). The \\\"human-as-a-tool\\\" is when a question can't be answered by the LLM / one of the supplied tools, so it asks a human to supplement with info.&lt;/content&gt;&lt;/document&gt;", "&lt;document&gt;&lt;title&gt;Flow Engineering with LangChain/LangGraph and CodiumAI - Reddit&lt;/title&gt;&lt;url&gt;https://www.reddit.com/r/Langchaindev/comments/1dl6pyk/flow_engineering_with_langchainlanggraph_and/&lt;/url&gt;&lt;content&gt;The talk among Itamar Friedman (CEO of CodiumAI) and Harrison Chase (CEO of LangChain) explores best practices, insights, examples, and hot takes on flow engineering: Flow Engineering with LangChain/LangGraph and CodiumAI. Flow Engineering can be used for many problems involving reasoning, and can outperform naive prompt engineering.&lt;/content&gt;&lt;/document&gt;"]
================================== Ai Message ==================================

LangGraph에 대한 유용한 자료를 다음과 같이 추천드립니다:

1. **[Insights and Learnings from Building a Complex Multi-Agent System](https://www.reddit.com/r/LangChain/comments/1byz3lr/insights_and_learnings_from_building_a_complex/)** - 이 글에서는 LangGraph의 유연성과 복잡한 에이전트 워크플로우에 대해 논의하고 있습니다. LangGraph가 crew.ai나 autogen보다 더 유연하다는 점을 강조합니다.

2. **[Tool-calling agents: Human approval before tool invocation?](https://www.reddit.com/r/LangChain/comments/1ci3m0k/toolcalling_agents_human_approval_before_tool/)** - 이 글에서는 'human-in-the-loop' 접근 방식에 대해 설명하며, LangGraph의 활용 사례를 다룹니다.

3. **[Flow Engineering with LangChain/LangGraph and CodiumAI](https://www.reddit.com/r/Langchaindev/comments/1dl6pyk/flow_engineering_with_langchainlanggraph_and/)** - Itamar Friedman과 Harrison Chase가 Flow Engineering의 모범 사례와 통찰을 공유하는 내용으로, LangGraph와 CodiumAI의 결합을 다룹니다. 

이 자료들은 LangGraph의 기능과 활용에 대한 깊은 이해를 도와줄 것입니다.</code></pre>
</div>
</div>
<p>최종 결과를 출력합니다.</p>
<p>이때 사용하는 <code>config</code> 는 최종 상태를 가져오는 것이 아니라, 최종 상태를 가져오기 위한 초기 <code>config</code> 입니다.</p>
<div id="24d3e865" class="cell" data-execution_count="38">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1"></a><span class="co"># 최종 결과 출력</span></span>
<span id="cb67-2"><a href="#cb67-2"></a><span class="cf">for</span> msg <span class="kw">in</span> graph.get_state(config).values[<span class="st">"messages"</span>]:</span>
<span id="cb67-3"><a href="#cb67-3"></a>    msg.pretty_print()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>================================ Human Message =================================

LangGraph 에 대해서 배워보고 싶습니다. 유용한 자료를 추천해 주세요!
================================== Ai Message ==================================
Tool Calls:
  tavily_web_search (call_xJVDxiPGNJcHmErUMrCEMxdF)
 Call ID: call_xJVDxiPGNJcHmErUMrCEMxdF
  Args:
    query: LangGraph human-in-the-loop workflow site:reddit.com
================================= Tool Message =================================
Name: tavily_web_search

["&lt;document&gt;&lt;title&gt;Insights and Learnings from Building a Complex Multi-Agent System&lt;/title&gt;&lt;url&gt;https://www.reddit.com/r/LangChain/comments/1byz3lr/insights_and_learnings_from_building_a_complex/&lt;/url&gt;&lt;content&gt;For the chatbot, Chainlit provides everything we need, except background processing. Let's use that. Langchain and LCEL are both flexible and unify the interfaces with the LLMs. We'll need a rather complicated agent workflow, in fact, multiple ones. LangGraph is more flexible than crew.ai or autogen.&lt;/content&gt;&lt;/document&gt;", "&lt;document&gt;&lt;title&gt;Tool-calling agents: Human approval before tool invocation?&lt;/title&gt;&lt;url&gt;https://www.reddit.com/r/LangChain/comments/1ci3m0k/toolcalling_agents_human_approval_before_tool/&lt;/url&gt;&lt;content&gt;Thank you. I've seen both of those examples before - the \\\"human-in-the-loop\\\" uses a linear chain (rather than agents). The \\\"human-as-a-tool\\\" is when a question can't be answered by the LLM / one of the supplied tools, so it asks a human to supplement with info.&lt;/content&gt;&lt;/document&gt;", "&lt;document&gt;&lt;title&gt;Flow Engineering with LangChain/LangGraph and CodiumAI - Reddit&lt;/title&gt;&lt;url&gt;https://www.reddit.com/r/Langchaindev/comments/1dl6pyk/flow_engineering_with_langchainlanggraph_and/&lt;/url&gt;&lt;content&gt;The talk among Itamar Friedman (CEO of CodiumAI) and Harrison Chase (CEO of LangChain) explores best practices, insights, examples, and hot takes on flow engineering: Flow Engineering with LangChain/LangGraph and CodiumAI. Flow Engineering can be used for many problems involving reasoning, and can outperform naive prompt engineering.&lt;/content&gt;&lt;/document&gt;"]
================================== Ai Message ==================================

LangGraph에 대한 유용한 자료를 다음과 같이 추천드립니다:

1. **[Insights and Learnings from Building a Complex Multi-Agent System](https://www.reddit.com/r/LangChain/comments/1byz3lr/insights_and_learnings_from_building_a_complex/)** - 이 글에서는 LangGraph의 유연성과 복잡한 에이전트 워크플로우에 대해 논의하고 있습니다. LangGraph가 crew.ai나 autogen보다 더 유연하다는 점을 강조합니다.

2. **[Tool-calling agents: Human approval before tool invocation?](https://www.reddit.com/r/LangChain/comments/1ci3m0k/toolcalling_agents_human_approval_before_tool/)** - 이 글에서는 'human-in-the-loop' 접근 방식에 대해 설명하며, LangGraph의 활용 사례를 다룹니다.

3. **[Flow Engineering with LangChain/LangGraph and CodiumAI](https://www.reddit.com/r/Langchaindev/comments/1dl6pyk/flow_engineering_with_langchainlanggraph_and/)** - Itamar Friedman과 Harrison Chase가 Flow Engineering의 모범 사례와 통찰을 공유하는 내용으로, LangGraph와 CodiumAI의 결합을 다룹니다. 

이 자료들은 LangGraph의 기능과 활용에 대한 깊은 이해를 도와줄 것입니다.</code></pre>
</div>
</div>


</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("kk3225\.netlify\.app");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>