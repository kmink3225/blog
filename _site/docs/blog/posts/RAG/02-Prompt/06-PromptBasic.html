<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="프롬프트의 개념과 구성 요소를 파악한다.">

<title>Prompt Structure – Kwangmin Kim</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Prompt Structure – Kwangmin Kim">
<meta property="og:description" content="프롬프트의 개념과 구성 요소를 파악한다.">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Prompt Structure – Kwangmin Kim">
<meta name="twitter:description" content="프롬프트의 개념과 구성 요소를 파악한다.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">Prompt Structure</h1>
            <p class="subtitle lead">프롬프트의 개념과 구성 요소</p>
                  <div>
        <div class="description">
          <p>프롬프트의 개념과 구성 요소를 파악한다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">AI</div>
                <div class="quarto-category">RAG</div>
                <div class="quarto-category">LangChain</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2025년 01월 16일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#프롬프트의-이론적-기초-theoretical-foundation" id="toc-프롬프트의-이론적-기초-theoretical-foundation" class="nav-link active" data-scroll-target="#프롬프트의-이론적-기초-theoretical-foundation"><span class="header-section-number">1</span> 프롬프트의 이론적 기초 (Theoretical Foundation)</a>
  <ul class="collapse">
  <li><a href="#프롬프트-엔지니어링의-정의와-위상" id="toc-프롬프트-엔지니어링의-정의와-위상" class="nav-link" data-scroll-target="#프롬프트-엔지니어링의-정의와-위상"><span class="header-section-number">1.1</span> 프롬프트 엔지니어링의 정의와 위상</a></li>
  <li><a href="#llm의-수학적-작동-원리" id="toc-llm의-수학적-작동-원리" class="nav-link" data-scroll-target="#llm의-수학적-작동-원리"><span class="header-section-number">1.2</span> LLM의 수학적 작동 원리</a></li>
  <li><a href="#주요-llm-모델-비교-2024-2025" id="toc-주요-llm-모델-비교-2024-2025" class="nav-link" data-scroll-target="#주요-llm-모델-비교-2024-2025"><span class="header-section-number">1.3</span> 주요 LLM 모델 비교 (2024-2025)</a></li>
  <li><a href="#프롬프트와-프롬프트-엔지니어링" id="toc-프롬프트와-프롬프트-엔지니어링" class="nav-link" data-scroll-target="#프롬프트와-프롬프트-엔지니어링"><span class="header-section-number">1.4</span> 프롬프트와 프롬프트 엔지니어링</a></li>
  </ul></li>
  <li><a href="#프롬프트-요소-element-of-prompt" id="toc-프롬프트-요소-element-of-prompt" class="nav-link" data-scroll-target="#프롬프트-요소-element-of-prompt"><span class="header-section-number">2</span> 프롬프트 요소 (Element of Prompt)</a>
  <ul class="collapse">
  <li><a href="#프롬프트-vs-프롬프트-엔지니어링-비교" id="toc-프롬프트-vs-프롬프트-엔지니어링-비교" class="nav-link" data-scroll-target="#프롬프트-vs-프롬프트-엔지니어링-비교"><span class="header-section-number">2.1</span> 프롬프트 vs 프롬프트 엔지니어링 비교</a></li>
  <li><a href="#프롬프트-엔지니어링의-구성-요소" id="toc-프롬프트-엔지니어링의-구성-요소" class="nav-link" data-scroll-target="#프롬프트-엔지니어링의-구성-요소"><span class="header-section-number">2.2</span> 프롬프트 엔지니어링의 구성 요소</a></li>
  <li><a href="#예시-출력물-분석" id="toc-예시-출력물-분석" class="nav-link" data-scroll-target="#예시-출력물-분석"><span class="header-section-number">2.3</span> 예시 출력물 분석</a></li>
  <li><a href="#type-d-type-a-입력값-지시-구름의-종류를-설명.-맥락-입력값을-활용해서-내용을-보충.-예시-권운-층운-등-입력-데이터-루크-하워드의-구름-분류와-설명" id="toc-type-d-type-a-입력값-지시-구름의-종류를-설명.-맥락-입력값을-활용해서-내용을-보충.-예시-권운-층운-등-입력-데이터-루크-하워드의-구름-분류와-설명" class="nav-link" data-scroll-target="#type-d-type-a-입력값-지시-구름의-종류를-설명.-맥락-입력값을-활용해서-내용을-보충.-예시-권운-층운-등-입력-데이터-루크-하워드의-구름-분류와-설명"><span class="header-section-number">2.4</span> Type D (Type A + 입력값): <code>지시: 구름의 종류를 설명.</code>, <code>맥락: [[입력값]]을 활용해서 내용을 보충.</code>, <code>예시: 권운, 층운 등</code>, <code>입력 데이터: 루크 하워드의 구름 분류와 설명</code></a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="프롬프트의-이론적-기초-theoretical-foundation" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="프롬프트의-이론적-기초-theoretical-foundation"><span class="header-section-number">1</span> 프롬프트의 이론적 기초 (Theoretical Foundation)</h2>
<section id="프롬프트-엔지니어링의-정의와-위상" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="프롬프트-엔지니어링의-정의와-위상"><span class="header-section-number">1.1</span> 프롬프트 엔지니어링의 정의와 위상</h3>
<ul>
<li><strong>프롬프트 엔지니어링</strong>: 자연어 인터페이스를 통해 대규모 언어모델(LLM)의 행동을 제어하고 최적화하는 체계적 방법론</li>
<li><strong>핵심 구성:</strong>
<ul>
<li>프롬프트 엔지니어링 = 언어학(Linguistics) + 인지과학(Cognitive Science) + 컴퓨터과학(Computer Science) + 통계학(Statistics)</li>
</ul></li>
</ul>
</section>
<section id="llm의-수학적-작동-원리" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="llm의-수학적-작동-원리"><span class="header-section-number">1.2</span> LLM의 수학적 작동 원리</h3>
<ul>
<li>AI (Artificial Intelligence)의 한 종류</li>
<li>초기 프롬프트나 문맥을 기반으로 다음 단어 분포를 예측하여 데이터를 생성</li>
<li><strong>Autoregression</strong> 사용: 과거 데이터 값을 입력으로 받아 다음 시점의 값을 예측</li>
</ul>
<section id="autoregressive-language-modeling-mechanism" class="level4" data-number="1.2.1">
<h4 data-number="1.2.1" class="anchored" data-anchor-id="autoregressive-language-modeling-mechanism"><span class="header-section-number">1.2.1</span> Autoregressive Language Modeling Mechanism</h4>
<ul>
<li>GPT-4는 본질적으로 <strong>Transformer</strong> 기반</li>
<li>주어진 텍스트에서 다음 토큰(단어 또는 하위 단어)을 예측하도록 훈련</li>
<li><strong>Autoregressive</strong> 모델 구조로 일관되고 문맥적으로 관련된 텍스트 생성
<ul>
<li>LLM은 다음 토큰의 조건부 확률 분포를 학습:</li>
</ul></li>
</ul>
<p><span class="math display">\[P(x_t | x_{&lt;t}) = \text{softmax}(W \cdot h_t + b)\]</span></p>
<p>여기서: - <span class="math inline">\(x_t\)</span>: 시점 <span class="math inline">\(t\)</span>의 토큰 - <span class="math inline">\(x_{&lt;t}\)</span>: 이전 모든 토큰들 (<span class="math inline">\(x_1, x_2, ..., x_{t-1}\)</span>) - <span class="math inline">\(h_t\)</span>: Transformer의 hidden state - <span class="math inline">\(W, b\)</span>: 학습 가능한 파라미터</p>
<p><strong>전체 시퀀스 생성 확률:</strong></p>
<p><span class="math display">\[P(x_1, x_2, ..., x_n) = \prod_{t=1}^{n} P(x_t | x_{&lt;t})\]</span></p>
</section>
<section id="transformer-아키텍처의-핵심" class="level4" data-number="1.2.2">
<h4 data-number="1.2.2" class="anchored" data-anchor-id="transformer-아키텍처의-핵심"><span class="header-section-number">1.2.2</span> Transformer 아키텍처의 핵심</h4>
<p><strong>Self-Attention 메커니즘:</strong></p>
<p><span class="math display">\[\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V\]</span></p>
<p>여기서: - <span class="math inline">\(Q\)</span> (Query): 현재 토큰의 질의 벡터 - <span class="math inline">\(K\)</span> (Key): 모든 토큰의 키 벡터 - <span class="math inline">\(V\)</span> (Value): 모든 토큰의 값 벡터 - <span class="math inline">\(d_k\)</span>: 키 벡터의 차원</p>
<p><strong>의미:</strong> - 각 토큰이 문맥 내 다른 토큰들과의 관계를 학습 - <span class="math inline">\(\sqrt{d_k}\)</span>로 스케일링하여 gradient vanishing 방지</p>
</section>
</section>
<section id="주요-llm-모델-비교-2024-2025" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="주요-llm-모델-비교-2024-2025"><span class="header-section-number">1.3</span> 주요 LLM 모델 비교 (2024-2025)</h3>
<section id="모델-발전-연대기-파라미터-기준" class="level4" data-number="1.3.1">
<h4 data-number="1.3.1" class="anchored" data-anchor-id="모델-발전-연대기-파라미터-기준"><span class="header-section-number">1.3.1</span> 모델 발전 연대기 (파라미터 기준)</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>연도</th>
<th>모델</th>
<th>파라미터</th>
<th>주요 혁신</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2018</td>
<td>ELMo</td>
<td>94M</td>
<td>문맥 기반 임베딩</td>
</tr>
<tr class="even">
<td>2019</td>
<td>BERT-Large</td>
<td>340M</td>
<td>양방향 인코더</td>
</tr>
<tr class="odd">
<td>2020</td>
<td>GPT-3</td>
<td>175B</td>
<td>Few-shot learning</td>
</tr>
<tr class="even">
<td>2021</td>
<td>Megatron-Turing NLG</td>
<td>530B</td>
<td>대규모 분산 학습</td>
</tr>
<tr class="odd">
<td>2023</td>
<td>GPT-4</td>
<td>~1.76T (추정)</td>
<td>Multimodal 통합</td>
</tr>
<tr class="even">
<td>2024</td>
<td>Claude 3 Opus</td>
<td>-</td>
<td>Constitutional AI</td>
</tr>
<tr class="odd">
<td>2025</td>
<td>GPT-4o</td>
<td>-</td>
<td>Real-time multimodal</td>
</tr>
</tbody>
</table>
</section>
<section id="현존-3대-주요-llm모델-특성-비교-20242025" class="level4" data-number="1.3.2">
<h4 data-number="1.3.2" class="anchored" data-anchor-id="현존-3대-주요-llm모델-특성-비교-20242025"><span class="header-section-number">1.3.2</span> 현존 3대 주요 LLM모델 특성 비교 (2024~2025)</h4>
<p><strong>OpenAI GPT-4o:</strong> - <strong>강점</strong>: 실시간 멀티모달, API 비용 효율성 (50% 절감), 빠른 응답 속도, 비용 50% 절감, 멀티모달, 정확한 결과, 실시간 비디오/오디오 지원 - <strong>아키텍처</strong>: Transformer + RLHF + Constitutional AI - <strong>최적 용도</strong>: 범용 텍스트 생성, 복잡한 추론, 코딩 - <strong>Chat Interface의 핵심 기능:</strong> - 이전 대화 내용 기억 (Remember what user said earlier in the conversation) - 후속 수정 허용 (Allow user to provide follow-up corrections) - 부적절한 요청 거부 학습 (Trained to decline inappropriate requests) <strong>Anthropic Claude 3:</strong> - <strong>강점</strong>: Constitutional AI를 통한 안전성, 200K 토큰 컨텍스트, 다국어 지원, 비전 및 이미지 처리, 헌법적 AI - <strong>핵심 기술</strong>: - Feature-Tuning: 모델 내부 활성화 패턴 직접 제어 - Interpretability Research: 뉴런 활성화의 개념적 매핑 - <strong>최적 용도</strong>: 장문 분석, 윤리적 추론, 구조화된 대화 - “Mapping the Mind of A Large Language Model”: - 모델의 뉴런 활성화 패턴을 인간이 해석 가능한 수백만 개의 개념으로 식별 - 언어 모델 내부 상태에 대한 개념 지도 생성 및 시각화 <strong>Google Gemini:</strong> - <strong>강점</strong>: 멀티모달 통합 (텍스트/이미지/오디오/비디오), 대부분 벤치마크에서 뛰어난 성능, 텍스트/이미지/오디오/비디오 지원 - <strong>벤치마크</strong>: MMLU, BBH 등 대부분 벤치마크 우위 - <strong>최적 용도</strong>: 멀티모달 분석, 과학적 추론</p>
</section>
<section id="model-tuning-방법" class="level4" data-number="1.3.3">
<h4 data-number="1.3.3" class="anchored" data-anchor-id="model-tuning-방법"><span class="header-section-number">1.3.3</span> Model Tuning 방법</h4>
<ul>
<li>fine-tuning: 사전 학습된 모델을 특정 작업이나 도메인에 맞게 추가 학습시키는 방법. 가중치를 직접 업데이트하여 모델을 특화시킴.</li>
<li><strong>prompt-engineering</strong>: 모델의 가중치 변경 없이 입력 프롬프트 설계를 통해 원하는 출력을 유도하는 방법. 가장 비용 효율적이고 빠른 접근법.</li>
<li>feature-tuning: 모델 내부의 특정 뉴런이나 활성화 패턴을 직접 제어하여 모델 행동을 조정하는 방법. Claude의 Constitutional AI에서 사용되는 고급 기법.</li>
</ul>
</section>
</section>
<section id="프롬프트와-프롬프트-엔지니어링" class="level3" data-number="1.4">
<h3 data-number="1.4" class="anchored" data-anchor-id="프롬프트와-프롬프트-엔지니어링"><span class="header-section-number">1.4</span> 프롬프트와 프롬프트 엔지니어링</h3>
<ul>
<li><strong>프롬프트</strong> = 새로운 대화 도구</li>
<li><strong>프롬프트 엔지니어링</strong> = 자연어로 컴퓨터와 상호작용하는 방법
<ul>
<li>프롬프트 엔지니어링은 모델의 출력을 제어하고 원하는 방향으로 유도</li>
</ul></li>
<li>프롬프트 엔지니어링의 중요성: 언어 모델 성능 향상을 위한 연구에 필요
<ul>
<li>출력제어: 모델의 응답 형식, 톤, 스타일을 정밀하게 조정하여 일관된 결과 생성</li>
<li>정확성: 명확한 지시와 맥락 제공으로 사실 기반의 정확한 정보 도출</li>
<li>편향완화: 중립적이고 균형 잡힌 프롬프트 설계로 모델의 편향된 응답 최소화</li>
<li>적응성: 다양한 도메인과 작업에 맞게 프롬프트를 조정하여 범용성 확보</li>
<li>문맥이해: 충분한 배경 정보 제공으로 모델의 문맥 파악 능력 향상</li>
<li>경제성: Fine-tuning 없이 프롬프트만으로 성능 개선, 시간과 비용 절감</li>
<li>윤리적 사용: 안전장치와 가이드라인을 프롬프트에 내장하여 책임 있는 AI 활용</li>
</ul></li>
</ul>
</section>
</section>
<section id="프롬프트-요소-element-of-prompt" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="프롬프트-요소-element-of-prompt"><span class="header-section-number">2</span> 프롬프트 요소 (Element of Prompt)</h2>
<section id="프롬프트-vs-프롬프트-엔지니어링-비교" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="프롬프트-vs-프롬프트-엔지니어링-비교"><span class="header-section-number">2.1</span> 프롬프트 vs 프롬프트 엔지니어링 비교</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 24%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>비교사항</th>
<th>프롬프트</th>
<th>프롬프트 엔지니어링</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>정의</strong></td>
<td>AI 모델에게 응답을 생성하도록 입력하는 텍스트, 문장</td>
<td>AI 모델로부터 원하는 출력을 얻기 위해 프롬프트를 설계하고 개선하는 과정</td>
</tr>
<tr class="even">
<td><strong>목적</strong></td>
<td>AI 모델로부터 응답이나 출력을 유도하기 위함</td>
<td>프롬프트를 설계하여 AI 모델의 응답을 최적화하고 제어하기 위함</td>
</tr>
<tr class="odd">
<td><strong>예시</strong></td>
<td>용에 대한 이야기 들려줘</td>
<td>용감한 용이 마을을 구하는 짧고 상상력 넘치는 이야기를 생생한 묘사와 대화를 사용하여 들려줘</td>
</tr>
<tr class="even">
<td><strong>필요 사항</strong></td>
<td>AI 모델의 입력 요구 사항에 대한 기본적인 이해</td>
<td>AI 모델의 내부 작동 방식, 창의성, 언어의 미묘한 차이에 대한 이해</td>
</tr>
</tbody>
</table>
</section>
<section id="프롬프트-엔지니어링의-구성-요소" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="프롬프트-엔지니어링의-구성-요소"><span class="header-section-number">2.2</span> 프롬프트 엔지니어링의 구성 요소</h3>
<ul>
<li>프롬프트 엔지니어링 = 프롬프트(인문학) + 엔지니어링(테크놀로지의 융합)</li>
<li>프롬프트의 <strong>4가지 핵심 요소:</strong>
<ol type="1">
<li>지시 (Instructions): 모델이 수행할 특정 작업 또는 지시</li>
<li>문맥 (Context): 모델이 수행할 특정 작업에 대한 참고 지식이나 배경</li>
<li>입력 데이터 (Input Data): 응답에 참고할 입력 값</li>
<li>출력 지시문 (Output Indicator): 응답 형식이나 결과 포맷</li>
</ol>
<ul>
<li>예시:</li>
</ul>
<pre><code>지시(Prompt): Sentiment Analysis를 해야 해.
문맥(Context): 아래 텍스트를 긍정, 중립, 부정 중에서 구분해줘.
입력 데이터(Input Text): 그 음식점 마라탕 맛이 그저 그랬어.

{sentiment}: {부정}</code></pre></li>
<li>프롬프트 타입 (Type)
<ul>
<li>Type A (기본): 지시문 + 출력문
<ul>
<li>예시: 구름 색깔은?</li>
</ul></li>
<li>Type B (Type A + 맥락): 지시문 + <strong>맥락</strong> + 출력문
<ul>
<li>예시: <strong>해가 질때</strong> 구름 색깔은?</li>
</ul></li>
<li>Type C (Type B + 예시): 지시문 + 맥락 + <strong>예시</strong> + 출력문
<ul>
<li>예시:</li>
</ul>
<pre><code>해가 질 때 구름 색깔과 종류는? 예시 구조처럼 대답해. 
#예시
1. 권운: 하얀 섬유 모양의 구름으로 얼음 결정으로 되어 있다. 
2. 고적운: 고적운은 중층운으로 양떼구름, 높쌘구름이라고도 한다</code></pre></li>
<li>Type D (Type C + 입력값): 지시문 + <strong>맥락 + 예시 + 입력값</strong> + 출력문
<ul>
<li>예시:</li>
</ul>
<pre><code>구름의 종류를 설명해줘.
아래 [[입력값]]을 활용해서, 내용을 보충해줘.
한 문단으로 완성해.
[[입력값]]
여러가지 다양한 모양의 구름을 최초로 나눈 사람은 영국의 기상학자 루크하우드 입니다.
그는 1803년, 구름을 네가지 이름으로 구분했습니다.
층운: 넓고, 얇게 펼쳐진 구름
권운: 가느다랗고 새털처럼 생긴 구름
적운: 쌓아 올려진 모양의 구름
난운: 회색빛의 먹구름
지금은 이보다 더 다양한 10개의 기본형으로 나눕니다.</code></pre></li>
</ul>
<pre><code># Type A 예시 출력물
구름 자체는 색깔을 가지고 있지 않습니다. 구름은 작은 물방울이나
얼음 결정으로 이루어져 있으며, 보통 하얗게 보이는데, 이는 태양
빛이 구름의 물방울에 의해 분산되어 그렇게 보이기 때문입니다.
그러나, 때때로 구름은 환경적인 요인에 따라 다른 색을 띠기도
합니다.

# Type B 예시 출력물
해가 질 때 구름의 색깔은 주로 빨강, 주황, 분홍색과 같은 따뜻한
톤으로 변합니다. 이 현상은 􃑄레일리 산란􃑄이라고 불리는 광학적
원리 때문입니다. 낮 동안, 태양 빛은 대기를 통과하면서 파란색
빛을 산란시키며, 이것이 하늘이 파랗게 보이는 이유입니다. 그러나
해가 지면서 태양 빛이 지평선에서 더 긴 경로를 거치게 되면서,
파란색과 녹색 빛은 더 많이 산란되고, 빨강과 주황색 빛이
우세해집니다. 이때 구름이 이 빛을 반사하면서 빨강, 주황, 분홍색
등으로 아름답게 물드는 것을 볼 수 있습니다.

# Type C 예시 출력물
해가 지는 시간에 나타나는 구름의 색깔과 종류를 설명해 드리겠습니다.
1) 고층운: 해가 지는 시간에 하늘에서 빛나는 얇고, 희미한 구름으로, 얼음 결정으로
이루어져 있다. 일반적으로 높은 고도􃏙약 5􃎿13km􃏚에 위치하며, 구름이 얇아서 태양의
빛을 통과시켜 아름다운 색감을 만들어낸다.
2) 적란운: 해가 질 무렵에 종종 보이는 두꺼운 구름으로, 하늘 전체를 덮을 수 있다. 대기
중 낮은 고도􃏙약 2km 이하􃏚에서 형성되며, 태양의 낮은 각도로 인해 붉은색 또는
주황색으로 물드는 경우가 많다.

이러한 구름은 일몰 시 특유의 아름다운 하늘색을 만들어내며, 대기 상태와 날씨 변화에
따라 다양한 형태와 색상을 보여줍니다.

# Type D 예시 출력물
구름의 종류를 최초로 나눈 사람은 영국의 기상학자 루크 하워드로, 그는 1803년에 구름을
네 가지 이름으로 구분했습니다: 층운, 권운, 적운, 난운입니다. 층운은 넓고 얇게 펼쳐진
구름으로, 하늘을 덮는 특징이 있습니다. 권운은 가느다랗고 새털처럼 생긴 구름으로,
고도가 높은 곳에서 형성됩니다. 적운은 쌓아 올려진 모양의 구름으로, 대개 맑은 날씨를
나타냅니다. 난운은 회색빛의 먹구름으로, 비나 눈을 예고하는 경우가 많습니다. 현대에는
이러한 기본 분류에서 더 나아가 10개의 기본형으로 구름을 나누어 분류합니다. 이러한
름의 분류는 기상학적 연구와 일기 예보에 중요한 기초 자료가 됩니다.</code></pre></li>
</ul>
</section>
<section id="예시-출력물-분석" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="예시-출력물-분석"><span class="header-section-number">2.3</span> 예시 출력물 분석</h3>
<section id="type-a-기본-지시-구름-색깔은-가장-기본적인-질문" class="level4" data-number="2.3.1">
<h4 data-number="2.3.1" class="anchored" data-anchor-id="type-a-기본-지시-구름-색깔은-가장-기본적인-질문"><span class="header-section-number">2.3.1</span> Type A (기본): <code>지시: 구름 색깔은?</code> (가장 기본적인 질문)</h4>
<ul>
<li>응답의 일반성: 질문에 대한 가장 <strong>일반적이고 보편적인 사실</strong>을 설명. “구름 자체는 색깔을 가지고 있지 않다”는 기본 전제를 알려줌.</li>
<li>기본 지식 활용: 모델이 학습한 일반적인 지식에서 ’구름의 색깔이 하얗게 보이는 이유’와 ’때때로 다른 색을 띠기도 한다’는 기본적인 설명을 제공.</li>
<li>정보량: 적절하지만 깊이가 얕고, 추가적인 배경 지식 없이 질문 자체에만 초점을 맞춘 답변</li>
<li>형식: 특별한 제약이 없으므로 자유로운 서술형 문단 형식으로 답변.</li>
</ul>
</section>
<section id="type-b-type-a-맥락-지시-구름-색깔은-맥락-해가-질-때-특정-상황을-제시" class="level4" data-number="2.3.2">
<h4 data-number="2.3.2" class="anchored" data-anchor-id="type-b-type-a-맥락-지시-구름-색깔은-맥락-해가-질-때-특정-상황을-제시"><span class="header-section-number">2.3.2</span> Type B (Type A + 맥락): <code>지시: 구름 색깔은?</code>, <code>맥락: 해가 질 때</code> (특정 상황을 제시)</h4>
<ul>
<li>응답의 구체성 향상: <code>해가 질 때</code>라는 <strong>특정 문맥에 초점을 맞춰 답변이 훨씬 구체적</strong>으로 변함. 단순한 색깔 언급을 넘어 빨강, 주황, 분홍색 등 따뜻한 톤으로 변하는 현상을 설명.</li>
<li>심화된 설명: 일반적인 상식 수준을 넘어 <code>레일리 산란</code>이라는 <strong>과학적인 원리</strong>까지 함께 제시하며 배경 설명을 풍부하게 제공.</li>
<li>정보량: Type A보다 정보량이 많고, 주어진 맥락과 관련된 전문적인 지식까지 포함되어 깊이가 더해져.</li>
<li>형식: 여전히 자유로운 서술형 문단이지만, 내용 구성이 맥락에 맞춰 보다 논리적이고 풍부.</li>
</ul>
</section>
<section id="type-c-type-b-예시-지시-해가-질-때-구름-색깔과-종류는-맥락-해가-질-때-예시-1.-권운-2.-고적운-특정-상황과-답변-형식-제시" class="level4" data-number="2.3.3">
<h4 data-number="2.3.3" class="anchored" data-anchor-id="type-c-type-b-예시-지시-해가-질-때-구름-색깔과-종류는-맥락-해가-질-때-예시-1.-권운-2.-고적운-특정-상황과-답변-형식-제시"><span class="header-section-number">2.3.3</span> Type C (Type B + 예시): <code>지시: 해가 질 때 구름 색깔과 종류는?</code>, <code>맥락: 해가 질 때</code>, <code>예시: 1. 권운 2. 고적운</code> (특정 상황과 답변 형식 제시)</h4>
<ul>
<li>응답의 형식 제어: <strong>프롬프트 내에 포함된 <code>예시 구조처럼</code>이라는 지시와 함께 제시된 <code>예시</code> 포맷</strong>을 준수. numbered list, 구름 이름, 설명의 구조를 완벽하게 재현.</li>
<li>정보의 구체성 유지: Type B에서와 같이 <code>해가 지는 시간</code>이라는 문맥을 유지하며, 해당 시간대에 관찰될 수 있는 <code>고층운</code>과 <code>적란운</code> 같은 <strong>구체적인 구름 종류와 그 특징</strong>을 설명</li>
<li>정보 활용의 유연성: 프롬프트에 제공된 예시 구름 종류(권운, 고적운)를 직접적으로 사용하지 않고도, ’해가 질 때’라는 맥락에 더 적합한 다른 구름 종류를 모델이 스스로 선택하여 예시와 같은 형식으로 설명. <strong>형식을 이해하고 적용</strong>하는 능력 존재</li>
<li>정보량: Type B와 유사하거나 약간 더 많은 정보량을 제공하지만, 깔끔하게 정리된 형식 덕분에 가독성이 높음</li>
</ul>
</section>
</section>
<section id="type-d-type-a-입력값-지시-구름의-종류를-설명.-맥락-입력값을-활용해서-내용을-보충.-예시-권운-층운-등-입력-데이터-루크-하워드의-구름-분류와-설명" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="type-d-type-a-입력값-지시-구름의-종류를-설명.-맥락-입력값을-활용해서-내용을-보충.-예시-권운-층운-등-입력-데이터-루크-하워드의-구름-분류와-설명"><span class="header-section-number">2.4</span> Type D (Type A + 입력값): <code>지시: 구름의 종류를 설명.</code>, <code>맥락: [[입력값]]을 활용해서 내용을 보충.</code>, <code>예시: 권운, 층운 등</code>, <code>입력 데이터: 루크 하워드의 구름 분류와 설명</code></h3>
<ul>
<li>외부 데이터의 완벽한 활용: 제공된 <code>[[입력값]]</code>에 있는 <strong>모든 정보를 그대로 반영하고 활용</strong>하여 답변을 구성. “루크 하워드”, “1803년”, “네 가지 이름(층운, 권운, 적운, 난운)과 각각의 설명”, “지금은 10개의 기본형으로 나눈다”는 내용이 모두 포함</li>
<li>명확한 출력 형식: <code>한 문단으로 완성해</code>라는 지시에 따라 <strong>하나의 긴 문단</strong>으로 깔끔하게 정리</li>
<li>자기 생성 능력과 외부 지식 융합: 모델이 <code>[[입력값]]</code>의 정보를 바탕으로 답변을 구성했지만, 마지막 문장(“이러한 구름의 분류는 기상학적 연구와 일기 예보에 중요한 기초 자료가 됩니다.”)처럼 <strong>모델이 스스로 가진 배경 지식을 추가하여 답변을 더욱 풍부</strong>. 문맥에 맞춰 의미를 부여하고 통합하는 능력.</li>
<li>응답의 정밀도와 신뢰성: 외부 데이터를 명확히 제공함으로써, 모델이 <strong>‘어떤 내용을 기반으로 답변했는지’</strong> 명확하게 알 수 있으며, 따라서 정보의 정확도나 신뢰도 향상</li>
</ul>
<ol type="1">
<li><strong>지시 (Instructions):</strong> 모델이 <strong>‘무엇을 할지’</strong>를 결정.</li>
<li><strong>문맥 (Context):</strong> 모델이 <strong>‘어떤 상황에서 답변할지’</strong>를 설정하여 답변의 구체성과 깊이를 더함.</li>
<li><strong>입력 데이터 (Input Data):</strong> 모델이 <strong>‘어떤 정보를 기반으로 답변할지’</strong>를 제시하여 답변의 사실적 정확도와 풍부함을 보장.</li>
<li><strong>출력 지시문 (Output Indicator):</strong> 모델이 <strong>‘어떤 형식으로 답변할지’</strong>를 지시하여 응답의 가독성과 활용성을 높임.</li>
</ol>
<p>이러한 요소들을 잘 조합하여 프롬프트를 작성할수록, 우리는 모델로부터 원하는 목적에 훨씬 더 부합하고 고품질의 응답을 얻을 수 있다.</p>


</section>
</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("kk3225\.netlify\.app");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>