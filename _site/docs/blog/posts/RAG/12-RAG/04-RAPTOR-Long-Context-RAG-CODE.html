<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Kwangmin Kim - RAPTOR: Recursive Abstractive Processing for Tree-Organized Retrieval</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - RAPTOR: Recursive Abstractive Processing for Tree-Organized Retrieval">
<meta property="og:description" content="blog">
<meta property="og:site_name" content="Kwangmin Kim">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#raptor-recursive-abstractive-processing-for-tree-organized-retrieval" id="toc-raptor-recursive-abstractive-processing-for-tree-organized-retrieval" class="nav-link active" data-scroll-target="#raptor-recursive-abstractive-processing-for-tree-organized-retrieval">RAPTOR: Recursive Abstractive Processing for Tree-Organized Retrieval</a>
  <ul class="collapse">
  <li><a href="#환경-설정" id="toc-환경-설정" class="nav-link" data-scroll-target="#환경-설정">환경 설정</a></li>
  <li><a href="#데이터-전처리" id="toc-데이터-전처리" class="nav-link" data-scroll-target="#데이터-전처리">데이터 전처리</a></li>
  <li><a href="#모델-설정" id="toc-모델-설정" class="nav-link" data-scroll-target="#모델-설정">모델 설정</a></li>
  <li><a href="#트리-구축" id="toc-트리-구축" class="nav-link" data-scroll-target="#트리-구축">트리 구축</a>
  <ul class="collapse">
  <li><a href="#차원-축소" id="toc-차원-축소" class="nav-link" data-scroll-target="#차원-축소">차원 축소</a></li>
  <li><a href="#최적의-클러스터-수-계산" id="toc-최적의-클러스터-수-계산" class="nav-link" data-scroll-target="#최적의-클러스터-수-계산">최적의 클러스터 수 계산</a></li>
  <li><a href="#클러스터링-수행" id="toc-클러스터링-수행" class="nav-link" data-scroll-target="#클러스터링-수행">클러스터링 수행</a></li>
  </ul></li>
  <li><a href="#rag-체인-정의" id="toc-rag-체인-정의" class="nav-link" data-scroll-target="#rag-체인-정의">RAG 체인 정의</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">RAPTOR: Recursive Abstractive Processing for Tree-Organized Retrieval</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="raptor-recursive-abstractive-processing-for-tree-organized-retrieval" class="level1">
<h1>RAPTOR: Recursive Abstractive Processing for Tree-Organized Retrieval</h1>
<p><a href="https://arxiv.org/pdf/2401.18059.pdf">RAPTOR</a> 논문은 문서의 색인 생성 및 검색에 대한 흥미로운 접근 방식을 제시합니다.</p>
<p><a href="https://teddylee777.notion.site/RAPTOR-e835d306fc664dc2ad76191dee1cd859?pvs=4">테디노트 논문 요약글(노션)</a></p>
<ul>
<li><code>leafs</code> 는 가장 low-level 의 시작 문서 집합입니다. 이 문서들은 임베딩되어 클러스터링됩니다.</li>
<li>그런 다음 클러스터는 유사한 문서들 간의 정보를 더 높은 수준(더 추상적인)으로 요약합니다.</li>
</ul>
<p>이 과정은 재귀적으로 수행되어, 원본 문서(<code>leafs</code>)에서 더 추상적인 요약으로 이어지는 “트리”를 형성합니다.</p>
<p><code>leafs</code>는 다음과 같은 문서들로 구성될 수 있습니다.</p>
<ul>
<li>단일 문서에서의 텍스트 청크(논문에서 보여준 것처럼)</li>
<li>전체 문서(아래에서 보여주는 것처럼)</li>
</ul>
<p>이번 튜토리얼에서는 LangChain 의 LCEL 문서에 이를 적용해 보도록 하겠습니다. 소스코드 기반의 RAG 시스템을 구축할 때 RAPTOR 방법론을 적용하는 방법에 대해서 다룹니다.</p>
<section id="환경-설정" class="level2">
<h2 class="anchored" data-anchor-id="환경-설정">환경 설정</h2>
<div id="45420489" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># API 키를 환경변수로 관리하기 위한 설정 파일</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dotenv <span class="im">import</span> load_dotenv</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># API 키 정보 로드</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>load_dotenv()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>True</code></pre>
</div>
</div>
<div id="572c2efd" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># LangSmith 추적을 설정합니다. https://smith.langchain.com</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># !pip install -qU langchain-teddynote</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain_teddynote <span class="im">import</span> logging</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 프로젝트 이름을 입력합니다.</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>logging.langsmith(<span class="st">"CH12-RAPTOR"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>LangSmith 추적을 시작합니다.
[프로젝트명]
CH12-RAPTOR</code></pre>
</div>
</div>
</section>
<section id="데이터-전처리" class="level2">
<h2 class="anchored" data-anchor-id="데이터-전처리">데이터 전처리</h2>
<p><code>doc</code>은 LCEL 문서의 고유한 웹 페이지입니다. context 는 2,000 토큰 미만에서 10,000 토큰 이상까지 다양합니다.</p>
<p>웹 문서에서 텍스트 데이터를 추출하고, 텍스트의 토큰 수를 계산하여 히스토그램으로 시각화합니다.</p>
<div id="1d3506db" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain_community.document_loaders.recursive_url_loader <span class="im">import</span> RecursiveUrlLoader</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> bs4 <span class="im">import</span> BeautifulSoup <span class="im">as</span> Soup</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tiktoken</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 토큰 수 계산</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> num_tokens_from_string(string: <span class="bu">str</span>, encoding_name: <span class="bu">str</span>):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    encoding <span class="op">=</span> tiktoken.get_encoding(encoding_name)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    num_tokens <span class="op">=</span> <span class="bu">len</span>(encoding.encode(string))</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> num_tokens</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co"># LCEL 문서 로드</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://python.langchain.com/docs/concepts/lcel/"</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>loader <span class="op">=</span> RecursiveUrlLoader(</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    url<span class="op">=</span>url, max_depth<span class="op">=</span><span class="dv">20</span>, extractor<span class="op">=</span><span class="kw">lambda</span> x: Soup(x, <span class="st">"html.parser"</span>).text</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>docs <span class="op">=</span> loader.load()</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="co"># PydanticOutputParser를 사용한 LCEL 문서 로드 (기본 LCEL 문서 외부)</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.pydantic.PydanticOutputParser.html"</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>loader <span class="op">=</span> RecursiveUrlLoader(</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    url<span class="op">=</span>url, max_depth<span class="op">=</span><span class="dv">1</span>, extractor<span class="op">=</span><span class="kw">lambda</span> x: Soup(x, <span class="st">"html.parser"</span>).text</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>docs_pydantic <span class="op">=</span> loader.load()</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Self Query를 사용한 LCEL 문서 로드 (기본 LCEL 문서 외부)</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://python.langchain.com/docs/how_to/self_query/"</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>loader <span class="op">=</span> RecursiveUrlLoader(</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    url<span class="op">=</span>url, max_depth<span class="op">=</span><span class="dv">1</span>, extractor<span class="op">=</span><span class="kw">lambda</span> x: Soup(x, <span class="st">"html.parser"</span>).text</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>docs_sq <span class="op">=</span> loader.load()</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="co"># 문서 텍스트</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>docs.extend([<span class="op">*</span>docs_pydantic, <span class="op">*</span>docs_sq])</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>docs_texts <span class="op">=</span> [d.page_content <span class="cf">for</span> d <span class="kw">in</span> docs]</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a><span class="co"># 각 문서에 대한 토큰 수 계산</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>counts <span class="op">=</span> [num_tokens_from_string(d, <span class="st">"cl100k_base"</span>) <span class="cf">for</span> d <span class="kw">in</span> docs_texts]</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a><span class="co"># 토큰 수의 히스토그램을 그립니다.</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>plt.hist(counts, bins<span class="op">=</span><span class="dv">30</span>, color<span class="op">=</span><span class="st">"blue"</span>, edgecolor<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Token Count Distribution"</span>)</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Token Count"</span>)</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Frequency"</span>)</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>plt.grid(axis<span class="op">=</span><span class="st">"y"</span>, alpha<span class="op">=</span><span class="fl">0.75</span>)</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a><span class="co"># 히스토그램을 표시합니다.</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="04-RAPTOR-Long-Context-RAG-CODE_files/figure-html/cell-4-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>문서 텍스트를 정렬합니다. 이때 메타데이터의 <code>source</code> 를 기준으로 정렬한 뒤, 모든 문서를 연결합니다.</p>
<div id="ff0a783a" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 문서를 출처 메타데이터 기준으로 정렬합니다.</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>d_sorted <span class="op">=</span> <span class="bu">sorted</span>(docs, key<span class="op">=</span><span class="kw">lambda</span> x: x.metadata[<span class="st">"source"</span>])</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>d_reversed <span class="op">=</span> <span class="bu">list</span>(<span class="bu">reversed</span>(d_sorted))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 역순으로 배열된 문서의 내용을 연결합니다.</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>concatenated_content <span class="op">=</span> <span class="st">"</span><span class="ch">\n\n\n</span><span class="st"> --- </span><span class="ch">\n\n\n</span><span class="st">"</span>.join(</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    [doc.page_content <span class="cf">for</span> doc <span class="kw">in</span> d_reversed]</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">"전체 토큰 수: </span><span class="sc">%s</span><span class="st">"</span>  <span class="co"># 모든 문맥에서의 토큰 수를 출력합니다.</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span> num_tokens_from_string(concatenated_content, <span class="st">"cl100k_base"</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>전체 토큰 수: 15591</code></pre>
</div>
</div>
<p><code>RecursiveCharacterTextSplitter</code>를 사용하여 텍스트를 분할합니다.</p>
<div id="8982e516" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 텍스트 분할을 위한 코드</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain_text_splitters <span class="im">import</span> RecursiveCharacterTextSplitter</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 기준 토큰수</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>chunk_size <span class="op">=</span> <span class="dv">2000</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 텍스트 분할기 초기화</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>text_splitter <span class="op">=</span> RecursiveCharacterTextSplitter.from_tiktoken_encoder(</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    chunk_size<span class="op">=</span>chunk_size, chunk_overlap<span class="op">=</span><span class="dv">0</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 주어진 텍스트를 분할</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>texts_split <span class="op">=</span> text_splitter.split_text(concatenated_content)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>다음으로는 분할된 chunk 들을 임베딩하여 vector store 에 저장합니다.</p>
<div id="b7d18ea6" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain_openai <span class="im">import</span> OpenAIEmbeddings</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.embeddings <span class="im">import</span> CacheBackedEmbeddings</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.storage <span class="im">import</span> LocalFileStore</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co"># cache 저장 경로 지정</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>store <span class="op">=</span> LocalFileStore(<span class="st">"./cache/"</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co"># embeddings 인스턴스를 생성</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>embeddings <span class="op">=</span> OpenAIEmbeddings(model<span class="op">=</span><span class="st">"text-embedding-3-small"</span>, disallowed_special<span class="op">=</span>())</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co"># CacheBackedEmbeddings 인스턴스를 생성</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>cached_embeddings <span class="op">=</span> CacheBackedEmbeddings.from_bytes_store(</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    embeddings, store, namespace<span class="op">=</span>embeddings.model</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="모델-설정" class="level2">
<h2 class="anchored" data-anchor-id="모델-설정">모델 설정</h2>
<div id="a48631ba" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain_teddynote.messages <span class="im">import</span> stream_response</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain_openai <span class="im">import</span> ChatOpenAI</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co"># llm 모델 초기화</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>llm <span class="op">=</span> ChatOpenAI(</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    model<span class="op">=</span><span class="st">"gpt-4.1-mini"</span>,</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    temperature<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="트리-구축" class="level2">
<h2 class="anchored" data-anchor-id="트리-구축">트리 구축</h2>
<p>트리 구축에서의 클러스터링 접근 방식에 대한 주요 개요입니다.</p>
<p><strong>GMM (가우시안 혼합 모델)</strong></p>
<ul>
<li>다양한 클러스터에 걸쳐 데이터 포인트의 분포를 모델링합니다.</li>
<li>모델의 베이지안 정보 기준(BIC)을 평가하여 최적의 클러스터 수를 결정합니다.</li>
</ul>
<p><strong>UMAP (Uniform Manifold Approximation and Projection)</strong></p>
<ul>
<li>클러스터링을 지원합니다.</li>
<li>고차원 데이터의 차원을 축소합니다.</li>
<li>UMAP은 데이터 포인트의 유사성에 기반하여 자연스러운 그룹화를 강조하는 데 도움을 줍니다.</li>
</ul>
<p><strong>지역 및 전역 클러스터링</strong></p>
<ul>
<li>데이터를 저차원으로 차원 축소하여 클러스터링을 수행합니다.</li>
</ul>
<p><strong>임계값 설정</strong></p>
<ul>
<li>GMM의 맥락에서 클러스터 멤버십을 결정하기 위해 적용됩니다.</li>
<li>확률 분포를 기반으로 합니다(데이터 포인트를 ≥ 1 클러스터에 할당).</li>
</ul>
<hr>
<p>GMM 및 임계값 설정에 대한 코드는 아래 두 출처에서 언급된 Sarthi et al의 것입니다.</p>
<p><strong>참조</strong></p>
<ul>
<li><a href="https://github.com/parthsarthi03/raptor/blob/master/raptor/cluster_tree_builder.py">원본 저장소</a></li>
<li><a href="https://github.com/run-llama/llama_index/blob/main/llama-index-packs/llama-index-packs-raptor/llama_index/packs/raptor/clustering.py">소소한 조정</a></li>
</ul>
<section id="차원-축소" class="level3">
<h3 class="anchored" data-anchor-id="차원-축소">차원 축소</h3>
<p><code>global_cluster_embeddings</code></p>
<ul>
<li>입력된 임베딩 벡터를 전역적으로 차원 축소하기 위해 UMAP을 적용합니다. 전역적으로 차원을 축소한 결과물을 얻어 추후 클러스터링에 활용합니다.</li>
</ul>
<p><strong>과정</strong></p>
<ul>
<li>n_neighbors: UMAP에 사용될 이웃(neighbor) 수를 정합니다. 데이터 포인트 하나를 이해할 때 주변 데이터 포인트 개수를 나타냅니다. 입력이 없으면 데이터 개수에 따라 자동으로 계산합니다.</li>
<li>umap.UMAP(…)를 사용하여, 고차원 임베딩을 dim 차원으로 축소합니다.</li>
<li>축소된 벡터들은 전역적(global)인 구조 파악에 도움이 되는 저차원 표현입니다.</li>
</ul>
<hr>
<p><code>local_cluster_embeddings</code></p>
<ul>
<li>선택한 데이터 부분집합에 대해 로컬(국소적) 차원 축소를 수행합니다.</li>
</ul>
<p><strong>과정</strong></p>
<ul>
<li>글로벌 차원 축소와 유사하지만, 로컬 차원 축소는 이미 한 번 전역 클러스터링을 통해 추출한 특정 그룹(글로벌 클러스터) 내 데이터에 대해 다시 UMAP을 적용합니다.</li>
<li>이 과정은 전역적으로 파악된 큰 구조 안에서 더 세밀한 클러스터 구조를 파악하는 데 도움이 됩니다.</li>
</ul>
<div id="2970a692" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Dict, List, Optional, Tuple</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> umap</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain.prompts <span class="im">import</span> ChatPromptTemplate</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain_core.output_parsers <span class="im">import</span> StrOutputParser</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.mixture <span class="im">import</span> GaussianMixture</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>RANDOM_SEED <span class="op">=</span> <span class="dv">42</span>  <span class="co"># 재현성을 위한 고정된 시드 값</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> global_cluster_embeddings(</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    embeddings: np.ndarray,</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    dim: <span class="bu">int</span>,</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    n_neighbors: Optional[<span class="bu">int</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    metric: <span class="bu">str</span> <span class="op">=</span> <span class="st">"cosine"</span>,</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""전역적으로 임베딩 벡터의 차원을 축소하는 함수입니다.</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="co">        embeddings (np.ndarray): 차원을 축소할 임베딩 벡터들</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="co">        dim (int): 축소할 차원의 수</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="co">        n_neighbors (Optional[int], optional): UMAP에서 사용할 이웃의 수. 기본값은 None으로, 이 경우 데이터 크기에 따라 자동 계산됨</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a><span class="co">        metric (str, optional): 거리 계산에 사용할 메트릭. 기본값은 "cosine"</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a><span class="co">        np.ndarray: 차원이 축소된 임베딩 벡터들</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 이웃 수 계산</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n_neighbors <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>        n_neighbors <span class="op">=</span> <span class="bu">int</span>((<span class="bu">len</span>(embeddings) <span class="op">-</span> <span class="dv">1</span>) <span class="op">**</span> <span class="fl">0.5</span>)</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># UMAP 적용</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> umap.UMAP(</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>        n_neighbors<span class="op">=</span>n_neighbors, n_components<span class="op">=</span>dim, metric<span class="op">=</span>metric</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>    ).fit_transform(embeddings)</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> local_cluster_embeddings(</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>    embeddings: np.ndarray, dim: <span class="bu">int</span>, num_neighbors: <span class="bu">int</span> <span class="op">=</span> <span class="dv">10</span>, metric: <span class="bu">str</span> <span class="op">=</span> <span class="st">"cosine"</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""로컬(국소적)하게 임베딩 벡터의 차원을 축소하는 함수입니다.</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a><span class="co">        embeddings (np.ndarray): 차원을 축소할 임베딩 벡터들</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a><span class="co">        dim (int): 축소할 차원의 수</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a><span class="co">        num_neighbors (int, optional): UMAP에서 사용할 이웃의 수. 기본값은 10</span></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a><span class="co">        metric (str, optional): 거리 계산에 사용할 메트릭. 기본값은 "cosine"</span></span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a><span class="co">        np.ndarray: 차원이 축소된 임베딩 벡터들</span></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># UMAP 적용</span></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> umap.UMAP(</span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>        n_neighbors<span class="op">=</span>num_neighbors, n_components<span class="op">=</span>dim, metric<span class="op">=</span>metric</span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>    ).fit_transform(embeddings)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="최적의-클러스터-수-계산" class="level3">
<h3 class="anchored" data-anchor-id="최적의-클러스터-수-계산">최적의 클러스터 수 계산</h3>
<p><code>get_optimal_clusters</code></p>
<ul>
<li>주어진 임베딩 데이터에 대해 가장 적절한 클러스터 수를 BIC 점수를 기반으로 결정합니다.</li>
<li>GMM과 BIC를 활용해 클러스터 개수를 자동으로 결정하므로, 사전에 클러스터 수를 지정할 필요가 없습니다.</li>
</ul>
<p><strong>과정</strong></p>
<ul>
<li>가능한 클러스터 수(1 ~ max_clusters 사이)를 순회하며 각 클러스터 개수로 GMM을 학습합니다.</li>
<li>각 GMM에 대해 BIC 점수를 계산한 뒤 리스트에 저장합니다.</li>
<li>BIC 점수가 가장 낮은(가장 좋은 성능을 보이는) 클러스터 개수를 선택하여 반환합니다.</li>
</ul>
<div id="ade041a4" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_optimal_clusters(</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    embeddings: np.ndarray, max_clusters: <span class="bu">int</span> <span class="op">=</span> <span class="dv">50</span>, random_state: <span class="bu">int</span> <span class="op">=</span> RANDOM_SEED</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""BIC 점수를 기반으로 최적의 클러스터 수를 찾는 함수입니다.</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">        embeddings (np.ndarray): 클러스터링할 임베딩 벡터들</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">        max_clusters (int, optional): 탐색할 최대 클러스터 수. 기본값은 50</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">        random_state (int, optional): 난수 생성을 위한 시드값. 기본값은 RANDOM_SEED</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="co">        int: BIC 점수가 가장 낮은(최적의) 클러스터 수</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 최대 클러스터 수와 임베딩의 길이 중 작은 값을 최대 클러스터 수로 설정</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    max_clusters <span class="op">=</span> <span class="bu">min</span>(max_clusters, <span class="bu">len</span>(embeddings))</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1부터 최대 클러스터 수까지의 범위를 생성</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    n_clusters <span class="op">=</span> np.arange(<span class="dv">1</span>, max_clusters)</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># BIC 점수를 저장할 리스트</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    bics <span class="op">=</span> []</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> n_clusters:</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        gm <span class="op">=</span> GaussianMixture(n_components<span class="op">=</span>n, random_state<span class="op">=</span>random_state)</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>        gm.fit(embeddings)</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 학습된 모델의 BIC 점수를 리스트에 추가</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>        bics.append(gm.bic(embeddings))</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># BIC 점수가 가장 낮은 클러스터 수를 반환</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n_clusters[np.argmin(bics)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="클러스터링-수행" class="level3">
<h3 class="anchored" data-anchor-id="클러스터링-수행">클러스터링 수행</h3>
<p><code>GMM_cluster</code></p>
<ul>
<li>GMM을 이용해 주어진 임베딩에 대해 클러스터를 할당합니다.</li>
</ul>
<p><strong>과정</strong></p>
<ul>
<li><code>get_optimal_clusters</code> 를 통해 최적의 클러스터 수를 찾습니다.</li>
<li><code>GaussianMixture</code> 모델을 해당 클러스터 수로 학습합니다.</li>
<li>각 데이터 포인트가 각 클러스터에 속할 확률(predict_proba)을 구합니다.</li>
<li>주어진 threshold를 바탕으로, 확률이 임계값을 초과하는 클러스터만 레이블로 할당합니다.</li>
</ul>
<div id="f86a6d1d" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> GMM_cluster(embeddings: np.ndarray, threshold: <span class="bu">float</span>, random_state: <span class="bu">int</span> <span class="op">=</span> <span class="dv">0</span>):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 최적의 클러스터 수 산정</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    n_clusters <span class="op">=</span> get_optimal_clusters(embeddings)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 가우시안 혼합 모델을 초기화</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    gm <span class="op">=</span> GaussianMixture(n_components<span class="op">=</span>n_clusters, random_state<span class="op">=</span>random_state)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    gm.fit(embeddings)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 임베딩이 각 클러스터에 속할 확률을 예측</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    probs <span class="op">=</span> gm.predict_proba(embeddings)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 임계값을 초과하는 확률을 가진 클러스터를 레이블로 선택</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> [np.where(prob <span class="op">&gt;</span> threshold)[<span class="dv">0</span>] <span class="cf">for</span> prob <span class="kw">in</span> probs]</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 레이블과 클러스터 수를 반환</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> labels, n_clusters</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>perform_clustering</code></p>
<ul>
<li>전역 차원 축소, 전역 클러스터링, 이후 로컬 차원 축소 및 로컬 클러스터링까지 전체 클러스터링 파이프라인을 수행하는 핵심 함수입니다.</li>
<li>이전의 과정을 하나의 파이프라인으로 만들어 종합하는 역할을 수행합니다.</li>
</ul>
<p><strong>과정</strong></p>
<ul>
<li>입력된 embeddings가 충분한지 확인(적은 경우 단순 할당).</li>
<li>전역 차원 축소: <code>global_cluster_embeddings</code> 로 전체 임베딩에 대해 UMAP 적용.</li>
<li>전역 클러스터링: 전역 차원 축소 결과에 대해 <code>GMM_cluster</code> 를 사용하여 전역 클러스터 형성.</li>
<li>각 전역 클러스터에 속하는 데이터만 추출 -&gt; 해당 집합에 대해 로컬 차원 축소(<code>local_cluster_embeddings</code>) 수행.</li>
<li>로컬 차원 축소 결과에 대해 다시 <code>GMM_cluster</code> 로 로컬 클러스터링 수행.</li>
<li>최종적으로, 각 데이터 포인트에 대해서 전역 및 로컬 클러스터 레이블을 함께 반환합니다.</li>
</ul>
<div id="32e97d75" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> perform_clustering(</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    embeddings: np.ndarray,</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    dim: <span class="bu">int</span>,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    threshold: <span class="bu">float</span>,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> List[np.ndarray]:</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co">    임베딩에 대해 계층적 클러스터링을 수행하는 함수입니다.</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">    전역 차원 축소와 클러스터링을 먼저 수행한 후, 각 전역 클러스터 내에서</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co">    로컬 차원 축소와 클러스터링을 수행합니다.</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co">        embeddings (np.ndarray): 클러스터링할 임베딩 벡터들</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="co">        dim (int): 차원 축소 시 목표 차원 수</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="co">        threshold (float): GMM 클러스터링에서 사용할 확률 임계값</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="co">        List[np.ndarray]: 각 데이터 포인트에 대한 로컬 클러스터 레이블 리스트.</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="co">                         각 레이블은 해당 데이터 포인트가 속한 로컬 클러스터의 인덱스를 담은 numpy 배열입니다.</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(embeddings) <span class="op">&lt;=</span> dim <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 데이터가 충분하지 않을 때 클러스터링을 피합니다.</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [np.array([<span class="dv">0</span>]) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(embeddings))]</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 글로벌 차원 축소</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    reduced_embeddings_global <span class="op">=</span> global_cluster_embeddings(embeddings, dim)</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 글로벌 클러스터링</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>    global_clusters, n_global_clusters <span class="op">=</span> GMM_cluster(</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>        reduced_embeddings_global, threshold</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 로컬 클러스터링을 위한 초기화</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>    all_local_clusters <span class="op">=</span> [np.array([]) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(embeddings))]</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>    total_clusters <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 각 글로벌 클러스터를 순회하며 로컬 클러스터링 수행</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_global_clusters):</span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 현재 글로벌 클러스터에 속하는 임베딩 추출</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>        global_cluster_embeddings_ <span class="op">=</span> embeddings[</span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>            np.array([i <span class="kw">in</span> gc <span class="cf">for</span> gc <span class="kw">in</span> global_clusters])</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(global_cluster_embeddings_) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(global_cluster_embeddings_) <span class="op">&lt;=</span> dim <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 작은 클러스터는 직접 할당으로 처리</span></span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a>            local_clusters <span class="op">=</span> [np.array([<span class="dv">0</span>]) <span class="cf">for</span> _ <span class="kw">in</span> global_cluster_embeddings_]</span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a>            n_local_clusters <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 로컬 차원 축소 및 클러스터링</span></span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a>            reduced_embeddings_local <span class="op">=</span> local_cluster_embeddings(</span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a>                global_cluster_embeddings_, dim</span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a>            local_clusters, n_local_clusters <span class="op">=</span> GMM_cluster(</span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a>                reduced_embeddings_local, threshold</span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-60"><a href="#cb14-60" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 로컬 클러스터 ID 할당, 이미 처리된 총 클러스터 수를 조정</span></span>
<span id="cb14-61"><a href="#cb14-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_local_clusters):</span>
<span id="cb14-62"><a href="#cb14-62" aria-hidden="true" tabindex="-1"></a>            local_cluster_embeddings_ <span class="op">=</span> global_cluster_embeddings_[</span>
<span id="cb14-63"><a href="#cb14-63" aria-hidden="true" tabindex="-1"></a>                np.array([j <span class="kw">in</span> lc <span class="cf">for</span> lc <span class="kw">in</span> local_clusters])</span>
<span id="cb14-64"><a href="#cb14-64" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb14-65"><a href="#cb14-65" aria-hidden="true" tabindex="-1"></a>            indices <span class="op">=</span> np.where(</span>
<span id="cb14-66"><a href="#cb14-66" aria-hidden="true" tabindex="-1"></a>                (embeddings <span class="op">==</span> local_cluster_embeddings_[:, <span class="va">None</span>]).<span class="bu">all</span>(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb14-67"><a href="#cb14-67" aria-hidden="true" tabindex="-1"></a>            )[<span class="dv">1</span>]</span>
<span id="cb14-68"><a href="#cb14-68" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> idx <span class="kw">in</span> indices:</span>
<span id="cb14-69"><a href="#cb14-69" aria-hidden="true" tabindex="-1"></a>                all_local_clusters[idx] <span class="op">=</span> np.append(</span>
<span id="cb14-70"><a href="#cb14-70" aria-hidden="true" tabindex="-1"></a>                    all_local_clusters[idx], j <span class="op">+</span> total_clusters</span>
<span id="cb14-71"><a href="#cb14-71" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb14-72"><a href="#cb14-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-73"><a href="#cb14-73" aria-hidden="true" tabindex="-1"></a>        total_clusters <span class="op">+=</span> n_local_clusters</span>
<span id="cb14-74"><a href="#cb14-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-75"><a href="#cb14-75" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> all_local_clusters</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>주어진 텍스트 리스트를 임베딩 모델을 이용해 벡터로 변환합니다.</p>
<div id="175963c6" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> embed(texts):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">    주어진 텍스트 리스트를 임베딩 벡터로 변환합니다.</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">        texts (List[str]): 임베딩할 텍스트 리스트</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="co">        np.ndarray: 텍스트의 임베딩 벡터를 포함하는 numpy 배열</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co">                   shape은 (텍스트 개수, 임베딩 차원)입니다.</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    text_embeddings <span class="op">=</span> embeddings.embed_documents(texts)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 임베딩을 numpy 배열로 변환</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    text_embeddings_np <span class="op">=</span> np.array(text_embeddings)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> text_embeddings_np</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>embed_cluster_texts</code></p>
<ul>
<li>텍스트 리스트를 임베딩하고, 위에서 정의한 클러스터링 절차를 수행한 뒤 결과를 데이터프레임 형태로 반환합니다</li>
</ul>
<p><strong>과정</strong></p>
<ul>
<li>embed 함수를 통해 텍스트를 임베딩합니다.</li>
<li>perform_clustering를 호출하여 클러스터 라벨을 얻습니다.</li>
<li>원본 텍스트, 임베딩, 클러스터 정보를 하나의 DataFrame에 통합하여 반환합니다.</li>
</ul>
<div id="351f42b6" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> embed_cluster_texts(texts):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 임베딩 생성</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    text_embeddings_np <span class="op">=</span> embed(texts)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 클러스터링 수행</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    cluster_labels <span class="op">=</span> perform_clustering(text_embeddings_np, <span class="dv">10</span>, <span class="fl">0.1</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 결과를 저장할 DataFrame 초기화</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame()</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 원본 텍스트 저장</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"text"</span>] <span class="op">=</span> texts</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># DataFrame에 리스트로 임베딩 저장</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"embd"</span>] <span class="op">=</span> <span class="bu">list</span>(text_embeddings_np)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 클러스터 라벨 저장</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"cluster"</span>] <span class="op">=</span> cluster_labels</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>fmt_txt</code> 함수는 <code>pandas</code>의 <code>DataFrame</code>에서 텍스트 문서를 단일 문자열로 포맷팅합니다.</p>
<div id="903883eb" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fmt_txt(df: pd.DataFrame) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">    주어진 DataFrame에서 텍스트 문서를 단일 문자열로 포맷팅하는 함수입니다.</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co">        df (pd.DataFrame): 포맷팅할 텍스트 문서를 포함한 DataFrame</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="co">        str: 텍스트 문서들을 특정 구분자로 결합한 단일 문자열</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    unique_txt <span class="op">=</span> df[<span class="st">"text"</span>].tolist()</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">"--- --- </span><span class="ch">\n</span><span class="st"> --- --- "</span>.join(unique_txt)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>embed_cluster_summarize_texts</code></p>
<ul>
<li>텍스트 리스트에 대해 임베딩 → 클러스터링 → 요약 까지 전체 프로세스를 수행합니다.</li>
</ul>
<p><strong>과정</strong></p>
<ul>
<li><p>임베딩 &amp; 클러스터링: <code>embed_cluster_texts</code> 함수를 이용해 입력된 텍스트를 임베딩하고 클러스터링한 결과를 <code>df_clusters</code> 로 얻습니다. 이 <code>df_clusters</code> 는 각 문서와 그 문서를 할당받은 (하나 이상일 수 있는) 클러스터를 가지고 있습니다.</p></li>
<li><p>클러스터 할당 확장: 어떤 문서가 여러 클러스터에 속할 수 있으므로, 이를 행 단위로 ‘문서-클러스터’ 페어로 확장한 <code>expanded_df</code> 를 만듭니다. 이렇게 하면 이후 처리(특히 요약 단계)에서 각 클러스터별로 문서를 쉽게 그룹화할 수 있습니다.</p></li>
<li><p>LLM(대형 언어 모델)을 이용한 요약: 각 클러스터에 속한 문서들의 텍스트를 하나의 문자열로 합친 뒤(<code>fmt_txt</code> 사용), 프롬프트 템플릿을 통해 LLM에 전달합니다. LLM은 해당 클러스터에 대한 요약 문장을 생성합니다.</p></li>
<li><p>요약 결과 정리: 클러스터별 요약 결과를 <code>df_summary</code> DataFrame에 저장합니다. 여기에는 summaries(요약문), level(입력 파라미터로 받은 처리 수준), cluster(클러스터 식별자)가 포함됩니다.</p></li>
</ul>
<div id="c242240e" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> embed_cluster_summarize_texts(</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    texts: List[<span class="bu">str</span>], level: <span class="bu">int</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Tuple[pd.DataFrame, pd.DataFrame]:</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">    텍스트 목록에 대해 임베딩, 클러스터링 및 요약을 수행합니다. 이 함수는 먼저 텍스트에 대한 임베딩을 생성하고,</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co">    유사성을 기반으로 클러스터링을 수행한 다음, 클러스터 할당을 확장하여 처리를 용이하게 하고 각 클러스터 내의 내용을 요약합니다.</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co">    매개변수:</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="co">    - texts: 처리할 텍스트 문서 목록입니다.</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="co">    - level: 처리의 깊이나 세부 사항을 정의할 수 있는 정수 매개변수입니다.</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co">    반환값:</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="co">    - 두 개의 데이터프레임을 포함하는 튜플:</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="co">      1. 첫 번째 데이터프레임(`df_clusters`)은 원본 텍스트, 그들의 임베딩, 그리고 클러스터 할당을 포함합니다.</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="co">      2. 두 번째 데이터프레임(`df_summary`)은 각 클러스터에 대한 요약, 지정된 세부 수준, 그리고 클러스터 식별자를 포함합니다.</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 텍스트를 임베딩하고 클러스터링하여 'text', 'embd', 'cluster' 열이 있는 데이터프레임을 생성합니다.</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    df_clusters <span class="op">=</span> embed_cluster_texts(texts)</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 클러스터를 쉽게 조작하기 위해 데이터프레임을 확장할 준비를 합니다.</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    expanded_list <span class="op">=</span> []</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 데이터프레임 항목을 문서-클러스터 쌍으로 확장하여 처리를 간단하게 합니다.</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> index, row <span class="kw">in</span> df_clusters.iterrows():</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> cluster <span class="kw">in</span> row[<span class="st">"cluster"</span>]:</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>            expanded_list.append(</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>                {<span class="st">"text"</span>: row[<span class="st">"text"</span>], <span class="st">"embd"</span>: row[<span class="st">"embd"</span>], <span class="st">"cluster"</span>: cluster}</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 확장된 목록에서 새 데이터프레임을 생성합니다.</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>    expanded_df <span class="op">=</span> pd.DataFrame(expanded_list)</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 처리를 위해 고유한 클러스터 식별자를 검색합니다.</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>    all_clusters <span class="op">=</span> expanded_df[<span class="st">"cluster"</span>].unique()</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"--Generated </span><span class="sc">{</span><span class="bu">len</span>(all_clusters)<span class="sc">}</span><span class="ss"> clusters--"</span>)</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 요약</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>    template <span class="op">=</span> <span class="st">"""여기 LangChain 표현 언어 문서의 하위 집합이 있습니다.</span></span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a><span class="st">    </span></span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a><span class="st">    LangChain 표현 언어는 LangChain에서 체인을 구성하는 방법을 제공합니다.</span></span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a><span class="st">    </span></span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a><span class="st">    제공된 문서의 자세한 요약을 제공하십시오.</span></span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a><span class="st">    </span></span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a><span class="st">    문서:</span></span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a><span class="st">    </span><span class="sc">{context}</span></span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a><span class="st">    """</span></span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a>    prompt <span class="op">=</span> ChatPromptTemplate.from_template(template)</span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>    chain <span class="op">=</span> prompt <span class="op">|</span> llm <span class="op">|</span> StrOutputParser()</span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 각 클러스터 내의 텍스트를 요약을 위해 포맷팅합니다.</span></span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>    summaries <span class="op">=</span> []</span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> all_clusters:</span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a>        df_cluster <span class="op">=</span> expanded_df[expanded_df[<span class="st">"cluster"</span>] <span class="op">==</span> i]</span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a>        formatted_txt <span class="op">=</span> fmt_txt(df_cluster)</span>
<span id="cb18-57"><a href="#cb18-57" aria-hidden="true" tabindex="-1"></a>        summaries.append(chain.invoke({<span class="st">"context"</span>: formatted_txt}))</span>
<span id="cb18-58"><a href="#cb18-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-59"><a href="#cb18-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 요약, 해당 클러스터 및 레벨을 저장할 데이터프레임을 생성합니다.</span></span>
<span id="cb18-60"><a href="#cb18-60" aria-hidden="true" tabindex="-1"></a>    df_summary <span class="op">=</span> pd.DataFrame(</span>
<span id="cb18-61"><a href="#cb18-61" aria-hidden="true" tabindex="-1"></a>        {</span>
<span id="cb18-62"><a href="#cb18-62" aria-hidden="true" tabindex="-1"></a>            <span class="st">"summaries"</span>: summaries,</span>
<span id="cb18-63"><a href="#cb18-63" aria-hidden="true" tabindex="-1"></a>            <span class="st">"level"</span>: [level] <span class="op">*</span> <span class="bu">len</span>(summaries),</span>
<span id="cb18-64"><a href="#cb18-64" aria-hidden="true" tabindex="-1"></a>            <span class="st">"cluster"</span>: <span class="bu">list</span>(all_clusters),</span>
<span id="cb18-65"><a href="#cb18-65" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb18-66"><a href="#cb18-66" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb18-67"><a href="#cb18-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-68"><a href="#cb18-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df_clusters, df_summary</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>recursive_embed_cluster_summarize</code></p>
<ul>
<li>텍스트 데이터에 대해 여러 “단계(Level)”에 걸쳐 클러스터링과 요약을 반복적으로 수행합니다.</li>
<li>처음에는 원본 텍스트에 대해 클러스터링 및 요약을 수행한 뒤, 각 클러스터 요약을 다음 단계의 입력 텍스트로 삼아 다시 임베딩 → 클러스터링 → 요약을 반복합니다.</li>
</ul>
<div id="c417dece" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> recursive_embed_cluster_summarize(</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    texts: List[<span class="bu">str</span>], level: <span class="bu">int</span> <span class="op">=</span> <span class="dv">1</span>, n_levels: <span class="bu">int</span> <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Dict[<span class="bu">int</span>, Tuple[pd.DataFrame, pd.DataFrame]]:</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 각 레벨에서의 결과를 저장할 사전</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> {}</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 현재 레벨에 대해 임베딩, 클러스터링, 요약 수행</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    df_clusters, df_summary <span class="op">=</span> embed_cluster_summarize_texts(texts, level)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 현재 레벨의 결과 저장</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    results[level] <span class="op">=</span> (df_clusters, df_summary)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 추가 재귀가 가능하고 의미가 있는지 결정</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    unique_clusters <span class="op">=</span> df_summary[<span class="st">"cluster"</span>].nunique()</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 현재 레벨이 최대 레벨보다 낮고, 유니크한 클러스터가 1개 이상인 경우</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> level <span class="op">&lt;</span> n_levels <span class="kw">and</span> unique_clusters <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 다음 레벨의 재귀 입력 텍스트로 요약 사용</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>        new_texts <span class="op">=</span> df_summary[<span class="st">"summaries"</span>].tolist()</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>        next_level_results <span class="op">=</span> recursive_embed_cluster_summarize(</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>            new_texts, level <span class="op">+</span> <span class="dv">1</span>, n_levels</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 다음 레벨의 결과를 현재 결과 사전에 병합</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>        results.update(next_level_results)</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> results</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>전체 문서의 개수를 확인합니다.</p>
<div id="2de5a73a" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 전체 문서의 개수</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(docs_texts)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>3</code></pre>
</div>
</div>
<p>이제 <code>recursive_embed_cluster_summarize</code> 함수를 호출하여 트리 구축을 시작합니다.</p>
<ul>
<li><code>level=1</code> 은 첫 번째 단계의 클러스터링 및 요약부터 시작한다는 의미입니다.</li>
<li><code>n_levels=3</code> 은 최대 세 단계까지(조건이 맞는 한) 클러스터링과 요약을 재귀적으로 반복할 수 있다는 뜻입니다.</li>
<li>결과적으로, 원본 텍스트(leaf_texts)는 먼저 level=1에서 요약되고 클러스터링됩니다. 그 결과로 나온 각 클러스터의 요약이 다음 단계의 입력(level=2)이 되고, 이를 다시 요약하여 클러스터링 한 결과가 level=3 단계의 입력이 될 수 있습니다.</li>
</ul>
<p>이 과정을 통해 점차 더 추상적이고 집약된 요약 정보를 얻을 수 있게 됩니다.</p>
<div id="e429ad5d" class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 트리 구축</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>leaf_texts <span class="op">=</span> docs_texts.copy()</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 재귀적으로 임베딩, 클러스터링 및 요약을 수행하여 결과를 얻음</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> recursive_embed_cluster_summarize(leaf_texts, level<span class="op">=</span><span class="dv">1</span>, n_levels<span class="op">=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>--Generated 1 clusters--</code></pre>
</div>
</div>
<p>다음으로는 vectorstore를 생성하고 로컬에 저장합니다.</p>
<div id="822f26cf" class="cell" data-execution_count="78">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>leaf_texts</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="78">
<pre><code>['\n\n\n\n\nLangChain Expression Language (LCEL) | \uf8ffü¶úÔ∏è\uf8ffüîó LangChain\n\n\n\n\n\n\nSkip to main contentIntegrationsAPI ReferenceMoreContributingPeopleError referenceLangSmithLangGraphLangChain HubLangChain JS/TSv0.3v0.3v0.2v0.1\uf8ffüí¨SearchIntroductionTutorialsBuild a Question Answering application over a Graph DatabaseTutorialsBuild a simple LLM application with chat models and prompt templatesBuild a ChatbotBuild a Retrieval Augmented Generation (RAG) App: Part 2Build an Extraction ChainBuild an AgentTaggingBuild a Retrieval Augmented Generation (RAG) App: Part 1Build a semantic search engineBuild a Question/Answering system over SQL dataSummarize TextHow-to guidesHow-to guidesHow to use tools in a chainHow to use a vectorstore as a retrieverHow to add memory to chatbotsHow to use example selectorsHow to add a semantic layer over graph databaseHow to invoke runnables in parallelHow to stream chat model responsesHow to add default invocation args to a RunnableHow to add retrieval to chatbotsHow to use few shot examples in chat modelsHow to do tool/function callingHow to install LangChain packagesHow to add examples to the prompt for query analysisHow to use few shot examplesHow to run custom functionsHow to use output parsers to parse an LLM response into structured formatHow to handle cases where no queries are generatedHow to route between sub-chainsHow to return structured data from a modelHow to summarize text through parallelizationHow to summarize text through iterative refinementHow to summarize text in a single LLM callHow to use toolkitsHow to add ad-hoc tool calling capability to LLMs and Chat ModelsBuild an Agent with AgentExecutor (Legacy)How to construct knowledge graphsHow to partially format prompt templatesHow to handle multiple queries when doing query analysisHow to use built-in tools and toolkitsHow to pass through arguments from one step to the nextHow to compose prompts togetherHow to handle multiple retrievers when doing query analysisHow to add values to a chain\'s stateHow to construct filters for query analysisHow to configure runtime chain internalsHow deal with high cardinality categoricals when doing query analysisCustom Document LoaderHow to use the MultiQueryRetrieverHow to add scores to retriever resultsCachingHow to use callbacks in async environmentsHow to attach callbacks to a runnableHow to propagate callbacks  constructorHow to dispatch custom callback eventsHow to pass callbacks in at runtimeHow to split by characterHow to cache chat model responsesHow to handle rate limitsHow to init any model in one lineHow to track token usage in ChatModelsHow to add tools to chatbotsHow to split codeHow to do retrieval with contextual compressionHow to convert Runnables to ToolsHow to create custom callback handlersHow to create a custom chat model classCustom EmbeddingsHow to create a custom LLM classCustom RetrieverHow to create toolsHow to debug your LLM appsHow to load CSVsHow to load documents from a directoryHow to load HTMLHow to load JSONHow to load MarkdownHow to load Microsoft Office filesHow to load PDFsHow to load web pagesHow to create a dynamic (self-constructing) chainText embedding modelsHow to combine results from multiple retrieversHow to select examples from a LangSmith datasetHow to select examples by lengthHow to select examples by maximal marginal relevance (MMR)How to select examples by n-gram overlapHow to select examples by similarityHow to use reference examples when doing extractionHow to handle long text when doing extractionHow to use prompting alone (no tool calling) to do extractionHow to add fallbacks to a runnableHow to filter messagesHybrid SearchHow to use the LangChain indexing APIHow to inspect runnablesLangChain Expression Language CheatsheetHow to cache LLM responsesHow to track token usage for LLMsRun models locallyHow to get log probabilitiesHow to reorder retrieved results to mitigate the "lost in the middle" effectHow to split Markdown by HeadersHow to merge consecutive messages of the same typeHow to add message historyHow to migrate from legacy LangChain agents to LangGraphHow to retrieve using multiple vectors per documentHow to pass multimodal data directly to modelsHow to use multimodal promptsHow to create a custom Output ParserHow to use the output-fixing parserHow to parse JSON outputHow to retry when a parsing error occursHow to parse text from message objectsHow to parse XML outputHow to parse YAML outputHow to use the Parent Document RetrieverHow to use LangChain with different Pydantic versionsHow to add chat historyHow to get a RAG application to add citationsHow to do per-user retrievalHow to get your RAG application to return sourcesHow to stream results from your RAG applicationHow to split JSON dataHow to recursively split text by charactersResponse metadataHow to pass runtime secrets to runnablesHow to do "self-querying" retrievalHow to split text based on semantic similarityHow to chain runnablesHow to save and load LangChain objectsHow to split text by tokensHow to split HTMLHow to do question answering over CSVsHow to deal with large databases when doing SQL question-answeringHow to better prompt when doing SQL question-answeringHow to do query validation as part of SQL question-answeringHow to stream runnablesHow to stream responses from an LLMHow to use a time-weighted vector store retrieverHow to return artifacts from a toolHow to use chat models to call toolsHow to disable parallel tool callingHow to force models to call a toolHow to access the RunnableConfig from a toolHow to pass tool outputs to chat modelsHow to pass run time values to toolsHow to stream events from a toolHow to stream tool callsHow to convert tools to OpenAI FunctionsHow to handle tool errorsHow to use few-shot prompting with tool callingHow to add a human-in-the-loop for toolsHow to bind model-specific toolsHow to trim messagesHow to create and query vector storesConceptual guideAgentsArchitectureAsync programming with langchainCallbacksChat historyChat modelsDocument loadersEmbedding modelsEvaluationExample selectorsFew-shot promptingConceptual guideKey-value storesLangChain Expression Language (LCEL)MessagesMultimodalityOutput parsersPrompt TemplatesRetrieval augmented generation (RAG)RetrievalRetrieversRunnable interfaceStreamingStructured outputsTestingString-in, string-out llmsText splittersTokensTool callingToolsTracingVector storesWhy LangChain?Ecosystem\uf8ffü¶ú\uf8ffüõ†Ô∏è LangSmith\uf8ffü¶ú\uf8ffüï∏Ô∏è LangGraphVersionsv0.3v0.2Pydantic compatibilityMigrating from v0.0 chainsHow to migrate from v0.0 chainsMigrating from ConstitutionalChainMigrating from ConversationalChainMigrating from ConversationalRetrievalChainMigrating from LLMChainMigrating from LLMMathChainMigrating from LLMRouterChainMigrating from MapReduceDocumentsChainMigrating from MapRerankDocumentsChainMigrating from MultiPromptChainMigrating from RefineDocumentsChainMigrating from RetrievalQAMigrating from StuffDocumentsChainUpgrading to LangGraph memoryHow to migrate to LangGraph memoryHow to use BaseChatMessageHistory with LangGraphMigrating off ConversationBufferMemory or ConversationStringBufferMemoryMigrating off ConversationBufferWindowMemory or ConversationTokenBufferMemoryMigrating off ConversationSummaryMemory or ConversationSummaryBufferMemoryA Long-Term Memory AgentRelease policySecurity PolicyConceptual guideLangChain Expression Language (LCEL)On this pageLangChain Expression Language (LCEL)\nPrerequisites\nRunnable Interface\n\nThe LangChain Expression Language (LCEL) takes a declarative approach to building new Runnables from existing Runnables.\nThis means that you describe what should happen, rather than how it should happen, allowing LangChain to optimize the run-time execution of the chains.\nWe often refer to a Runnable created using LCEL as a "chain". It\'s important to remember that a "chain" is Runnable and it implements the full Runnable Interface.\nnote\nThe LCEL cheatsheet shows common patterns that involve the Runnable interface and LCEL expressions.\nPlease see the following list of how-to guides that cover common tasks with LCEL.\nA list of built-in Runnables can be found in the LangChain Core API Reference. Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.\n\nBenefits of LCEL‚Äã\nLangChain optimizes the run-time execution of chains built with LCEL in a number of ways:\n\nOptimized parallel execution: Run Runnables in parallel using RunnableParallel or run multiple inputs through a given chain in parallel using the Runnable Batch API. Parallel execution can significantly reduce the latency as processing can be done in parallel instead of sequentially.\nGuaranteed Async support: Any chain built with LCEL can be run asynchronously using the Runnable Async API. This can be useful when running chains in a server environment where you want to handle large number of requests concurrently.\nSimplify streaming: LCEL chains can be streamed, allowing for incremental output as the chain is executed. LangChain can optimize the streaming of the output to minimize the time-to-first-token(time elapsed until the first chunk of output from a chat model or llm comes out).\n\nOther benefits include:\n\nSeamless LangSmith tracing\nAs your chains get more and more complex, it becomes increasingly important to understand what exactly is happening at every step.\nWith LCEL, all steps are automatically logged to LangSmith for maximum observability and debuggability.\nStandard API: Because all chains are built using the Runnable interface, they can be used in the same way as any other Runnable.\nDeployable with LangServe: Chains built with LCEL can be deployed using for production use.\n\nShould I use LCEL?‚Äã\nLCEL is an orchestration solution -- it allows LangChain to handle run-time execution of chains in an optimized way.\nWhile we have seen users run chains with hundreds of steps in production, we generally recommend using LCEL for simpler orchestration tasks. When the application requires complex state management, branching, cycles or multiple agents, we recommend that users take advantage of LangGraph.\nIn LangGraph, users define graphs that specify the application\'s flow. This allows users to keep using LCEL within individual nodes when LCEL is needed, while making it easy to define complex orchestration logic that is more readable and maintainable.\nHere are some guidelines:\n\nIf you are making a single LLM call, you don\'t need LCEL; instead call the underlying chat model directly.\nIf you have a simple chain (e.g., prompt + llm + parser, simple retrieval set up etc.), LCEL is a reasonable fit, if you\'re taking advantage of the LCEL benefits.\nIf you\'re building a complex chain (e.g., with branching, cycles, multiple agents, etc.) use LangGraph instead. Remember that you can always use LCEL within individual nodes in LangGraph.\n\nComposition Primitives‚Äã\nLCEL chains are built by composing existing Runnables together. The two main composition primitives are RunnableSequence and RunnableParallel.\nMany other composition primitives (e.g., RunnableAssign) can be thought of as variations of these two primitives.\nnoteYou can find a list of all composition primitives in the LangChain Core API Reference.\nRunnableSequence‚Äã\nRunnableSequence is a composition primitive that allows you "chain" multiple runnables sequentially, with the output of one runnable serving as the input to the next.\nfrom langchain_core.runnables import RunnableSequencechain = RunnableSequence([runnable1, runnable2])API Reference:RunnableSequence\nInvoking the chain with some input:\nfinal_output = chain.invoke(some_input)\ncorresponds to the following:\noutput1 = runnable1.invoke(some_input)final_output = runnable2.invoke(output1)\nnoterunnable1 and runnable2 are placeholders for any Runnable that you want to chain together.\nRunnableParallel‚Äã\nRunnableParallel is a composition primitive that allows you to run multiple runnables concurrently, with the same input provided to each.\nfrom langchain_core.runnables import RunnableParallelchain = RunnableParallel({    "key1": runnable1,    "key2": runnable2,})API Reference:RunnableParallel\nInvoking the chain with some input:\nfinal_output = chain.invoke(some_input)\nWill yield a final_output dictionary with the same keys as the input dictionary, but with the values replaced by the output of the corresponding runnable.\n{    "key1": runnable1.invoke(some_input),    "key2": runnable2.invoke(some_input),}\nRecall, that the runnables are executed in parallel, so while the result is the same as\ndictionary comprehension shown above, the execution time is much faster.\nnoteRunnableParallelsupports both synchronous and asynchronous execution (as all Runnables do).\nFor synchronous execution, RunnableParallel uses a ThreadPoolExecutor to run the runnables concurrently.\nFor asynchronous execution, RunnableParallel uses asyncio.gather to run the runnables concurrently.\n\nComposition Syntax‚Äã\nThe usage of RunnableSequence and RunnableParallel is so common that we created a shorthand syntax for using them. This helps\nto make the code more readable and concise.\nThe | operator‚Äã\nWe have overloaded the | operator to create a RunnableSequence from two Runnables.\nchain = runnable1 | runnable2\nis Equivalent to:\nchain = RunnableSequence([runnable1, runnable2])\nThe .pipe method`‚Äã\nIf you have moral qualms with operator overloading, you can use the .pipe method instead. This is equivalent to the | operator.\nchain = runnable1.pipe(runnable2)\nCoercion‚Äã\nLCEL applies automatic type coercion to make it easier to compose chains.\nIf you do not understand the type coercion, you can always use the RunnableSequence and RunnableParallel classes directly.\nThis will make the code more verbose, but it will also make it more explicit.\nDictionary to RunnableParallel‚Äã\nInside an LCEL expression, a dictionary is automatically converted to a RunnableParallel.\nFor example, the following code:\nmapping = {    "key1": runnable1,    "key2": runnable2,}chain = mapping | runnable3\nIt gets automatically converted to the following:\nchain = RunnableSequence([RunnableParallel(mapping), runnable3])\ncautionYou have to be careful because the mapping dictionary is not a RunnableParallel object, it is just a dictionary. This means that the following code will raise an AttributeError:mapping.invoke(some_input)\nFunction to RunnableLambda‚Äã\nInside an LCEL expression, a function is automatically converted to a RunnableLambda.\ndef some_func(x):    return xchain = some_func | runnable1\nIt gets automatically converted to the following:\nchain = RunnableSequence([RunnableLambda(some_func), runnable1])\ncautionYou have to be careful because the lambda function is not a RunnableLambda object, it is just a function. This means that the following code will raise an AttributeError:lambda x: x + 1.invoke(some_input)\nLegacy chains‚Äã\nLCEL aims to provide consistency around behavior and customization over legacy subclassed chains such as LLMChain and\nConversationalRetrievalChain. Many of these legacy chains hide important details like prompts, and as a wider variety\nof viable models emerge, customization has become more and more important.\nIf you are currently using one of these legacy chains, please see this guide for guidance on how to migrate.\nFor guides on how to do specific tasks with LCEL, check out the relevant how-to guides.Edit this pageWas this page helpful?PreviousKey-value storesNextMessagesBenefits of LCELShould I use LCEL?Composition PrimitivesRunnableSequenceRunnableParallelComposition SyntaxThe | operatorThe .pipe method`CoercionLegacy chainsCommunityTwitterGitHubOrganizationPythonJS/TSMoreHomepageBlogYouTubeCopyright ¬© 2024 LangChain, Inc.\n\n',
 '\n\n\n\n\n\n\n\n\nPydanticOutputParser ‚Äî \uf8ffü¶ú\uf8ffüîó LangChain  documentation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\n\n\nBack to top\n\n\n\n\nCtrl+K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    Reference\n  \n\n\n\n\n\n\n\n\n\nCtrl+K\n\n\n\n\n\n\n\nDocs\n\n\n\n\n\n\n\n\n\n\nGitHub\n\n\n\nX / Twitter\n\n\n\n\n\n\n\n\nCtrl+K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    Reference\n  \n\n\n\n\n\n\n\n\n\n\nDocs\n\n\n\n\n\n\n\n\n\n\nGitHub\n\n\n\nX / Twitter\n\n\n\n\n\n\n\nSection Navigation\nBase packages\n\nCore\nagents\nbeta\ncaches\ncallbacks\nchat_history\nchat_loaders\nchat_sessions\ndocument_loaders\ndocuments\nembeddings\nexample_selectors\nexceptions\nglobals\nindexing\nlanguage_models\nload\nmessages\noutput_parsers\nBaseGenerationOutputParser\nBaseLLMOutputParser\nBaseOutputParser\nJsonOutputParser\nSimpleJsonOutputParser\nCommaSeparatedListOutputParser\nListOutputParser\nMarkdownListOutputParser\nNumberedListOutputParser\nJsonKeyOutputFunctionsParser\nJsonOutputFunctionsParser\nOutputFunctionsParser\nPydanticAttrOutputFunctionsParser\nPydanticOutputFunctionsParser\nJsonOutputKeyToolsParser\nJsonOutputToolsParser\nPydanticToolsParser\nPydanticOutputParser\nStrOutputParser\nBaseCumulativeTransformOutputParser\nBaseTransformOutputParser\nXMLOutputParser\ndroplastn\nmake_invalid_tool_call\nparse_tool_call\nparse_tool_calls\nnested_element\n\n\noutputs\nprompt_values\nprompts\nrate_limiters\nretrievers\nrunnables\nstores\nstructured_query\nsys_info\ntools\ntracers\nutils\nvectorstores\n\n\nLangchain\nText Splitters\nCommunity\nExperimental\n\nIntegrations\n\nAI21\nAnthropic\nAstraDB\nAWS\nAzure Dynamic Sessions\nBox\nCerebras\nChroma\nCohere\nCouchbase\nDatabricks\nElasticsearch\nExa\nFireworks\nGoogle Community\nGoogle GenAI\nGoogle VertexAI\nGroq\nHuggingface\nIBM\nMilvus\nMistralAI\nNeo4J\nNomic\nNvidia Ai Endpoints\nOllama\nOpenAI\nPinecone\nPostgres\nPrompty\nQdrant\nRedis\nSema4\nSnowflake\nSqlserver\nStandard Tests\nTogether\nUnstructured\nUpstage\nVoyageAI\nWeaviate\nXAI\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLangChain Python API Reference\nlangchain-core: 0.3.28\noutput_parsers\nPydanticOutputParser\n\n\n\n\n\n\n\n\n\nPydanticOutputParser#\n\n\nclass langchain_core.output_parsers.pydantic.PydanticOutputParser[source]#\nBases: JsonOutputParser, Generic[TBaseModel]\nParse an output using a pydantic model.\n\nNote\nPydanticOutputParser implements the standard Runnable Interface. \uf8ffüèÉ\nThe Runnable Interface has additional methods that are available on runnables, such as with_types, with_retry, assign, bind, get_graph, and more.\n\n\n\nparam diff: bool = False#\nIn streaming mode, whether to yield diffs between the previous and current\nparsed output, or just the current parsed output.\n\n\n\nparam pydantic_object: Annotated[type[TBaseModel], SkipValidation()] [Required]#\nThe pydantic model to parse.\n\n\n\nasync abatch(inputs: list[Input], config: RunnableConfig | list[RunnableConfig] | None = None, *, return_exceptions: bool = False, **kwargs: Any | None) ‚Üí list[Output]#\nDefault implementation runs ainvoke in parallel using asyncio.gather.\nThe default implementation of batch works well for IO bound runnables.\nSubclasses should override this method if they can batch more efficiently;\ne.g., if the underlying Runnable uses an API which supports a batch mode.\n\nParameters:\n\ninputs (list[Input]) ‚Äì A list of inputs to the Runnable.\nconfig (RunnableConfig | list[RunnableConfig] | None) ‚Äì A config to use when invoking the Runnable.\nThe config supports standard keys like ‚Äòtags‚Äô, ‚Äòmetadata‚Äô for tracing\npurposes, ‚Äòmax_concurrency‚Äô for controlling how much work to do\nin parallel, and other keys. Please refer to the RunnableConfig\nfor more details. Defaults to None.\nreturn_exceptions (bool) ‚Äì Whether to return exceptions instead of raising them.\nDefaults to False.\nkwargs (Any | None) ‚Äì Additional keyword arguments to pass to the Runnable.\n\n\nReturns:\nA list of outputs from the Runnable.\n\nReturn type:\nlist[Output]\n\n\n\n\n\nasync abatch_as_completed(inputs: Sequence[Input], config: RunnableConfig | Sequence[RunnableConfig] | None = None, *, return_exceptions: bool = False, **kwargs: Any | None) ‚Üí AsyncIterator[tuple[int, Output | Exception]]#\nRun ainvoke in parallel on a list of inputs,\nyielding results as they complete.\n\nParameters:\n\ninputs (Sequence[Input]) ‚Äì A list of inputs to the Runnable.\nconfig (RunnableConfig | Sequence[RunnableConfig] | None) ‚Äì A config to use when invoking the Runnable.\nThe config supports standard keys like ‚Äòtags‚Äô, ‚Äòmetadata‚Äô for tracing\npurposes, ‚Äòmax_concurrency‚Äô for controlling how much work to do\nin parallel, and other keys. Please refer to the RunnableConfig\nfor more details. Defaults to None. Defaults to None.\nreturn_exceptions (bool) ‚Äì Whether to return exceptions instead of raising them.\nDefaults to False.\nkwargs (Any | None) ‚Äì Additional keyword arguments to pass to the Runnable.\n\n\nYields:\nA tuple of the index of the input and the output from the Runnable.\n\nReturn type:\nAsyncIterator[tuple[int, Output | Exception]]\n\n\n\n\n\nasync ainvoke(input: str | BaseMessage, config: RunnableConfig | None = None, **kwargs: Any | None) ‚Üí T#\nDefault implementation of ainvoke, calls invoke from a thread.\nThe default implementation allows usage of async code even if\nthe Runnable did not implement a native async version of invoke.\nSubclasses should override this method if they can run asynchronously.\n\nParameters:\n\ninput (str | BaseMessage)\nconfig (RunnableConfig | None)\nkwargs (Any | None)\n\n\nReturn type:\nT\n\n\n\n\n\nasync aparse(text: str) ‚Üí T#\nAsync parse a single string model output into some structure.\n\nParameters:\ntext (str) ‚Äì String output of a language model.\n\nReturns:\nStructured output.\n\nReturn type:\nT\n\n\n\n\n\nasync aparse_result(result: list[Generation], *, partial: bool = False) ‚Üí T#\nAsync parse a list of candidate model Generations into a specific format.\n\nThe return value is parsed from only the first Generation in the result, whichis assumed to be the highest-likelihood Generation.\n\n\n\nParameters:\n\nresult (list[Generation]) ‚Äì A list of Generations to be parsed. The Generations are assumed\nto be different candidate outputs for a single model input.\npartial (bool) ‚Äì Whether to parse the output as a partial result. This is useful\nfor parsers that can parse partial results. Default is False.\n\n\nReturns:\nStructured output.\n\nReturn type:\nT\n\n\n\n\n\nasync astream(input: Input, config: RunnableConfig | None = None, **kwargs: Any | None) ‚Üí AsyncIterator[Output]#\nDefault implementation of astream, which calls ainvoke.\nSubclasses should override this method if they support streaming output.\n\nParameters:\n\ninput (Input) ‚Äì The input to the Runnable.\nconfig (RunnableConfig | None) ‚Äì The config to use for the Runnable. Defaults to None.\nkwargs (Any | None) ‚Äì Additional keyword arguments to pass to the Runnable.\n\n\nYields:\nThe output of the Runnable.\n\nReturn type:\nAsyncIterator[Output]\n\n\n\n\n\nasync astream_events(input: Any, config: RunnableConfig | None = None, *, version: Literal[\'v1\', \'v2\'], include_names: Sequence[str] | None = None, include_types: Sequence[str] | None = None, include_tags: Sequence[str] | None = None, exclude_names: Sequence[str] | None = None, exclude_types: Sequence[str] | None = None, exclude_tags: Sequence[str] | None = None, **kwargs: Any) ‚Üí AsyncIterator[StandardStreamEvent | CustomStreamEvent]#\nGenerate a stream of events.\nUse to create an iterator over StreamEvents that provide real-time information\nabout the progress of the Runnable, including StreamEvents from intermediate\nresults.\nA StreamEvent is a dictionary with the following schema:\n\n\nevent: str - Event names are of theformat: on_[runnable_type]_(start|stream|end).\n\n\n\nname: str - The name of the Runnable that generated the event.\n\nrun_id: str - randomly generated ID associated with the given execution ofthe Runnable that emitted the event.\nA child Runnable that gets invoked as part of the execution of a\nparent Runnable is assigned its own unique ID.\n\n\n\n\nparent_ids: List[str] - The IDs of the parent runnables thatgenerated the event. The root Runnable will have an empty list.\nThe order of the parent IDs is from the root to the immediate parent.\nOnly available for v2 version of the API. The v1 version of the API\nwill return an empty list.\n\n\n\n\ntags: Optional[List[str]] - The tags of the Runnable that generatedthe event.\n\n\n\n\nmetadata: Optional[Dict[str, Any]] - The metadata of the Runnablethat generated the event.\n\n\n\ndata: Dict[str, Any]\n\nBelow is a table that illustrates some events that might be emitted by various\nchains. Metadata fields have been omitted from the table for brevity.\nChain definitions have been included after the table.\nATTENTION This reference table is for the V2 version of the schema.\n\n\nevent\nname\nchunk\ninput\noutput\n\n\n\non_chat_model_start\n[model name]\n\n{‚Äúmessages‚Äù: [[SystemMessage, HumanMessage]]}\n\n\non_chat_model_stream\n[model name]\nAIMessageChunk(content=‚Äùhello‚Äù)\n\n\n\non_chat_model_end\n[model name]\n\n{‚Äúmessages‚Äù: [[SystemMessage, HumanMessage]]}\nAIMessageChunk(content=‚Äùhello world‚Äù)\n\non_llm_start\n[model name]\n\n{‚Äòinput‚Äô: ‚Äòhello‚Äô}\n\n\non_llm_stream\n[model name]\n‚ÄòHello‚Äô\n\n\n\non_llm_end\n[model name]\n\n‚ÄòHello human!‚Äô\n\n\non_chain_start\nformat_docs\n\n\n\n\non_chain_stream\nformat_docs\n‚Äúhello world!, goodbye world!‚Äù\n\n\n\non_chain_end\nformat_docs\n\n[Document(‚Ä¶)]\n‚Äúhello world!, goodbye world!‚Äù\n\non_tool_start\nsome_tool\n\n{‚Äúx‚Äù: 1, ‚Äúy‚Äù: ‚Äú2‚Äù}\n\n\non_tool_end\nsome_tool\n\n\n{‚Äúx‚Äù: 1, ‚Äúy‚Äù: ‚Äú2‚Äù}\n\non_retriever_start\n[retriever name]\n\n{‚Äúquery‚Äù: ‚Äúhello‚Äù}\n\n\non_retriever_end\n[retriever name]\n\n{‚Äúquery‚Äù: ‚Äúhello‚Äù}\n[Document(‚Ä¶), ..]\n\non_prompt_start\n[template_name]\n\n{‚Äúquestion‚Äù: ‚Äúhello‚Äù}\n\n\non_prompt_end\n[template_name]\n\n{‚Äúquestion‚Äù: ‚Äúhello‚Äù}\nChatPromptValue(messages: [SystemMessage, ‚Ä¶])\n\n\n\n\nIn addition to the standard events, users can also dispatch custom events (see example below).\nCustom events will be only be surfaced with in the v2 version of the API!\nA custom event has following format:\n\n\nAttribute\nType\nDescription\n\n\n\nname\nstr\nA user defined name for the event.\n\ndata\nAny\nThe data associated with the event. This can be anything, though we suggest making it JSON serializable.\n\n\n\n\nHere are declarations associated with the standard events shown above:\nformat_docs:\ndef format_docs(docs: List[Document]) -&gt; str:\n    \'\'\'Format the docs.\'\'\'\n    return ", ".join([doc.page_content for doc in docs])\n\nformat_docs = RunnableLambda(format_docs)\n\n\nsome_tool:\n@tool\ndef some_tool(x: int, y: str) -&gt; dict:\n    \'\'\'Some_tool.\'\'\'\n    return {"x": x, "y": y}\n\n\nprompt:\ntemplate = ChatPromptTemplate.from_messages(\n    [("system", "You are Cat Agent 007"), ("human", "{question}")]\n).with_config({"run_name": "my_template", "tags": ["my_template"]})\n\n\nExample:\nfrom langchain_core.runnables import RunnableLambda\n\nasync def reverse(s: str) -&gt; str:\n    return s[::-1]\n\nchain = RunnableLambda(func=reverse)\n\nevents = [\n    event async for event in chain.astream_events("hello", version="v2")\n]\n\n# will produce the following events (run_id, and parent_ids\n# has been omitted for brevity):\n[\n    {\n        "data": {"input": "hello"},\n        "event": "on_chain_start",\n        "metadata": {},\n        "name": "reverse",\n        "tags": [],\n    },\n    {\n        "data": {"chunk": "olleh"},\n        "event": "on_chain_stream",\n        "metadata": {},\n        "name": "reverse",\n        "tags": [],\n    },\n    {\n        "data": {"output": "olleh"},\n        "event": "on_chain_end",\n        "metadata": {},\n        "name": "reverse",\n        "tags": [],\n    },\n]\n\n\nExample: Dispatch Custom Event\nfrom langchain_core.callbacks.manager import (\n    adispatch_custom_event,\n)\nfrom langchain_core.runnables import RunnableLambda, RunnableConfig\nimport asyncio\n\n\nasync def slow_thing(some_input: str, config: RunnableConfig) -&gt; str:\n    """Do something that takes a long time."""\n    await asyncio.sleep(1) # Placeholder for some slow operation\n    await adispatch_custom_event(\n        "progress_event",\n        {"message": "Finished step 1 of 3"},\n        config=config # Must be included for python &lt; 3.10\n    )\n    await asyncio.sleep(1) # Placeholder for some slow operation\n    await adispatch_custom_event(\n        "progress_event",\n        {"message": "Finished step 2 of 3"},\n        config=config # Must be included for python &lt; 3.10\n    )\n    await asyncio.sleep(1) # Placeholder for some slow operation\n    return "Done"\n\nslow_thing = RunnableLambda(slow_thing)\n\nasync for event in slow_thing.astream_events("some_input", version="v2"):\n    print(event)\n\n\n\nParameters:\n\ninput (Any) ‚Äì The input to the Runnable.\nconfig (RunnableConfig | None) ‚Äì The config to use for the Runnable.\nversion (Literal[\'v1\', \'v2\']) ‚Äì The version of the schema to use either v2 or v1.\nUsers should use v2.\nv1 is for backwards compatibility and will be deprecated\nin 0.4.0.\nNo default will be assigned until the API is stabilized.\ncustom events will only be surfaced in v2.\ninclude_names (Sequence[str] | None) ‚Äì Only include events from runnables with matching names.\ninclude_types (Sequence[str] | None) ‚Äì Only include events from runnables with matching types.\ninclude_tags (Sequence[str] | None) ‚Äì Only include events from runnables with matching tags.\nexclude_names (Sequence[str] | None) ‚Äì Exclude events from runnables with matching names.\nexclude_types (Sequence[str] | None) ‚Äì Exclude events from runnables with matching types.\nexclude_tags (Sequence[str] | None) ‚Äì Exclude events from runnables with matching tags.\nkwargs (Any) ‚Äì Additional keyword arguments to pass to the Runnable.\nThese will be passed to astream_log as this implementation\nof astream_events is built on top of astream_log.\n\n\nYields:\nAn async stream of StreamEvents.\n\nRaises:\nNotImplementedError ‚Äì If the version is not v1 or v2.\n\nReturn type:\nAsyncIterator[StandardStreamEvent | CustomStreamEvent]\n\n\n\n\n\nbatch(inputs: list[Input], config: RunnableConfig | list[RunnableConfig] | None = None, *, return_exceptions: bool = False, **kwargs: Any | None) ‚Üí list[Output]#\nDefault implementation runs invoke in parallel using a thread pool executor.\nThe default implementation of batch works well for IO bound runnables.\nSubclasses should override this method if they can batch more efficiently;\ne.g., if the underlying Runnable uses an API which supports a batch mode.\n\nParameters:\n\ninputs (list[Input])\nconfig (RunnableConfig | list[RunnableConfig] | None)\nreturn_exceptions (bool)\nkwargs (Any | None)\n\n\nReturn type:\nlist[Output]\n\n\n\n\n\nbatch_as_completed(inputs: Sequence[Input], config: RunnableConfig | Sequence[RunnableConfig] | None = None, *, return_exceptions: bool = False, **kwargs: Any | None) ‚Üí Iterator[tuple[int, Output | Exception]]#\nRun invoke in parallel on a list of inputs,\nyielding results as they complete.\n\nParameters:\n\ninputs (Sequence[Input])\nconfig (RunnableConfig | Sequence[RunnableConfig] | None)\nreturn_exceptions (bool)\nkwargs (Any | None)\n\n\nReturn type:\nIterator[tuple[int, Output | Exception]]\n\n\n\n\n\nbind(**kwargs: Any) ‚Üí Runnable[Input, Output]#\nBind arguments to a Runnable, returning a new Runnable.\nUseful when a Runnable in a chain requires an argument that is not\nin the output of the previous Runnable or included in the user input.\n\nParameters:\nkwargs (Any) ‚Äì The arguments to bind to the Runnable.\n\nReturns:\nA new Runnable with the arguments bound.\n\nReturn type:\nRunnable[Input, Output]\n\n\nExample:\nfrom langchain_community.chat_models import ChatOllama\nfrom langchain_core.output_parsers import StrOutputParser\n\nllm = ChatOllama(model=\'llama2\')\n\n# Without bind.\nchain = (\n    llm\n    | StrOutputParser()\n)\n\nchain.invoke("Repeat quoted words exactly: \'One two three four five.\'")\n# Output is \'One two three four five.\'\n\n# With bind.\nchain = (\n    llm.bind(stop=["three"])\n    | StrOutputParser()\n)\n\nchain.invoke("Repeat quoted words exactly: \'One two three four five.\'")\n# Output is \'One two\'\n\n\n\n\n\nconfigurable_alternatives(which: ConfigurableField, *, default_key: str = \'default\', prefix_keys: bool = False, **kwargs: Runnable[Input, Output] | Callable[[], Runnable[Input, Output]]) ‚Üí RunnableSerializable#\nConfigure alternatives for Runnables that can be set at runtime.\n\nParameters:\n\nwhich (ConfigurableField) ‚Äì The ConfigurableField instance that will be used to select the\nalternative.\ndefault_key (str) ‚Äì The default key to use if no alternative is selected.\nDefaults to ‚Äúdefault‚Äù.\nprefix_keys (bool) ‚Äì Whether to prefix the keys with the ConfigurableField id.\nDefaults to False.\n**kwargs (Runnable[Input, Output] | Callable[[], Runnable[Input, Output]]) ‚Äì A dictionary of keys to Runnable instances or callables that\nreturn Runnable instances.\n\n\nReturns:\nA new Runnable with the alternatives configured.\n\nReturn type:\nRunnableSerializable\n\n\nfrom langchain_anthropic import ChatAnthropic\nfrom langchain_core.runnables.utils import ConfigurableField\nfrom langchain_openai import ChatOpenAI\n\nmodel = ChatAnthropic(\n    model_name="claude-3-sonnet-20240229"\n).configurable_alternatives(\n    ConfigurableField(id="llm"),\n    default_key="anthropic",\n    openai=ChatOpenAI()\n)\n\n# uses the default model ChatAnthropic\nprint(model.invoke("which organization created you?").content)\n\n# uses ChatOpenAI\nprint(\n    model.with_config(\n        configurable={"llm": "openai"}\n    ).invoke("which organization created you?").content\n)\n\n\n\n\n\nconfigurable_fields(**kwargs: ConfigurableField | ConfigurableFieldSingleOption | ConfigurableFieldMultiOption) ‚Üí RunnableSerializable#\nConfigure particular Runnable fields at runtime.\n\nParameters:\n**kwargs (ConfigurableField | ConfigurableFieldSingleOption | ConfigurableFieldMultiOption) ‚Äì A dictionary of ConfigurableField instances to configure.\n\nReturns:\nA new Runnable with the fields configured.\n\nReturn type:\nRunnableSerializable\n\n\nfrom langchain_core.runnables import ConfigurableField\nfrom langchain_openai import ChatOpenAI\n\nmodel = ChatOpenAI(max_tokens=20).configurable_fields(\n    max_tokens=ConfigurableField(\n        id="output_token_number",\n        name="Max tokens in the output",\n        description="The maximum number of tokens in the output",\n    )\n)\n\n# max_tokens = 20\nprint(\n    "max_tokens_20: ",\n    model.invoke("tell me something about chess").content\n)\n\n# max_tokens = 200\nprint("max_tokens_200: ", model.with_config(\n    configurable={"output_token_number": 200}\n    ).invoke("tell me something about chess").content\n)\n\n\n\n\n\nget_format_instructions() ‚Üí str[source]#\nReturn the format instructions for the JSON output.\n\nReturns:\nThe format instructions for the JSON output.\n\nReturn type:\nstr\n\n\n\n\n\ninvoke(input: str | BaseMessage, config: RunnableConfig | None = None, **kwargs: Any) ‚Üí T#\nTransform a single input into an output. Override to implement.\n\nParameters:\n\ninput (str | BaseMessage) ‚Äì The input to the Runnable.\nconfig (RunnableConfig | None) ‚Äì A config to use when invoking the Runnable.\nThe config supports standard keys like ‚Äòtags‚Äô, ‚Äòmetadata‚Äô for tracing\npurposes, ‚Äòmax_concurrency‚Äô for controlling how much work to do\nin parallel, and other keys. Please refer to the RunnableConfig\nfor more details.\nkwargs (Any)\n\n\nReturns:\nThe output of the Runnable.\n\nReturn type:\nT\n\n\n\n\n\nparse(text: str) ‚Üí TBaseModel[source]#\nParse the output of an LLM call to a pydantic object.\n\nParameters:\ntext (str) ‚Äì The output of the LLM call.\n\nReturns:\nThe parsed pydantic object.\n\nReturn type:\nTBaseModel\n\n\n\n\n\nparse_result(result: list[Generation], *, partial: bool = False) ‚Üí TBaseModel | None[source]#\nParse the result of an LLM call to a pydantic object.\n\nParameters:\n\nresult (list[Generation]) ‚Äì The result of the LLM call.\npartial (bool) ‚Äì Whether to parse partial JSON objects.\nIf True, the output will be a JSON object containing\nall the keys that have been returned so far.\nDefaults to False.\n\n\nReturns:\nThe parsed pydantic object.\n\nReturn type:\nTBaseModel | None\n\n\n\n\n\nparse_with_prompt(completion: str, prompt: PromptValue) ‚Üí Any#\nParse the output of an LLM call with the input prompt for context.\nThe prompt is largely provided in the event the OutputParser wants\nto retry or fix the output in some way, and needs information from\nthe prompt to do so.\n\nParameters:\n\ncompletion (str) ‚Äì String output of a language model.\nprompt (PromptValue) ‚Äì Input PromptValue.\n\n\nReturns:\nStructured output.\n\nReturn type:\nAny\n\n\n\n\n\nstream(input: Input, config: RunnableConfig | None = None, **kwargs: Any | None) ‚Üí Iterator[Output]#\nDefault implementation of stream, which calls invoke.\nSubclasses should override this method if they support streaming output.\n\nParameters:\n\ninput (Input) ‚Äì The input to the Runnable.\nconfig (RunnableConfig | None) ‚Äì The config to use for the Runnable. Defaults to None.\nkwargs (Any | None) ‚Äì Additional keyword arguments to pass to the Runnable.\n\n\nYields:\nThe output of the Runnable.\n\nReturn type:\nIterator[Output]\n\n\n\n\n\nwith_alisteners(*, on_start: AsyncListener | None = None, on_end: AsyncListener | None = None, on_error: AsyncListener | None = None) ‚Üí Runnable[Input, Output]#\nBind asynchronous lifecycle listeners to a Runnable, returning a new Runnable.\non_start: Asynchronously called before the Runnable starts running.\non_end: Asynchronously called after the Runnable finishes running.\non_error: Asynchronously called if the Runnable throws an error.\nThe Run object contains information about the run, including its id,\ntype, input, output, error, start_time, end_time, and any tags or metadata\nadded to the run.\n\nParameters:\n\non_start (Optional[AsyncListener]) ‚Äì Asynchronously called before the Runnable starts running.\nDefaults to None.\non_end (Optional[AsyncListener]) ‚Äì Asynchronously called after the Runnable finishes running.\nDefaults to None.\non_error (Optional[AsyncListener]) ‚Äì Asynchronously called if the Runnable throws an error.\nDefaults to None.\n\n\nReturns:\nA new Runnable with the listeners bound.\n\nReturn type:\nRunnable[Input, Output]\n\n\nExample:\nfrom langchain_core.runnables import RunnableLambda\nimport time\n\nasync def test_runnable(time_to_sleep : int):\n    print(f"Runnable[{time_to_sleep}s]: starts at {format_t(time.time())}")\n    await asyncio.sleep(time_to_sleep)\n    print(f"Runnable[{time_to_sleep}s]: ends at {format_t(time.time())}")\n\nasync def fn_start(run_obj : Runnable):\n    print(f"on start callback starts at {format_t(time.time())}\n    await asyncio.sleep(3)\n    print(f"on start callback ends at {format_t(time.time())}")\n\nasync def fn_end(run_obj : Runnable):\n    print(f"on end callback starts at {format_t(time.time())}\n    await asyncio.sleep(2)\n    print(f"on end callback ends at {format_t(time.time())}")\n\nrunnable = RunnableLambda(test_runnable).with_alisteners(\n    on_start=fn_start,\n    on_end=fn_end\n)\nasync def concurrent_runs():\n    await asyncio.gather(runnable.ainvoke(2), runnable.ainvoke(3))\n\nasyncio.run(concurrent_runs())\nResult:\non start callback starts at 2024-05-16T14:20:29.637053+00:00\non start callback starts at 2024-05-16T14:20:29.637150+00:00\non start callback ends at 2024-05-16T14:20:32.638305+00:00\non start callback ends at 2024-05-16T14:20:32.638383+00:00\nRunnable[3s]: starts at 2024-05-16T14:20:32.638849+00:00\nRunnable[5s]: starts at 2024-05-16T14:20:32.638999+00:00\nRunnable[3s]: ends at 2024-05-16T14:20:35.640016+00:00\non end callback starts at 2024-05-16T14:20:35.640534+00:00\nRunnable[5s]: ends at 2024-05-16T14:20:37.640169+00:00\non end callback starts at 2024-05-16T14:20:37.640574+00:00\non end callback ends at 2024-05-16T14:20:37.640654+00:00\non end callback ends at 2024-05-16T14:20:39.641751+00:00\n\n\n\n\n\nwith_config(config: RunnableConfig | None = None, **kwargs: Any) ‚Üí Runnable[Input, Output]#\nBind config to a Runnable, returning a new Runnable.\n\nParameters:\n\nconfig (RunnableConfig | None) ‚Äì The config to bind to the Runnable.\nkwargs (Any) ‚Äì Additional keyword arguments to pass to the Runnable.\n\n\nReturns:\nA new Runnable with the config bound.\n\nReturn type:\nRunnable[Input, Output]\n\n\n\n\n\nwith_fallbacks(fallbacks: Sequence[Runnable[Input, Output]], *, exceptions_to_handle: tuple[type[BaseException], ...] = (&lt;class \'Exception\'&gt;,), exception_key: Optional[str] = None) ‚Üí RunnableWithFallbacksT[Input, Output]#\nAdd fallbacks to a Runnable, returning a new Runnable.\nThe new Runnable will try the original Runnable, and then each fallback\nin order, upon failures.\n\nParameters:\n\nfallbacks (Sequence[Runnable[Input, Output]]) ‚Äì A sequence of runnables to try if the original Runnable fails.\nexceptions_to_handle (tuple[type[BaseException], ...]) ‚Äì A tuple of exception types to handle.\nDefaults to (Exception,).\nexception_key (Optional[str]) ‚Äì If string is specified then handled exceptions will be passed\nto fallbacks as part of the input under the specified key. If None,\nexceptions will not be passed to fallbacks. If used, the base Runnable\nand its fallbacks must accept a dictionary as input. Defaults to None.\n\n\nReturns:\nA new Runnable that will try the original Runnable, and then each\nfallback in order, upon failures.\n\nReturn type:\nRunnableWithFallbacksT[Input, Output]\n\n\nExample\nfrom typing import Iterator\n\nfrom langchain_core.runnables import RunnableGenerator\n\n\ndef _generate_immediate_error(input: Iterator) -&gt; Iterator[str]:\n    raise ValueError()\n    yield ""\n\n\ndef _generate(input: Iterator) -&gt; Iterator[str]:\n    yield from "foo bar"\n\n\nrunnable = RunnableGenerator(_generate_immediate_error).with_fallbacks(\n    [RunnableGenerator(_generate)]\n    )\nprint(\'\'.join(runnable.stream({}))) #foo bar\n\n\n\nParameters:\n\nfallbacks (Sequence[Runnable[Input, Output]]) ‚Äì A sequence of runnables to try if the original Runnable fails.\nexceptions_to_handle (tuple[type[BaseException], ...]) ‚Äì A tuple of exception types to handle.\nexception_key (Optional[str]) ‚Äì If string is specified then handled exceptions will be passed\nto fallbacks as part of the input under the specified key. If None,\nexceptions will not be passed to fallbacks. If used, the base Runnable\nand its fallbacks must accept a dictionary as input.\n\n\nReturns:\nA new Runnable that will try the original Runnable, and then each\nfallback in order, upon failures.\n\nReturn type:\nRunnableWithFallbacksT[Input, Output]\n\n\n\n\n\nwith_listeners(*, on_start: Callable[[Run], None] | Callable[[Run, RunnableConfig], None] | None = None, on_end: Callable[[Run], None] | Callable[[Run, RunnableConfig], None] | None = None, on_error: Callable[[Run], None] | Callable[[Run, RunnableConfig], None] | None = None) ‚Üí Runnable[Input, Output]#\nBind lifecycle listeners to a Runnable, returning a new Runnable.\non_start: Called before the Runnable starts running, with the Run object.\non_end: Called after the Runnable finishes running, with the Run object.\non_error: Called if the Runnable throws an error, with the Run object.\nThe Run object contains information about the run, including its id,\ntype, input, output, error, start_time, end_time, and any tags or metadata\nadded to the run.\n\nParameters:\n\non_start (Optional[Union[Callable[[Run], None], Callable[[Run, RunnableConfig], None]]]) ‚Äì Called before the Runnable starts running. Defaults to None.\non_end (Optional[Union[Callable[[Run], None], Callable[[Run, RunnableConfig], None]]]) ‚Äì Called after the Runnable finishes running. Defaults to None.\non_error (Optional[Union[Callable[[Run], None], Callable[[Run, RunnableConfig], None]]]) ‚Äì Called if the Runnable throws an error. Defaults to None.\n\n\nReturns:\nA new Runnable with the listeners bound.\n\nReturn type:\nRunnable[Input, Output]\n\n\nExample:\nfrom langchain_core.runnables import RunnableLambda\nfrom langchain_core.tracers.schemas import Run\n\nimport time\n\ndef test_runnable(time_to_sleep : int):\n    time.sleep(time_to_sleep)\n\ndef fn_start(run_obj: Run):\n    print("start_time:", run_obj.start_time)\n\ndef fn_end(run_obj: Run):\n    print("end_time:", run_obj.end_time)\n\nchain = RunnableLambda(test_runnable).with_listeners(\n    on_start=fn_start,\n    on_end=fn_end\n)\nchain.invoke(2)\n\n\n\n\n\nwith_retry(*, retry_if_exception_type: tuple[type[BaseException], ...] = (&lt;class \'Exception\'&gt;,), wait_exponential_jitter: bool = True, stop_after_attempt: int = 3) ‚Üí Runnable[Input, Output]#\nCreate a new Runnable that retries the original Runnable on exceptions.\n\nParameters:\n\nretry_if_exception_type (tuple[type[BaseException], ...]) ‚Äì A tuple of exception types to retry on.\nDefaults to (Exception,).\nwait_exponential_jitter (bool) ‚Äì Whether to add jitter to the wait\ntime between retries. Defaults to True.\nstop_after_attempt (int) ‚Äì The maximum number of attempts to make before\ngiving up. Defaults to 3.\n\n\nReturns:\nA new Runnable that retries the original Runnable on exceptions.\n\nReturn type:\nRunnable[Input, Output]\n\n\nExample:\nfrom langchain_core.runnables import RunnableLambda\n\ncount = 0\n\n\ndef _lambda(x: int) -&gt; None:\n    global count\n    count = count + 1\n    if x == 1:\n        raise ValueError("x is 1")\n    else:\n         pass\n\n\nrunnable = RunnableLambda(_lambda)\ntry:\n    runnable.with_retry(\n        stop_after_attempt=2,\n        retry_if_exception_type=(ValueError,),\n    ).invoke(1)\nexcept ValueError:\n    pass\n\nassert (count == 2)\n\n\n\nParameters:\n\nretry_if_exception_type (tuple[type[BaseException], ...]) ‚Äì A tuple of exception types to retry on\nwait_exponential_jitter (bool) ‚Äì Whether to add jitter to the wait time\nbetween retries\nstop_after_attempt (int) ‚Äì The maximum number of attempts to make before giving up\n\n\nReturns:\nA new Runnable that retries the original Runnable on exceptions.\n\nReturn type:\nRunnable[Input, Output]\n\n\n\n\n\nwith_types(*, input_type: type[Input] | None = None, output_type: type[Output] | None = None) ‚Üí Runnable[Input, Output]#\nBind input and output types to a Runnable, returning a new Runnable.\n\nParameters:\n\ninput_type (type[Input] | None) ‚Äì The input type to bind to the Runnable. Defaults to None.\noutput_type (type[Output] | None) ‚Äì The output type to bind to the Runnable. Defaults to None.\n\n\nReturns:\nA new Runnable with the types bound.\n\nReturn type:\nRunnable[Input, Output]\n\n\n\n\nExamples using PydanticOutputParser\n\nGenerate Synthetic Data\nHow to retry when a parsing error occurs\nHow to return structured data from a model\nHow to use output parsers to parse an LLM response into structured format\nHow to use prompting alone (no tool calling) to do extraction\nHow to use the output-fixing parser\n\n\n\n\n\n\n\n\n On this page\n  \n\n\nPydanticOutputParser\ndiff\npydantic_object\nabatch()\nabatch_as_completed()\nainvoke()\naparse()\naparse_result()\nastream()\nastream_events()\nbatch()\nbatch_as_completed()\nbind()\nconfigurable_alternatives()\nconfigurable_fields()\nget_format_instructions()\ninvoke()\nparse()\nparse_result()\nparse_with_prompt()\nstream()\nwith_alisteners()\nwith_config()\nwith_fallbacks()\nwith_listeners()\nwith_retry()\nwith_types()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n      ¬© Copyright 2023, LangChain Inc.\n      \n\n\n\n\n\n\n',
 '\n\n\n\n\nHow to do "self-querying" retrieval | \uf8ffü¶úÔ∏è\uf8ffüîó LangChain\n\n\n\n\n\n\nSkip to main contentIntegrationsAPI ReferenceMoreContributingPeopleError referenceLangSmithLangGraphLangChain HubLangChain JS/TSv0.3v0.3v0.2v0.1\uf8ffüí¨SearchIntroductionTutorialsBuild a Question Answering application over a Graph DatabaseTutorialsBuild a simple LLM application with chat models and prompt templatesBuild a ChatbotBuild a Retrieval Augmented Generation (RAG) App: Part 2Build an Extraction ChainBuild an AgentTaggingBuild a Retrieval Augmented Generation (RAG) App: Part 1Build a semantic search engineBuild a Question/Answering system over SQL dataSummarize TextHow-to guidesHow-to guidesHow to use tools in a chainHow to use a vectorstore as a retrieverHow to add memory to chatbotsHow to use example selectorsHow to add a semantic layer over graph databaseHow to invoke runnables in parallelHow to stream chat model responsesHow to add default invocation args to a RunnableHow to add retrieval to chatbotsHow to use few shot examples in chat modelsHow to do tool/function callingHow to install LangChain packagesHow to add examples to the prompt for query analysisHow to use few shot examplesHow to run custom functionsHow to use output parsers to parse an LLM response into structured formatHow to handle cases where no queries are generatedHow to route between sub-chainsHow to return structured data from a modelHow to summarize text through parallelizationHow to summarize text through iterative refinementHow to summarize text in a single LLM callHow to use toolkitsHow to add ad-hoc tool calling capability to LLMs and Chat ModelsBuild an Agent with AgentExecutor (Legacy)How to construct knowledge graphsHow to partially format prompt templatesHow to handle multiple queries when doing query analysisHow to use built-in tools and toolkitsHow to pass through arguments from one step to the nextHow to compose prompts togetherHow to handle multiple retrievers when doing query analysisHow to add values to a chain\'s stateHow to construct filters for query analysisHow to configure runtime chain internalsHow deal with high cardinality categoricals when doing query analysisCustom Document LoaderHow to use the MultiQueryRetrieverHow to add scores to retriever resultsCachingHow to use callbacks in async environmentsHow to attach callbacks to a runnableHow to propagate callbacks  constructorHow to dispatch custom callback eventsHow to pass callbacks in at runtimeHow to split by characterHow to cache chat model responsesHow to handle rate limitsHow to init any model in one lineHow to track token usage in ChatModelsHow to add tools to chatbotsHow to split codeHow to do retrieval with contextual compressionHow to convert Runnables to ToolsHow to create custom callback handlersHow to create a custom chat model classCustom EmbeddingsHow to create a custom LLM classCustom RetrieverHow to create toolsHow to debug your LLM appsHow to load CSVsHow to load documents from a directoryHow to load HTMLHow to load JSONHow to load MarkdownHow to load Microsoft Office filesHow to load PDFsHow to load web pagesHow to create a dynamic (self-constructing) chainText embedding modelsHow to combine results from multiple retrieversHow to select examples from a LangSmith datasetHow to select examples by lengthHow to select examples by maximal marginal relevance (MMR)How to select examples by n-gram overlapHow to select examples by similarityHow to use reference examples when doing extractionHow to handle long text when doing extractionHow to use prompting alone (no tool calling) to do extractionHow to add fallbacks to a runnableHow to filter messagesHybrid SearchHow to use the LangChain indexing APIHow to inspect runnablesLangChain Expression Language CheatsheetHow to cache LLM responsesHow to track token usage for LLMsRun models locallyHow to get log probabilitiesHow to reorder retrieved results to mitigate the "lost in the middle" effectHow to split Markdown by HeadersHow to merge consecutive messages of the same typeHow to add message historyHow to migrate from legacy LangChain agents to LangGraphHow to retrieve using multiple vectors per documentHow to pass multimodal data directly to modelsHow to use multimodal promptsHow to create a custom Output ParserHow to use the output-fixing parserHow to parse JSON outputHow to retry when a parsing error occursHow to parse text from message objectsHow to parse XML outputHow to parse YAML outputHow to use the Parent Document RetrieverHow to use LangChain with different Pydantic versionsHow to add chat historyHow to get a RAG application to add citationsHow to do per-user retrievalHow to get your RAG application to return sourcesHow to stream results from your RAG applicationHow to split JSON dataHow to recursively split text by charactersResponse metadataHow to pass runtime secrets to runnablesHow to do "self-querying" retrievalHow to split text based on semantic similarityHow to chain runnablesHow to save and load LangChain objectsHow to split text by tokensHow to split HTMLHow to do question answering over CSVsHow to deal with large databases when doing SQL question-answeringHow to better prompt when doing SQL question-answeringHow to do query validation as part of SQL question-answeringHow to stream runnablesHow to stream responses from an LLMHow to use a time-weighted vector store retrieverHow to return artifacts from a toolHow to use chat models to call toolsHow to disable parallel tool callingHow to force models to call a toolHow to access the RunnableConfig from a toolHow to pass tool outputs to chat modelsHow to pass run time values to toolsHow to stream events from a toolHow to stream tool callsHow to convert tools to OpenAI FunctionsHow to handle tool errorsHow to use few-shot prompting with tool callingHow to add a human-in-the-loop for toolsHow to bind model-specific toolsHow to trim messagesHow to create and query vector storesConceptual guideAgentsArchitectureAsync programming with langchainCallbacksChat historyChat modelsDocument loadersEmbedding modelsEvaluationExample selectorsFew-shot promptingConceptual guideKey-value storesLangChain Expression Language (LCEL)MessagesMultimodalityOutput parsersPrompt TemplatesRetrieval augmented generation (RAG)RetrievalRetrieversRunnable interfaceStreamingStructured outputsTestingString-in, string-out llmsText splittersTokensTool callingToolsTracingVector storesWhy LangChain?Ecosystem\uf8ffü¶ú\uf8ffüõ†Ô∏è LangSmith\uf8ffü¶ú\uf8ffüï∏Ô∏è LangGraphVersionsv0.3v0.2Pydantic compatibilityMigrating from v0.0 chainsHow to migrate from v0.0 chainsMigrating from ConstitutionalChainMigrating from ConversationalChainMigrating from ConversationalRetrievalChainMigrating from LLMChainMigrating from LLMMathChainMigrating from LLMRouterChainMigrating from MapReduceDocumentsChainMigrating from MapRerankDocumentsChainMigrating from MultiPromptChainMigrating from RefineDocumentsChainMigrating from RetrievalQAMigrating from StuffDocumentsChainUpgrading to LangGraph memoryHow to migrate to LangGraph memoryHow to use BaseChatMessageHistory with LangGraphMigrating off ConversationBufferMemory or ConversationStringBufferMemoryMigrating off ConversationBufferWindowMemory or ConversationTokenBufferMemoryMigrating off ConversationSummaryMemory or ConversationSummaryBufferMemoryA Long-Term Memory AgentRelease policySecurity PolicyHow-to guidesHow to do "self-querying" retrievalOn this pageHow to do "self-querying" retrieval\ninfoHead to Integrations for documentation on vector stores with built-in support for self-querying.\nA self-querying retriever is one that, as the name suggests, has the ability to query itself. Specifically, given any natural language query, the retriever uses a query-constructing LLM chain to write a structured query and then applies that structured query to its underlying vector store. This allows the retriever to not only use the user-input query for semantic similarity comparison with the contents of stored documents but to also extract filters from the user query on the metadata of stored documents and to execute those filters.\n\nGet started‚Äã\nFor demonstration purposes we\'ll use a Chroma vector store. We\'ve created a small demo set of documents that contain summaries of movies.\nNote: The self-query retriever requires you to have lark package installed.\n%pip install --upgrade --quiet  lark langchain-chroma\nfrom langchain_chroma import Chromafrom langchain_core.documents import Documentfrom langchain_openai import OpenAIEmbeddingsdocs = [    Document(        page_content="A bunch of scientists bring back dinosaurs and mayhem breaks loose",        metadata={"year": 1993, "rating": 7.7, "genre": "science fiction"},    ),    Document(        page_content="Leo DiCaprio gets lost in a dream within a dream within a dream within a ...",        metadata={"year": 2010, "director": "Christopher Nolan", "rating": 8.2},    ),    Document(        page_content="A psychologist / detective gets lost in a series of dreams within dreams within dreams and Inception reused the idea",        metadata={"year": 2006, "director": "Satoshi Kon", "rating": 8.6},    ),    Document(        page_content="A bunch of normal-sized women are supremely wholesome and some men pine after them",        metadata={"year": 2019, "director": "Greta Gerwig", "rating": 8.3},    ),    Document(        page_content="Toys come alive and have a blast doing so",        metadata={"year": 1995, "genre": "animated"},    ),    Document(        page_content="Three men walk into the Zone, three men walk out of the Zone",        metadata={            "year": 1979,            "director": "Andrei Tarkovsky",            "genre": "thriller",            "rating": 9.9,        },    ),]vectorstore = Chroma.from_documents(docs, OpenAIEmbeddings())API Reference:Document | OpenAIEmbeddings\nCreating our self-querying retriever‚Äã\nNow we can instantiate our retriever. To do this we\'ll need to provide some information upfront about the metadata fields that our documents support and a short description of the document contents.\nfrom langchain.chains.query_constructor.schema import AttributeInfofrom langchain.retrievers.self_query.base import SelfQueryRetrieverfrom langchain_openai import ChatOpenAImetadata_field_info = [    AttributeInfo(        name="genre",        description="The genre of the movie. One of [\'science fiction\', \'comedy\', \'drama\', \'thriller\', \'romance\', \'action\', \'animated\']",        type="string",    ),    AttributeInfo(        name="year",        description="The year the movie was released",        type="integer",    ),    AttributeInfo(        name="director",        description="The name of the movie director",        type="string",    ),    AttributeInfo(        name="rating", description="A 1-10 rating for the movie", type="float"    ),]document_content_description = "Brief summary of a movie"llm = ChatOpenAI(temperature=0)retriever = SelfQueryRetriever.from_llm(    llm,    vectorstore,    document_content_description,    metadata_field_info,)API Reference:AttributeInfo | SelfQueryRetriever | ChatOpenAI\nTesting it out‚Äã\nAnd now we can actually try using our retriever!\n# This example only specifies a filterretriever.invoke("I want to watch a movie rated higher than 8.5")\n[Document(page_content=\'Three men walk into the Zone, three men walk out of the Zone\', metadata={\'director\': \'Andrei Tarkovsky\', \'genre\': \'thriller\', \'rating\': 9.9, \'year\': 1979}), Document(page_content=\'A psychologist / detective gets lost in a series of dreams within dreams within dreams and Inception reused the idea\', metadata={\'director\': \'Satoshi Kon\', \'rating\': 8.6, \'year\': 2006})]\n# This example specifies a query and a filterretriever.invoke("Has Greta Gerwig directed any movies about women")\n[Document(page_content=\'A bunch of normal-sized women are supremely wholesome and some men pine after them\', metadata={\'director\': \'Greta Gerwig\', \'rating\': 8.3, \'year\': 2019})]\n# This example specifies a composite filterretriever.invoke("What\'s a highly rated (above 8.5) science fiction film?")\n[Document(page_content=\'A psychologist / detective gets lost in a series of dreams within dreams within dreams and Inception reused the idea\', metadata={\'director\': \'Satoshi Kon\', \'rating\': 8.6, \'year\': 2006}), Document(page_content=\'Three men walk into the Zone, three men walk out of the Zone\', metadata={\'director\': \'Andrei Tarkovsky\', \'genre\': \'thriller\', \'rating\': 9.9, \'year\': 1979})]\n# This example specifies a query and composite filterretriever.invoke(    "What\'s a movie after 1990 but before 2005 that\'s all about toys, and preferably is animated")\n[Document(page_content=\'Toys come alive and have a blast doing so\', metadata={\'genre\': \'animated\', \'year\': 1995})]\nFilter k‚Äã\nWe can also use the self query retriever to specify k: the number of documents to fetch.\nWe can do this by passing enable_limit=True to the constructor.\nretriever = SelfQueryRetriever.from_llm(    llm,    vectorstore,    document_content_description,    metadata_field_info,    enable_limit=True,)# This example only specifies a relevant queryretriever.invoke("What are two movies about dinosaurs")\n[Document(page_content=\'A bunch of scientists bring back dinosaurs and mayhem breaks loose\', metadata={\'genre\': \'science fiction\', \'rating\': 7.7, \'year\': 1993}), Document(page_content=\'Toys come alive and have a blast doing so\', metadata={\'genre\': \'animated\', \'year\': 1995})]\nConstructing from scratch with LCEL‚Äã\nTo see what\'s going on under the hood, and to have more custom control, we can reconstruct our retriever from scratch.\nFirst, we need to create a query-construction chain. This chain will take a user query and generated a StructuredQuery object which captures the filters specified by the user. We provide some helper functions for creating a prompt and output parser. These have a number of tunable params that we\'ll ignore here for simplicity.\nfrom langchain.chains.query_constructor.base import (    StructuredQueryOutputParser,    get_query_constructor_prompt,)prompt = get_query_constructor_prompt(    document_content_description,    metadata_field_info,)output_parser = StructuredQueryOutputParser.from_components()query_constructor = prompt | llm | output_parserAPI Reference:StructuredQueryOutputParser | get_query_constructor_prompt\nLet\'s look at our prompt:\nprint(prompt.format(query="dummy question"))\nYour goal is to structure the user\'s query to match the request schema provided below.&lt;&lt; Structured Request Schema &gt;&gt;When responding use a markdown code snippet with a JSON object formatted in the following schema:\\`\\`\\`json{    "query": string \\ text string to compare to document contents    "filter": string \\ logical condition statement for filtering documents}\\`\\`\\`The query string should contain only text that is expected to match the contents of documents. Any conditions in the filter should not be mentioned in the query as well.A logical condition statement is composed of one or more comparison and logical operation statements.A comparison statement takes the form: `comp(attr, val)`:- `comp` (eq | ne | gt | gte | lt | lte | contain | like | in | nin): comparator- `attr` (string):  name of attribute to apply the comparison to- `val` (string): is the comparison valueA logical operation statement takes the form `op(statement1, statement2, ...)`:- `op` (and | or | not): logical operator- `statement1`, `statement2`, ... (comparison statements or logical operation statements): one or more statements to apply the operation toMake sure that you only use the comparators and logical operators listed above and no others.Make sure that filters only refer to attributes that exist in the data source.Make sure that filters only use the attributed names with its function names if there are functions applied on them.Make sure that filters only use format `YYYY-MM-DD` when handling date data typed values.Make sure that filters take into account the descriptions of attributes and only make comparisons that are feasible given the type of data being stored.Make sure that filters are only used as needed. If there are no filters that should be applied return "NO_FILTER" for the filter value.&lt;&lt; Example 1. &gt;&gt;Data Source:\\`\\`\\`json{    "content": "Lyrics of a song",    "attributes": {        "artist": {            "type": "string",            "description": "Name of the song artist"        },        "length": {            "type": "integer",            "description": "Length of the song in seconds"        },        "genre": {            "type": "string",            "description": "The song genre, one of "pop", "rock" or "rap""        }    }}\\`\\`\\`User Query:What are songs by Taylor Swift or Katy Perry about teenage romance under 3 minutes long in the dance pop genreStructured Request:\\`\\`\\`json{    "query": "teenager love",    "filter": "and(or(eq(\\"artist\\", \\"Taylor Swift\\"), eq(\\"artist\\", \\"Katy Perry\\")), lt(\\"length\\", 180), eq(\\"genre\\", \\"pop\\"))"}\\`\\`\\`&lt;&lt; Example 2. &gt;&gt;Data Source:\\`\\`\\`json{    "content": "Lyrics of a song",    "attributes": {        "artist": {            "type": "string",            "description": "Name of the song artist"        },        "length": {            "type": "integer",            "description": "Length of the song in seconds"        },        "genre": {            "type": "string",            "description": "The song genre, one of "pop", "rock" or "rap""        }    }}\\`\\`\\`User Query:What are songs that were not published on SpotifyStructured Request:\\`\\`\\`json{    "query": "",    "filter": "NO_FILTER"}\\`\\`\\`&lt;&lt; Example 3. &gt;&gt;Data Source:\\`\\`\\`json{    "content": "Brief summary of a movie",    "attributes": {    "genre": {        "description": "The genre of the movie. One of [\'science fiction\', \'comedy\', \'drama\', \'thriller\', \'romance\', \'action\', \'animated\']",        "type": "string"    },    "year": {        "description": "The year the movie was released",        "type": "integer"    },    "director": {        "description": "The name of the movie director",        "type": "string"    },    "rating": {        "description": "A 1-10 rating for the movie",        "type": "float"    }}}\\`\\`\\`User Query:dummy questionStructured Request:\nAnd what our full chain produces:\nquery_constructor.invoke(    {        "query": "What are some sci-fi movies from the 90\'s directed by Luc Besson about taxi drivers"    })\nStructuredQuery(query=\'taxi driver\', filter=Operation(operator=&lt;Operator.AND: \'and\'&gt;, arguments=[Comparison(comparator=&lt;Comparator.EQ: \'eq\'&gt;, attribute=\'genre\', value=\'science fiction\'), Operation(operator=&lt;Operator.AND: \'and\'&gt;, arguments=[Comparison(comparator=&lt;Comparator.GTE: \'gte\'&gt;, attribute=\'year\', value=1990), Comparison(comparator=&lt;Comparator.LT: \'lt\'&gt;, attribute=\'year\', value=2000)]), Comparison(comparator=&lt;Comparator.EQ: \'eq\'&gt;, attribute=\'director\', value=\'Luc Besson\')]), limit=None)\nThe query constructor is the key element of the self-query retriever. To make a great retrieval system you\'ll need to make sure your query constructor works well. Often this requires adjusting the prompt, the examples in the prompt, the attribute descriptions, etc. For an example that walks through refining a query constructor on some hotel inventory data, check out this cookbook.\nThe next key element is the structured query translator. This is the object responsible for translating the generic StructuredQuery object into a metadata filter in the syntax of the vector store you\'re using. LangChain comes with a number of built-in translators. To see them all head to the Integrations section.\nfrom langchain_community.query_constructors.chroma import ChromaTranslatorretriever = SelfQueryRetriever(    query_constructor=query_constructor,    vectorstore=vectorstore,    structured_query_translator=ChromaTranslator(),)API Reference:ChromaTranslator\nretriever.invoke(    "What\'s a movie after 1990 but before 2005 that\'s all about toys, and preferably is animated")\n[Document(page_content=\'Toys come alive and have a blast doing so\', metadata={\'genre\': \'animated\', \'year\': 1995})]Edit this pageWas this page helpful?PreviousHow to pass runtime secrets to runnablesNextHow to split text based on semantic similarityGet startedCreating our self-querying retrieverTesting it outFilter kConstructing from scratch with LCELCommunityTwitterGitHubOrganizationPythonJS/TSMoreHomepageBlogYouTubeCopyright ¬© 2024 LangChain, Inc.\n\n']</code></pre>
</div>
</div>
<div id="fbd18b8a" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain_community.vectorstores <span class="im">import</span> FAISS</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>all_texts <span class="op">=</span> leaf_texts.copy()</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 레벨을 정렬하여 순회</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> level <span class="kw">in</span> <span class="bu">sorted</span>(results.keys()):</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 현재 레벨의 DataFrame에서 요약을 추출</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    summaries <span class="op">=</span> results[level][<span class="dv">1</span>][<span class="st">"summaries"</span>].tolist()</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 현재 레벨의 요약을 all_texts에 추가합니다.</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    all_texts.extend(summaries)</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 이제 all_texts를 사용하여 FAISS vectorstore를 구축합니다.</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>vectorstore <span class="op">=</span> FAISS.from_texts(texts<span class="op">=</span>all_texts, embedding<span class="op">=</span>embeddings)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>DB 를 로컬에 저장합니다.</p>
<div id="15f67a9f" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>DB_INDEX <span class="op">=</span> <span class="st">"RAPTOR"</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 기존 DB 인덱스가 존재하면 로드하여 vectorstore와 병합한 후 저장합니다.</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> os.path.exists(DB_INDEX):</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    local_index <span class="op">=</span> FAISS.load_local(DB_INDEX, embeddings)</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    local_index.merge_from(vectorstore)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    local_index.save_local(DB_INDEX)</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    vectorstore.save_local(folder_path<span class="op">=</span>DB_INDEX)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>vectorstore</code> 로부터 <code>retriever</code>를 생성합니다.</p>
<div id="398b4dab" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># retriever 생성</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>retriever <span class="op">=</span> vectorstore.as_retriever()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="rag-체인-정의" class="level2">
<h2 class="anchored" data-anchor-id="rag-체인-정의">RAG 체인 정의</h2>
<p>이제 생성된 vectorstore를 이용해 RAG 체인을 정의하고 실행하여 결과를 확인합니다.</p>
<div id="a9c26dc6" class="cell" data-execution_count="87">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain <span class="im">import</span> hub</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain_core.runnables <span class="im">import</span> RunnablePassthrough</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> langchain_core.prompts <span class="im">import</span> PromptTemplate</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 프롬프트 정의</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>prompt <span class="op">=</span> PromptTemplate.from_template(</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"""</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="st">    You are an Code copilot assistant specializing in Code based Question-Answering (QA) tasks within a Retrieval-Augmented Generation (RAG) system. </span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="st">You are given LangChain documentation. Your primary mission is to answer questions based on provided context.</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="st">Ensure your response is concise and directly addresses the question without any additional narration.</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a><span class="st">###</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a><span class="st">Your final answer should be written concisely (but include important numerical values, technical terms, jargon, and names).</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="st"># Steps</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a><span class="st">1. Carefully read and understand the context provided.</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a><span class="st">2. Identify the key information related to the question within the context.</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a><span class="st">3. Formulate a concise answer based on the relevant information.</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a><span class="st">4. Ensure your final answer directly addresses the question.</span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a><span class="st">5. Be sure to include full example code if the question is about code.</span></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a><span class="st"># Output Format:</span></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a><span class="st">[General introduction of the answer]</span></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a><span class="st">[Comprehensive answer to the question including code example]</span></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a><span class="st">###</span></span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a><span class="st">Remember:</span></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a><span class="st">- It's crucial to base your answer solely on the **PROVIDED CONTEXT**. </span></span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a><span class="st">- DO NOT use any external knowledge or information not present in the given materials.</span></span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a><span class="st">###</span></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a><span class="st"># Here is the user's QUESTION that you should answer:</span></span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a><span class="sc">{question}</span></span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-39"><a href="#cb29-39" aria-hidden="true" tabindex="-1"></a><span class="st"># Here is the CONTEXT that you should use to answer the question:</span></span>
<span id="cb29-40"><a href="#cb29-40" aria-hidden="true" tabindex="-1"></a><span class="sc">{context}</span></span>
<span id="cb29-41"><a href="#cb29-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-42"><a href="#cb29-42" aria-hidden="true" tabindex="-1"></a><span class="st">[Note]</span></span>
<span id="cb29-43"><a href="#cb29-43" aria-hidden="true" tabindex="-1"></a><span class="st">- Answer should be written in Korean.</span></span>
<span id="cb29-44"><a href="#cb29-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-45"><a href="#cb29-45" aria-hidden="true" tabindex="-1"></a><span class="st"># Your final ANSWER to the user's QUESTION:"""</span></span>
<span id="cb29-46"><a href="#cb29-46" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb29-47"><a href="#cb29-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-48"><a href="#cb29-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-49"><a href="#cb29-49" aria-hidden="true" tabindex="-1"></a><span class="co"># 문서 포맷팅</span></span>
<span id="cb29-50"><a href="#cb29-50" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> format_docs(docs):</span>
<span id="cb29-51"><a href="#cb29-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>.join(<span class="ss">f"&lt;document&gt;</span><span class="sc">{</span>doc<span class="sc">.</span>page_content<span class="sc">}</span><span class="ss">&lt;/document&gt;"</span> <span class="cf">for</span> doc <span class="kw">in</span> docs)</span>
<span id="cb29-52"><a href="#cb29-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-53"><a href="#cb29-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-54"><a href="#cb29-54" aria-hidden="true" tabindex="-1"></a><span class="co"># RAG 체인 정의</span></span>
<span id="cb29-55"><a href="#cb29-55" aria-hidden="true" tabindex="-1"></a>rag_chain <span class="op">=</span> (</span>
<span id="cb29-56"><a href="#cb29-56" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"context"</span>: retriever <span class="op">|</span> format_docs, <span class="st">"question"</span>: RunnablePassthrough()}</span>
<span id="cb29-57"><a href="#cb29-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> prompt</span>
<span id="cb29-58"><a href="#cb29-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> llm</span>
<span id="cb29-59"><a href="#cb29-59" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> StrOutputParser()</span>
<span id="cb29-60"><a href="#cb29-60" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><a href="https://smith.langchain.com/public/3e459bd4-4265-4c1d-b43d-279a1204d983/r">LangSmith 링크</a></p>
<div id="e0efdda7" class="cell" data-execution_count="88">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 추상적인 질문 실행</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>answer <span class="op">=</span> rag_chain.stream(<span class="st">"전체 문서의 핵심 주제에 대해 설명해주세요."</span>)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>stream_response(answer)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>LangChain Expression Language (LCEL)의 핵심 주제는 LangChain 생태계 내에서 체인 또는 "Runnable"의 실행을 구성하고 최적화하는 선언적 프레임워크입니다. LCEL은 사용자가 체인에서 무엇을 해야 하는지를 정의할 수 있게 하여 LangChain이 실행 시간을 최적화할 수 있도록 합니다. 이는 병렬 처리나 비동기 실행이 필요한 작업에 특히 유용하며, RunnableParallel 및 Runnable Async API를 통해 이를 지원합니다. LCEL은 병렬 실행, 스트리밍, 관찰 가능성, 표준 API를 제공하며, 간단한 체인 구성 및 복잡한 체인 내 개별 노드에서 사용될 수 있습니다.</code></pre>
</div>
</div>
<p><a href="https://smith.langchain.com/public/c29887c7-f005-450a-a747-7d932c753721/r">LangSmith 링크</a></p>
<div id="6e8193fb" class="cell" data-execution_count="89">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Low Level 질문 실행</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>answer <span class="op">=</span> rag_chain.stream(<span class="st">"self-querying 방법과 예시 코드를 작성해 주세요."</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>stream_response(answer)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>self-querying 방법은 자연어 쿼리를 받아 구조화된 쿼리를 작성하고 이를 벡터 저장소에 적용하여 문서의 메타데이터를 필터링하는 기능을 제공합니다. 아래는 self-querying을 구현하는 예시 코드입니다.

```python
# 필요한 패키지 설치
%pip install --upgrade --quiet lark langchain-chroma

from langchain_chroma import Chroma
from langchain_core.documents import Document
from langchain_openai import OpenAIEmbeddings
from langchain.chains.query_constructor.schema import AttributeInfo
from langchain.retrievers.self_query.base import SelfQueryRetriever
from langchain_openai import ChatOpenAI

# 문서 데이터 생성
docs = [
    Document(
        page_content="A bunch of scientists bring back dinosaurs and mayhem breaks loose",
        metadata={"year": 1993, "rating": 7.7, "genre": "science fiction"},
    ),
    Document(
        page_content="Leo DiCaprio gets lost in a dream within a dream within a dream within a ...",
        metadata={"year": 2010, "director": "Christopher Nolan", "rating": 8.2},
    ),
    # 추가 문서들...
]

# 벡터 저장소 생성
vectorstore = Chroma.from_documents(docs, OpenAIEmbeddings())

# 메타데이터 필드 정보 설정
metadata_field_info = [
    AttributeInfo(
        name="genre",
        description="The genre of the movie. One of ['science fiction', 'comedy', 'drama', 'thriller', 'romance', 'action', 'animated']",
        type="string",
    ),
    AttributeInfo(
        name="year",
        description="The year the movie was released",
        type="integer",
    ),
    AttributeInfo(
        name="director",
        description="The name of the movie director",
        type="string",
    ),
    AttributeInfo(
        name="rating", description="A 1-10 rating for the movie", type="float"
    ),
]

# 문서 내용 설명
document_content_description = "Brief summary of a movie"

# LLM 설정
llm = ChatOpenAI(temperature=0)

# SelfQueryRetriever 생성
retriever = SelfQueryRetriever.from_llm(
    llm,
    vectorstore,
    document_content_description,
    metadata_field_info,
)

# 쿼리 실행 예시
print(retriever.invoke("I want to watch a movie rated higher than 8.5"))
print(retriever.invoke("Has Greta Gerwig directed any movies about women"))
```

이 코드는 self-querying retriever를 설정하고, 사용자가 입력한 자연어 쿼리를 기반으로 문서의 메타데이터를 필터링하여 관련 문서를 검색하는 방법을 보여줍니다.</code></pre>
</div>
</div>
<div id="52666307" class="cell" data-execution_count="90">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Low Level 질문 실행</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>answer <span class="op">=</span> rag_chain.stream(<span class="st">"PydanticOutputParser 을 활용한 예시 코드를 작성해 주세요."</span>)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>stream_response(answer)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>PydanticOutputParser를 활용한 예시 코드는 다음과 같습니다. 이 코드는 Pydantic 모델을 사용하여 LLM의 출력을 구조화된 데이터로 파싱하는 방법을 보여줍니다.

```python
from pydantic import BaseModel
from langchain_core.output_parsers import PydanticOutputParser

# Pydantic 모델 정의
class MyModel(BaseModel):
    name: str
    age: int

# PydanticOutputParser 인스턴스 생성
parser = PydanticOutputParser(pydantic_object=MyModel)

# LLM의 출력 예시
llm_output = '{"name": "John Doe", "age": 30}'

# 출력 파싱
parsed_output = parser.parse(llm_output)

print(parsed_output)
```

이 코드는 `MyModel`이라는 Pydantic 모델을 정의하고, `PydanticOutputParser`를 사용하여 LLM의 JSON 형식 출력을 `MyModel` 객체로 파싱합니다.</code></pre>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>