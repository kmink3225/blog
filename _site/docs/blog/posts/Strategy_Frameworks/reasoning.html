<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="연역적, 귀납적, 가추적 추론 등 10가지 주요 추론 방법론을 체계적으로 정리한다. 각 추론 방식의 정의, 특징, 적용 사례를 통해 논리적 사고의 기초를 다지고, AI 시스템, 프롬프트 엔지니어링, 데이터 분석에서 어떻게 활용되는지 설명한다. 스탠포드 철학 백과사전(Stanford Encyclopedia of Philosophy)을 비롯한 권위 있는 학술 자료를 근거로 각 방법론의 이론적 배경을 제공한다.">

<title>Kwangmin Kim - 추론 방법론 체계</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - 추론 방법론 체계">
<meta property="og:description" content="연역적, 귀납적, 가추적 추론 등 10가지 주요 추론 방법론을 체계적으로 정리한다. 각 추론 방식의 정의, 특징, 적용 사례를 통해 논리적 사고의 기초를 다지고, AI 시스템, 프롬프트 엔지니어링, 데이터 분석에서 어떻게 활용되는지 설명한다. 스탠포드 철학 백과사전(Stanford Encyclopedia of Philosophy)을 비롯한 권위 있는 학술 자료를 근거로 각 방법론의 이론적 배경을 제공한다.">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Kwangmin Kim - 추론 방법론 체계">
<meta name="twitter:description" content="연역적, 귀납적, 가추적 추론 등 10가지 주요 추론 방법론을 체계적으로 정리한다. 각 추론 방식의 정의, 특징, 적용 사례를 통해 논리적 사고의 기초를 다지고, AI 시스템, 프롬프트 엔지니어링, 데이터 분석에서 어떻게 활용되는지 설명한다. 스탠포드 철학 백과사전(Stanford Encyclopedia of Philosophy)을 비롯한 권위 있는 학술 자료를 근거로 각 방법론의 이론적 배경을 제공한다.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">추론 방법론 체계</h1>
            <p class="subtitle lead">논리적 사고의 유형과 AI 시스템 적용</p>
                  <div>
        <div class="description">
          <p>연역적, 귀납적, 가추적 추론 등 10가지 주요 추론 방법론을 체계적으로 정리한다. 각 추론 방식의 정의, 특징, 적용 사례를 통해 논리적 사고의 기초를 다지고, AI 시스템, 프롬프트 엔지니어링, 데이터 분석에서 어떻게 활용되는지 설명한다. 스탠포드 철학 백과사전(Stanford Encyclopedia of Philosophy)을 비롯한 권위 있는 학술 자료를 근거로 각 방법론의 이론적 배경을 제공한다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Strategy Frameworks</div>
                <div class="quarto-category">Data Science</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2025년 12월 11일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#배경" id="toc-배경" class="nav-link active" data-scroll-target="#배경"><span class="header-section-number">1</span> 배경</a></li>
  <li><a href="#연역적-추론deductive-reasoning" id="toc-연역적-추론deductive-reasoning" class="nav-link" data-scroll-target="#연역적-추론deductive-reasoning"><span class="header-section-number">2</span> 연역적 추론(Deductive Reasoning)</a>
  <ul class="collapse">
  <li><a href="#정의" id="toc-정의" class="nav-link" data-scroll-target="#정의"><span class="header-section-number">2.1</span> 정의</a></li>
  <li><a href="#특징" id="toc-특징" class="nav-link" data-scroll-target="#특징"><span class="header-section-number">2.2</span> 특징</a></li>
  <li><a href="#예시" id="toc-예시" class="nav-link" data-scroll-target="#예시"><span class="header-section-number">2.3</span> 예시</a></li>
  <li><a href="#연역-추론의-하위-기법" id="toc-연역-추론의-하위-기법" class="nav-link" data-scroll-target="#연역-추론의-하위-기법"><span class="header-section-number">2.4</span> 연역 추론의 하위 기법</a></li>
  <li><a href="#ai-시스템-적용" id="toc-ai-시스템-적용" class="nav-link" data-scroll-target="#ai-시스템-적용"><span class="header-section-number">2.5</span> AI 시스템 적용</a></li>
  <li><a href="#근거" id="toc-근거" class="nav-link" data-scroll-target="#근거"><span class="header-section-number">2.6</span> 근거</a></li>
  </ul></li>
  <li><a href="#귀납적-추론inductive-reasoning" id="toc-귀납적-추론inductive-reasoning" class="nav-link" data-scroll-target="#귀납적-추론inductive-reasoning"><span class="header-section-number">3</span> 귀납적 추론(Inductive Reasoning)</a>
  <ul class="collapse">
  <li><a href="#정의-1" id="toc-정의-1" class="nav-link" data-scroll-target="#정의-1"><span class="header-section-number">3.1</span> 정의</a></li>
  <li><a href="#특징-1" id="toc-특징-1" class="nav-link" data-scroll-target="#특징-1"><span class="header-section-number">3.2</span> 특징</a></li>
  <li><a href="#예시-1" id="toc-예시-1" class="nav-link" data-scroll-target="#예시-1"><span class="header-section-number">3.3</span> 예시</a></li>
  <li><a href="#귀납적-추론의-하위-기법" id="toc-귀납적-추론의-하위-기법" class="nav-link" data-scroll-target="#귀납적-추론의-하위-기법"><span class="header-section-number">3.4</span> 귀납적 추론의 하위 기법</a></li>
  <li><a href="#ai-시스템-적용-1" id="toc-ai-시스템-적용-1" class="nav-link" data-scroll-target="#ai-시스템-적용-1"><span class="header-section-number">3.5</span> AI 시스템 적용</a></li>
  <li><a href="#근거-1" id="toc-근거-1" class="nav-link" data-scroll-target="#근거-1"><span class="header-section-number">3.6</span> 근거</a></li>
  </ul></li>
  <li><a href="#가추적-추론abductive-reasoning" id="toc-가추적-추론abductive-reasoning" class="nav-link" data-scroll-target="#가추적-추론abductive-reasoning"><span class="header-section-number">4</span> 가추적 추론(Abductive Reasoning)</a>
  <ul class="collapse">
  <li><a href="#정의-2" id="toc-정의-2" class="nav-link" data-scroll-target="#정의-2"><span class="header-section-number">4.1</span> 정의</a></li>
  <li><a href="#특징-2" id="toc-특징-2" class="nav-link" data-scroll-target="#특징-2"><span class="header-section-number">4.2</span> 특징</a></li>
  <li><a href="#예시-2" id="toc-예시-2" class="nav-link" data-scroll-target="#예시-2"><span class="header-section-number">4.3</span> 예시</a></li>
  <li><a href="#가추적-추론의-하위-기법" id="toc-가추적-추론의-하위-기법" class="nav-link" data-scroll-target="#가추적-추론의-하위-기법"><span class="header-section-number">4.4</span> 가추적 추론의 하위 기법</a></li>
  <li><a href="#ai-시스템-적용-2" id="toc-ai-시스템-적용-2" class="nav-link" data-scroll-target="#ai-시스템-적용-2"><span class="header-section-number">4.5</span> AI 시스템 적용</a></li>
  <li><a href="#근거-2" id="toc-근거-2" class="nav-link" data-scroll-target="#근거-2"><span class="header-section-number">4.6</span> 근거</a></li>
  </ul></li>
  <li><a href="#유추적-추론analogical-reasoning" id="toc-유추적-추론analogical-reasoning" class="nav-link" data-scroll-target="#유추적-추론analogical-reasoning"><span class="header-section-number">5</span> 유추적 추론(Analogical Reasoning)</a>
  <ul class="collapse">
  <li><a href="#정의-3" id="toc-정의-3" class="nav-link" data-scroll-target="#정의-3"><span class="header-section-number">5.1</span> 정의</a></li>
  <li><a href="#특징-3" id="toc-특징-3" class="nav-link" data-scroll-target="#특징-3"><span class="header-section-number">5.2</span> 특징</a></li>
  <li><a href="#예시-3" id="toc-예시-3" class="nav-link" data-scroll-target="#예시-3"><span class="header-section-number">5.3</span> 예시</a></li>
  <li><a href="#유추적-추론의-하위-기법" id="toc-유추적-추론의-하위-기법" class="nav-link" data-scroll-target="#유추적-추론의-하위-기법"><span class="header-section-number">5.4</span> 유추적 추론의 하위 기법</a></li>
  <li><a href="#ai-시스템-적용-3" id="toc-ai-시스템-적용-3" class="nav-link" data-scroll-target="#ai-시스템-적용-3"><span class="header-section-number">5.5</span> AI 시스템 적용</a></li>
  <li><a href="#근거-3" id="toc-근거-3" class="nav-link" data-scroll-target="#근거-3"><span class="header-section-number">5.6</span> 근거</a></li>
  </ul></li>
  <li><a href="#확률적-추론probabilistic-reasoning" id="toc-확률적-추론probabilistic-reasoning" class="nav-link" data-scroll-target="#확률적-추론probabilistic-reasoning"><span class="header-section-number">6</span> 확률적 추론(Probabilistic Reasoning)</a>
  <ul class="collapse">
  <li><a href="#정의-4" id="toc-정의-4" class="nav-link" data-scroll-target="#정의-4"><span class="header-section-number">6.1</span> 정의</a></li>
  <li><a href="#특징-4" id="toc-특징-4" class="nav-link" data-scroll-target="#특징-4"><span class="header-section-number">6.2</span> 특징</a></li>
  <li><a href="#예시-4" id="toc-예시-4" class="nav-link" data-scroll-target="#예시-4"><span class="header-section-number">6.3</span> 예시</a></li>
  <li><a href="#확률적-추론의-하위-기법" id="toc-확률적-추론의-하위-기법" class="nav-link" data-scroll-target="#확률적-추론의-하위-기법"><span class="header-section-number">6.4</span> 확률적 추론의 하위 기법</a></li>
  <li><a href="#ai-시스템-적용-4" id="toc-ai-시스템-적용-4" class="nav-link" data-scroll-target="#ai-시스템-적용-4"><span class="header-section-number">6.5</span> AI 시스템 적용</a></li>
  <li><a href="#근거-4" id="toc-근거-4" class="nav-link" data-scroll-target="#근거-4"><span class="header-section-number">6.6</span> 근거</a></li>
  </ul></li>
  <li><a href="#통계적-추론statistical-inference" id="toc-통계적-추론statistical-inference" class="nav-link" data-scroll-target="#통계적-추론statistical-inference"><span class="header-section-number">7</span> 통계적 추론(Statistical Inference)</a>
  <ul class="collapse">
  <li><a href="#정의-5" id="toc-정의-5" class="nav-link" data-scroll-target="#정의-5"><span class="header-section-number">7.1</span> 정의</a></li>
  <li><a href="#특징-5" id="toc-특징-5" class="nav-link" data-scroll-target="#특징-5"><span class="header-section-number">7.2</span> 특징</a></li>
  <li><a href="#예시-5" id="toc-예시-5" class="nav-link" data-scroll-target="#예시-5"><span class="header-section-number">7.3</span> 예시</a></li>
  <li><a href="#통계적-추론의-하위-기법" id="toc-통계적-추론의-하위-기법" class="nav-link" data-scroll-target="#통계적-추론의-하위-기법"><span class="header-section-number">7.4</span> 통계적 추론의 하위 기법</a></li>
  <li><a href="#ai-시스템-적용-5" id="toc-ai-시스템-적용-5" class="nav-link" data-scroll-target="#ai-시스템-적용-5"><span class="header-section-number">7.5</span> AI 시스템 적용</a></li>
  <li><a href="#근거-5" id="toc-근거-5" class="nav-link" data-scroll-target="#근거-5"><span class="header-section-number">7.6</span> 근거</a></li>
  </ul></li>
  <li><a href="#규범적규칙-기반-추론rule-based-reasoning" id="toc-규범적규칙-기반-추론rule-based-reasoning" class="nav-link" data-scroll-target="#규범적규칙-기반-추론rule-based-reasoning"><span class="header-section-number">8</span> 규범적·규칙 기반 추론(Rule-based Reasoning)</a>
  <ul class="collapse">
  <li><a href="#정의-6" id="toc-정의-6" class="nav-link" data-scroll-target="#정의-6"><span class="header-section-number">8.1</span> 정의</a></li>
  <li><a href="#특징-6" id="toc-특징-6" class="nav-link" data-scroll-target="#특징-6"><span class="header-section-number">8.2</span> 특징</a></li>
  <li><a href="#예시-6" id="toc-예시-6" class="nav-link" data-scroll-target="#예시-6"><span class="header-section-number">8.3</span> 예시</a></li>
  <li><a href="#규칙-기반-추론의-하위-기법" id="toc-규칙-기반-추론의-하위-기법" class="nav-link" data-scroll-target="#규칙-기반-추론의-하위-기법"><span class="header-section-number">8.4</span> 규칙 기반 추론의 하위 기법</a></li>
  <li><a href="#ai-시스템-적용-6" id="toc-ai-시스템-적용-6" class="nav-link" data-scroll-target="#ai-시스템-적용-6"><span class="header-section-number">8.5</span> AI 시스템 적용</a></li>
  <li><a href="#근거-6" id="toc-근거-6" class="nav-link" data-scroll-target="#근거-6"><span class="header-section-number">8.6</span> 근거</a></li>
  </ul></li>
  <li><a href="#사례-기반-추론case-based-reasoning-cbr" id="toc-사례-기반-추론case-based-reasoning-cbr" class="nav-link" data-scroll-target="#사례-기반-추론case-based-reasoning-cbr"><span class="header-section-number">9</span> 사례 기반 추론(Case-based Reasoning, CBR)</a>
  <ul class="collapse">
  <li><a href="#정의-7" id="toc-정의-7" class="nav-link" data-scroll-target="#정의-7"><span class="header-section-number">9.1</span> 정의</a></li>
  <li><a href="#특징-7" id="toc-특징-7" class="nav-link" data-scroll-target="#특징-7"><span class="header-section-number">9.2</span> 특징</a></li>
  <li><a href="#사례-기반-추론의-하위-기법-cbr-사이클---4rs" id="toc-사례-기반-추론의-하위-기법-cbr-사이클---4rs" class="nav-link" data-scroll-target="#사례-기반-추론의-하위-기법-cbr-사이클---4rs"><span class="header-section-number">9.3</span> 사례 기반 추론의 하위 기법 (CBR 사이클 - 4Rs)</a></li>
  <li><a href="#예시-7" id="toc-예시-7" class="nav-link" data-scroll-target="#예시-7"><span class="header-section-number">9.4</span> 예시</a></li>
  <li><a href="#ai-시스템-적용-7" id="toc-ai-시스템-적용-7" class="nav-link" data-scroll-target="#ai-시스템-적용-7"><span class="header-section-number">9.5</span> AI 시스템 적용</a></li>
  <li><a href="#근거-7" id="toc-근거-7" class="nav-link" data-scroll-target="#근거-7"><span class="header-section-number">9.6</span> 근거</a></li>
  </ul></li>
  <li><a href="#전제-수정-기반-추론non-monotonic-reasoning" id="toc-전제-수정-기반-추론non-monotonic-reasoning" class="nav-link" data-scroll-target="#전제-수정-기반-추론non-monotonic-reasoning"><span class="header-section-number">10</span> 전제 수정 기반 추론(Non-monotonic Reasoning)</a>
  <ul class="collapse">
  <li><a href="#정의-8" id="toc-정의-8" class="nav-link" data-scroll-target="#정의-8"><span class="header-section-number">10.1</span> 정의</a></li>
  <li><a href="#특징-8" id="toc-특징-8" class="nav-link" data-scroll-target="#특징-8"><span class="header-section-number">10.2</span> 특징</a></li>
  <li><a href="#예시-8" id="toc-예시-8" class="nav-link" data-scroll-target="#예시-8"><span class="header-section-number">10.3</span> 예시</a></li>
  <li><a href="#전제-수정-기반-추론의-하위-기법" id="toc-전제-수정-기반-추론의-하위-기법" class="nav-link" data-scroll-target="#전제-수정-기반-추론의-하위-기법"><span class="header-section-number">10.4</span> 전제 수정 기반 추론의 하위 기법</a></li>
  <li><a href="#ai-시스템-적용-8" id="toc-ai-시스템-적용-8" class="nav-link" data-scroll-target="#ai-시스템-적용-8"><span class="header-section-number">10.5</span> AI 시스템 적용</a></li>
  <li><a href="#근거-8" id="toc-근거-8" class="nav-link" data-scroll-target="#근거-8"><span class="header-section-number">10.6</span> 근거</a></li>
  </ul></li>
  <li><a href="#형식-논리-기반-추론formal-logic-reasoning" id="toc-형식-논리-기반-추론formal-logic-reasoning" class="nav-link" data-scroll-target="#형식-논리-기반-추론formal-logic-reasoning"><span class="header-section-number">11</span> 형식 논리 기반 추론(Formal Logic Reasoning)</a>
  <ul class="collapse">
  <li><a href="#정의-9" id="toc-정의-9" class="nav-link" data-scroll-target="#정의-9"><span class="header-section-number">11.1</span> 정의</a></li>
  <li><a href="#주요-논리-체계" id="toc-주요-논리-체계" class="nav-link" data-scroll-target="#주요-논리-체계"><span class="header-section-number">11.2</span> 주요 논리 체계</a></li>
  <li><a href="#ai-시스템-적용-9" id="toc-ai-시스템-적용-9" class="nav-link" data-scroll-target="#ai-시스템-적용-9"><span class="header-section-number">11.3</span> AI 시스템 적용</a></li>
  <li><a href="#근거-9" id="toc-근거-9" class="nav-link" data-scroll-target="#근거-9"><span class="header-section-number">11.4</span> 근거</a></li>
  </ul></li>
  <li><a href="#추론-방법론-비교표" id="toc-추론-방법론-비교표" class="nav-link" data-scroll-target="#추론-방법론-비교표"><span class="header-section-number">12</span> 추론 방법론 비교표</a></li>
  <li><a href="#결론" id="toc-결론" class="nav-link" data-scroll-target="#결론"><span class="header-section-number">13</span> 결론</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="배경" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="배경"><span class="header-section-number">1</span> 배경</h2>
<p><strong>추론(Reasoning)</strong>은 주어진 정보나 전제로부터 새로운 결론을 도출하는 인지 과정이다.<br>
인간의 의사결정, 문제해결, 과학적 발견의 핵심이며, AI 시스템 설계에서도 필수적이다.</p>
<p><strong>추론 방법론이 중요한 이유:</strong><br>
- 논리적 오류를 방지하고 체계적인 사고 가능<br>
- 데이터 분석과 가설 검증의 이론적 기반 제공<br>
- AI 모델의 추론 과정 이해 및 프롬프트 설계 개선<br>
- 비즈니스 의사결정에서 근거 기반 전략 수립</p>
</section>
<section id="연역적-추론deductive-reasoning" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="연역적-추론deductive-reasoning"><span class="header-section-number">2</span> 연역적 추론(Deductive Reasoning)</h2>
<section id="정의" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="정의"><span class="header-section-number">2.1</span> 정의</h3>
<p><strong>전제가 참이면 결론도 반드시 참이 되는 논리적 추론 방식.</strong><br>
논리학에서 가장 엄격한 형태의 추론이며, 수학·형식논리·프로그래밍의 기본 구조다.</p>
</section>
<section id="특징" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="특징"><span class="header-section-number">2.2</span> 특징</h3>
<ul>
<li><strong>확실성</strong>: 전제가 참이면 결론의 진리값이 보장됨<br>
</li>
<li><strong>하향식(Top-Down)</strong>: 일반 원리 → 특수 사례<br>
</li>
<li><strong>검증 가능성</strong>: 논리적 타당성을 형식적으로 검증 가능</li>
</ul>
</section>
<section id="예시" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="예시"><span class="header-section-number">2.3</span> 예시</h3>
<p><strong>삼단논법(Syllogism):</strong><br>
- 대전제: 모든 사람은 죽는다<br>
- 소전제: A는 사람이다<br>
- 결론: 그러므로 A는 죽는다</p>
<p><strong>프로그래밍 적용:</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># 규칙: 나이 &gt;= 18이면 성인</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="cf">if</span> age <span class="op">&gt;=</span> <span class="dv">18</span>:</span>
<span id="cb1-3"><a href="#cb1-3"></a>    status <span class="op">=</span> <span class="st">"성인"</span>  <span class="co"># 연역적 결론</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="연역-추론의-하위-기법" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="연역-추론의-하위-기법"><span class="header-section-number">2.4</span> 연역 추론의 하위 기법</h3>
<p><strong>귀류법(Reductio ad Absurdum):</strong><br>
- 가정을 참이라 놓고 → 논리 전개 → 모순 도출 → 가정이 거짓임을 증명<br>
- 수학 정리 증명에 핵심적 (예: √2의 무리수 증명)</p>
<p><strong>수학적 귀납법(Mathematical Induction):</strong><br>
- 기본 단계 증명 + 귀납 단계 증명 → 모든 자연수에 대해 성립<br>
- 재귀적 구조의 정당성 증명에 사용</p>
<pre><code>수학적 귀납법이 이름에 ‘귀납’이 들어가는데도 **연역법의 하위 기법**으로 분류되는 이유는,
이 방식이 실제로는 **귀납이 아니라 엄밀한 연역 구조로 작동**하기 때문이다.

아래를 단계별로 보면 바로 드러난다.

---

# 1. 수학적 귀납법의 구조를 논리적으로 뜯어보면

일반적인 수학적 귀납법은 다음과 같은 논리 구조를 갖는다.

1. ( P(1) )이 참이라고 증명한다.
2. ( P(k) )이 참이라고 가정한다.
3. 이 가정이 참이면 ( P(k+1) )도 반드시 참이라는 것을 증명한다.
4. 따라서 모든 자연수 ( n )에 대해 ( P(n) )이 참이다.

겉으로는 “1, 2, 3…을 관찰해 규칙을 일반화”하는 귀납처럼 보이지만, 실제 진행 방식은 전적으로 아래 구조다.

* **전제(기초 사례 + 귀납 가정)**
* → **논리적 추론(연역)**
* → **결론(전체 수에 대한 명제의 진리)**

즉, **명제를 전체에 대해 참으로 만드는 논리적 구조를 연역적으로 구축하는 과정**이다.

---

# 2. 귀납법과의 차이

귀납법(Induction)은

* 여러 사례를 관찰
* 그 패턴이 보편적이라고 추정
  하는 방식이다.
  확률적·경험적 기반이며, 결론은 확률적 참에 가깝다.

반면, 수학적 귀납법은

* 사례 관찰이 아니라
* “가정이 참이면 다음도 참”이라는 엄격한 논리 규칙
* 이를 전체 집합에 적용
  그래서 **결론이 100% 확정적으로 참**이 된다.

즉, **확률적 추정이 아니라 논리적 필연성**을 만드는 구조다.

---

# 3. 왜 이름은 ‘귀납’인데 실제는 연역인가

역사적·형태적 이유 때문이다.

초기 수학자는

* 1에서 2
* 2에서 3
* 3에서 4
  …로 “위로 올라간다”는 점에서 “귀납”이라는 이름을 붙였다.

하지만 현대 논리학에서는 이 방식이

* 일반 명제의 참을 **논리적으로 연역**하는 메커니즘이기에
  연역법(deductive reasoning)의 하위로 분류한다.

이것은 논리학·수리논리학·형식논리학에서 국제적으로 합의된 관례다.

---

# 4. 정리

수학적 귀납법이 연역의 하위인 이유는 다음과 같다.

1. 사례 기반 추론(귀납)이 아니라,
2. 전제를 세우고
3. 논리적 필연성을 전개해
4. 전체 명제의 참을 확정하는 구조이기 때문.

그래서
**이름은 귀납이지만 논리학적 성격은 완전히 연역**이다.

---

네가 만들려는 폴더 구조에서는 다음과 같이 넣는 것이 가장 깔끔하다.

* Reasoning Frameworks

  * Deductive Reasoning

    * Direct Deduction
    * Reductio ad Absurdum(귀류법)
    * Mathematical Induction(수학적 귀납법)

필요하면 추론 전체를 논리학 기준으로 **정식 트리 구조**로 만들어줄게.


</code></pre>
<p><strong>직접 증명(Direct Proof):</strong><br>
- 전제에서 결론까지 논리적 단계를 순차적으로 전개</p>
</section>
<section id="ai-시스템-적용" class="level3" data-number="2.5">
<h3 data-number="2.5" class="anchored" data-anchor-id="ai-시스템-적용"><span class="header-section-number">2.5</span> AI 시스템 적용</h3>
<ul>
<li><strong>규칙 기반 시스템</strong>: IF-THEN 규칙으로 추론 엔진 구축<br>
</li>
<li><strong>프롬프트 설계</strong>: “다음 규칙에 따라 판단하시오…”<br>
</li>
<li><strong>검증 로직</strong>: 입력 데이터 유효성 검사</li>
</ul>
</section>
<section id="근거" class="level3" data-number="2.6">
<h3 data-number="2.6" class="anchored" data-anchor-id="근거"><span class="header-section-number">2.6</span> 근거</h3>
<ul>
<li>Stanford Encyclopedia of Philosophy: Logic, Deduction<br>
<a href="https://plato.stanford.edu/entries/logic-deduction/">https://plato.stanford.edu/entries/logic-deduction/</a></li>
</ul>
</section>
</section>
<section id="귀납적-추론inductive-reasoning" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="귀납적-추론inductive-reasoning"><span class="header-section-number">3</span> 귀납적 추론(Inductive Reasoning)</h2>
<section id="정의-1" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="정의-1"><span class="header-section-number">3.1</span> 정의</h3>
<p><strong>개별 사례를 관찰하고, 그 패턴을 기반으로 일반적 결론을 추론하는 방식.</strong><br>
결론은 ‘가능성이 높은’ 형태로 제시되며, 절대적 확실성을 보장하지 않는다.</p>
</section>
<section id="특징-1" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="특징-1"><span class="header-section-number">3.2</span> 특징</h3>
<ul>
<li><strong>확률성</strong>: 전제가 참이어도 결론은 ‘개연성 있음’<br>
</li>
<li><strong>상향식(Bottom-Up)</strong>: 특수 사례 → 일반 원리<br>
</li>
<li><strong>경험 기반</strong>: 관찰과 실험 데이터로부터 패턴 발견</li>
</ul>
</section>
<section id="예시-1" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="예시-1"><span class="header-section-number">3.3</span> 예시</h3>
<p><strong>고전적 사례:</strong><br>
- 관찰: 백조 100마리를 봤는데 모두 흰색이었다<br>
- 귀납: 백조는 대부분 흰색일 것이다<br>
- 한계: 검은 백조 발견 시 결론이 무너짐</p>
<p><strong>데이터 분석 적용:</strong></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># 사용자 1000명의 행동 패턴 관찰</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>pattern <span class="op">=</span> analyze_user_behavior(users)</span>
<span id="cb3-3"><a href="#cb3-3"></a>general_rule <span class="op">=</span> <span class="st">"사용자는 평균 3회 방문 후 구매한다"</span>  <span class="co"># 귀납적 일반화</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="귀납적-추론의-하위-기법" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="귀납적-추론의-하위-기법"><span class="header-section-number">3.4</span> 귀납적 추론의 하위 기법</h3>
<p><strong>열거적 귀납(Enumerative Induction):</strong><br>
- 다수의 관찰 사례에서 공통 속성 발견 → 일반 법칙 도출<br>
- 예: “관찰한 까마귀 1000마리가 모두 검다” → “모든 까마귀는 검다”</p>
<p><strong>제거 귀납(Eliminative Induction):</strong><br>
- 가능한 가설들을 제거해가며 남은 것을 채택 (밀의 방법)<br>
- 일치법, 차이법, 공변법, 잉여법 등</p>
<p><strong>유비 귀납(Analogical Induction):</strong><br>
- 유사한 사례의 패턴을 새로운 경우에 확장<br>
- 과학적 모델 구축의 기초</p>
</section>
<section id="ai-시스템-적용-1" class="level3" data-number="3.5">
<h3 data-number="3.5" class="anchored" data-anchor-id="ai-시스템-적용-1"><span class="header-section-number">3.5</span> AI 시스템 적용</h3>
<ul>
<li><strong>머신러닝</strong>: 학습 데이터에서 패턴 발견 → 일반화 모델 구축<br>
</li>
<li><strong>프롬프트 설계</strong>: “다음 사례들을 보고 공통 패턴을 찾으시오…”<br>
</li>
<li><strong>사용자 연구</strong>: 행동 로그 분석 → 일반적 사용자 프로필 도출</li>
</ul>
</section>
<section id="근거-1" class="level3" data-number="3.6">
<h3 data-number="3.6" class="anchored" data-anchor-id="근거-1"><span class="header-section-number">3.6</span> 근거</h3>
<ul>
<li>Stanford Encyclopedia of Philosophy: Inductive Logic<br>
<a href="https://plato.stanford.edu/entries/logic-inductive/">https://plato.stanford.edu/entries/logic-inductive/</a></li>
</ul>
</section>
</section>
<section id="가추적-추론abductive-reasoning" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="가추적-추론abductive-reasoning"><span class="header-section-number">4</span> 가추적 추론(Abductive Reasoning)</h2>
<section id="정의-2" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="정의-2"><span class="header-section-number">4.1</span> 정의</h3>
<p><strong>관찰된 사실을 가장 잘 설명하는 가설을 선택하는 추론 방식.</strong><br>
“최선의 설명으로의 추론(Inference to the Best Explanation)”이라고도 불린다.<br>
과학적 발견, 의료 진단, 문제 해결, 디버깅에 핵심적이다.</p>
</section>
<section id="특징-2" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="특징-2"><span class="header-section-number">4.2</span> 특징</h3>
<ul>
<li><strong>설명력</strong>: 여러 가설 중 관찰 사실을 가장 잘 설명하는 것 선택<br>
</li>
<li><strong>잠정성</strong>: 새로운 증거가 나오면 가설 수정 가능<br>
</li>
<li><strong>창조성</strong>: 새로운 가설 생성이 핵심 (연역/귀납과 차별점)</li>
</ul>
</section>
<section id="예시-2" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="예시-2"><span class="header-section-number">4.3</span> 예시</h3>
<p><strong>일상적 추론:</strong><br>
- 관찰 1: 방이 젖어 있다<br>
- 관찰 2: 창문이 열려 있다<br>
- 관찰 3: 밖에 비가 온 흔적이 있다<br>
- 가추: 비가 창문으로 들어왔을 가능성이 가장 크다</p>
<p><strong>의료 진단:</strong></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># 증상: 발열, 기침, 두통</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>symptoms <span class="op">=</span> [<span class="st">"fever"</span>, <span class="st">"cough"</span>, <span class="st">"headache"</span>]</span>
<span id="cb4-3"><a href="#cb4-3"></a>possible_diseases <span class="op">=</span> [<span class="st">"감기"</span>, <span class="st">"독감"</span>, <span class="st">"폐렴"</span>]</span>
<span id="cb4-4"><a href="#cb4-4"></a>best_hypothesis <span class="op">=</span> select_most_likely(symptoms, possible_diseases)</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="bu">print</span>(<span class="ss">f"가장 가능성 높은 진단: </span><span class="sc">{</span>best_hypothesis<span class="sc">}</span><span class="ss">"</span>)  <span class="co"># 가추적 결론</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="가추적-추론의-하위-기법" class="level3" data-number="4.4">
<h3 data-number="4.4" class="anchored" data-anchor-id="가추적-추론의-하위-기법"><span class="header-section-number">4.4</span> 가추적 추론의 하위 기법</h3>
<p><strong>역행 추론(Retroductive Reasoning):</strong><br>
- 결과로부터 원인을 추정하는 방식<br>
- 범죄 수사, 고장 진단에 핵심적</p>
<p><strong>진단적 추론(Diagnostic Reasoning):</strong><br>
- 증상/징후에서 근본 원인 파악<br>
- 의료 진단, 시스템 장애 분석</p>
<p><strong>가설-검증 순환(Hypothesis-Testing Cycle):</strong><br>
- 가설 생성 → 예측 도출 → 실험/관찰 → 가설 수정<br>
- 과학적 방법론의 핵심</p>
</section>
<section id="ai-시스템-적용-2" class="level3" data-number="4.5">
<h3 data-number="4.5" class="anchored" data-anchor-id="ai-시스템-적용-2"><span class="header-section-number">4.5</span> AI 시스템 적용</h3>
<ul>
<li><strong>LLM 추론</strong>: 사용자 의도를 가장 잘 설명하는 응답 생성<br>
</li>
<li><strong>디버깅</strong>: 오류 메시지에서 원인 추정<br>
</li>
<li><strong>프롬프트 설계</strong>: “다음 관찰 결과의 가장 그럴듯한 원인은?”</li>
</ul>
</section>
<section id="근거-2" class="level3" data-number="4.6">
<h3 data-number="4.6" class="anchored" data-anchor-id="근거-2"><span class="header-section-number">4.6</span> 근거</h3>
<ul>
<li>Stanford Encyclopedia of Philosophy: Abduction<br>
<a href="https://plato.stanford.edu/entries/abduction/">https://plato.stanford.edu/entries/abduction/</a></li>
</ul>
</section>
</section>
<section id="유추적-추론analogical-reasoning" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="유추적-추론analogical-reasoning"><span class="header-section-number">5</span> 유추적 추론(Analogical Reasoning)</h2>
<section id="정의-3" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="정의-3"><span class="header-section-number">5.1</span> 정의</h3>
<p><strong>A와 B가 여러 속성을 공유하므로, 다른 속성도 유사할 것이라고 추론하는 방식.</strong><br>
과학적 모델링, 법률 판례, 교육, 창의적 문제해결에서 광범위하게 사용된다.</p>
</section>
<section id="특징-3" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="특징-3"><span class="header-section-number">5.2</span> 특징</h3>
<ul>
<li><strong>유사성 기반</strong>: 대상 간 구조적·기능적 유사성 활용<br>
</li>
<li><strong>전이</strong>: 익숙한 영역(source)의 지식을 새로운 영역(target)으로 이동<br>
</li>
<li><strong>제한성</strong>: 유사성이 과장되면 잘못된 결론 도출 위험</li>
</ul>
</section>
<section id="예시-3" class="level3" data-number="5.3">
<h3 data-number="5.3" class="anchored" data-anchor-id="예시-3"><span class="header-section-number">5.3</span> 예시</h3>
<p><strong>생물학적 유추:</strong><br>
- Source: 자동차 엔진이 과열되면 성능 저하<br>
- Target: 인체도 과열되면 성능 저하<br>
- 유추: 인체도 냉각(수분 공급)이 필요하다</p>
<p><strong>법률 판례:</strong></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># 과거 유사 사건 A에서 판결 X</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>similar_case <span class="op">=</span> find_analogous_case(current_case)</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="cf">if</span> similarity_score <span class="op">&gt;</span> threshold:</span>
<span id="cb5-4"><a href="#cb5-4"></a>    predicted_ruling <span class="op">=</span> similar_case.ruling  <span class="co"># 유추적 예측</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="유추적-추론의-하위-기법" class="level3" data-number="5.4">
<h3 data-number="5.4" class="anchored" data-anchor-id="유추적-추론의-하위-기법"><span class="header-section-number">5.4</span> 유추적 추론의 하위 기법</h3>
<p><strong>구조 매핑(Structure Mapping):</strong><br>
- 두 영역 간 관계 구조의 대응 관계 찾기<br>
- 과학적 이론 개발, 은유 이해에 활용</p>
<p><strong>비례적 유추(Proportional Analogy):</strong><br>
- A:B = C:D 형태의 관계 추론<br>
- 수학적 문제 해결, 패턴 인식</p>
<p><strong>인과적 유추(Causal Analogy):</strong><br>
- 한 영역의 인과 관계를 다른 영역에 투사<br>
- 새로운 도메인의 메커니즘 이해</p>
</section>
<section id="ai-시스템-적용-3" class="level3" data-number="5.5">
<h3 data-number="5.5" class="anchored" data-anchor-id="ai-시스템-적용-3"><span class="header-section-number">5.5</span> AI 시스템 적용</h3>
<ul>
<li><strong>Few-shot Learning</strong>: 몇 가지 예시로 새로운 작업 수행<br>
</li>
<li><strong>Transfer Learning</strong>: 한 도메인 학습 → 다른 도메인 적용<br>
</li>
<li><strong>프롬프트 설계</strong>: “다음 예시와 유사하게 작성하시오…”</li>
</ul>
</section>
<section id="근거-3" class="level3" data-number="5.6">
<h3 data-number="5.6" class="anchored" data-anchor-id="근거-3"><span class="header-section-number">5.6</span> 근거</h3>
<ul>
<li>Stanford Encyclopedia of Philosophy: Analogy and Analogical Reasoning<br>
<a href="https://plato.stanford.edu/entries/reasoning-analogy/">https://plato.stanford.edu/entries/reasoning-analogy/</a></li>
</ul>
</section>
</section>
<section id="확률적-추론probabilistic-reasoning" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="확률적-추론probabilistic-reasoning"><span class="header-section-number">6</span> 확률적 추론(Probabilistic Reasoning)</h2>
<section id="정의-4" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="정의-4"><span class="header-section-number">6.1</span> 정의</h3>
<p><strong>불확실한 사건을 확률로 표현하고, 결론의 가능성을 계산하는 추론 방식.</strong><br>
베이즈 추론(Bayesian Inference)이 대표적이며, 통계학·머신러닝·의사결정의 핵심이다.</p>
</section>
<section id="특징-4" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="특징-4"><span class="header-section-number">6.2</span> 특징</h3>
<ul>
<li><strong>수치화</strong>: 불확실성을 정량적으로 표현 (0~1 사이 확률)<br>
</li>
<li><strong>갱신 가능</strong>: 새로운 증거로 확률 업데이트 (베이즈 정리)<br>
</li>
<li><strong>의사결정</strong>: 기댓값 최대화로 최적 선택</li>
</ul>
</section>
<section id="예시-4" class="level3" data-number="6.3">
<h3 data-number="6.3" class="anchored" data-anchor-id="예시-4"><span class="header-section-number">6.3</span> 예시</h3>
<p><strong>의료 진단(베이즈 정리):</strong><br>
- 사전확률: 질병 X의 유병률 1%<br>
- 증상 A 발생 시 질병 X일 확률: 90%<br>
- 검사 결과 양성: 사후확률 재계산</p>
<p><strong>스팸 필터:</strong></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="co"># 단어 출현 확률로 스팸 여부 판단</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>P_spam <span class="op">=</span> <span class="fl">0.3</span>  <span class="co"># 사전확률</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>P_word_given_spam <span class="op">=</span> <span class="fl">0.8</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>P_word_given_ham <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co"># 베이즈 정리로 사후확률 계산</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>P_spam_given_word <span class="op">=</span> (P_word_given_spam <span class="op">*</span> P_spam) <span class="op">/</span> P_word</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="확률적-추론의-하위-기법" class="level3" data-number="6.4">
<h3 data-number="6.4" class="anchored" data-anchor-id="확률적-추론의-하위-기법"><span class="header-section-number">6.4</span> 확률적 추론의 하위 기법</h3>
<p><strong>베이지안 추론(Bayesian Inference):</strong><br>
- 사전확률 + 새 증거 → 사후확률 업데이트<br>
- 순차적 학습과 의사결정에 최적</p>
<p><strong>마르코프 체인(Markov Chain):</strong><br>
- 현재 상태만으로 미래 예측 (무기억성)<br>
- 시계열 분석, 텍스트 생성</p>
<p><strong>몬테카를로 방법(Monte Carlo Method):</strong><br>
- 무작위 샘플링으로 확률 분포 추정<br>
- 복잡한 적분 계산, 시뮬레이션</p>
</section>
<section id="ai-시스템-적용-4" class="level3" data-number="6.5">
<h3 data-number="6.5" class="anchored" data-anchor-id="ai-시스템-적용-4"><span class="header-section-number">6.5</span> AI 시스템 적용</h3>
<ul>
<li><strong>베이지안 네트워크</strong>: 변수 간 확률적 관계 모델링<br>
</li>
<li><strong>강화학습</strong>: 행동 선택 확률 업데이트<br>
</li>
<li><strong>불확실성 정량화</strong>: 모델 예측의 신뢰도 측정</li>
</ul>
</section>
<section id="근거-4" class="level3" data-number="6.6">
<h3 data-number="6.6" class="anchored" data-anchor-id="근거-4"><span class="header-section-number">6.6</span> 근거</h3>
<ul>
<li>Stanford Encyclopedia of Philosophy: Bayesian Epistemology<br>
<a href="https://plato.stanford.edu/entries/epistemology-bayesian/">https://plato.stanford.edu/entries/epistemology-bayesian/</a></li>
</ul>
</section>
</section>
<section id="통계적-추론statistical-inference" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="통계적-추론statistical-inference"><span class="header-section-number">7</span> 통계적 추론(Statistical Inference)</h2>
<section id="정의-5" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="정의-5"><span class="header-section-number">7.1</span> 정의</h3>
<p><strong>표본 데이터에서 모집단의 특성을 추정하는 추론 방식.</strong><br>
가설검정, 신뢰구간, 회귀분석 등이 포함되며, 데이터 과학의 기초다.</p>
</section>
<section id="특징-5" class="level3" data-number="7.2">
<h3 data-number="7.2" class="anchored" data-anchor-id="특징-5"><span class="header-section-number">7.2</span> 특징</h3>
<ul>
<li><strong>샘플링 기반</strong>: 전체 데이터 대신 표본으로 추론<br>
</li>
<li><strong>오차 정량화</strong>: 표준오차, 신뢰구간으로 불확실성 표현<br>
</li>
<li><strong>가설검정</strong>: 귀무가설 기각 여부로 결론 도출</li>
</ul>
</section>
<section id="예시-5" class="level3" data-number="7.3">
<h3 data-number="7.3" class="anchored" data-anchor-id="예시-5"><span class="header-section-number">7.3</span> 예시</h3>
<p><strong>A/B 테스트:</strong><br>
- 표본: 사용자 1000명의 전환율 측정<br>
- 추론: 모집단 전체의 전환율 95% 신뢰구간 [2.5%, 3.5%]<br>
- 결론: 신뢰구간이 겹치지 않으면 유의미한 차이</p>
<p><strong>회귀분석:</strong></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb7-2"><a href="#cb7-2"></a>X <span class="op">=</span> sm.add_constant(age)  <span class="co"># 독립변수: 나이</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>y <span class="op">=</span> income  <span class="co"># 종속변수: 소득</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>model <span class="op">=</span> sm.OLS(y, X).fit()</span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="bu">print</span>(model.summary())  <span class="co"># 나이와 소득의 관계 추론</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="통계적-추론의-하위-기법" class="level3" data-number="7.4">
<h3 data-number="7.4" class="anchored" data-anchor-id="통계적-추론의-하위-기법"><span class="header-section-number">7.4</span> 통계적 추론의 하위 기법</h3>
<p><strong>모수적 추론(Parametric Inference):</strong><br>
- 모집단 분포 가정 (정규분포 등) → 모수 추정<br>
- t-검정, ANOVA, 선형회귀</p>
<p><strong>비모수적 추론(Non-parametric Inference):</strong><br>
- 분포 가정 없이 순위/부호 기반 추론<br>
- Mann-Whitney 검정, Kruskal-Wallis 검정</p>
<p><strong>부트스트랩(Bootstrap):</strong><br>
- 재표본추출로 표본 분포 근사<br>
- 신뢰구간 계산, 표준오차 추정</p>
</section>
<section id="ai-시스템-적용-5" class="level3" data-number="7.5">
<h3 data-number="7.5" class="anchored" data-anchor-id="ai-시스템-적용-5"><span class="header-section-number">7.5</span> AI 시스템 적용</h3>
<ul>
<li><strong>모델 평가</strong>: 검증 세트로 일반화 성능 추정<br>
</li>
<li><strong>실험 설계</strong>: A/B 테스트로 기능 개선 효과 검증<br>
</li>
<li><strong>불확실성 측정</strong>: 예측 구간(prediction interval) 계산</li>
</ul>
</section>
<section id="근거-5" class="level3" data-number="7.6">
<h3 data-number="7.6" class="anchored" data-anchor-id="근거-5"><span class="header-section-number">7.6</span> 근거</h3>
<ul>
<li>Casella, G., &amp; Berger, R. L. (2002). <em>Statistical Inference</em>. Duxbury Press.</li>
</ul>
</section>
</section>
<section id="규범적규칙-기반-추론rule-based-reasoning" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="규범적규칙-기반-추론rule-based-reasoning"><span class="header-section-number">8</span> 규범적·규칙 기반 추론(Rule-based Reasoning)</h2>
<section id="정의-6" class="level3" data-number="8.1">
<h3 data-number="8.1" class="anchored" data-anchor-id="정의-6"><span class="header-section-number">8.1</span> 정의</h3>
<p><strong>정해진 규칙(Rule), 조건(Condition), 정책(Policy)에 따라 결론을 도출하는 방식.</strong><br>
전문가 시스템, 비즈니스 룰 엔진, 법률 시스템에서 핵심적이다.</p>
</section>
<section id="특징-6" class="level3" data-number="8.2">
<h3 data-number="8.2" class="anchored" data-anchor-id="특징-6"><span class="header-section-number">8.2</span> 특징</h3>
<ul>
<li><strong>명시성</strong>: 규칙이 명확하게 정의됨 (IF-THEN 형태)<br>
</li>
<li><strong>추적 가능성</strong>: 추론 과정을 단계별로 설명 가능<br>
</li>
<li><strong>유지보수성</strong>: 규칙 추가/수정으로 시스템 업데이트 용이</li>
</ul>
</section>
<section id="예시-6" class="level3" data-number="8.3">
<h3 data-number="8.3" class="anchored" data-anchor-id="예시-6"><span class="header-section-number">8.3</span> 예시</h3>
<p><strong>비즈니스 규칙:</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># 할인 정책 규칙</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="cf">if</span> customer.membership <span class="op">==</span> <span class="st">"VIP"</span>:</span>
<span id="cb8-3"><a href="#cb8-3"></a>    discount <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="cf">elif</span> customer.purchase_amount <span class="op">&gt;</span> <span class="dv">100000</span>:</span>
<span id="cb8-5"><a href="#cb8-5"></a>    discount <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="cf">else</span>:</span>
<span id="cb8-7"><a href="#cb8-7"></a>    discount <span class="op">=</span> <span class="dv">0</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>전문가 시스템(MYCIN - 의료 진단):</strong><br>
- Rule 1: IF 발열 AND 기침 THEN 감기 의심<br>
- Rule 2: IF 감기 의심 AND 고열 THEN 독감 가능성</p>
</section>
<section id="규칙-기반-추론의-하위-기법" class="level3" data-number="8.4">
<h3 data-number="8.4" class="anchored" data-anchor-id="규칙-기반-추론의-하위-기법"><span class="header-section-number">8.4</span> 규칙 기반 추론의 하위 기법</h3>
<p><strong>순방향 연쇄(Forward Chaining):</strong><br>
- 사실(facts)에서 시작 → 규칙 적용 → 결론 도출<br>
- 데이터 주도형, 실시간 모니터링 시스템</p>
<p><strong>역방향 연쇄(Backward Chaining):</strong><br>
- 목표에서 시작 → 필요한 조건 역추적<br>
- 목표 지향형, 진단 시스템</p>
<p><strong>퍼지 규칙(Fuzzy Rules):</strong><br>
- 부분 진리값 (예: “매우 높음” = 0.9)<br>
- 불확실한 환경에서 유연한 추론</p>
</section>
<section id="ai-시스템-적용-6" class="level3" data-number="8.5">
<h3 data-number="8.5" class="anchored" data-anchor-id="ai-시스템-적용-6"><span class="header-section-number">8.5</span> AI 시스템 적용</h3>
<ul>
<li><strong>하이브리드 AI</strong>: LLM + 규칙 엔진 결합<br>
</li>
<li><strong>프롬프트 설계</strong>: “다음 규칙을 엄격히 따르시오…”<br>
</li>
<li><strong>가드레일</strong>: AI 출력 검증 및 필터링</li>
</ul>
</section>
<section id="근거-6" class="level3" data-number="8.6">
<h3 data-number="8.6" class="anchored" data-anchor-id="근거-6"><span class="header-section-number">8.6</span> 근거</h3>
<ul>
<li>Russell, S., &amp; Norvig, P. (2021). <em>Artificial Intelligence: A Modern Approach</em> (4th ed.). Pearson.</li>
</ul>
</section>
</section>
<section id="사례-기반-추론case-based-reasoning-cbr" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="사례-기반-추론case-based-reasoning-cbr"><span class="header-section-number">9</span> 사례 기반 추론(Case-based Reasoning, CBR)</h2>
<section id="정의-7" class="level3" data-number="9.1">
<h3 data-number="9.1" class="anchored" data-anchor-id="정의-7"><span class="header-section-number">9.1</span> 정의</h3>
<p><strong>과거 유사 사례를 검색하고, 그 해결 방법을 현재 문제에 적용하는 추론 방식.</strong><br>
법률 판례, 의료 진단, 고객 지원, 추천 시스템에서 널리 사용된다.</p>
</section>
<section id="특징-7" class="level3" data-number="9.2">
<h3 data-number="9.2" class="anchored" data-anchor-id="특징-7"><span class="header-section-number">9.2</span> 특징</h3>
<ul>
<li><strong>경험 기반</strong>: 명시적 규칙 없이 과거 사례 활용<br>
</li>
<li><strong>적응</strong>: 과거 사례를 현재 상황에 맞게 수정<br>
</li>
<li><strong>학습</strong>: 새로운 사례를 지속적으로 축적</li>
</ul>
</section>
<section id="사례-기반-추론의-하위-기법-cbr-사이클---4rs" class="level3" data-number="9.3">
<h3 data-number="9.3" class="anchored" data-anchor-id="사례-기반-추론의-하위-기법-cbr-사이클---4rs"><span class="header-section-number">9.3</span> 사례 기반 추론의 하위 기법 (CBR 사이클 - 4Rs)</h3>
<ol type="1">
<li><strong>Retrieve (검색)</strong>: 유사 사례 검색
<ul>
<li>k-NN, 코사인 유사도, 벡터 검색<br>
</li>
</ul></li>
<li><strong>Reuse (재사용)</strong>: 과거 해결책 재사용
<ul>
<li>직접 적용, 템플릿 기반 적용<br>
</li>
</ul></li>
<li><strong>Revise (수정)</strong>: 현재 상황에 맞게 수정
<ul>
<li>규칙 기반 적응, 학습 기반 조정<br>
</li>
</ul></li>
<li><strong>Retain (보존)</strong>: 새로운 사례로 저장
<ul>
<li>사례 베이스 업데이트, 인덱싱</li>
</ul></li>
</ol>
<p><strong>협업 필터링(Collaborative Filtering):</strong><br>
- 사용자 기반: 유사 사용자의 선호 활용<br>
- 아이템 기반: 유사 아이템의 평가 활용</p>
</section>
<section id="예시-7" class="level3" data-number="9.4">
<h3 data-number="9.4" class="anchored" data-anchor-id="예시-7"><span class="header-section-number">9.4</span> 예시</h3>
<p><strong>법률 판례:</strong></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># 현재 사건과 유사한 과거 판례 검색</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>current_case <span class="op">=</span> {<span class="st">"type"</span>: <span class="st">"계약위반"</span>, <span class="st">"amount"</span>: <span class="dv">5000</span>}</span>
<span id="cb9-3"><a href="#cb9-3"></a>similar_cases <span class="op">=</span> case_db.search(similarity_threshold<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb9-4"><a href="#cb9-4"></a>predicted_ruling <span class="op">=</span> similar_cases[<span class="dv">0</span>].ruling  <span class="co"># 과거 판결 적용</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>추천 시스템(협업 필터링):</strong><br>
- 사용자 A와 유사한 사용자 B의 구매 이력 참조<br>
- 사용자 A에게 B가 좋아한 상품 추천</p>
</section>
<section id="ai-시스템-적용-7" class="level3" data-number="9.5">
<h3 data-number="9.5" class="anchored" data-anchor-id="ai-시스템-적용-7"><span class="header-section-number">9.5</span> AI 시스템 적용</h3>
<ul>
<li><strong>RAG(Retrieval-Augmented Generation)</strong>: 유사 문서 검색 → 답변 생성<br>
</li>
<li><strong>Few-shot Learning</strong>: 소수의 예시로 학습<br>
</li>
<li><strong>고객 지원 챗봇</strong>: 과거 응대 사례 참조</li>
</ul>
</section>
<section id="근거-7" class="level3" data-number="9.6">
<h3 data-number="9.6" class="anchored" data-anchor-id="근거-7"><span class="header-section-number">9.6</span> 근거</h3>
<ul>
<li>Aamodt, A., &amp; Plaza, E. (1994). “Case-Based Reasoning: Foundational Issues, Methodological Variations, and System Approaches.” <em>AI Communications</em>, 7(1), 39-59.</li>
</ul>
<hr>
</section>
</section>
<section id="전제-수정-기반-추론non-monotonic-reasoning" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="전제-수정-기반-추론non-monotonic-reasoning"><span class="header-section-number">10</span> 전제 수정 기반 추론(Non-monotonic Reasoning)</h2>
<section id="정의-8" class="level3" data-number="10.1">
<h3 data-number="10.1" class="anchored" data-anchor-id="정의-8"><span class="header-section-number">10.1</span> 정의</h3>
<p><strong>새로운 정보가 추가되면 기존 결론을 철회하거나 수정할 수 있는 추론 방식.</strong><br>
고전 논리(단조 논리)와 달리, 현실 세계의 불완전한 정보를 다룬다.</p>
</section>
<section id="특징-8" class="level3" data-number="10.2">
<h3 data-number="10.2" class="anchored" data-anchor-id="특징-8"><span class="header-section-number">10.2</span> 특징</h3>
<ul>
<li><strong>철회 가능성</strong>: 추가 정보로 결론 변경 (Defeasibility)<br>
</li>
<li><strong>기본 가정</strong>: 명시되지 않은 것은 “보통” 참으로 간주<br>
</li>
<li><strong>현실성</strong>: 일상적 추론을 더 잘 모델링</li>
</ul>
</section>
<section id="예시-8" class="level3" data-number="10.3">
<h3 data-number="10.3" class="anchored" data-anchor-id="예시-8"><span class="header-section-number">10.3</span> 예시</h3>
<p><strong>기본 추론(Default Reasoning):</strong><br>
- 초기: “새는 보통 날 수 있다” + “트위티는 새다” → 트위티는 날 수 있다<br>
- 추가 정보: “트위티는 펭귄이다”<br>
- 수정: 트위티는 날 수 없다 (기존 결론 철회)</p>
<p><strong>자율주행 AI:</strong></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># 초기 판단: 신호등 녹색 → 진행</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="cf">if</span> traffic_light <span class="op">==</span> <span class="st">"green"</span>:</span>
<span id="cb10-3"><a href="#cb10-3"></a>    action <span class="op">=</span> <span class="st">"proceed"</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co"># 추가 정보: 보행자 돌진</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="cf">if</span> pedestrian_detected:</span>
<span id="cb10-6"><a href="#cb10-6"></a>    action <span class="op">=</span> <span class="st">"stop"</span>  <span class="co"># 기존 결론 철회</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="전제-수정-기반-추론의-하위-기법" class="level3" data-number="10.4">
<h3 data-number="10.4" class="anchored" data-anchor-id="전제-수정-기반-추론의-하위-기법"><span class="header-section-number">10.4</span> 전제 수정 기반 추론의 하위 기법</h3>
<p><strong>기본 논리(Default Logic):</strong><br>
- 명시되지 않은 것은 “보통” 참으로 간주<br>
- 예외 발견 시 기본 가정 철회</p>
<p><strong>회피 논리(Circumscription):</strong><br>
- 비정상을 최소화하는 방향으로 추론<br>
- 폐세계 가정(Closed World Assumption)</p>
<p><strong>진실 유지 시스템(Truth Maintenance System):</strong><br>
- 추론 과정의 의존성 추적<br>
- 모순 발견 시 자동으로 가정 철회</p>
</section>
<section id="ai-시스템-적용-8" class="level3" data-number="10.5">
<h3 data-number="10.5" class="anchored" data-anchor-id="ai-시스템-적용-8"><span class="header-section-number">10.5</span> AI 시스템 적용</h3>
<ul>
<li><strong>상식 추론(Commonsense Reasoning)</strong>: 예외 상황 처리<br>
</li>
<li><strong>대화 시스템</strong>: 맥락 변화에 따른 응답 조정<br>
</li>
<li><strong>불완전 정보 처리</strong>: 가정 기반 추론 후 수정</li>
</ul>
</section>
<section id="근거-8" class="level3" data-number="10.6">
<h3 data-number="10.6" class="anchored" data-anchor-id="근거-8"><span class="header-section-number">10.6</span> 근거</h3>
<ul>
<li>Stanford Encyclopedia of Philosophy: Non-Monotonic Logic<br>
<a href="https://plato.stanford.edu/entries/logic-nonmonotonic/">https://plato.stanford.edu/entries/logic-nonmonotonic/</a></li>
</ul>
<hr>
</section>
</section>
<section id="형식-논리-기반-추론formal-logic-reasoning" class="level2" data-number="11">
<h2 data-number="11" class="anchored" data-anchor-id="형식-논리-기반-추론formal-logic-reasoning"><span class="header-section-number">11</span> 형식 논리 기반 추론(Formal Logic Reasoning)</h2>
<section id="정의-9" class="level3" data-number="11.1">
<h3 data-number="11.1" class="anchored" data-anchor-id="정의-9"><span class="header-section-number">11.1</span> 정의</h3>
<p><strong>수학적으로 엄밀하게 정의된 논리 체계를 사용하는 추론 방식.</strong><br>
연역 추론의 정교한 변형들로, 복잡한 상황을 형식적으로 표현하고 검증한다.</p>
</section>
<section id="주요-논리-체계" class="level3" data-number="11.2">
<h3 data-number="11.2" class="anchored" data-anchor-id="주요-논리-체계"><span class="header-section-number">11.2</span> 주요 논리 체계</h3>
<p><strong>명제 논리(Propositional Logic):</strong><br>
- 가장 기본적인 형식 논리<br>
- 명제를 참/거짓으로 판단 (AND, OR, NOT 연산)<br>
- 예: <code>P ∧ Q → R</code> (P와 Q가 참이면 R도 참)</p>
<p><strong>술어 논리(Predicate Logic, First-Order Logic):</strong><br>
- 변수, 양화사(∀, ∃) 추가<br>
- 예: <code>∀x (사람(x) → 죽는다(x))</code> (모든 x에 대해…)<br>
- 데이터베이스 쿼리, 자동 정리 증명에 사용</p>
<p><strong>양상 논리(Modal Logic):</strong><br>
- 필연성(□), 가능성(◇) 표현<br>
- 예: <code>□P</code> (P는 반드시 참), <code>◇P</code> (P는 가능함)<br>
- 인식론, 윤리학, 프로그램 검증에 적용</p>
<p><strong>시간 논리(Temporal Logic):</strong><br>
- 시간 관계 표현: 항상(G), 결국(F), 다음(X)<br>
- 예: <code>G(요청 → F(응답))</code> (요청 후 결국 응답이 옴)<br>
- 하드웨어/소프트웨어 검증에 필수</p>
<p><strong>비고전 논리(Non-classical Logic):</strong><br>
- 직관주의 논리(Intuitionistic Logic): 구성적 증명<br>
- 퍼지 논리(Fuzzy Logic): 부분적 진리값 (0~1)<br>
- 다치 논리(Many-valued Logic): 참/거짓 외 제3의 값</p>
</section>
<section id="ai-시스템-적용-9" class="level3" data-number="11.3">
<h3 data-number="11.3" class="anchored" data-anchor-id="ai-시스템-적용-9"><span class="header-section-number">11.3</span> AI 시스템 적용</h3>
<ul>
<li><strong>자동 정리 증명</strong>: Coq, Isabelle 등<br>
</li>
<li><strong>모델 검증(Model Checking)</strong>: 소프트웨어 안전성 검증<br>
</li>
<li><strong>지식 표현</strong>: 온톨로지, 시맨틱 웹</li>
</ul>
</section>
<section id="근거-9" class="level3" data-number="11.4">
<h3 data-number="11.4" class="anchored" data-anchor-id="근거-9"><span class="header-section-number">11.4</span> 근거</h3>
<ul>
<li>Stanford Encyclopedia of Philosophy: Logic and Artificial Intelligence<br>
<a href="https://plato.stanford.edu/entries/logic-ai/">https://plato.stanford.edu/entries/logic-ai/</a><br>
</li>
<li>Fitting, M. (1996). <em>First-Order Logic and Automated Theorem Proving</em>. Springer.</li>
</ul>
<hr>
</section>
</section>
<section id="추론-방법론-비교표" class="level2" data-number="12">
<h2 data-number="12" class="anchored" data-anchor-id="추론-방법론-비교표"><span class="header-section-number">12</span> 추론 방법론 비교표</h2>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 19%">
<col style="width: 16%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th>추론 방식</th>
<th>확실성</th>
<th>방향</th>
<th>주요 활용 분야</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>연역적</td>
<td>높음 (전제→결론 필연)</td>
<td>일반→특수</td>
<td>수학, 프로그래밍, 형식 검증</td>
</tr>
<tr class="even">
<td>귀납적</td>
<td>중간 (개연성)</td>
<td>특수→일반</td>
<td>머신러닝, 과학적 발견</td>
</tr>
<tr class="odd">
<td>가추적</td>
<td>낮음~중간 (최선 설명)</td>
<td>관찰→가설</td>
<td>진단, 디버깅, 과학적 가설</td>
</tr>
<tr class="even">
<td>유추적</td>
<td>중간 (유사성 기반)</td>
<td>도메인 전이</td>
<td>Few-shot Learning, 교육</td>
</tr>
<tr class="odd">
<td>확률적</td>
<td>정량화 (확률값)</td>
<td>불확실성 모델링</td>
<td>베이지안 추론, 의사결정</td>
</tr>
<tr class="even">
<td>통계적</td>
<td>정량화 (신뢰구간)</td>
<td>표본→모집단</td>
<td>A/B 테스트, 회귀분석</td>
</tr>
<tr class="odd">
<td>규칙 기반</td>
<td>높음 (규칙 명시)</td>
<td>조건→결론</td>
<td>전문가 시스템, 정책 엔진</td>
</tr>
<tr class="even">
<td>사례 기반</td>
<td>중간 (과거 경험)</td>
<td>유사 사례 검색</td>
<td>법률, RAG, 추천 시스템</td>
</tr>
<tr class="odd">
<td>전제 수정</td>
<td>가변 (철회 가능)</td>
<td>기본 가정+예외</td>
<td>상식 추론, 자율주행</td>
</tr>
<tr class="even">
<td>형식 논리</td>
<td>매우 높음 (수학적)</td>
<td>공리→정리</td>
<td>정리 증명, 모델 검증</td>
</tr>
</tbody>
</table>
<hr>
</section>
<section id="결론" class="level2" data-number="13">
<h2 data-number="13" class="anchored" data-anchor-id="결론"><span class="header-section-number">13</span> 결론</h2>
<p><strong>추론 방법론의 선택은 문제의 특성에 따라 결정된다:</strong><br>
- <strong>확실성이 필요한 경우</strong>: 연역적, 규칙 기반, 형식 논리<br>
- <strong>데이터 기반 발견</strong>: 귀납적, 통계적, 확률적<br>
- <strong>불완전한 정보 처리</strong>: 가추적, 전제 수정 기반<br>
- <strong>경험 활용</strong>: 사례 기반, 유추적</p>
<p><strong>AI 시스템 설계 시 고려사항:</strong><br>
1. 단일 추론 방식만 사용하지 말고 하이브리드 접근<br>
2. 추론 과정의 투명성과 설명 가능성 확보<br>
3. 오류 처리와 불확실성 정량화<br>
4. 도메인 특성에 맞는 추론 체계 선택</p>
<p>현대 AI는 여러 추론 방법론을 결합하여 복잡한 문제를 해결한다.<br>
LLM은 귀납적 학습 + 가추적 추론 + 유추적 전이를 통합적으로 수행하며,<br>
RAG 시스템은 사례 기반 검색 + 연역적 생성을 결합한다.<br>
추론 이론의 깊은 이해는 더 강력하고 신뢰할 수 있는 AI 시스템 구축의 기초가 된다.</p>


</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>