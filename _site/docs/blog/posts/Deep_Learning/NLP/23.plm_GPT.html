<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="GPT는 Transformer 디코더 기반의 생성형 사전 학습 모델로 자연어 생성 분야에 혁신을 가져왔다. Next Token Prediction을 통한 사전 학습 방식, 강력한 텍스트 생성 능력, 그리고 In-Context Learning을 통한 Few-Shot 학습 능력을 분석한다. GPT의 구조, 학습 방법, 각 버전별 발전 과정과 함께 ChatGPT로 이어지는 생성형 AI 혁명의 시작점으로서의 의미를 다룬다.">

<title>GPT: Generative Pre-trained Transformer – Kwangmin Kim</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="GPT: Generative Pre-trained Transformer – Kwangmin Kim">
<meta property="og:description" content="GPT는 Transformer 디코더 기반의 생성형 사전 학습 모델로 자연어 생성 분야에 혁신을 가져왔다. Next Token Prediction을 통한 사전 학습 방식, 강력한 텍스트 생성 능력, 그리고 In-Context Learning을 통한 Few-Shot 학습 능력을 분석한다. GPT의 구조, 학습 방법, 각 버전별 발전 과정과 함께 ChatGPT로 이어지는 생성형 AI 혁명의 시작점으로서의 의미를 다룬다.">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="GPT: Generative Pre-trained Transformer – Kwangmin Kim">
<meta name="twitter:description" content="GPT는 Transformer 디코더 기반의 생성형 사전 학습 모델로 자연어 생성 분야에 혁신을 가져왔다. Next Token Prediction을 통한 사전 학습 방식, 강력한 텍스트 생성 능력, 그리고 In-Context Learning을 통한 Few-Shot 학습 능력을 분석한다. GPT의 구조, 학습 방법, 각 버전별 발전 과정과 함께 ChatGPT로 이어지는 생성형 AI 혁명의 시작점으로서의 의미를 다룬다.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">GPT: Generative Pre-trained Transformer</h1>
            <p class="subtitle lead">생성형 언어 모델의 혁신과 대화형 AI의 출발점</p>
                  <div>
        <div class="description">
          <p>GPT는 Transformer 디코더 기반의 생성형 사전 학습 모델로 자연어 생성 분야에 혁신을 가져왔다. Next Token Prediction을 통한 사전 학습 방식, 강력한 텍스트 생성 능력, 그리고 In-Context Learning을 통한 Few-Shot 학습 능력을 분석한다. GPT의 구조, 학습 방법, 각 버전별 발전 과정과 함께 ChatGPT로 이어지는 생성형 AI 혁명의 시작점으로서의 의미를 다룬다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">NLP</div>
                <div class="quarto-category">Deep Learning</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2025년 01월 23일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#요약" id="toc-요약" class="nav-link active" data-scroll-target="#요약"><span class="header-section-number">1</span> 요약</a></li>
  <li><a href="#nlp-모델-발전-과정" id="toc-nlp-모델-발전-과정" class="nav-link" data-scroll-target="#nlp-모델-발전-과정"><span class="header-section-number">2</span> NLP 모델 발전 과정</a></li>
  <li><a href="#gpt-이전-모델들의-한계점" id="toc-gpt-이전-모델들의-한계점" class="nav-link" data-scroll-target="#gpt-이전-모델들의-한계점"><span class="header-section-number">3</span> GPT 이전 모델들의 한계점</a>
  <ul class="collapse">
  <li><a href="#기존-언어-모델의-문제점" id="toc-기존-언어-모델의-문제점" class="nav-link" data-scroll-target="#기존-언어-모델의-문제점"><span class="header-section-number">3.1</span> 기존 언어 모델의 문제점</a></li>
  </ul></li>
  <li><a href="#gpt-generative-pre-trained-transformer" id="toc-gpt-generative-pre-trained-transformer" class="nav-link" data-scroll-target="#gpt-generative-pre-trained-transformer"><span class="header-section-number">4</span> GPT (Generative Pre-trained Transformer)</a>
  <ul class="collapse">
  <li><a href="#개요와-기본-개념" id="toc-개요와-기본-개념" class="nav-link" data-scroll-target="#개요와-기본-개념"><span class="header-section-number">4.1</span> 개요와 기본 개념</a>
  <ul class="collapse">
  <li><a href="#핵심-아이디어" id="toc-핵심-아이디어" class="nav-link" data-scroll-target="#핵심-아이디어"><span class="header-section-number">4.1.1</span> 핵심 아이디어</a></li>
  </ul></li>
  <li><a href="#아키텍처-상세" id="toc-아키텍처-상세" class="nav-link" data-scroll-target="#아키텍처-상세"><span class="header-section-number">4.2</span> 아키텍처 상세</a>
  <ul class="collapse">
  <li><a href="#transformer-디코더-기반-구조" id="toc-transformer-디코더-기반-구조" class="nav-link" data-scroll-target="#transformer-디코더-기반-구조"><span class="header-section-number">4.2.1</span> Transformer 디코더 기반 구조</a></li>
  <li><a href="#핵심-구성-요소" id="toc-핵심-구성-요소" class="nav-link" data-scroll-target="#핵심-구성-요소"><span class="header-section-number">4.2.2</span> 핵심 구성 요소</a></li>
  </ul></li>
  <li><a href="#학습-방법" id="toc-학습-방법" class="nav-link" data-scroll-target="#학습-방법"><span class="header-section-number">4.3</span> 학습 방법</a>
  <ul class="collapse">
  <li><a href="#사전-학습-pre-training" id="toc-사전-학습-pre-training" class="nav-link" data-scroll-target="#사전-학습-pre-training"><span class="header-section-number">4.3.1</span> 사전 학습 (Pre-training)</a></li>
  <li><a href="#fine-tuning" id="toc-fine-tuning" class="nav-link" data-scroll-target="#fine-tuning"><span class="header-section-number">4.3.2</span> Fine-tuning</a></li>
  </ul></li>
  <li><a href="#gpt-버전별-발전-과정" id="toc-gpt-버전별-발전-과정" class="nav-link" data-scroll-target="#gpt-버전별-발전-과정"><span class="header-section-number">4.4</span> GPT 버전별 발전 과정</a>
  <ul class="collapse">
  <li><a href="#gpt-1-2018년-6월" id="toc-gpt-1-2018년-6월" class="nav-link" data-scroll-target="#gpt-1-2018년-6월"><span class="header-section-number">4.4.1</span> GPT-1 (2018년 6월)</a></li>
  <li><a href="#gpt-2-2019년-2월" id="toc-gpt-2-2019년-2월" class="nav-link" data-scroll-target="#gpt-2-2019년-2월"><span class="header-section-number">4.4.2</span> GPT-2 (2019년 2월)</a></li>
  <li><a href="#gpt-3-2020년-5월" id="toc-gpt-3-2020년-5월" class="nav-link" data-scroll-target="#gpt-3-2020년-5월"><span class="header-section-number">4.4.3</span> GPT-3 (2020년 5월)</a></li>
  <li><a href="#gpt-4-2023년-3월" id="toc-gpt-4-2023년-3월" class="nav-link" data-scroll-target="#gpt-4-2023년-3월"><span class="header-section-number">4.4.4</span> GPT-4 (2023년 3월)</a></li>
  </ul></li>
  <li><a href="#gpt의-핵심-혁신" id="toc-gpt의-핵심-혁신" class="nav-link" data-scroll-target="#gpt의-핵심-혁신"><span class="header-section-number">4.5</span> GPT의 핵심 혁신</a>
  <ul class="collapse">
  <li><a href="#스케일링-법칙-scaling-laws" id="toc-스케일링-법칙-scaling-laws" class="nav-link" data-scroll-target="#스케일링-법칙-scaling-laws"><span class="header-section-number">4.5.1</span> 스케일링 법칙 (Scaling Laws)</a></li>
  <li><a href="#창발적-능력-emergent-abilities" id="toc-창발적-능력-emergent-abilities" class="nav-link" data-scroll-target="#창발적-능력-emergent-abilities"><span class="header-section-number">4.5.2</span> 창발적 능력 (Emergent Abilities)</a></li>
  <li><a href="#인간-피드백-강화-학습-rlhf" id="toc-인간-피드백-강화-학습-rlhf" class="nav-link" data-scroll-target="#인간-피드백-강화-학습-rlhf"><span class="header-section-number">4.5.3</span> 인간 피드백 강화 학습 (RLHF)</a></li>
  <li><a href="#prompt-engineering의-발전" id="toc-prompt-engineering의-발전" class="nav-link" data-scroll-target="#prompt-engineering의-발전"><span class="header-section-number">4.5.4</span> Prompt Engineering의 발전</a></li>
  </ul></li>
  <li><a href="#gpt의-강점과-한계" id="toc-gpt의-강점과-한계" class="nav-link" data-scroll-target="#gpt의-강점과-한계"><span class="header-section-number">4.6</span> GPT의 강점과 한계</a>
  <ul class="collapse">
  <li><a href="#강점" id="toc-강점" class="nav-link" data-scroll-target="#강점"><span class="header-section-number">4.6.1</span> 강점</a></li>
  <li><a href="#한계" id="toc-한계" class="nav-link" data-scroll-target="#한계"><span class="header-section-number">4.6.2</span> 한계</a></li>
  </ul></li>
  <li><a href="#현재적-의미와-영향" id="toc-현재적-의미와-영향" class="nav-link" data-scroll-target="#현재적-의미와-영향"><span class="header-section-number">4.7</span> 현재적 의미와 영향</a></li>
  </ul></li>
  <li><a href="#결론" id="toc-결론" class="nav-link" data-scroll-target="#결론"><span class="header-section-number">5</span> 결론</a>
  <ul class="collapse">
  <li><a href="#gpt의-핵심-기여" id="toc-gpt의-핵심-기여" class="nav-link" data-scroll-target="#gpt의-핵심-기여"><span class="header-section-number">5.0.1</span> GPT의 핵심 기여</a></li>
  <li><a href="#생성형-ai-생태계의-탄생" id="toc-생성형-ai-생태계의-탄생" class="nav-link" data-scroll-target="#생성형-ai-생태계의-탄생"><span class="header-section-number">5.0.2</span> 생성형 AI 생태계의 탄생</a></li>
  <li><a href="#기술적-영향과-후속-발전" id="toc-기술적-영향과-후속-발전" class="nav-link" data-scroll-target="#기술적-영향과-후속-발전"><span class="header-section-number">5.0.3</span> 기술적 영향과 후속 발전</a></li>
  <li><a href="#사회적-변화와-도전-과제" id="toc-사회적-변화와-도전-과제" class="nav-link" data-scroll-target="#사회적-변화와-도전-과제"><span class="header-section-number">5.0.4</span> 사회적 변화와 도전 과제</a></li>
  <li><a href="#긍정적-영향" id="toc-긍정적-영향" class="nav-link" data-scroll-target="#긍정적-영향"><span class="header-section-number">5.0.5</span> 긍정적 영향</a></li>
  <li><a href="#해결-과제" id="toc-해결-과제" class="nav-link" data-scroll-target="#해결-과제"><span class="header-section-number">5.0.6</span> 해결 과제</a></li>
  <li><a href="#미래-전망과-발전-방향" id="toc-미래-전망과-발전-방향" class="nav-link" data-scroll-target="#미래-전망과-발전-방향"><span class="header-section-number">5.1</span> 미래 전망과 발전 방향</a>
  <ul class="collapse">
  <li><a href="#기술적-발전" id="toc-기술적-발전" class="nav-link" data-scroll-target="#기술적-발전"><span class="header-section-number">5.1.1</span> 기술적 발전</a></li>
  <li><a href="#응용-분야-확장" id="toc-응용-분야-확장" class="nav-link" data-scroll-target="#응용-분야-확장"><span class="header-section-number">5.1.2</span> 응용 분야 확장</a></li>
  </ul></li>
  <li><a href="#역사적-의미" id="toc-역사적-의미" class="nav-link" data-scroll-target="#역사적-의미"><span class="header-section-number">5.2</span> 역사적 의미</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="요약" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 요약</h1>
<p>GPT(Generative Pre-trained Transformer)는 2018년 OpenAI에서 발표한 혁신적인 생성형 사전 학습 언어 모델이다. 기존의 이해 중심 모델들과 달리 텍스트 생성에 특화되어 강력한 언어 생성 능력을 보여주었으며, 현재 ChatGPT로 이어지는 생성형 AI 혁명의 출발점이 되었다.</p>
<p>주요 특징과 혁신 사항은 다음과 같다:</p>
<ul>
<li><strong>생성형 언어 모델링</strong>:
<ul>
<li>Transformer 디코더 구조를 사용하여 순차적 텍스트 생성에 최적화</li>
<li>Causal Self-Attention으로 이전 토큰들만을 참조하는 일방향 처리</li>
<li>Next Token Prediction을 통한 자기회귀적 텍스트 생성</li>
</ul></li>
<li><strong>혁신적인 사전 학습 방식</strong>:
<ul>
<li><strong>Next Token Prediction</strong>: 이전 토큰들을 바탕으로 다음 토큰을 예측하는 단순하면서도 강력한 학습 목표</li>
<li>대규모 텍스트 데이터에서 언어의 패턴과 구조를 학습</li>
<li>문맥을 이해하고 일관성 있는 긴 텍스트 생성 능력 획득</li>
</ul></li>
<li><strong>확장성과 성능 향상</strong>:
<ul>
<li>GPT-1(117M) → GPT-2(1.5B) → GPT-3(175B) → GPT-4(추정 1T+)로 모델 크기 확장</li>
<li>데이터 양과 모델 크기 증가만으로도 성능이 지속적으로 향상됨을 입증</li>
<li>Scaling Laws를 통한 성능 예측 가능성 제시</li>
</ul></li>
<li><strong>In-Context Learning과 Few-Shot 능력</strong>:
<ul>
<li>별도 Fine-tuning 없이도 예시만으로 새로운 태스크 수행</li>
<li>Prompt Engineering을 통한 다양한 응용 가능성</li>
<li>Zero-shot, One-shot, Few-shot Learning의 강력한 성능</li>
</ul></li>
<li><strong>생성형 AI 패러다임 확립</strong>:
<ul>
<li>단순한 분류/이해를 넘어선 창조적 텍스트 생성</li>
<li>ChatGPT, GPT-4 등으로 이어지는 대화형 AI의 기반 마련</li>
<li>코드 생성, 창작, 번역, 요약 등 광범위한 생성 태스크에서 인간 수준 성능</li>
</ul></li>
</ul>
<p>GPT의 등장은 자연어 처리를 이해 중심에서 생성 중심으로 패러다임을 전환시켰으며, 현재 우리가 경험하고 있는 생성형 AI 시대의 기초를 마련했다.</p>
</section>
<section id="nlp-모델-발전-과정" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> NLP 모델 발전 과정</h1>
<pre><code>RNN Language Model
├── Seq2Seq
├── Beam Search
├── Subword Tokenization
├── Attention
├── Transformer Encoder (Vaswani et al., 2017)
|   ├── Positional Encoding
|   ├── Multi-Head Attention
|   └── Feed Forward Neural Network
|
├── Transformer Decoder (Vaswani et al., 2017)
|
├── GPT 시리즈 (OpenAI,2018~)
|   ├── GPT-1~4
|   └── ChatGPT (OpenAI,2022~)
|
├── BERT 시리즈 (Google,2018~)
|   ├── BERT
|   ├── RoBERTa
|   └── ALBERT
|
├── BERT 변형 모델들
|   ├── RoBERTa (Facebook, 2019)
|   ├── ALBERT (Google, 2019)
|   ├── DistilBERT (Hugging Face, 2019)
|   └── ELECTRA (Google, 2020)
|
└── 후속 발전 모델들
    ├── T5, XLNet, DeBERTa
    └── ChatGPT, PaLM, Claude, Gemini 등</code></pre>
</section>
<section id="gpt-이전-모델들의-한계점" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> GPT 이전 모델들의 한계점</h1>
<section id="기존-언어-모델의-문제점" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="기존-언어-모델의-문제점"><span class="header-section-number">3.1</span> 기존 언어 모델의 문제점</h2>
<ul>
<li><strong>일방향성의 한계</strong>:
<ul>
<li>기존 RNN 기반 언어 모델은 순차적 처리로 인한 병렬화 불가</li>
<li>긴 시퀀스에서의 그래디언트 소실 문제</li>
<li>문맥 정보의 제한적 활용</li>
</ul></li>
<li><strong>제한적인 전이 학습</strong>:
<ul>
<li>태스크별로 별도의 모델 아키텍처 필요</li>
<li>사전 학습된 표현의 활용도 제한</li>
<li>Fine-tuning 과정에서 많은 라벨 데이터 요구</li>
</ul></li>
<li><strong>생성 능력의 부족</strong>:
<ul>
<li>주로 분류나 이해 태스크에 집중</li>
<li>창조적이고 일관성 있는 텍스트 생성의 어려움</li>
<li>다양한 도메인과 스타일에 대한 적응력 부족</li>
</ul></li>
</ul>
</section>
</section>
<section id="gpt-generative-pre-trained-transformer" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> GPT (Generative Pre-trained Transformer)</h1>
<section id="개요와-기본-개념" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="개요와-기본-개념"><span class="header-section-number">4.1</span> 개요와 기본 개념</h2>
<ul>
<li>GPT는 <strong>생성형 사전 학습 트랜스포머</strong>로, 2018년 OpenAI에서 발표한 혁신적인 언어 모델이다.</li>
<li>기존의 이해 중심 모델들과 달리 <strong>텍스트 생성</strong>에 특화되어 설계되었으며, 현재 ChatGPT로까지 이어지는 생성형 AI 혁명의 시발점이 되었다.</li>
</ul>
<section id="핵심-아이디어" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="핵심-아이디어"><span class="header-section-number">4.1.1</span> 핵심 아이디어</h3>
<ul>
<li><strong>단순함의 힘</strong>: Next Token Prediction이라는 단순한 목표로 복잡한 언어 능력 학습</li>
<li><strong>확장성</strong>: 모델 크기와 데이터 양을 늘리는 것만으로도 성능 향상 가능</li>
<li><strong>범용성</strong>: 하나의 모델로 다양한 생성 태스크 수행</li>
</ul>
</section>
</section>
<section id="아키텍처-상세" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="아키텍처-상세"><span class="header-section-number">4.2</span> 아키텍처 상세</h2>
<section id="transformer-디코더-기반-구조" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="transformer-디코더-기반-구조"><span class="header-section-number">4.2.1</span> Transformer 디코더 기반 구조</h3>
<pre><code>입력 토큰들 → 토큰 임베딩 + 위치 임베딩
    ↓
Transformer 디코더 블록 × N
├── Masked Multi-Head Self-Attention
├── Layer Normalization
├── Feed-Forward Network
└── Layer Normalization
    ↓
출력 Linear Layer → 다음 토큰 확률 분포</code></pre>
</section>
<section id="핵심-구성-요소" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="핵심-구성-요소"><span class="header-section-number">4.2.2</span> 핵심 구성 요소</h3>
<ul>
<li><strong>Causal Self-Attention</strong>:
<ul>
<li>이전 위치의 토큰들만 참조 가능 (미래 정보 차단)</li>
<li>순차적 생성 과정에서 정보 누출 방지</li>
<li>문장을 왼쪽부터 오른쪽으로 읽으면서, 현재 단어를 이해할 때 이미 본 단어들만 참고할 수 있다</li>
<li>예: “나는 오늘 학교에 갔다”에서 “학교”를 처리할 때, “나는”, “오늘”만 참고 가능하고 “갔다”는 참고 불가</li>
<li>이렇게 하는 이유는 텍스트 생성 시 다음 단어를 예측해야 하는데, 미래 단어를 미리 알면 부정행위가 되기 때문</li>
<li>Attention score matrix에서 상삼각 부분을 -∞로 마스킹</li>
<li>Softmax 적용 후 미래 위치의 attention weight가 0이 됨</li>
<li>결과적으로 현재 위치 이전의 토큰들만 정보 제공</li>
<li>참고: Self-Attention
<ul>
<li>한 문장 내에서 각 단어가 다른 모든 단어들과 얼마나 관련이 있는지를 계산하는 메커니즘</li>
<li>문장: “그 강아지는 공원에서 뛰어다니며 즐거워했다”</li>
<li>각 단어를 처리할 때:
<ul>
<li>“강아지”를 이해하려면 → “뛰어다니며”, “즐거워했다”와 연결해서 생각</li>
<li>“뛰어다니며”를 이해하려면 → “강아지”, “공원에서”와 연결해서 생각</li>
<li>“즐거워했다”를 이해하려면 → “강아지”와 강하게 연결해서 생각</li>
</ul></li>
<li>핵심: 각 단어가 문장의 다른 모든 단어들을 “쳐다보면서” 관련성을 파악</li>
</ul></li>
</ul></li>
<li><strong>위치 인코딩</strong>:
<ul>
<li>Transformer는 본질적으로 순서를 모르는 구조이므로, 토큰의 위치 정보를 별도로 주입해야 한다.</li>
<li>학습 가능한 절대 위치 임베딩 사용</li>
<li>토큰의 순서 정보를 모델에 제공</li>
<li>단어 카드를 무작위로 섞어놓으면 문장의 의미가 바뀌는 것처럼, AI도 단어의 순서를 알아야 함</li>
<li>“강아지가 고양이를 쫓았다”와 “고양이가 강아지를 쫓았다”는 완전히 다른 의미</li>
<li>각 위치(1번째, 2번째, 3번째…)에 고유한 “위치 ID카드”를 부여하는 개념</li>
<li>학습 가능한 위치 임베딩 사용 (고정된 삼각함수 대신)</li>
<li>각 위치마다 별도의 벡터를 학습하여 토큰 임베딩에 더함</li>
<li>최대 시퀀스 길이까지만 위치 정보 제공 가능</li>
</ul></li>
<li><strong>Layer Normalization</strong>:
<ul>
<li>딥러닝에서 학습을 안정화하고 빠르게 만드는 정규화 기법</li>
<li>각 서브레이어 이후 정규화 적용</li>
<li>요리할 때 재료들의 크기를 비슷하게 맞춰서 골고루 익도록 하는 것과 유사</li>
<li>신경망 각 층에서 데이터의 분포가 너무 치우치거나 분산되지 않도록 조정</li>
<li>마치 각 층마다 “데이터 정리정돈”을 해주는 역할</li>
<li>학습 안정성과 수렴 속도 향상</li>
<li>Pre-LN(Pre Layer Normalization) 구조로 깊은 네트워크 학습 가능
<ul>
<li>각 Transformer 블록 내부의 서브레이어(attention, feedforward) 이후에 적용</li>
<li>Post-LN 구조: 서브레이어 입력 전에 정규화 (원래 Transformer는 Post-LN)</li>
<li>깊은 네트워크에서도 gradient가 잘 전달되어 학습이 안정적</li>
<li>정규화 없이는 깊은 네트워크에서 gradient vanishing/exploding 문제 발생</li>
<li>학습 속도가 빨라지고 더 높은 학습률 사용 가능</li>
<li>각 층의 입력 분포가 안정적이어서 일관된 학습 가능</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section id="학습-방법" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="학습-방법"><span class="header-section-number">4.3</span> 학습 방법</h2>
<section id="사전-학습-pre-training" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="사전-학습-pre-training"><span class="header-section-number">4.3.1</span> 사전 학습 (Pre-training)</h3>
<p><strong>목표</strong>: Next Token Prediction <span class="math display">\[ P(w_t | w_1, w_2, ..., w_{t-1}) = \text{softmax}(W_o \cdot h_t) \]</span></p>
<ul>
<li><p><strong>데이터</strong>: 대규모 인터넷 텍스트 (CommonCrawl, WebText, Books, Wikipedia 등)</p></li>
<li><p><strong>손실 함수</strong>: Cross-Entropy Loss <span class="math display">\[ \mathcal{L} = -\sum_{t=1}^{T} \log P(w_t | w_1, ..., w_{t-1}) \]</span></p></li>
<li><p><strong>학습 과정</strong>:</p>
<ol type="1">
<li>입력 시퀀스의 각 위치에서 다음 토큰 예측</li>
<li>실제 토큰과 예측 분포 간의 크로스 엔트로피 최소화</li>
<li>자기회귀적 생성을 통한 언어 패턴 학습</li>
</ol></li>
</ul>
</section>
<section id="fine-tuning" class="level3" data-number="4.3.2">
<h3 data-number="4.3.2" class="anchored" data-anchor-id="fine-tuning"><span class="header-section-number">4.3.2</span> Fine-tuning</h3>
<p><strong>기존 방식</strong>: * 태스크별 특수 토큰 추가 (예: <code>[CLS]</code>, <code>[SEP]</code>) * 출력 레이어만 태스크에 맞게 수정 * 적은 양의 라벨 데이터로 추가 학습</p>
<p><strong>GPT-3 이후</strong>: * <strong>In-Context Learning</strong>: Fine-tuning 없이 예시만으로 태스크 수행 * <strong>Prompt Engineering</strong>: 적절한 프롬프트 설계를 통한 성능 최적화 * <strong>Few-Shot Learning</strong>: 소수 예시로 새로운 태스크 학습</p>
</section>
</section>
<section id="gpt-버전별-발전-과정" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="gpt-버전별-발전-과정"><span class="header-section-number">4.4</span> GPT 버전별 발전 과정</h2>
<section id="gpt-1-2018년-6월" class="level3" data-number="4.4.1">
<h3 data-number="4.4.1" class="anchored" data-anchor-id="gpt-1-2018년-6월"><span class="header-section-number">4.4.1</span> GPT-1 (2018년 6월)</h3>
<ul>
<li><strong>모델 크기</strong>: 117M 파라미터</li>
<li><strong>데이터</strong>: BooksCorpus (7,000권의 책)</li>
<li><strong>혁신 사항</strong>:
<ul>
<li>Transformer 디코더 기반 언어 모델 최초 제안</li>
<li>Unsupervised Pre-training + Supervised Fine-tuning 패러다임 확립</li>
<li>다양한 NLP 태스크에서 기존 모델 대비 성능 향상</li>
</ul></li>
</ul>
</section>
<section id="gpt-2-2019년-2월" class="level3" data-number="4.4.2">
<h3 data-number="4.4.2" class="anchored" data-anchor-id="gpt-2-2019년-2월"><span class="header-section-number">4.4.2</span> GPT-2 (2019년 2월)</h3>
<ul>
<li><strong>모델 크기</strong>: 1.5B 파라미터 (Small: 117M, Medium: 345M, Large: 762M, XL: 1.5B)</li>
<li><strong>데이터</strong>: WebText (800만 개 웹페이지, 40GB)</li>
<li><strong>혁신 사항</strong>:
<ul>
<li>모델 크기 대폭 확장 (10배 증가)</li>
<li>Zero-shot 태스크 수행 능력 확인</li>
<li>고품질 텍스트 생성으로 인한 오남용 우려 (초기 공개 제한)</li>
<li>“더 큰 모델이 더 좋은 성능”이라는 스케일링 법칙 입증</li>
</ul></li>
</ul>
</section>
<section id="gpt-3-2020년-5월" class="level3" data-number="4.4.3">
<h3 data-number="4.4.3" class="anchored" data-anchor-id="gpt-3-2020년-5월"><span class="header-section-number">4.4.3</span> GPT-3 (2020년 5월)</h3>
<ul>
<li><strong>모델 크기</strong>: 175B 파라미터</li>
<li><strong>데이터</strong>: 570GB 텍스트 (CommonCrawl, WebText2, Books1/2, Wikipedia)</li>
<li><strong>혁신 사항</strong>:
<ul>
<li><strong>In-Context Learning</strong>: Fine-tuning 없이 예시만으로 태스크 수행</li>
<li><strong>Few-Shot Learning</strong>: 소수 예시로 새로운 태스크 학습</li>
<li>인간 수준의 텍스트 생성 품질</li>
<li>코딩, 수학, 추론 등 다양한 도메인에서 놀라운 성능</li>
<li>API 형태로 서비스 제공하여 생성형 AI 생태계 구축</li>
</ul></li>
</ul>
</section>
<section id="gpt-4-2023년-3월" class="level3" data-number="4.4.4">
<h3 data-number="4.4.4" class="anchored" data-anchor-id="gpt-4-2023년-3월"><span class="header-section-number">4.4.4</span> GPT-4 (2023년 3월)</h3>
<ul>
<li><strong>모델 크기</strong>: 공개되지 않음 (추정 1T+ 파라미터)</li>
<li><strong>데이터</strong>: 다중 모달 데이터 (텍스트 + 이미지)</li>
<li><strong>혁신 사항</strong>:
<ul>
<li><strong>다중 모달 능력</strong>: 텍스트와 이미지 동시 처리</li>
<li>더욱 향상된 추론 능력과 안전성</li>
<li>긴 컨텍스트 처리 능력 (32K 토큰)</li>
<li>전문 시험에서 인간 수준 또는 그 이상의 성능</li>
</ul></li>
</ul>
</section>
</section>
<section id="gpt의-핵심-혁신" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="gpt의-핵심-혁신"><span class="header-section-number">4.5</span> GPT의 핵심 혁신</h2>
<section id="스케일링-법칙-scaling-laws" class="level3" data-number="4.5.1">
<h3 data-number="4.5.1" class="anchored" data-anchor-id="스케일링-법칙-scaling-laws"><span class="header-section-number">4.5.1</span> 스케일링 법칙 (Scaling Laws)</h3>
<p><span class="math display">\[\text{Loss} \propto N^{-\alpha}\]</span></p>
<ul>
<li>모델 크기(N), 데이터 양, 계산량이 증가할수록 성능 향상</li>
<li>예측 가능한 성능 개선 곡선</li>
<li>“더 크면 더 좋다”는 단순하지만 강력한 원리</li>
</ul>
</section>
<section id="창발적-능력-emergent-abilities" class="level3" data-number="4.5.2">
<h3 data-number="4.5.2" class="anchored" data-anchor-id="창발적-능력-emergent-abilities"><span class="header-section-number">4.5.2</span> 창발적 능력 (Emergent Abilities)</h3>
<ul>
<li><strong>특정 임계점</strong>을 넘으면 갑자기 나타나는 새로운 능력들</li>
<li><strong>In-Context Learning</strong>: GPT-3에서 처음 관찰</li>
<li><strong>Chain-of-Thought Reasoning</strong>: 단계별 추론 능력</li>
<li><strong>코드 생성</strong>: 프로그래밍 언어 이해와 생성</li>
</ul>
</section>
<section id="인간-피드백-강화-학습-rlhf" class="level3" data-number="4.5.3">
<h3 data-number="4.5.3" class="anchored" data-anchor-id="인간-피드백-강화-학습-rlhf"><span class="header-section-number">4.5.3</span> 인간 피드백 강화 학습 (RLHF)</h3>
<p><strong>InstructGPT와 ChatGPT에 도입</strong>: 1. <strong>Supervised Fine-tuning</strong>: 고품질 대화 데이터로 학습 2. <strong>Reward Model</strong>: 인간 선호도 기반 보상 모델 학습 3. <strong>PPO</strong>: 보상 모델을 사용한 강화 학습</p>
</section>
<section id="prompt-engineering의-발전" class="level3" data-number="4.5.4">
<h3 data-number="4.5.4" class="anchored" data-anchor-id="prompt-engineering의-발전"><span class="header-section-number">4.5.4</span> Prompt Engineering의 발전</h3>
<ul>
<li><strong>Zero-shot</strong>: 예시 없이 태스크 수행</li>
<li><strong>Few-shot</strong>: 소수 예시로 태스크 학습</li>
<li><strong>Chain-of-Thought</strong>: 단계별 추론 과정 명시</li>
<li><strong>Constitutional AI</strong>: 원칙 기반 행동 유도</li>
</ul>
</section>
</section>
<section id="gpt의-강점과-한계" class="level2" data-number="4.6">
<h2 data-number="4.6" class="anchored" data-anchor-id="gpt의-강점과-한계"><span class="header-section-number">4.6</span> GPT의 강점과 한계</h2>
<section id="강점" class="level3" data-number="4.6.1">
<h3 data-number="4.6.1" class="anchored" data-anchor-id="강점"><span class="header-section-number">4.6.1</span> 강점</h3>
<ul>
<li><strong>뛰어난 생성 능력</strong>: 일관성 있고 창의적인 텍스트 생성</li>
<li><strong>범용성</strong>: 하나의 모델로 다양한 태스크 수행</li>
<li><strong>적응성</strong>: 프롬프트만으로 새로운 태스크 수행</li>
<li><strong>확장성</strong>: 모델 크기 증가로 성능 향상 가능</li>
</ul>
</section>
<section id="한계" class="level3" data-number="4.6.2">
<h3 data-number="4.6.2" class="anchored" data-anchor-id="한계"><span class="header-section-number">4.6.2</span> 한계</h3>
<ul>
<li><strong>사실성 문제</strong>: 할루시네이션 (거짓 정보 생성)</li>
<li><strong>편향성</strong>: 학습 데이터의 편향 반영</li>
<li><strong>해석 가능성</strong>: 내부 동작 원리의 불투명성</li>
<li><strong>계산 비용</strong>: 대규모 모델의 높은 추론 비용</li>
</ul>
</section>
</section>
<section id="현재적-의미와-영향" class="level2" data-number="4.7">
<h2 data-number="4.7" class="anchored" data-anchor-id="현재적-의미와-영향"><span class="header-section-number">4.7</span> 현재적 의미와 영향</h2>
<p>GPT는 단순한 기술 발전을 넘어 <strong>인간-AI 상호작용의 패러다임</strong>을 바꾸었다:</p>
<ul>
<li><strong>ChatGPT 현상</strong>: 일반 대중의 AI 접근성 혁신</li>
<li><strong>생성형 AI 생태계</strong>: 수많은 응용 서비스와 스타트업 등장</li>
<li><strong>업무 방식 변화</strong>: 글쓰기, 코딩, 창작 등 지식 작업의 혁신</li>
<li><strong>교육 패러다임 변화</strong>: AI 활용 능력의 중요성 대두</li>
</ul>
</section>
</section>
<section id="결론" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> 결론</h1>
<ul>
<li>GPT는 자연어 처리 분야에서 <strong>생성형 AI 혁명</strong>의 출발점이 된 가장 중요한 혁신 중 하나다.</li>
<li>2018년 첫 발표 이후 현재까지 NLP 연구와 실용 AI의 패러다임을 완전히 바꾸어 놓았다.</li>
</ul>
<section id="gpt의-핵심-기여" class="level3" data-number="5.0.1">
<h3 data-number="5.0.1" class="anchored" data-anchor-id="gpt의-핵심-기여"><span class="header-section-number">5.0.1</span> GPT의 핵심 기여</h3>
<ul>
<li><strong>생성형 언어 모델의 확립</strong>: 이해 중심에서 생성 중심으로 NLP 패러다임 전환, Next Token Prediction이라는 단순한 목표로 복잡한 언어 능력 획득</li>
<li><strong>스케일링 법칙의 입증</strong>: 모델 크기와 데이터 양 증가만으로도 성능이 예측 가능하게 향상됨을 보여주어 대규모 AI 개발의 방향 제시</li>
<li><strong>In-Context Learning의 발견</strong>: Fine-tuning 없이도 예시만으로 새로운 태스크를 수행할 수 있는 혁신적 능력으로 AI 활용 방식을 근본적으로 변화</li>
<li><strong>창발적 능력의 관찰</strong>: 특정 규모를 넘으면 갑자기 나타나는 추론, 코딩, 창작 등의 고차원적 능력으로 AI 발전의 새로운 가능성 제시</li>
</ul>
</section>
<section id="생성형-ai-생태계의-탄생" class="level3" data-number="5.0.2">
<h3 data-number="5.0.2" class="anchored" data-anchor-id="생성형-ai-생태계의-탄생"><span class="header-section-number">5.0.2</span> 생성형 AI 생태계의 탄생</h3>
<p>GPT의 등장은 단순한 기술 발전을 넘어 완전히 새로운 <strong>생성형 AI 생태계</strong>를 만들어냈다:</p>
<ul>
<li><strong>ChatGPT 현상</strong>: 2022년 ChatGPT 출시로 일반 대중이 AI와 자연어로 대화하는 새로운 경험 제공, 전 세계적인 AI 관심과 활용 폭발적 증가</li>
<li><strong>산업 생태계 변화</strong>: 수많은 GPT 기반 서비스와 스타트업 등장, 기존 산업의 디지털 전환 가속화</li>
<li><strong>생산성 혁신</strong>: 글쓰기, 코딩, 번역, 요약 등 지식 작업의 자동화 및 보조 도구로 활용되어 업무 효율성 획기적 향상</li>
<li><strong>창작과 교육 변화</strong>: AI와의 협업을 통한 새로운 창작 방식 등장, 교육 방법과 평가 체계의 근본적 재고</li>
</ul>
</section>
<section id="기술적-영향과-후속-발전" class="level3" data-number="5.0.3">
<h3 data-number="5.0.3" class="anchored" data-anchor-id="기술적-영향과-후속-발전"><span class="header-section-number">5.0.3</span> 기술적 영향과 후속 발전</h3>
<p>GPT가 확립한 기술적 기반은 이후 모든 언어 AI 발전의 토대가 되었다:</p>
<ul>
<li><strong>아키텍처 표준화</strong>: Transformer 디코더 기반 구조가 생성형 언어 모델의 표준이 됨</li>
<li><strong>훈련 방법론</strong>: Next Token Prediction과 RLHF(인간 피드백 강화 학습)가 대화형 AI 개발의 핵심 방법론으로 자리잡음</li>
<li><strong>다중 모달 확장</strong>: GPT-4의 텍스트-이미지 처리 능력을 시작으로 멀티모달 AI 발전의 기반 마련</li>
<li><strong>경쟁 모델들의 등장</strong>: Google의 Gemini, Anthropic의 Claude, Meta의 Llama 등 다양한 대안 모델들의 개발 촉진</li>
</ul>
</section>
<section id="사회적-변화와-도전-과제" class="level3" data-number="5.0.4">
<h3 data-number="5.0.4" class="anchored" data-anchor-id="사회적-변화와-도전-과제"><span class="header-section-number">5.0.4</span> 사회적 변화와 도전 과제</h3>
<p>GPT는 기술적 혁신을 넘어 사회 전반에 깊은 영향을 미치고 있다:</p>
</section>
<section id="긍정적-영향" class="level3" data-number="5.0.5">
<h3 data-number="5.0.5" class="anchored" data-anchor-id="긍정적-영향"><span class="header-section-number">5.0.5</span> 긍정적 영향</h3>
<ul>
<li><strong>접근성 혁신</strong>: 복잡한 기술 지식 없이도 자연어로 AI 활용 가능</li>
<li><strong>창의성 증진</strong>: AI와의 협업을 통한 새로운 아이디어 창출과 표현 방식 확장</li>
<li><strong>교육 개인화</strong>: 맞춤형 학습 지원과 즉시 피드백 제공</li>
<li><strong>언어 장벽 해소</strong>: 실시간 번역과 다국어 소통 지원</li>
</ul>
</section>
<section id="해결-과제" class="level3" data-number="5.0.6">
<h3 data-number="5.0.6" class="anchored" data-anchor-id="해결-과제"><span class="header-section-number">5.0.6</span> 해결 과제</h3>
<ul>
<li><strong>진실성과 신뢰성</strong>: 할루시네이션 문제와 잘못된 정보 생성 위험</li>
<li><strong>윤리적 책임</strong>: AI 생성 콘텐츠의 책임 소재와 저작권 문제</li>
<li><strong>사회적 불평등</strong>: AI 접근성 격차와 일자리 대체 우려</li>
<li><strong>안전성 확보</strong>: 악용 방지와 AI 정렬(Alignment) 문제</li>
</ul>
</section>
<section id="미래-전망과-발전-방향" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="미래-전망과-발전-방향"><span class="header-section-number">5.1</span> 미래 전망과 발전 방향</h2>
<p>GPT가 열어놓은 생성형 AI의 미래는 다음과 같은 방향으로 발전할 것으로 예상된다:</p>
<section id="기술적-발전" class="level3" data-number="5.1.1">
<h3 data-number="5.1.1" class="anchored" data-anchor-id="기술적-발전"><span class="header-section-number">5.1.1</span> 기술적 발전</h3>
<ul>
<li><strong>더 큰 규모</strong>: 수조 파라미터 규모의 모델과 더욱 방대한 학습 데이터</li>
<li><strong>효율성 개선</strong>: 추론 속도 향상과 계산 비용 감소를 위한 최적화 기술</li>
<li><strong>전문화</strong>: 도메인별 특화 모델과 개인화된 AI 어시스턴트</li>
<li><strong>다중 모달</strong>: 텍스트, 이미지, 음성, 비디오를 통합한 범용 AI</li>
</ul>
</section>
<section id="응용-분야-확장" class="level3" data-number="5.1.2">
<h3 data-number="5.1.2" class="anchored" data-anchor-id="응용-분야-확장"><span class="header-section-number">5.1.2</span> 응용 분야 확장</h3>
<ul>
<li><strong>과학 연구</strong>: 논문 작성, 가설 생성, 실험 설계 지원</li>
<li><strong>의료 분야</strong>: 진단 보조, 치료법 연구, 의료 문서 작성</li>
<li><strong>법률 서비스</strong>: 계약서 분석, 판례 검색, 법률 문서 작성</li>
<li><strong>예술과 미디어</strong>: 소설, 시나리오, 음악 창작의 새로운 방법론</li>
</ul>
</section>
</section>
<section id="역사적-의미" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="역사적-의미"><span class="header-section-number">5.2</span> 역사적 의미</h2>
<p>GPT의 등장은 <strong>인공지능 역사의 중요한 전환점</strong>이다. 1950년대 튜링 테스트 제안, 1980년대 신경망 부흥, 2010년대 딥러닝 혁명에 이어, GPT는 <strong>AI가 인간과 자연스럽게 소통할 수 있는 시대</strong>를 열었다.</p>
<p>특히 ChatGPT의 대중적 성공은 AI를 전문가들만의 도구에서 일반인도 일상적으로 사용하는 기술로 바꾸어 놓았다. 이는 개인용 컴퓨터나 인터넷의 등장에 비견될 만한 기술적, 사회적 변화를 의미한다.</p>
<p>GPT로 시작된 생성형 AI 시대는 이제 막 시작되었으며, 향후 인간의 창조적 활동, 학습 방식, 의사소통 패턴까지 근본적으로 변화시킬 것이다. 이러한 변화의 중심에서 GPT는 <strong>AI와 인간이 협력하는 새로운 시대의 출발점</strong>으로 역사에 기록될 것이다.</p>


</section>
</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("kk3225\.netlify\.app");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>