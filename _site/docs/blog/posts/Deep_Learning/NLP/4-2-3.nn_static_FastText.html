<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="dcterms.date" content="2025-01-08">
<meta name="description" content="자연어 처리(NLP)에서 단어를 내부 단어(subword)의 벡터 합으로 표현하는 FastText 모델의 원리와 특징을 소개한다. OOV 문제 해결 및 형태론적 정보 활용의 이점을 살펴본다.">

<title>텍스트 벡터화: FastText의 이해 – Kwangmin Kim</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="텍스트 벡터화: FastText의 이해 – Kwangmin Kim">
<meta property="og:description" content="자연어 처리(NLP)에서 단어를 내부 단어(subword)의 벡터 합으로 표현하는 FastText 모델의 원리와 특징을 소개한다. OOV 문제 해결 및 형태론적 정보 활용의 이점을 살펴본다.">
<meta property="og:site_name" content="Kwangmin Kim">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#요약" id="toc-요약" class="nav-link active" data-scroll-target="#요약"><span class="header-section-number">1</span> 요약</a></li>
  <li><a href="#텍스트-인코딩-및-벡터화" id="toc-텍스트-인코딩-및-벡터화" class="nav-link" data-scroll-target="#텍스트-인코딩-및-벡터화"><span class="header-section-number">2</span> 텍스트 인코딩 및 벡터화</a></li>
  <li><a href="#신경망-사용-20082018-static-word-embedding" id="toc-신경망-사용-20082018-static-word-embedding" class="nav-link" data-scroll-target="#신경망-사용-20082018-static-word-embedding"><span class="header-section-number">3</span> 신경망 사용 (2008~2018): Static Word Embedding</a>
  <ul class="collapse">
  <li><a href="#fasttext-2017" id="toc-fasttext-2017" class="nav-link" data-scroll-target="#fasttext-2017"><span class="header-section-number">3.1</span> FastText (2017)</a>
  <ul class="collapse">
  <li><a href="#기존-방법의-한계" id="toc-기존-방법의-한계" class="nav-link" data-scroll-target="#기존-방법의-한계"><span class="header-section-number">3.1.1</span> 기존 방법의 한계</a></li>
  <li><a href="#fasttext의-해결책" id="toc-fasttext의-해결책" class="nav-link" data-scroll-target="#fasttext의-해결책"><span class="header-section-number">3.1.2</span> FastText의 해결책</a></li>
  <li><a href="#실제-성능-비교" id="toc-실제-성능-비교" class="nav-link" data-scroll-target="#실제-성능-비교"><span class="header-section-number">3.1.3</span> 실제 성능 비교</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#결론" id="toc-결론" class="nav-link" data-scroll-target="#결론"><span class="header-section-number">4</span> 결론</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">텍스트 벡터화: FastText의 이해</h1>
<p class="subtitle lead">Subword 정보를 활용한 단어 임베딩</p>
  <div class="quarto-categories">
    <div class="quarto-category">NLP</div>
    <div class="quarto-category">Deep Learning</div>
  </div>
  </div>

<div>
  <div class="description">
    <p>자연어 처리(NLP)에서 단어를 내부 단어(subword)의 벡터 합으로 표현하는 FastText 모델의 원리와 특징을 소개한다. OOV 문제 해결 및 형태론적 정보 활용의 이점을 살펴본다.</p>
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Kwangmin Kim </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 8, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="요약" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 요약</h1>
<p>이 문서는 기존 Word2Vec이나 GloVe와 달리 단어를 내부 단어(subword)들의 집합으로 간주하여 임베딩하는 FastText 모델의 기본 원리를 설명한다.</p>
<ul>
<li><strong>기존 방법의 한계와 FastText의 접근법</strong>:
<ul>
<li>Word2Vec, GloVe 등은 단어를 하나의 단위로 취급하여 OOV(Out-of-Vocabulary) 문제에 취약하고, 단어 내부의 형태론적 정보를 활용하기 어렵다는 한계가 있다.</li>
<li>FastText는 단어를 문자 n-gram(character n-grams)으로 분해하고, 이 n-gram 벡터들의 합으로 단어 벡터를 표현함으로써 이러한 문제를 해결하고자 한다.</li>
</ul></li>
<li><strong>FastText의 특징</strong>:
<ul>
<li><strong>Subword 정보 활용</strong>: 각 단어는 고유 벡터와 함께 해당 단어를 구성하는 모든 문자 n-gram 벡터들의 합으로 표현된다.</li>
<li><strong>OOV 문제 완화</strong>: 훈련 시 보지 못한 단어라도, 구성 n-gram이 훈련 데이터에 존재하면 해당 n-gram 벡터들을 조합하여 의미적으로 유사한 벡터를 생성할 수 있다.</li>
<li><strong>형태론적 정보 포착</strong>: 어근이나 접사와 같은 형태론적 특징을 공유하는 단어들은 유사한 n-gram을 공유하게 되어, 결과적으로 유사한 임베딩 벡터를 갖게 된다. 이는 특히 교착어에서 유용하다.</li>
</ul></li>
<li><strong>결론</strong>: FastText가 subword 정보를 활용하여 OOV 문제 및 희귀 단어 처리에 강점을 가지며, 형태론적 특징을 임베딩에 반영하는 방식을 소개하고 정적 임베딩 분야에서의 의미를 요약한다.</li>
</ul>
</section>
<section id="텍스트-인코딩-및-벡터화" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 텍스트 인코딩 및 벡터화</h1>
<pre><code>텍스트 벡터화
├── 1. 전통적 방법 (통계 기반)
│   ├── BoW
│   ├── DTM
│   └── TF-IDF
│
├── 2. 신경망 기반 (문맥 독립)
│   ├── 문맥 독립적 임베딩
│   │   └── Embedding Layer (딥러닝 모델 내 구성 요소)
│   ├── Word2Vec (CBOW, Skip-gram)
│   ├── FastText
│   ├── GloVe
│   └── 기타 모델: Swivel, LexVec 등
│
└── 3. 문맥 기반 임베딩 (Contextual Embedding)
    └── RNN 계열
        ├── LSTM
        ├── GRU
        └── ELMo</code></pre>
</section>
<section id="신경망-사용-20082018-static-word-embedding" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> 신경망 사용 (2008~2018): Static Word Embedding</h1>
<section id="fasttext-2017" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="fasttext-2017"><span class="header-section-number">3.1</span> FastText (2017)</h2>
<ul>
<li>Sub-word 정보 활용</li>
<li>단어를 character n-gram으로 분해</li>
<li>예: “apple” → {“ap”, “pp”, “pl”, “le”} + “apple”</li>
<li>장점:
<ul>
<li>OOV(Out-of-Vocabulary) 문제 해결</li>
<li>형태학적 정보 포착</li>
<li>한국어와 같은 교착어에 효과적</li>
</ul></li>
</ul>
<section id="기존-방법의-한계" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="기존-방법의-한계"><span class="header-section-number">3.1.1</span> 기존 방법의 한계</h3>
<ul>
<li><p>Word2Vec/GloVe 문제:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 훈련 데이터에 없는 단어 (OOV)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">"사과"</span> → [<span class="fl">0.2</span>, <span class="fl">0.4</span>, <span class="fl">0.1</span>, ...]  ✓ (학습됨)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">"사과들"</span> → ???  ✗ (학습 안됨)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">"사과나무"</span> → ???  ✗ (학습 안됨)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>한국어의 특별한 어려움:</p>
<pre><code>"먹다" → "먹는다", "먹었다", "먹고", "먹어서", "먹지만", ...
수천 가지 변형이 가능하지만 모두 같은 어근 "먹"을 공유</code></pre></li>
</ul>
</section>
<section id="fasttext의-해결책" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="fasttext의-해결책"><span class="header-section-number">3.1.2</span> FastText의 해결책</h3>
<ul>
<li>Subword 분해</li>
<li>Character n-gram 분해
<ul>
<li>예시: “사과” (n=2,3으로 설정)</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">"사과"</span> 분해:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> <span class="dv">2</span><span class="op">-</span>gram: <span class="st">"&lt;사"</span>, <span class="st">"사과"</span>, <span class="st">"과&gt;"</span>  <span class="co"># &lt;, &gt;는 단어 경계 표시</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> <span class="dv">3</span><span class="op">-</span>gram: <span class="st">"&lt;사과"</span>, <span class="st">"사과&gt;"</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> 전체 단어: <span class="st">"사과"</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>최종 n<span class="op">-</span>gram 집합: {<span class="st">"&lt;사"</span>, <span class="st">"사과"</span>, <span class="st">"과&gt;"</span>, <span class="st">"&lt;사과"</span>, <span class="st">"사과&gt;"</span>, <span class="st">"사과"</span>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>벡터 표현
<ul>
<li><p>기존 Word2Vec:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>vector(<span class="st">"사과"</span>) <span class="op">=</span> lookup_table[<span class="st">"사과"</span>]  <span class="co"># 하나의 벡터</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>FastText:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>vector(<span class="st">"사과"</span>) <span class="op">=</span> vector(<span class="st">"&lt;사"</span>) <span class="op">+</span> vector(<span class="st">"사과"</span>) <span class="op">+</span> vector(<span class="st">"과&gt;"</span>) <span class="op">+</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>      vector(<span class="st">"&lt;사과"</span>) <span class="op">+</span> vector(<span class="st">"사과&gt;"</span>) <span class="op">+</span> vector(<span class="st">"사과"</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>      <span class="co"># n-gram 벡터들의 합</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul></li>
<li>OOV 문제 해결 과정
<ul>
<li>새로운 단어 처리</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 훈련 시 보지 못한 단어: "사과나무"</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 1단계: n-gram 분해</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">"사과나무"</span> → {<span class="st">"&lt;사"</span>, <span class="st">"사과"</span>, <span class="st">"과나"</span>, <span class="st">"나무"</span>, <span class="st">"무&gt;"</span>, <span class="st">"&lt;사과"</span>, <span class="st">"사과나"</span>, <span class="st">"과나무"</span>, <span class="st">"나무&gt;"</span>, <span class="st">"사과나무"</span>}</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 2단계: 학습된 n-gram 벡터 찾기</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">"&lt;사"</span>: [<span class="fl">0.1</span>, <span class="fl">0.2</span>, ...]     ✓ (있음)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">"사과"</span>: [<span class="fl">0.3</span>, <span class="fl">0.1</span>, ...]    ✓ (있음)  </span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">"과나"</span>: [<span class="fl">0.0</span>, <span class="fl">0.0</span>, ...]    ✗ (없음 → <span class="dv">0</span><span class="er">벡터</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">"나무"</span>: [<span class="fl">0.2</span>, <span class="fl">0.4</span>, ...]    ✓ (있음)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">"무&gt;"</span>: [<span class="fl">0.1</span>, <span class="fl">0.1</span>, ...]     ✓ (있음)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 3단계: 합계 계산</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>vector(<span class="st">"사과나무"</span>) <span class="op">=</span> <span class="bu">sum</span>(존재하는_ngram_벡터들) <span class="op">/</span> 개수</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>결과: “사과나무”는 “사과”와 “나무”의 의미를 모두 반영한 벡터를 얻음!</li>
</ul></li>
<li>형태학적 정보 포착
<ul>
<li>한국어 예시</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>훈련 데이터:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">"먹는다"</span> → {<span class="st">"&lt;먹"</span>, <span class="st">"먹는"</span>, <span class="st">"는다"</span>, <span class="st">"다&gt;"</span>, ...}</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">"먹었다"</span> → {<span class="st">"&lt;먹"</span>, <span class="st">"먹었"</span>, <span class="st">"었다"</span>, <span class="st">"다&gt;"</span>, ...}  </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">"먹고"</span> → {<span class="st">"&lt;먹"</span>, <span class="st">"먹고"</span>, <span class="st">"고&gt;"</span>, ...}</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 공통 n-gram "&lt;먹", "먹"이 반복 학습됨</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co"># → "먹" 관련 의미가 강화됨</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>새로운 단어 <span class="st">"먹거나"</span>:</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>{<span class="st">"&lt;먹"</span>, <span class="st">"먹거"</span>, <span class="st">"거나"</span>, <span class="st">"나&gt;"</span>, ...}</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co"># "&lt;먹" n-gram을 통해 "먹다"와 관련된 의미를 자동으로 얻음!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>영어 예시</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">"running"</span> ↔ <span class="st">"run"</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">"running"</span> → {<span class="st">"ru"</span>, <span class="st">"un"</span>, <span class="st">"nn"</span>, <span class="st">"ni"</span>, <span class="st">"in"</span>, <span class="st">"ng"</span>, <span class="st">"run"</span>, <span class="st">"unn"</span>, <span class="st">"nni"</span>, ...}</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">"run"</span> → {<span class="st">"ru"</span>, <span class="st">"un"</span>, <span class="st">"run"</span>, ...}</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>공통 부분: {<span class="st">"ru"</span>, <span class="st">"un"</span>, <span class="st">"run"</span>}을 통해 관계 학습</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
</ul>
</section>
<section id="실제-성능-비교" class="level3" data-number="3.1.3">
<h3 data-number="3.1.3" class="anchored" data-anchor-id="실제-성능-비교"><span class="header-section-number">3.1.3</span> 실제 성능 비교</h3>
<ul>
<li>한국어 형태소 분석 없이도 효과적</li>
<li><strong>Word2Vec</strong>:</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">"좋다"</span>: [<span class="fl">0.2</span>, <span class="fl">0.4</span>, <span class="fl">0.1</span>, ...]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">"좋은"</span>: ??? (없으면 <span class="op">&lt;</span>UNK<span class="op">&gt;</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">"좋아서"</span>: ??? (없으면 <span class="op">&lt;</span>UNK<span class="op">&gt;</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li><strong>FastText</strong>:</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">"좋다"</span>: [<span class="fl">0.2</span>, <span class="fl">0.4</span>, <span class="fl">0.1</span>, ...]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">"좋은"</span>: [<span class="fl">0.18</span>, <span class="fl">0.38</span>, <span class="fl">0.12</span>, ...]  <span class="co"># "좋" n-gram으로 유추</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">"좋아서"</span>: [<span class="fl">0.19</span>, <span class="fl">0.39</span>, <span class="fl">0.11</span>, ...]  <span class="co"># "좋" n-gram으로 유추</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>결과: 형태소 분석기 없이도 어근의 의미를 공유하는 벡터들을 얻을 수 있음!</li>
<li>Trade-off:
<ul>
<li>장점: OOV 해결, 형태학적 정보 포착</li>
<li>단점: n-gram 개수만큼 파라미터 증가</li>
</ul></li>
<li>Word2Vec: 단어 수 × 벡터 차원</li>
<li>FastText: (단어 수 + 모든_ngram_수) × 벡터 차원</li>
</ul>
<p><strong>실용적 해결책</strong>: 빈도가 낮은 n-gram은 제외하여 크기 조절</p>
</section>
</section>
</section>
<section id="결론" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> 결론</h1>
<p>본 문서에서는 단어를 문자 n-gram들의 합으로 표현하여 임베딩하는 FastText 모델의 기본적인 아이디어와 작동 방식을 살펴보았다. FastText는 Word2Vec의 Skip-gram 모델을 기반으로 하면서 subword 정보를 추가적으로 활용하는 것이 핵심이다.</p>
<ul>
<li><strong>FastText의 주요 특징</strong>:
<ul>
<li><strong>Subword 단위 임베딩</strong>: 단어를 더 작은 단위인 문자 n-gram으로 분해하고, 각 n-gram에 대한 임베딩 벡터를 학습한다. 최종 단어 임베딩은 해당 단어를 구성하는 n-gram 벡터들의 합 (또는 평균)으로 구성된다. 이로 인해 단어의 내부 구조와 형태론적 특징을 포착할 수 있다.</li>
<li><strong>OOV 문제 대처</strong>: 훈련 말뭉치에 등장하지 않은 단어(OOV)에 대해서도, 해당 단어의 n-gram들이 훈련 과정에서 학습되었다면, 이를 조합하여 새로운 단어의 벡터를 추정할 수 있다. 이는 Word2Vec이나 GloVe가 OOV 단어에 대해 특별한 토큰(예: <code>&lt;UNK&gt;</code>)으로 처리하거나 무시하는 것과 대조적이다.</li>
<li><strong>희귀 단어 및 형태소 풍부 언어에 유리</strong>: 등장 빈도가 낮은 희귀 단어의 경우에도 구성 n-gram 정보를 통해 상대적으로 안정적인 임베딩을 얻을 수 있으며, 한국어와 같이 어미나 조사가 다양하게 변하는 교착어에서 형태론적 유사성을 잘 반영할 수 있다.</li>
</ul></li>
<li><strong>FastText의 의미</strong>:
<ul>
<li>FastText는 단어 자체뿐만 아니라 단어를 구성하는 내부 요소(subword)까지 고려함으로써 기존 정적 임베딩 방법론들의 한계를 일부 개선했다. 특히 OOV 문제에 대한 실용적인 해결책을 제시하고, 단어의 형태론적 정보를 임베딩에 자연스럽게 통합했다는 점에서 의미가 있다.</li>
<li>Word2Vec, GloVe와 함께 FastText는 다양한 NLP 문제에서 효과적인 단어 표현 방법으로 활용되며, 정적 임베딩 기법의 중요한 갈래를 형성한다.</li>
</ul></li>
</ul>
<p>결론적으로, FastText는 subword 정보를 활용하여 단어 벡터의 표현력을 높이고 OOV 문제에 강인함을 보이는 유용한 정적 임베딩 방법이다. 단순하면서도 효과적인 아이디어로 많은 자연어 처리 응용 분야에 기여했다.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("kk3225\.netlify\.app");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>