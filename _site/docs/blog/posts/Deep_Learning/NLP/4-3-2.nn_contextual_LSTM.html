<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="dcterms.date" content="2025-01-11">
<meta name="description" content="RNN의 한계인 장기 의존성 문제를 해결하기 위해 등장한 LSTM(Long Short-Term Memory)의 기본 원리와 구조를 소개한다. LSTM의 핵심 구성 요소인 셀 상태와 세 가지 게이트(입력, 삭제, 출력)가 어떻게 정보를 효과적으로 제어하고 장기 기억을 가능하게 하는지 살펴본다. 양방향 LSTM의 개념도 간략히 다룬다.">

<title>Kwangmin Kim - 텍스트 벡터화: LSTM의 이해</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - 텍스트 벡터화: LSTM의 이해">
<meta property="og:description" content="RNN의 한계인 장기 의존성 문제를 해결하기 위해 등장한 LSTM(Long Short-Term Memory)의 기본 원리와 구조를 소개한다. LSTM의 핵심 구성 요소인 셀 상태와 세 가지 게이트(입력, 삭제, 출력)가 어떻게 정보를 효과적으로 제어하고 장기 기억을 가능하게 하는지 살펴본다. 양방향 LSTM의 개념도 간략히 다룬다.">
<meta property="og:site_name" content="Kwangmin Kim">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#요약" id="toc-요약" class="nav-link active" data-scroll-target="#요약"><span class="header-section-number">1</span> 요약</a></li>
  <li><a href="#텍스트-인코딩-및-벡터화" id="toc-텍스트-인코딩-및-벡터화" class="nav-link" data-scroll-target="#텍스트-인코딩-및-벡터화"><span class="header-section-number">2</span> 텍스트 인코딩 및 벡터화</a>
  <ul class="collapse">
  <li><a href="#문맥을-고려한-벡터화-2018-현재-동적-임베딩" id="toc-문맥을-고려한-벡터화-2018-현재-동적-임베딩" class="nav-link" data-scroll-target="#문맥을-고려한-벡터화-2018-현재-동적-임베딩"><span class="header-section-number">2.1</span> 문맥을 고려한 벡터화 (2018-현재): 동적 임베딩</a>
  <ul class="collapse">
  <li><a href="#기존-rnn의-한계-장기-의존성-문제" id="toc-기존-rnn의-한계-장기-의존성-문제" class="nav-link" data-scroll-target="#기존-rnn의-한계-장기-의존성-문제"><span class="header-section-number">2.1.1</span> 기존 RNN의 한계: 장기 의존성 문제</a></li>
  <li><a href="#lstm-long-short-term-memory.-1997" id="toc-lstm-long-short-term-memory.-1997" class="nav-link" data-scroll-target="#lstm-long-short-term-memory.-1997"><span class="header-section-number">2.1.2</span> LSTM (Long Short-Term Memory. 1997)</a></li>
  <li><a href="#양방향-lstm-bidirectional-lstm.-2005" id="toc-양방향-lstm-bidirectional-lstm.-2005" class="nav-link" data-scroll-target="#양방향-lstm-bidirectional-lstm.-2005"><span class="header-section-number">2.1.3</span> 양방향 LSTM (Bidirectional LSTM. 2005)</a></li>
  </ul></li>
  <li><a href="#결론" id="toc-결론" class="nav-link" data-scroll-target="#결론"><span class="header-section-number">2.2</span> 결론</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">텍스트 벡터화: LSTM의 이해</h1>
<p class="subtitle lead">RNN의 장기 의존성 문제 해결을 위한 Long Short-Term Memory</p>
  <div class="quarto-categories">
    <div class="quarto-category">NLP</div>
    <div class="quarto-category">Deep Learning</div>
  </div>
  </div>

<div>
  <div class="description">
    <p>RNN의 한계인 장기 의존성 문제를 해결하기 위해 등장한 LSTM(Long Short-Term Memory)의 기본 원리와 구조를 소개한다. LSTM의 핵심 구성 요소인 셀 상태와 세 가지 게이트(입력, 삭제, 출력)가 어떻게 정보를 효과적으로 제어하고 장기 기억을 가능하게 하는지 살펴본다. 양방향 LSTM의 개념도 간략히 다룬다.</p>
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Kwangmin Kim </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 11, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="요약" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 요약</h1>
<p>이 문서는 기존 RNN(Recurrent Neural Network)의 주요 한계점인 장기 의존성 문제(Long-Term Dependency Problem)를 해결하기 위해 제안된 LSTM(Long Short-Term Memory) 네트워크의 기본적인 작동 원리와 구조를 설명한다.</p>
<ul>
<li><strong>기존 RNN의 한계와 LSTM의 등장 배경</strong>:
<ul>
<li>바닐라 RNN은 시퀀스가 길어질수록 초기 정보가 소실되어 먼 과거의 정보를 현재까지 전달하기 어렵다는 장기 의존성 문제를 가진다. 이는 기울기 소실/폭주 문제와도 관련된다.</li>
<li>LSTM은 이러한 문제를 해결하기 위해 셀 내부에 ’게이트(gate)’라는 정교한 정보 제어 메커니즘을 도입했다.</li>
</ul></li>
<li><strong>LSTM의 핵심 구성 요소 및 작동 원리</strong>:
<ul>
<li><strong>셀 상태 (Cell State, <span class="math inline">\(C_t\)</span>)</strong>: LSTM의 핵심으로, 컨베이어 벨트처럼 정보를 비교적 오래 기억하고 전달하는 역할을 한다. 게이트들을 통해 정보가 추가되거나 제거된다.</li>
<li><strong>게이트 (Gates)</strong>: 세 가지 주요 게이트가 셀 상태와 은닉 상태(hidden state, <span class="math inline">\(h_t\)</span>)를 제어한다.
<ul>
<li><strong>삭제 게이트 (Forget Gate, <span class="math inline">\(f_t\)</span>)</strong>: 이전 셀 상태(<span class="math inline">\(C_{t-1}\)</span>)에서 어떤 정보를 버릴지 결정한다.</li>
<li><strong>입력 게이트 (Input Gate, <span class="math inline">\(i_t\)</span>)</strong>: 현재 입력(<span class="math inline">\(x_t\)</span>)과 이전 은닉 상태(<span class="math inline">\(h_{t-1}\)</span>)를 바탕으로 어떤 새로운 정보를 셀 상태에 저장할지 결정한다. 후보 값(<span class="math inline">\(g_t\)</span>)과 함께 사용된다.</li>
<li><strong>출력 게이트 (Output Gate, <span class="math inline">\(o_t\)</span>)</strong>: 현재 셀 상태를 바탕으로 어떤 정보를 현재 시점의 은닉 상태(<span class="math inline">\(h_t\)</span>)로 출력할지 결정한다.</li>
</ul></li>
<li>이러한 게이트들은 시그모이드(sigmoid) 함수를 통해 0과 1 사이의 값을 출력하여 정보의 흐름을 조절하고, 요소별 곱셈(element-wise product)을 통해 정보를 선택적으로 통과시키거나 차단한다.</li>
</ul></li>
<li><strong>양방향 LSTM (Bidirectional LSTM, BiLSTM)</strong>:
<ul>
<li>단방향 LSTM의 정보 흐름(과거→미래) 한계를 극복하기 위해, 순방향 LSTM과 역방향 LSTM을 함께 사용하여 과거와 미래의 문맥을 모두 고려한다. 최종 출력은 두 LSTM의 은닉 상태를 결합하여 생성된다.</li>
</ul></li>
<li><strong>의의</strong>: LSTM은 장기 의존성 문제를 효과적으로 완화하여 더 긴 시퀀스에서도 의미 있는 정보를 학습할 수 있게 만들었다. 이는 자연어 처리, 음성 인식, 기계 번역 등 다양한 분야에서 RNN 계열 모델의 성능을 크게 향상시키는 데 기여했으며, ELMo와 같은 초기 문맥 기반 임베딩 모델의 중요 구성 요소로 활용되었다.</li>
</ul>
<p>이 문서를 통해 독자는 LSTM이 어떻게 게이트 메커니즘을 통해 정보의 흐름을 제어하고 장기 기억을 가능하게 하는지에 대한 기본적인 이해를 얻을 수 있다.</p>
</section>
<section id="텍스트-인코딩-및-벡터화" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 텍스트 인코딩 및 벡터화</h1>
<pre><code>텍스트 벡터화
├── 1. 전통적 방법 (통계 기반)
│   ├── BoW
│   ├── DTM
│   └── TF-IDF
│
├── 2. 신경망 기반 (문맥 독립)
│   ├── 문맥 독립적 임베딩
│   │   └── Embedding Layer (딥러닝 모델 내 구성 요소)
│   ├── Word2Vec (CBOW, Skip-gram)
│   ├── FastText
│   ├── GloVe
│   └── 기타 모델: Swivel, LexVec 등
│
└── 3. 문맥 기반 임베딩 (Contextual Embedding)
    ├── RNN 계열
    │   ├── LSTM
        ├── GRU
    │   └── ELMo
    ├── Attention 메커니즘
    │   ├── Basic Attention
    │   ├── Self-Attention
    │   └── Multi-Head Attention
    └── Transformer 계열
        ├── BERT, RoBERTa, ALBERT
        ├── GPT 시리즈
        ├── KoBERT, KoGPT 등 한국어 특화
        └── 기타 모델: T5, LaMDA, PaLM, XLNet, ELECTRA</code></pre>
<section id="문맥을-고려한-벡터화-2018-현재-동적-임베딩" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="문맥을-고려한-벡터화-2018-현재-동적-임베딩"><span class="header-section-number">2.1</span> 문맥을 고려한 벡터화 (2018-현재): 동적 임베딩</h2>
<section id="기존-rnn의-한계-장기-의존성-문제" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="기존-rnn의-한계-장기-의존성-문제"><span class="header-section-number">2.1.1</span> 기존 RNN의 한계: 장기 의존성 문제</h3>
<ul>
<li>장기 의존성 문제 (Long-Term Dependency Problem): 기존의 RNN은 시점이 깅러지면 앞에 있던 정보가 소실되는 장기 의존성 문제를 갖고 있다</li>
<li>즉, 너무 오래 전의 정보를 기억하지 못함. 이것은 RNN의 고질적인 문제입니다.</li>
<li>기울기 소실 문제 (Gradient Vanishing Problem): 너무 오래 전의 정보를 기억하지 못함</li>
<li>Vanilla RNN: 기존의 RNN, 아이스크림 맛중에서 vanilla가 가장 기본적인 맛이기 때문에 vanilla RNN이라고 부른다.</li>
</ul>
</section>
<section id="lstm-long-short-term-memory.-1997" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="lstm-long-short-term-memory.-1997"><span class="header-section-number">2.1.2</span> LSTM (Long Short-Term Memory. 1997)</h3>
<ul>
<li>LSTM은 기존의 RNN의 장기 의존성 문제를 해결하기 위해 은닉층에 추가적인 메커니즘을 도입한다.</li>
<li>추가 메커니즘은 기억력을 증가시키는 것이다.</li>
<li>industry에서 RNN을 썼다고 하면 대부분 LSTM이나 GRU를 쓰는 것을 의미한다.</li>
<li>기존의 RNN은 이전 시점의 hidden state의 정보를 현재 시점의 hidden state에 전달하면서 현재 시점의 출력값도 만들어내는 구조였다.</li>
<li>기존의 RNN은 cell state가 없었다.</li>
<li>LSTM은 이전의 hidden state와 cell state 둘 모두를 다음 시점의 hidden state와 cell state의 정보를 전달한다.</li>
<li>cell state에 gate라는 구조를 통해서 정보를 더하거나 빼는 등의 통제를 한다.</li>
</ul>
<section id="input-gate" class="level4" data-number="2.1.2.1">
<h4 data-number="2.1.2.1" class="anchored" data-anchor-id="input-gate"><span class="header-section-number">2.1.2.1</span> input gate</h4>
<ul>
<li>현재 정보를 기억하기 위한 gate이다.<br>
</li>
<li>cell state: <span class="math inline">\(x_t\)</span> 와 <span class="math inline">\(h_{t-1}\)</span> 을 받아서 현재 시점의 선택된 기억할 값을 정한다.
<ul>
<li>sigmoid 함수를 통해 [0,1]을 반환</li>
<li>tanh 함수를 통해 [-1,1]을 반환</li>
<li>이 두 종류의 값을 갖고 cell state에서 이번에 선택된 기억할 값을 정한다. 즉,</li>
<li><span class="math inline">\(i_t = \sigma(W_{x_{i}}x_t + W_{h_i}h_{t-1} + b_i)\)</span></li>
<li><span class="math inline">\(g_t = \tanh(W_{x_g} x_t + W_{h_g} h_{t-1} + b_g)\)</span></li>
<li>이때, <span class="math inline">\(i_t\)</span> 는 0~1 사이의 값을 가지며, <span class="math inline">\(g_t\)</span> 는 -1~1 사이의 값을 가진다.</li>
<li>이 두 값을 곱해서 현재 시점의 cell state를 결정한다.</li>
</ul></li>
</ul>
</section>
<section id="forget-gate" class="level4" data-number="2.1.2.2">
<h4 data-number="2.1.2.2" class="anchored" data-anchor-id="forget-gate"><span class="header-section-number">2.1.2.2</span> forget gate</h4>
<ul>
<li>이전 정보를 잊기 위한 gate이다.<br>
</li>
<li>기억을 삭제하기 위한 gate이다.</li>
<li>sigmoid 함수를 지나 [0,1]을 반환된 값으로 0에 가까울수록 정보가 많이 삭제된 것이며, 1에 가까울수록 정보를 온전히 기억한 셈이다. 즉,</li>
<li><span class="math inline">\(f_t=\sigma(W_{x_f}x_t+W_{h_f}h_{t-1}+b_f)\)</span></li>
<li>이렇게, 일부 기억을 소실하고 입력 게이트의 <span class="math inline">\(i_t\)</span> 와 <span class="math inline">\(g_t\)</span> 의 정보를 조합하여 elementwise product를 수행하여 더해서 이번에 기억할 값을 결정
<ul>
<li>elementwise product: 각 요소별 곱셈을 의미한다.</li>
<li>즉, 현재 시점의 cell state는 이전의 cell state와 현재 시점의 정보를 조합하여 결정된다.</li>
<li><span class="math inline">\(C_t = f_t \odot C_{t-1} + i_t \odot g_t\)</span></li>
<li>이때, <span class="math inline">\(\odot\)</span> 는 요소별 곱셈을 의미한다.</li>
<li><span class="math inline">\(i_t \odot g_t\)</span> = input gate의 값, 현재 시점의 기억할 값</li>
<li><span class="math inline">\(C_{t-1}\)</span> = 이전 시점의 cell state</li>
<li><span class="math inline">\(f_t \odot C_{t-1}\)</span> = forget gate의 값으로 과거의 기억을 삭제한 값</li>
<li>즉, 현재 시점의 cell state는 이전의 cell state와 현재 시점의 정보를 조합하여 결정된다.</li>
</ul></li>
</ul>
</section>
<section id="input-gate와-forget-gate의-영향력" class="level4" data-number="2.1.2.3">
<h4 data-number="2.1.2.3" class="anchored" data-anchor-id="input-gate와-forget-gate의-영향력"><span class="header-section-number">2.1.2.3</span> input gate와 forget gate의 영향력</h4>
<ul>
<li><span class="math inline">\(f_t\)</span> 가 0이 되면 이전 시점의 cell state가 완전히 삭제되고 오직 input gate만이 현재 시점의 cell state값을 결정한다.
<ul>
<li>이를 forget gate가 닫히고 input gate만 열린 상태라고 한다.</li>
</ul></li>
<li>반면, <span class="math inline">\(i_t\)</span> 가 0이 되면 이전 시점의 cell state를 완전히 삭제하고 오직 forget gate만이 현재 시점의 cell state값을 결정한다.
<ul>
<li>이를 input gate가 닫히고 forget gate만 열린 상태라고 한다.</li>
</ul></li>
<li>따라서, input gate는 현재 시점의 입력을 얼마나 반영할지 결정</li>
<li>반면, forget gate는 이전 시점의 기억을 얼마나 유지할지 결정</li>
</ul>
</section>
<section id="output-gate" class="level4" data-number="2.1.2.4">
<h4 data-number="2.1.2.4" class="anchored" data-anchor-id="output-gate"><span class="header-section-number">2.1.2.4</span> output gate</h4>
<ul>
<li>현재 시점의 출력을 결정하기 위한 gate이다.</li>
<li>Hidden state를 연산하는 일에 쓰이며 Cell state와 비교하여 단기 상태라고도 부른다.</li>
<li>이전 시점의 cell state는 현재 시점의 cell 내부에 기억력을 돕기위한 역할만 하고 현재 시점의 출력엔 영향을 주지 않는다.</li>
<li>현재 시점의 출력은 이전 시점의 hidden state에 영향을 받은 현재 시점의 hidden state에 의해서만 결정된다.</li>
<li>sigmoid 함수를 통해 [0,1]을 반환</li>
<li>이 값을 현재 시점의 cell state에 곱해서 현재 시점의 출력을 결정한다.즉,</li>
<li><span class="math inline">\(o_t = \sigma(W_{x_o}x_t + W_{h_o}h_{t-1} + b_o)\)</span></li>
<li><span class="math inline">\(h_t = o_t \odot \tanh(C_t)\)</span></li>
</ul>
</section>
</section>
<section id="양방향-lstm-bidirectional-lstm.-2005" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="양방향-lstm-bidirectional-lstm.-2005"><span class="header-section-number">2.1.3</span> 양방향 LSTM (Bidirectional LSTM. 2005)</h3>
<ul>
<li>기본 LSTM의 한계: 단방향 처리로 인한 정보 손실
<ul>
<li>기본 LSTM은 과거에서 미래로만 정보를 처리한다</li>
<li>현재 시점에서 미래의 정보를 활용할 수 없어 맥락 이해가 제한적이다</li>
<li>예: “그는 은행에 갔다”에서 “은행”이 금융기관인지 강둑인지 앞뒤 문맥을 모두 봐야 판단 가능</li>
</ul></li>
<li>양방향 LSTM은 순방향과 역방향 두 개의 LSTM을 동시에 사용한다</li>
<li>Forward LSTM과 Backward LSTM이 독립적으로 작동하여 전체 시퀀스의 맥락을 모두 활용한다</li>
<li>자연어 처리, 음성 인식 등에서 단방향 LSTM보다 우수한 성능을 보인다</li>
<li>Forward LSTM (순방향)
<ul>
<li>일반적인 LSTM과 동일하게 시점 1부터 시점 T까지 순차적으로 처리한다</li>
<li>각 시점에서 과거 정보를 현재로 전달한다</li>
<li>Forward hidden state: <span class="math inline">\(\overrightarrow{h_t}\)</span>, Forward cell state: <span class="math inline">\(\overrightarrow{C_t}\)</span></li>
<li>Gate 연산:
<ul>
<li><span class="math inline">\(\overrightarrow{i_t} = \sigma(W_{x_i}x_t + W_{h_i}\overrightarrow{h_{t-1}} + b_i)\)</span> (input gate)</li>
<li><span class="math inline">\(\overrightarrow{f_t} = \sigma(W_{x_f}x_t + W_{h_f}\overrightarrow{h_{t-1}} + b_f)\)</span> (forget gate)</li>
<li><span class="math inline">\(\overrightarrow{g_t} = \tanh(W_{x_g}x_t + W_{h_g}\overrightarrow{h_{t-1}} + b_g)\)</span> (candidate values)</li>
<li><span class="math inline">\(\overrightarrow{C_t} = \overrightarrow{f_t} \odot \overrightarrow{C_{t-1}} + \overrightarrow{i_t} \odot \overrightarrow{g_t}\)</span> (cell state)</li>
<li><span class="math inline">\(\overrightarrow{o_t} = \sigma(W_{x_o}x_t + W_{h_o}\overrightarrow{h_{t-1}} + b_o)\)</span> (output gate)</li>
<li><span class="math inline">\(\overrightarrow{h_t} = \overrightarrow{o_t} \odot \tanh(\overrightarrow{C_t})\)</span> (hidden state)</li>
</ul></li>
</ul></li>
<li>Backward LSTM (역방향)
<ul>
<li>시점 T부터 시점 1까지 역순으로 처리한다</li>
<li>각 시점에서 미래 정보를 현재로 전달한다 (<span class="math inline">\(t+1\)</span> 시점에서 <span class="math inline">\(t\)</span> 시점으로)</li>
<li>Backward hidden state: <span class="math inline">\(\overleftarrow{h_t}\)</span>, Backward cell state: <span class="math inline">\(\overleftarrow{C_t}\)</span></li>
<li>Gate 연산 (별도의 가중치 매개변수 <span class="math inline">\(W'\)</span> 사용):
<ul>
<li><span class="math inline">\(\overleftarrow{i_t} = \sigma(W'_{x_i}x_t + W'_{h_i}\overleftarrow{h_{t+1}} + b'_i)\)</span> (input gate)</li>
<li><span class="math inline">\(\overleftarrow{f_t} = \sigma(W'_{x_f}x_t + W'_{h_f}\overleftarrow{h_{t+1}} + b'_f)\)</span> (forget gate)</li>
<li><span class="math inline">\(\overleftarrow{g_t} = \tanh(W'_{x_g}x_t + W'_{h_g}\overleftarrow{h_{t+1}} + b'_g)\)</span> (candidate values)</li>
<li><span class="math inline">\(\overleftarrow{C_t} = \overleftarrow{f_t} \odot \overleftarrow{C_{t+1}} + \overleftarrow{i_t} \odot \overleftarrow{g_t}\)</span> (cell state)</li>
<li><span class="math inline">\(\overleftarrow{o_t} = \sigma(W'_{x_o}x_t + W'_{h_o}\overleftarrow{h_{t+1}} + b'_o)\)</span> (output gate)</li>
<li><span class="math inline">\(\overleftarrow{h_t} = \overleftarrow{o_t} \odot \tanh(\overleftarrow{C_t})\)</span> (hidden state)</li>
</ul></li>
</ul></li>
<li>최종 출력 결합
<ul>
<li>각 시점에서 Forward와 Backward의 hidden state를 결합하여 최종 출력을 생성한다</li>
<li>가장 일반적인 방법은 연결(concatenation)이다: <span class="math inline">\(h_t = [\overrightarrow{h_t}; \overleftarrow{h_t}]\)</span></li>
<li>최종 hidden state의 차원은 단방향 LSTM의 2배가 된다</li>
<li>다른 결합 방식들:
<ul>
<li>합계: <span class="math inline">\(h_t = \overrightarrow{h_t} + \overleftarrow{h_t}\)</span></li>
<li>평균: <span class="math inline">\(h_t = \frac{\overrightarrow{h_t} + \overleftarrow{h_t}}{2}\)</span></li>
<li>가중합: <span class="math inline">\(h_t = \alpha \overrightarrow{h_t} + (1-\alpha) \overleftarrow{h_t}\)</span></li>
</ul></li>
</ul></li>
<li>양방향 LSTM의 장점과 한계
<ul>
<li>장점: 전체 시퀀스의 맥락 정보를 모두 활용하여 더 정확한 표현 학습이 가능하다</li>
<li>단점: 전체 시퀀스가 필요하므로 실시간 처리가 불가능하다</li>
<li>계산 복잡도가 단방향 LSTM의 약 2배로 증가한다</li>
<li>파라미터 수와 메모리 사용량이 증가한다</li>
</ul></li>
</ul>
<section id="deep-bidirectional-rnn-20132015" class="level4" data-number="2.1.3.1">
<h4 data-number="2.1.3.1" class="anchored" data-anchor-id="deep-bidirectional-rnn-20132015"><span class="header-section-number">2.1.3.1</span> Deep Bidirectional RNN (2013~2015)</h4>
<ul>
<li>Deep RNN
<ul>
<li>RNN의 은닉층을 여러 개 쌓은 모델</li>
<li>각 은닉층은 이전 은닉층의 출력을 입력으로 받아 현재 은닉층의 출력을 생성</li>
<li>이렇게 하여 더 복잡한 패턴을 학습할 수 있다.</li>
</ul></li>
<li>Bidirectional RNN
<ul>
<li>기본적인 구조는 RNN과 유사하다.</li>
</ul></li>
<li>Deep Bidirectional RNN
<ul>
<li>기본적인 구조는 RNN과 유사하다.</li>
<li>하지만, 더 많은 레이어를 가지고 있어 더 많은 정보를 저장할 수 있다.</li>
</ul></li>
<li>또한, 더 많은 연산을 필요로 하여 더 많은 시간이 걸린다.</li>
<li>하지만, 더 나은 성능을 보인다.</li>
<li>일반적으로 GRU는 LSTM보다 더 빠르게 학습되지만, LSTM은 더 나은 성능을 보인다.</li>
<li>따라서, 일반적으로 LSTM이 더 많이 사용된다.</li>
</ul>
</section>
</section>
</section>
<section id="결론" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="결론"><span class="header-section-number">2.2</span> 결론</h2>
<p>본 문서에서는 RNN의 장기 의존성 문제를 해결하기 위해 설계된 LSTM(Long Short-Term Memory) 네트워크의 핵심적인 구조와 작동 방식을 살펴보았다. LSTM은 셀 상태와 세 가지 주요 게이트(입력, 삭제, 출력)를 통해 정보의 흐름을 정교하게 제어함으로써 장기 기억을 효과적으로 수행한다.</p>
<ul>
<li><strong>LSTM의 핵심 원리 요약</strong>:
<ul>
<li>LSTM의 중심에는 장기적인 정보를 저장하는 ’셀 상태(Cell State)’가 있으며, 이 셀 상태는 게이트들에 의해 선택적으로 정보가 추가되거나 제거되면서 업데이트된다.</li>
<li><strong>삭제 게이트</strong>는 과거 정보 중 불필요한 것을 잊도록 하고, <strong>입력 게이트</strong>는 현재 정보 중 중요한 것을 셀 상태에 추가하며, <strong>출력 게이트</strong>는 현재 셀 상태를 바탕으로 다음 은닉 상태(단기 기억) 및 출력을 결정한다.</li>
<li>이러한 게이트 메커니즘 덕분에 LSTM은 기울기 소실 문제를 완화하고, 시퀀스 내의 멀리 떨어진 정보 간의 의존성을 학습할 수 있다.</li>
</ul></li>
<li><strong>양방향 LSTM의 활용</strong>:
<ul>
<li>단일 방향 LSTM이 과거의 문맥만을 고려하는 한계를 보완하기 위해, 순방향과 역방향 LSTM을 결합한 양방향 LSTM(BiLSTM)이 널리 사용된다. BiLSTM은 특정 시점의 양쪽 문맥 정보를 모두 활용하여 보다 풍부한 표현을 학습할 수 있게 한다.</li>
</ul></li>
<li><strong>문맥 이해와 NLP에서의 중요성</strong>:
<ul>
<li>LSTM은 복잡한 시퀀스 데이터를 모델링하는 데 강력한 성능을 보여주었으며, 특히 자연어 처리 분야에서 문장이나 문서의 문맥적 의미를 파악하는 데 중요한 역할을 했다.</li>
<li>ELMo와 같은 초기 문맥 기반 워드 임베딩 모델의 기반 구조로 사용되었으며, 이후 등장한 트랜스포머 아키텍처 이전까지 다양한 NLP 태스크에서 핵심적인 구성 요소로 활용되었다.</li>
</ul></li>
</ul>
<p>결론적으로, LSTM은 RNN의 한계를 극복하고 시퀀스 데이터, 특히 장기 의존성을 가진 데이터 처리에 있어 중요한 진보를 이룬 모델이다. 정교한 내부 메커니즘을 통해 정보의 선택적 기억과 망각을 가능하게 함으로써, 복잡한 패턴 학습 능력을 크게 향상시켰다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>