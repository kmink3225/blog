<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="dcterms.date" content="2025-01-12">
<meta name="description" content="LSTM(Long Short-Term Memory)의 복잡성을 줄이면서 유사한 성능을 목표로 개발된 GRU(Gated Recurrent Unit)의 핵심 원리와 두 가지 게이트(리셋 게이트, 업데이트 게이트)의 작동 방식을 설명한다. GRU가 어떻게 장기 의존성 문제를 해결하고 다양한 시퀀스 모델링 작업에 효과적으로 사용될 수 있는지 살펴본다.">

<title>Kwangmin Kim - 텍스트 벡터화: GRU의 이해</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - 텍스트 벡터화: GRU의 이해">
<meta property="og:description" content="LSTM(Long Short-Term Memory)의 복잡성을 줄이면서 유사한 성능을 목표로 개발된 GRU(Gated Recurrent Unit)의 핵심 원리와 두 가지 게이트(리셋 게이트, 업데이트 게이트)의 작동 방식을 설명한다. GRU가 어떻게 장기 의존성 문제를 해결하고 다양한 시퀀스 모델링 작업에 효과적으로 사용될 수 있는지 살펴본다.">
<meta property="og:site_name" content="Kwangmin Kim">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#요약" id="toc-요약" class="nav-link active" data-scroll-target="#요약"><span class="header-section-number">1</span> 요약</a></li>
  <li><a href="#텍스트-인코딩-및-벡터화" id="toc-텍스트-인코딩-및-벡터화" class="nav-link" data-scroll-target="#텍스트-인코딩-및-벡터화"><span class="header-section-number">2</span> 텍스트 인코딩 및 벡터화</a></li>
  <li><a href="#문맥을-고려한-벡터화-2018-현재-동적-임베딩" id="toc-문맥을-고려한-벡터화-2018-현재-동적-임베딩" class="nav-link" data-scroll-target="#문맥을-고려한-벡터화-2018-현재-동적-임베딩"><span class="header-section-number">3</span> 문맥을 고려한 벡터화 (2018-현재): 동적 임베딩</a>
  <ul class="collapse">
  <li><a href="#gru-gated-recurrent-unit" id="toc-gru-gated-recurrent-unit" class="nav-link" data-scroll-target="#gru-gated-recurrent-unit"><span class="header-section-number">3.1</span> GRU (Gated Recurrent Unit)</a>
  <ul class="collapse">
  <li><a href="#gru의-구조와-작동-원리" id="toc-gru의-구조와-작동-원리" class="nav-link" data-scroll-target="#gru의-구조와-작동-원리"><span class="header-section-number">3.1.1</span> GRU의 구조와 작동 원리</a></li>
  <li><a href="#장기-의존성-문제-해결" id="toc-장기-의존성-문제-해결" class="nav-link" data-scroll-target="#장기-의존성-문제-해결"><span class="header-section-number">3.1.2</span> 장기 의존성 문제 해결</a></li>
  <li><a href="#lstm과의-비교" id="toc-lstm과의-비교" class="nav-link" data-scroll-target="#lstm과의-비교"><span class="header-section-number">3.1.3</span> LSTM과의 비교</a></li>
  <li><a href="#양방향-gru-bidirectional-gru" id="toc-양방향-gru-bidirectional-gru" class="nav-link" data-scroll-target="#양방향-gru-bidirectional-gru"><span class="header-section-number">3.1.4</span> 양방향 GRU (Bidirectional GRU)</a></li>
  </ul></li>
  <li><a href="#결론" id="toc-결론" class="nav-link" data-scroll-target="#결론"><span class="header-section-number">3.2</span> 결론</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">텍스트 벡터화: GRU의 이해</h1>
<p class="subtitle lead">LSTM의 대안, Gated Recurrent Unit의 구조와 원리</p>
  <div class="quarto-categories">
    <div class="quarto-category">NLP</div>
    <div class="quarto-category">Deep Learning</div>
  </div>
  </div>

<div>
  <div class="description">
    <p>LSTM(Long Short-Term Memory)의 복잡성을 줄이면서 유사한 성능을 목표로 개발된 GRU(Gated Recurrent Unit)의 핵심 원리와 두 가지 게이트(리셋 게이트, 업데이트 게이트)의 작동 방식을 설명한다. GRU가 어떻게 장기 의존성 문제를 해결하고 다양한 시퀀스 모델링 작업에 효과적으로 사용될 수 있는지 살펴본다.</p>
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Kwangmin Kim </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 12, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="요약" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 요약</h1>
<p>이 문서는 순환 신경망(RNN)의 한계점인 장기 의존성 문제를 효과적으로 해결하기 위해 제안된 GRU(Gated Recurrent Unit)의 기본 원리와 구조를 소개한다. GRU는 LSTM(Long Short-Term Memory)과 유사한 성능을 보이면서도 내부 구조를 단순화하여 계산 효율성을 높인 모델이다.</p>
<p>주요 내용은 다음과 같다.</p>
<ul>
<li><strong>RNN의 장기 의존성 문제와 GRU의 등장</strong>:
<ul>
<li>기존 RNN은 시퀀스 길이가 길어질수록 과거의 중요 정보가 손실되는 장기 의존성 문제를 겪는다.</li>
<li>GRU는 이러한 문제를 해결하기 위해 LSTM과 마찬가지로 게이트 메커니즘을 사용하지만, 더 적은 수의 게이트로 구성된다.</li>
</ul></li>
<li><strong>GRU의 핵심 구성 요소 및 작동 원리</strong>:
<ul>
<li><strong>리셋 게이트 (Reset Gate, <span class="math inline">\(r_t\)</span>)</strong>: 이전 시점의 은닉 상태(<span class="math inline">\(h_{t-1}\)</span>)에서 어떤 정보를 무시하고 현재 입력(<span class="math inline">\(x_t\)</span>)과 함께 새로운 후보 은닉 상태를 만들지 결정한다.</li>
<li><strong>업데이트 게이트 (Update Gate, <span class="math inline">\(z_t\)</span>)</strong>: 이전 은닉 상태(<span class="math inline">\(h_{t-1}\)</span>)의 정보를 얼마나 유지하고, 현재 계산된 후보 은닉 상태(<span class="math inline">\(\tilde{h}_t\)</span>)의 정보를 얼마나 반영하여 새로운 은닉 상태(<span class="math inline">\(h_t\)</span>)를 만들지 결정한다.</li>
<li>이 두 게이트는 시그모이드 함수를 통해 0과 1 사이의 값을 출력하며, 이를 통해 정보 흐름을 정교하게 제어한다. GRU는 LSTM과 달리 별도의 셀 상태(Cell State)를 사용하지 않고 은닉 상태(Hidden State)만으로 정보를 전달한다.</li>
</ul></li>
<li><strong>LSTM과의 비교</strong>:
<ul>
<li>GRU는 LSTM에 비해 게이트 수가 적고(2개 vs 3개), 파라미터 수도 적어 계산 비용이 낮고 학습 속도가 빠를 수 있다.</li>
<li>많은 경우 LSTM과 비슷한 성능을 보이며, 데이터셋의 크기가 작거나 특정 문제에서는 GRU가 더 나은 결과를 보이기도 한다.</li>
</ul></li>
<li><strong>의의</strong>: GRU는 장기 의존성 문제를 완화하여 긴 시퀀스에서도 효과적인 학습을 가능하게 하며, 자연어 처리, 음성 인식 등 다양한 분야에서 RNN 계열 모델의 중요한 선택지로 활용된다.</li>
</ul>
<p>이 문서를 통해 독자는 GRU가 어떻게 게이트 메커니즘을 통해 정보의 흐름을 제어하고 장기 기억을 가능하게 하는지에 대한 기본적인 이해를 얻을 수 있다.</p>
</section>
<section id="텍스트-인코딩-및-벡터화" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> 텍스트 인코딩 및 벡터화</h1>
<pre><code>텍스트 벡터화
├── 1. 전통적 방법 (통계 기반)
│   ├── BoW
│   ├── DTM
│   └── TF-IDF
│
├── 2. 신경망 기반 (문맥 독립)
│   ├── 문맥 독립적 임베딩
│   │   └── Embedding Layer (딥러닝 모델 내 구성 요소)
│   ├── Word2Vec (CBOW, Skip-gram)
│   ├── FastText
│   ├── GloVe
│   └── 기타 모델: Swivel, LexVec 등
│
└── 3. 문맥 기반 임베딩 (Contextual Embedding)
    ├── RNN 계열
    │   ├── LSTM
        ├── GRU
    │   └── ELMo
    ├── Attention 메커니즘
    │   ├── Basic Attention
    │   ├── Self-Attention
    │   └── Multi-Head Attention
    └── Transformer 계열
        ├── BERT, RoBERTa, ALBERT
        ├── GPT 시리즈
        ├── KoBERT, KoGPT 등 한국어 특화
        └── 기타 모델: T5, LaMDA, PaLM, XLNet, ELECTRA</code></pre>
</section>
<section id="문맥을-고려한-벡터화-2018-현재-동적-임베딩" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> 문맥을 고려한 벡터화 (2018-현재): 동적 임베딩</h1>
<section id="gru-gated-recurrent-unit" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="gru-gated-recurrent-unit"><span class="header-section-number">3.1</span> GRU (Gated Recurrent Unit)</h2>
<p>GRU(Gated Recurrent Unit)는 2014년 조경현 교수 등이 제안한 순환 신경망의 한 종류로, LSTM(Long Short-Term Memory)과 마찬가지로 기존 RNN의 장기 의존성 문제를 해결하기 위해 설계되었다. GRU는 LSTM의 복잡한 구조를 단순화하면서도 유사한 성능을 내는 것을 목표로 하며, LSTM보다 적은 수의 게이트를 사용하여 계산 효율성을 높였다.</p>
<p>주요 특징은 다음과 같다:</p>
<ul>
<li>LSTM과 마찬가지로 장기 의존성 문제에 강인한 모습을 보인다.</li>
<li>LSTM에는 3개의 게이트(입력, 삭제, 출력 게이트)와 별도의 셀 상태(Cell State)가 있었던 반면, GRU는 <strong>리셋 게이트(Reset Gate)</strong>와 <strong>업데이트 게이트(Update Gate)</strong>라는 2개의 게이트만을 사용하며, 별도의 셀 상태 없이 은닉 상태(Hidden State)를 통해 정보를 전달한다.</li>
<li>이로 인해 LSTM보다 파라미터 수가 적어 일반적으로 학습 속도가 빠르고, 계산량이 적으며, 특히 데이터가 적은 경우 과적합(overfitting)에 대한 강점을 가질 수 있다.</li>
</ul>
<p>GRU의 핵심 아이디어는 각 시점에서 이전 정보를 얼마나 ’리셋’할지, 그리고 새로운 정보를 얼마나 ’업데이트’할지를 게이트를 통해 학습하여 조절하는 것이다.</p>
<section id="gru의-구조와-작동-원리" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="gru의-구조와-작동-원리"><span class="header-section-number">3.1.1</span> GRU의 구조와 작동 원리</h3>
<p>GRU는 현재 입력 <span class="math inline">\(x_t\)</span> 와 이전 시점의 은닉 상태 <span class="math inline">\(h_{t-1}\)</span> 을 받아 현재 시점의 은닉 상태 <span class="math inline">\(h_t\)</span> 를 출력한다. 이 과정은 다음의 두 가지 주요 게이트와 후보 은닉 상태 계산을 통해 이루어진다.</p>
<section id="리셋-게이트-reset-gate-r_t" class="level4" data-number="3.1.1.1">
<h4 data-number="3.1.1.1" class="anchored" data-anchor-id="리셋-게이트-reset-gate-r_t"><span class="header-section-number">3.1.1.1</span> 1. 리셋 게이트 (Reset Gate, <span class="math inline">\(r_t\)</span> )</h4>
<p>리셋 게이트는 이전 은닉 상태 <span class="math inline">\(h_{t-1}\)</span> 의 정보를 얼마나 ‘잊을지’ 또는 ’무시할지’를 결정한다. 이 게이트는 현재 입력 <span class="math inline">\(x_t\)</span>와 이전 은닉 상태 <span class="math inline">\(h_{t-1}\)</span> 을 사용하여 계산된다.</p>
<p><span class="math inline">\(r_t = \sigma(W_r x_t + U_r h_{t-1} + b_r)\)</span></p>
<ul>
<li><span class="math inline">\(W_r, U_r\)</span> : 리셋 게이트의 가중치 행렬</li>
<li><span class="math inline">\(b_r\)</span> : 리셋 게이트의 편향 벡터</li>
<li><span class="math inline">\(\sigma\)</span> : 시그모이드 함수 (출력값을 0과 1 사이로 제한하여 게이트의 열림/닫힘 정도를 결정)</li>
</ul>
<p>리셋 게이트의 출력 <span class="math inline">\(r_t\)</span> 는 0에 가까울수록 이전 은닉 상태의 정보를 많이 잊고(즉, 새로운 후보값 생성 시 이전 정보의 영향력을 줄임), 1에 가까울수록 많이 기억(활용)하게 된다. 이 <span class="math inline">\(r_t\)</span> 는 후보 은닉 상태 <span class="math inline">\(\tilde{h}_t\)</span> 를 계산할 때 이전 은닉 상태 <span class="math inline">\(h_{t-1}\)</span> 에 요소별 곱(element-wise product, <span class="math inline">\(\odot\)</span> )으로 적용되어, <span class="math inline">\(h_{t-1}\)</span> 의 어떤 부분을 새로운 후보 은닉 상태 계산에 사용할지 결정한다.</p>
</section>
<section id="업데이트-게이트-update-gate-z_t" class="level4" data-number="3.1.1.2">
<h4 data-number="3.1.1.2" class="anchored" data-anchor-id="업데이트-게이트-update-gate-z_t"><span class="header-section-number">3.1.1.2</span> 2. 업데이트 게이트 (Update Gate, <span class="math inline">\(z_t\)</span> )</h4>
<p>업데이트 게이트는 이전 은닉 상태 <span class="math inline">\(h_{t-1}\)</span> 의 정보를 얼마나 현재 은닉 상태 <span class="math inline">\(h_t\)</span>로 가져올지, 그리고 새로 계산된 후보 은닉 상태 <span class="math inline">\(\tilde{h}_t\)</span> 의 정보를 얼마나 반영할지를 결정한다. LSTM의 삭제 게이트와 입력 게이트의 역할을 동시에 수행한다고 볼 수 있다.</p>
<p><span class="math inline">\(z_t = \sigma(W_z x_t + U_z h_{t-1} + b_z)\)</span></p>
<ul>
<li><span class="math inline">\(W_z, U_z\)</span> : 업데이트 게이트의 가중치 행렬</li>
<li><span class="math inline">\(b_z\)</span> : 업데이트 게이트의 편향 벡터</li>
</ul>
<p>업데이트 게이트의 출력 <span class="math inline">\(z_t\)</span> 는 <span class="math inline">\(h_t\)</span> 를 계산할 때 <span class="math inline">\(\tilde{h}_t\)</span> 에 곱해지는 가중치 역할을 하며, <span class="math inline">\((1-z_t)\)</span> 는 <span class="math inline">\(h_{t-1}\)</span> 에 곱해지는 가중치 역할을 한다. 즉, <span class="math inline">\(z_t\)</span> 가 1에 가까우면 후보 은닉 상태 <span class="math inline">\(\tilde{h}_t\)</span> 의 정보를 많이 반영하고, <span class="math inline">\(z_t\)</span> 가 0에 가까우면 이전 은닉 상태 <span class="math inline">\(h_{t-1}\)</span> 의 정보를 많이 유지한다.</p>
</section>
<section id="후보-은닉-상태-candidate-hidden-state-tildeh_t" class="level4" data-number="3.1.1.3">
<h4 data-number="3.1.1.3" class="anchored" data-anchor-id="후보-은닉-상태-candidate-hidden-state-tildeh_t"><span class="header-section-number">3.1.1.3</span> 3. 후보 은닉 상태 (Candidate Hidden State, <span class="math inline">\(\tilde{h}_t\)</span> )</h4>
<p>후보 은닉 상태는 현재 시점의 정보를 담고 있는 새로운 은닉 값의 ’후보’이다. 이는 현재 입력 <span class="math inline">\(x_t\)</span>와 리셋 게이트에 의해 조절된 이전 은닉 상태 <span class="math inline">\((r_t \odot h_{t-1})\)</span> 를 사용하여 계산된다.</p>
<p><span class="math inline">\(\tilde{h}_t = \tanh(W_h x_t + U_h (r_t \odot h_{t-1}) + b_h)\)</span></p>
<ul>
<li><span class="math inline">\(W_h, U_h\)</span> : 후보 은닉 상태 계산을 위한 가중치 행렬</li>
<li><span class="math inline">\(b_h\)</span> : 후보 은닉 상태 계산을 위한 편향 벡터</li>
<li><span class="math inline">\(\tanh\)</span> : 하이퍼볼릭 탄젠트 함수 (출력값을 -1과 1 사이로 제한)</li>
</ul>
<p>리셋 게이트 <span class="math inline">\(r_t\)</span> 가 <span class="math inline">\(h_{t-1}\)</span> 에 곱해짐으로써, <span class="math inline">\(h_{t-1}\)</span> 중 과거 정보 중 현재 필요한 부분만 선택적으로 활용하여 현재 입력 <span class="math inline">\(x_t\)</span> 와 함께 새로운 정보 <span class="math inline">\(\tilde{h}_t\)</span> 를 구성하는 데 사용된다.</p>
</section>
<section id="최종-은닉-상태-final-hidden-state-h_t" class="level4" data-number="3.1.1.4">
<h4 data-number="3.1.1.4" class="anchored" data-anchor-id="최종-은닉-상태-final-hidden-state-h_t"><span class="header-section-number">3.1.1.4</span> 4. 최종 은닉 상태 (Final Hidden State, <span class="math inline">\(h_t\)</span> )</h4>
<p>최종적으로 현재 시점의 은닉 상태 <span class="math inline">\(h_t\)</span> 는 업데이트 게이트 <span class="math inline">\(z_t\)</span> 에 의해 이전 은닉 상태 <span class="math inline">\(h_{t-1}\)</span> 과 후보 은닉 상태 <span class="math inline">\(\tilde{h}_t\)</span> 가 조합되어 결정된다.</p>
<p><span class="math inline">\(h_t = (1 - z_t) \odot h_{t-1} + z_t \odot \tilde{h}_t\)</span></p>
<ul>
<li>이 식은 <span class="math inline">\(h_{t-1}\)</span> 과 <span class="math inline">\(\tilde{h}_t\)</span> 사이의 가중 평균과 유사한 형태로, <span class="math inline">\(z_t\)</span> 가 <span class="math inline">\(\tilde{h}_t\)</span> 를 얼마나 반영할지, 그리고 <span class="math inline">\((1-z_t)\)</span> 가 <span class="math inline">\(h_{t-1}\)</span> 을 얼마나 유지할지를 결정한다.</li>
<li><span class="math inline">\(z_t\)</span> 가 1이면 <span class="math inline">\(h_t = \tilde{h}_t\)</span> (이전 상태 무시, 새 정보만 반영)</li>
<li><span class="math inline">\(z_t\)</span> 가 0이면 <span class="math inline">\(h_t = h_{t-1}\)</span> (이전 상태 유지, 새 정보 무시)</li>
</ul>
<p>이러한 방식으로 GRU는 두 개의 게이트를 통해 정보의 흐름을 효과적으로 제어하며 장기 의존성 문제를 해결하려고 시도한다. LSTM에서 셀 상태와 은닉 상태를 분리했던 것과 달리, GRU는 은닉 상태 <span class="math inline">\(h_t\)</span> 하나로 이 두 가지 역할을 어느 정도 통합하여 수행한다.</p>
</section>
</section>
<section id="장기-의존성-문제-해결" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="장기-의존성-문제-해결"><span class="header-section-number">3.1.2</span> 장기 의존성 문제 해결</h3>
<p>GRU의 게이트 메커니즘은 RNN의 기울기 소실/폭주 문제를 완화하여 장기 의존성을 포착하는 데 도움을 준다.</p>
<ul>
<li><strong>업데이트 게이트 ( <span class="math inline">\(z_t\)</span> )</strong>: <span class="math inline">\(z_t\)</span> 값을 통해 이전 시점의 정보를 얼마나 유지할지 학습한다. 시퀀스에서 중요한 정보가 먼 과거에 있더라도, 네트워크는 <span class="math inline">\(z_t\)</span> 를 0에 가깝게 유지하여 해당 정보를 <span class="math inline">\(h_t\)</span> 로 계속 전달할 수 있다. 이는 장기적인 의존성을 유지하는 데 기여한다.</li>
<li><strong>리셋 게이트 ( <span class="math inline">\(r_t\)</span> )</strong>: <span class="math inline">\(r_t\)</span> 값을 통해 과거 정보 중 현재 예측에 불필요한 부분을 효과적으로 리셋(무시)할 수 있다. 이를 통해 현재 필요한 정보에 집중하고, 과거의 덜 중요한 정보로 인해 학습이 방해받는 것을 줄인다.</li>
</ul>
<p>이처럼 필요한 정보는 오래 유지하고, 불필요한 정보는 적절히 리셋함으로써 GRU는 긴 시퀀스에서도 안정적인 학습을 가능하게 한다.</p>
</section>
<section id="lstm과의-비교" class="level3" data-number="3.1.3">
<h3 data-number="3.1.3" class="anchored" data-anchor-id="lstm과의-비교"><span class="header-section-number">3.1.3</span> LSTM과의 비교</h3>
<p>GRU는 LSTM과 유사한 목적을 가지고 있지만 몇 가지 주요 차이점이 있다.</p>
<table class="table">
<colgroup>
<col style="width: 10%">
<col style="width: 44%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th>특징</th>
<th>LSTM (Long Short-Term Memory)</th>
<th>GRU (Gated Recurrent Unit)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>게이트 수</strong></td>
<td>3개 (입력 게이트, 삭제 게이트, 출력 게이트)</td>
<td>2개 (리셋 게이트, 업데이트 게이트)</td>
</tr>
<tr class="even">
<td><strong>셀 상태</strong></td>
<td>별도의 셀 상태 ( <span class="math inline">\(C_t\)</span> )를 가짐 (장기 기억 담당)</td>
<td>별도의 셀 상태 없음 (은닉 상태 <span class="math inline">\(h_t\)</span> 가 장기 기억과 현재 출력을 모두 담당)</td>
</tr>
<tr class="odd">
<td><strong>파라미터 수</strong></td>
<td>일반적으로 GRU보다 많음</td>
<td>일반적으로 LSTM보다 적음</td>
</tr>
<tr class="even">
<td><strong>계산 복잡도</strong></td>
<td>GRU보다 높음</td>
<td>LSTM보다 낮음 (학습 속도 빠를 수 있음)</td>
</tr>
<tr class="odd">
<td><strong>성능</strong></td>
<td>다양한 NLP 작업에서 강력한 성능 입증. 일반적으로 복잡한 데이터셋에서 유리</td>
<td>많은 경우 LSTM과 유사한 성능. 데이터가 적거나 특정 작업에서 더 나을 수 있음</td>
</tr>
<tr class="even">
<td><strong>정보 흐름</strong></td>
<td>셀 상태와 은닉 상태를 통해 정보 흐름 제어</td>
<td>은닉 상태와 두 게이트를 통해 정보 흐름 제어</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>구조적 차이</strong>: LSTM은 명시적인 메모리 셀( <span class="math inline">\(C_t\)</span> )을 사용하여 장기 정보를 저장하고, 세 개의 게이트로 이 셀과 은닉 상태( <span class="math inline">\(h_t\)</span> )를 제어한다. 반면 GRU는 셀 상태 없이 은닉 상태( <span class="math inline">\(h_t\)</span> )만으로 정보를 전달하며, 리셋 게이트와 업데이트 게이트 두 개로 정보 흐름을 제어한다. 업데이트 게이트가 LSTM의 삭제 게이트와 입력 게이트의 역할을 통합한 것으로 볼 수 있다.</li>
<li><strong>효율성</strong>: GRU는 파라미터 수가 적기 때문에 계산 효율성이 높고 학습 속도가 빠를 수 있으며, 특히 데이터셋의 크기가 작을 때 과적합을 피하는 데 유리할 수 있다.</li>
<li><strong>성능</strong>: 어떤 모델이 항상 우수하다고 단정하기는 어렵다. 문제의 성격, 데이터셋의 크기 및 복잡성, 하이퍼파라미터 튜닝 등에 따라 결과가 달라질 수 있다. 많은 연구에서 두 모델이 유사한 성능을 보인다고 보고되지만, 때로는 GRU가, 때로는 LSTM이 약간 더 나은 성능을 보이기도 한다.</li>
<li><strong>선택 기준</strong>: 일반적으로는 LSTM이 더 많은 표현력을 가질 수 있다고 여겨져 복잡한 문제에 우선 시도될 수 있지만, 계산 자원이 제한적이거나 빠른 학습이 필요할 경우, 또는 데이터가 충분하지 않을 경우에는 GRU가 좋은 대안이 될 수 있다. 실제 적용 시에는 두 모델을 모두 실험해보고 성능을 비교하는 것이 좋다.</li>
</ul>
</section>
<section id="양방향-gru-bidirectional-gru" class="level3" data-number="3.1.4">
<h3 data-number="3.1.4" class="anchored" data-anchor-id="양방향-gru-bidirectional-gru"><span class="header-section-number">3.1.4</span> 양방향 GRU (Bidirectional GRU)</h3>
<p>양방향 LSTM(BiLSTM)과 마찬가지로, 양방향 GRU(BiGRU)도 시퀀스 데이터 처리 시 과거와 미래의 문맥을 모두 고려하기 위해 사용된다. BiGRU는 순방향 GRU와 역방향 GRU 두 개를 병렬로 구성한다.</p>
<ul>
<li><strong>순방향 GRU</strong>: 입력 시퀀스를 처음부터 끝까지 순서대로 처리한다.</li>
<li><strong>역방향 GRU</strong>: 입력 시퀀스를 끝에서부터 처음까지 역순으로 처리한다.</li>
</ul>
<p>각 시점에서 두 GRU의 은닉 상태는 보통 연결(concatenation)되어 해당 시점의 최종적인 특징 표현으로 사용된다. 이를 통해 특정 시점의 단어나 요소에 대한 이해도를 높일 수 있다. 예를 들어, 문장에서 단어의 의미를 파악할 때 해당 단어의 앞뒤 단어들이 모두 중요한 역할을 하는 경우 BiGRU가 효과적이다.</p>
</section>
</section>
<section id="결론" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="결론"><span class="header-section-number">3.2</span> 결론</h2>
<p>본 문서에서는 RNN의 장기 의존성 문제를 해결하기 위해 설계된 GRU(Gated Recurrent Unit)의 핵심적인 구조와 작동 방식을 살펴보았다. GRU는 LSTM의 대안으로 제시되었으며, 더 단순한 구조와 적은 파라미터로도 유사하거나 때로는 더 나은 성능을 제공할 수 있음을 보여주었다.</p>
<ul>
<li><strong>GRU의 핵심 원리 요약</strong>:
<ul>
<li>GRU는 <strong>리셋 게이트</strong>와 <strong>업데이트 게이트</strong>라는 두 가지 게이트 메커니즘을 통해 정보의 흐름을 정교하게 제어한다. 리셋 게이트는 과거 정보 중 현재 예측에 덜 중요한 부분을 무시하도록 하고, 업데이트 게이트는 과거 정보와 현재 후보 정보 사이의 균형을 조절하여 다음 은닉 상태를 결정한다.</li>
<li>별도의 셀 상태 없이 은닉 상태만으로 장기 정보를 효과적으로 전달하며, 이는 LSTM에 비해 구조적 단순성과 계산 효율성을 가져다준다.</li>
</ul></li>
<li><strong>LSTM과의 관계 및 장점</strong>:
<ul>
<li>GRU는 LSTM보다 파라미터 수가 적어 학습 속도가 빠르고, 특히 데이터가 적은 환경에서 과적합의 위험을 줄일 수 있는 장점이 있다.</li>
<li>많은 자연어 처리 및 시퀀스 모델링 문제에서 LSTM과 대등한 성능을 보여주어, 모델 선택 시 중요한 고려 대상이 된다.</li>
</ul></li>
<li><strong>문맥 이해와 NLP에서의 중요성</strong>:
<ul>
<li>GRU는 장기 의존성을 효과적으로 처리할 수 있어 긴 시퀀스 데이터의 문맥적 의미를 파악하는 데 중요한 역할을 한다.</li>
<li>자연어 이해, 기계 번역, 음성 인식 등 다양한 NLP 태스크에서 순환 신경망의 핵심 구성 요소로 활용되며, 특히 계산 효율성이 중요하거나 빠른 프로토타이핑이 필요할 때 유용하다.</li>
</ul></li>
</ul>
<p>결론적으로, GRU는 LSTM과 함께 시퀀스 데이터, 특히 장기 의존성을 가진 데이터 처리에 있어 중요한 진보를 이룬 모델이다. 단순화된 게이트 메커니즘을 통해 정보의 선택적 기억과 업데이트를 가능하게 함으로써, 복잡한 패턴 학습 능력을 효과적으로 제공하며 다양한 응용 분야에서 그 가치를 입증하고 있다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>