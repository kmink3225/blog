<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="LangChain의 기본 개념과 OpenAI API 활용법을 다룬다.">

<title>Kwangmin Kim - ChatOpenAI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - ChatOpenAI">
<meta property="og:description" content="LangChain의 기본 개념과 OpenAI API 활용법을 다룬다.">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Kwangmin Kim - ChatOpenAI">
<meta name="twitter:description" content="LangChain의 기본 개념과 OpenAI API 활용법을 다룬다.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">ChatOpenAI</h1>
            <p class="subtitle lead">LangChain 기초</p>
                  <div>
        <div class="description">
          <p>LangChain의 기본 개념과 OpenAI API 활용법을 다룬다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">AI</div>
                <div class="quarto-category">RAG</div>
                <div class="quarto-category">LangChain</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2025년 01월 08일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#답변의-형식ai-message" id="toc-답변의-형식ai-message" class="nav-link active" data-scroll-target="#답변의-형식ai-message"><span class="header-section-number">0.1</span> 답변의 형식(AI Message)</a></li>
  <li><a href="#logprob-활성화" id="toc-logprob-활성화" class="nav-link" data-scroll-target="#logprob-활성화"><span class="header-section-number">0.2</span> LogProb 활성화</a></li>
  <li><a href="#스트리밍-출력" id="toc-스트리밍-출력" class="nav-link" data-scroll-target="#스트리밍-출력"><span class="header-section-number">0.3</span> 스트리밍 출력</a></li>
  <li><a href="#프롬프트-캐싱" id="toc-프롬프트-캐싱" class="nav-link" data-scroll-target="#프롬프트-캐싱"><span class="header-section-number">1</span> 프롬프트 캐싱</a></li>
  <li><a href="#멀티모달-모델이미지-인식" id="toc-멀티모달-모델이미지-인식" class="nav-link" data-scroll-target="#멀티모달-모델이미지-인식"><span class="header-section-number">2</span> 멀티모달 모델(이미지 인식)</a></li>
  <li><a href="#system-user-프롬프트-수정" id="toc-system-user-프롬프트-수정" class="nav-link" data-scroll-target="#system-user-프롬프트-수정"><span class="header-section-number">3</span> System, User 프롬프트 수정</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<div id="26cb8e63" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># API KEY를 환경변수로 관리하기 위한 설정 파일</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">from</span> dotenv <span class="im">import</span> load_dotenv</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co"># API KEY 정보로드</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>load_dotenv()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="8bb11616" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># LangSmith 추적을 설정합니다. https://smith.langchain.com</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co"># .env 파일에 LANGCHAIN_API_KEY를 입력합니다.</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co"># !pip install -qU langchain-teddynote</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="im">from</span> langchain_teddynote <span class="im">import</span> logging</span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="co"># 프로젝트 이름을 입력합니다.</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>logging.langsmith(<span class="st">"CH01-Basic"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>OpenAI 사의 채팅 전용 Large Language Model(llm) 입니다.</p>
<p>객체를 생성할 때 다음을 옵션 값을 지정할 수 있습니다. 옵션에 대한 상세 설명은 다음과 같습니다.</p>
<p><code>temperature</code></p>
<ul>
<li>사용할 샘플링 온도는 0과 2 사이에서 선택합니다. 0.8과 같은 높은 값은 출력을 더 무작위하게 만들고, 0.2와 같은 낮은 값은 출력을 더 집중되고 결정론적으로 만듭니다.</li>
</ul>
<p><code>max_tokens</code></p>
<ul>
<li>채팅 완성에서 생성할 토큰의 최대 개수입니다.</li>
</ul>
<p><code>model_name</code>: 적용 가능한 모델 리스트 - <code>gpt-4.1</code> - <code>gpt-4.1-mini</code> - <code>gpt-4.1-nano</code> - <code>gpt-4.1</code> - <code>gpt-4.1-mini</code> - <code>o1-mini</code>, <code>o3</code>, <code>o4-mini</code>: tier5 계정 이상만 사용 가능. $1,000 이상 충전해야 tier5 계정이 됩니다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/gpt-models3.png" class="img-fluid figure-img"></p>
<figcaption>gpt-models.png</figcaption>
</figure>
</div>
<ul>
<li>링크: https://platform.openai.com/docs/models</li>
</ul>
<div id="c3b65841" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="im">from</span> langchain_openai <span class="im">import</span> ChatOpenAI</span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co"># 객체 생성</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>llm <span class="op">=</span> ChatOpenAI(</span>
<span id="cb3-5"><a href="#cb3-5"></a>    temperature<span class="op">=</span><span class="fl">0.1</span>,  <span class="co"># 창의성 (0.0 ~ 2.0)</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    model_name<span class="op">=</span><span class="st">"gpt-4.1-nano"</span>,  <span class="co"># 모델명</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>)</span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="co"># 질의내용</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>question <span class="op">=</span> <span class="st">"대한민국의 수도는 어디인가요?"</span></span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co"># 질의</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="bu">print</span>(<span class="ss">f"[답변]: </span><span class="sc">{</span>llm<span class="sc">.</span>invoke(question)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="답변의-형식ai-message" class="level3" data-number="0.1">
<h3 data-number="0.1" class="anchored" data-anchor-id="답변의-형식ai-message"><span class="header-section-number">0.1</span> 답변의 형식(AI Message)</h3>
<div id="1f8b5206" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># 질의내용</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>question <span class="op">=</span> <span class="st">"대한민국의 수도는 어디인가요?"</span></span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co"># 질의</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>response <span class="op">=</span> llm.invoke(question)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="7c6cc83a" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>response</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="8e2122e2" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>response.content</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="fa70b4e7" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>response.response_metadata</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="logprob-활성화" class="level3" data-number="0.2">
<h3 data-number="0.2" class="anchored" data-anchor-id="logprob-활성화"><span class="header-section-number">0.2</span> LogProb 활성화</h3>
<p>주어진 텍스트에 대한 모델의 <strong>토큰 확률의 로그 값</strong> 을 의미합니다. 토큰이란 문장을 구성하는 개별 단어나 문자 등의 요소를 의미하고, 확률은 <strong>모델이 그 토큰을 예측할 확률</strong>을 나타냅니다.</p>
<div id="a8d2d89a" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># 객체 생성</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>llm_with_logprob <span class="op">=</span> ChatOpenAI(</span>
<span id="cb8-3"><a href="#cb8-3"></a>    temperature<span class="op">=</span><span class="fl">0.1</span>,  <span class="co"># 창의성 (0.0 ~ 2.0)</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>    max_tokens<span class="op">=</span><span class="dv">2048</span>,  <span class="co"># 최대 토큰수</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    model_name<span class="op">=</span><span class="st">"gpt-4.1-nano"</span>,  <span class="co"># 모델명</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>).bind(logprobs<span class="op">=</span><span class="va">True</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="8cb5fdb9" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># 질의내용</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>question <span class="op">=</span> <span class="st">"대한민국의 수도는 어디인가요?"</span></span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co"># 질의</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>response <span class="op">=</span> llm_with_logprob.invoke(question)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="a6ffdeca" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># 결과 출력</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>response.response_metadata</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="스트리밍-출력" class="level3" data-number="0.3">
<h3 data-number="0.3" class="anchored" data-anchor-id="스트리밍-출력"><span class="header-section-number">0.3</span> 스트리밍 출력</h3>
<p>스트리밍 옵션은 질의에 대한 답변을 실시간으로 받을 때 유용합니다.</p>
<div id="113f9b99" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># 스트림 방식으로 질의</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="co"># answer 에 스트리밍 답변의 결과를 받습니다.</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>answer <span class="op">=</span> llm.stream(<span class="st">"대한민국의 아름다운 관광지 10곳과 주소를 알려주세요!"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="b48972c7" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="co"># 스트리밍 방식으로 각 토큰을 출력합니다. (실시간 출력)</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="cf">for</span> token <span class="kw">in</span> answer:</span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="bu">print</span>(token.content, end<span class="op">=</span><span class="st">""</span>, flush<span class="op">=</span><span class="va">True</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="268a4c67" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="im">from</span> langchain_teddynote.messages <span class="im">import</span> stream_response</span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="co"># 스트림 방식으로 질의</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="co"># answer 에 스트리밍 답변의 결과를 받습니다.</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>answer <span class="op">=</span> llm.stream(<span class="st">"대한민국의 아름다운 관광지 10곳과 주소를 알려주세요!"</span>)</span>
<span id="cb13-6"><a href="#cb13-6"></a>stream_response(answer)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="프롬프트-캐싱" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="프롬프트-캐싱"><span class="header-section-number">1</span> 프롬프트 캐싱</h2>
<ul>
<li>참고 링크: https://platform.openai.com/docs/guides/prompt-caching</li>
</ul>
<p>프롬프트 캐싱 기능을 활용하면 반복하여 동일하게 입력으로 들어가는 토큰에 대한 비용을 아낄 수 있습니다.</p>
<p>다만, 캐싱에 활용할 토큰은 고정된 PREFIX 를 주는 것이 권장됩니다.</p>
<p>아래의 예시에서는 <code>&lt;PROMPT_CACHING&gt;</code> 부분에 고정된 토큰을 주어 캐싱을 활용하는 방법을 설명합니다.</p>
<div id="913c1816" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="im">from</span> langchain_teddynote.messages <span class="im">import</span> stream_response</span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a>very_long_prompt <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="st">당신은 매우 친절한 AI 어시스턴트 입니다. </span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="st">당신의 임무는 주어진 질문에 대해 친절하게 답변하는 것입니다.</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="st">아래는 사용자의 질문에 답변할 때 참고할 수 있는 정보입니다.</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="st">주어진 정보를 참고하여 답변해 주세요.</span></span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="st">&lt;WANT_TO_CACHE_HERE&gt;</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="st">#참고:</span></span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="st">**Prompt Caching**</span></span>
<span id="cb14-12"><a href="#cb14-12"></a><span class="st">Model prompts often contain repetitive content, like system prompts and common instructions. OpenAI routes API requests to servers that recently processed the same prompt, making it cheaper and faster than processing a prompt from scratch. This can reduce latency by up to 80% and cost by 50</span><span class="sc">% f</span><span class="st">or long prompts. Prompt Caching works automatically on all your API requests (no code changes required) and has no additional fees associated with it.</span></span>
<span id="cb14-13"><a href="#cb14-13"></a></span>
<span id="cb14-14"><a href="#cb14-14"></a><span class="st">Prompt Caching is enabled for the following models:</span></span>
<span id="cb14-15"><a href="#cb14-15"></a></span>
<span id="cb14-16"><a href="#cb14-16"></a><span class="st">gpt-4.1 (excludes gpt-4.1-2024-05-13 and chatgpt-4.1-latest)</span></span>
<span id="cb14-17"><a href="#cb14-17"></a><span class="st">gpt-4.1-mini</span></span>
<span id="cb14-18"><a href="#cb14-18"></a><span class="st">o1-preview</span></span>
<span id="cb14-19"><a href="#cb14-19"></a><span class="st">o1-mini</span></span>
<span id="cb14-20"><a href="#cb14-20"></a><span class="st">This guide describes how prompt caching works in detail, so that you can optimize your prompts for lower latency and cost.</span></span>
<span id="cb14-21"><a href="#cb14-21"></a></span>
<span id="cb14-22"><a href="#cb14-22"></a><span class="st">Structuring prompts</span></span>
<span id="cb14-23"><a href="#cb14-23"></a><span class="st">Cache hits are only possible for exact prefix matches within a prompt. To realize caching benefits, place static content like instructions and examples at the beginning of your prompt, and put variable content, such as user-specific information, at the end. This also applies to images and tools, which must be identical between requests.</span></span>
<span id="cb14-24"><a href="#cb14-24"></a></span>
<span id="cb14-25"><a href="#cb14-25"></a><span class="st">How it works</span></span>
<span id="cb14-26"><a href="#cb14-26"></a><span class="st">Caching is enabled automatically for prompts that are 1024 tokens or longer. When you make an API request, the following steps occur:</span></span>
<span id="cb14-27"><a href="#cb14-27"></a></span>
<span id="cb14-28"><a href="#cb14-28"></a><span class="st">Cache Lookup: The system checks if the initial portion (prefix) of your prompt is stored in the cache.</span></span>
<span id="cb14-29"><a href="#cb14-29"></a><span class="st">Cache Hit: If a matching prefix is found, the system uses the cached result. This significantly decreases latency and reduces costs.</span></span>
<span id="cb14-30"><a href="#cb14-30"></a><span class="st">Cache Miss: If no matching prefix is found, the system processes your full prompt. After processing, the prefix of your prompt is cached for future requests.</span></span>
<span id="cb14-31"><a href="#cb14-31"></a><span class="st">Cached prefixes generally remain active for 5 to 10 minutes of inactivity. However, during off-peak periods, caches may persist for up to one hour.</span></span>
<span id="cb14-32"><a href="#cb14-32"></a></span>
<span id="cb14-33"><a href="#cb14-33"></a><span class="st">Requirements</span></span>
<span id="cb14-34"><a href="#cb14-34"></a><span class="st">Caching is available for prompts containing 1024 tokens or more, with cache hits occurring in increments of 128 tokens. Therefore, the number of cached tokens in a request will always fall within the following sequence: 1024, 1152, 1280, 1408, and so on, depending on the prompt's length.</span></span>
<span id="cb14-35"><a href="#cb14-35"></a></span>
<span id="cb14-36"><a href="#cb14-36"></a><span class="st">All requests, including those with fewer than 1024 tokens, will display a cached_tokens field of the usage.prompt_tokens_details chat completions object indicating how many of the prompt tokens were a cache hit. For requests under 1024 tokens, cached_tokens will be zero.</span></span>
<span id="cb14-37"><a href="#cb14-37"></a></span>
<span id="cb14-38"><a href="#cb14-38"></a><span class="st">What can be cached</span></span>
<span id="cb14-39"><a href="#cb14-39"></a><span class="st">Messages: The complete messages array, encompassing system, user, and assistant interactions.</span></span>
<span id="cb14-40"><a href="#cb14-40"></a><span class="st">Images: Images included in user messages, either as links or as base64-encoded data, as well as multiple images can be sent. Ensure the detail parameter is set identically, as it impacts image tokenization.</span></span>
<span id="cb14-41"><a href="#cb14-41"></a><span class="st">Tool use: Both the messages array and the list of available tools can be cached, contributing to the minimum 1024 token requirement.</span></span>
<span id="cb14-42"><a href="#cb14-42"></a><span class="st">Structured outputs: The structured output schema serves as a prefix to the system message and can be cached.</span></span>
<span id="cb14-43"><a href="#cb14-43"></a><span class="st">Best practices</span></span>
<span id="cb14-44"><a href="#cb14-44"></a><span class="st">Structure prompts with static or repeated content at the beginning and dynamic content at the end.</span></span>
<span id="cb14-45"><a href="#cb14-45"></a><span class="st">Monitor metrics such as cache hit rates, latency, and the percentage of tokens cached to optimize your prompt and caching strategy.</span></span>
<span id="cb14-46"><a href="#cb14-46"></a><span class="st">To increase cache hits, use longer prompts and make API requests during off-peak hours, as cache evictions are more frequent during peak times.</span></span>
<span id="cb14-47"><a href="#cb14-47"></a><span class="st">Prompts that haven't been used recently are automatically removed from the cache. To minimize evictions, maintain a consistent stream of requests with the same prompt prefix.</span></span>
<span id="cb14-48"><a href="#cb14-48"></a><span class="st">Frequently asked questions</span></span>
<span id="cb14-49"><a href="#cb14-49"></a><span class="st">How is data privacy maintained for caches?</span></span>
<span id="cb14-50"><a href="#cb14-50"></a></span>
<span id="cb14-51"><a href="#cb14-51"></a><span class="st">Prompt caches are not shared between organizations. Only members of the same organization can access caches of identical prompts.</span></span>
<span id="cb14-52"><a href="#cb14-52"></a></span>
<span id="cb14-53"><a href="#cb14-53"></a><span class="st">Does Prompt Caching affect output token generation or the final response of the API?</span></span>
<span id="cb14-54"><a href="#cb14-54"></a></span>
<span id="cb14-55"><a href="#cb14-55"></a><span class="st">Prompt Caching does not influence the generation of output tokens or the final response provided by the API. Regardless of whether caching is used, the output generated will be identical. This is because only the prompt itself is cached, while the actual response is computed anew each time based on the cached prompt. </span></span>
<span id="cb14-56"><a href="#cb14-56"></a></span>
<span id="cb14-57"><a href="#cb14-57"></a><span class="st">Is there a way to manually clear the cache?</span></span>
<span id="cb14-58"><a href="#cb14-58"></a></span>
<span id="cb14-59"><a href="#cb14-59"></a><span class="st">Manual cache clearing is not currently available. Prompts that have not been encountered recently are automatically cleared from the cache. Typical cache evictions occur after 5-10 minutes of inactivity, though sometimes lasting up to a maximum of one hour during off-peak periods.</span></span>
<span id="cb14-60"><a href="#cb14-60"></a></span>
<span id="cb14-61"><a href="#cb14-61"></a><span class="st">Will I be expected to pay extra for writing to Prompt Caching?</span></span>
<span id="cb14-62"><a href="#cb14-62"></a></span>
<span id="cb14-63"><a href="#cb14-63"></a><span class="st">No. Caching happens automatically, with no explicit action needed or extra cost paid to use the caching feature.</span></span>
<span id="cb14-64"><a href="#cb14-64"></a></span>
<span id="cb14-65"><a href="#cb14-65"></a><span class="st">Do cached prompts contribute to TPM rate limits?</span></span>
<span id="cb14-66"><a href="#cb14-66"></a></span>
<span id="cb14-67"><a href="#cb14-67"></a><span class="st">Yes, as caching does not affect rate limits.</span></span>
<span id="cb14-68"><a href="#cb14-68"></a></span>
<span id="cb14-69"><a href="#cb14-69"></a><span class="st">Is discounting for Prompt Caching available on Scale Tier and the Batch API?</span></span>
<span id="cb14-70"><a href="#cb14-70"></a></span>
<span id="cb14-71"><a href="#cb14-71"></a><span class="st">Discounting for Prompt Caching is not available on the Batch API but is available on Scale Tier. With Scale Tier, any tokens that are spilled over to the shared API will also be eligible for caching.</span></span>
<span id="cb14-72"><a href="#cb14-72"></a></span>
<span id="cb14-73"><a href="#cb14-73"></a><span class="st">Does Prompt Caching work on Zero Data Retention requests?</span></span>
<span id="cb14-74"><a href="#cb14-74"></a></span>
<span id="cb14-75"><a href="#cb14-75"></a><span class="st">Yes, Prompt Caching is compliant with existing Zero Data Retention policies.</span></span>
<span id="cb14-76"><a href="#cb14-76"></a><span class="st">&lt;/WANT_TO_CACHE_HERE&gt;</span></span>
<span id="cb14-77"><a href="#cb14-77"></a></span>
<span id="cb14-78"><a href="#cb14-78"></a><span class="st">#Question:</span></span>
<span id="cb14-79"><a href="#cb14-79"></a><span class="sc">{}</span></span>
<span id="cb14-80"><a href="#cb14-80"></a></span>
<span id="cb14-81"><a href="#cb14-81"></a><span class="st">"""</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="9959260e" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="im">from</span> langchain.callbacks <span class="im">import</span> get_openai_callback</span>
<span id="cb15-2"><a href="#cb15-2"></a></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="cf">with</span> get_openai_callback() <span class="im">as</span> cb:</span>
<span id="cb15-4"><a href="#cb15-4"></a>    <span class="co"># 답변 요청</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>    answer <span class="op">=</span> llm.invoke(</span>
<span id="cb15-6"><a href="#cb15-6"></a>        very_long_prompt.<span class="bu">format</span>(<span class="st">"프롬프트 캐싱 기능에 대해 2문장으로 설명하세요"</span>)</span>
<span id="cb15-7"><a href="#cb15-7"></a>    )</span>
<span id="cb15-8"><a href="#cb15-8"></a>    <span class="bu">print</span>(cb)</span>
<span id="cb15-9"><a href="#cb15-9"></a>    <span class="co"># 캐싱된 토큰 출력</span></span>
<span id="cb15-10"><a href="#cb15-10"></a>    cached_tokens <span class="op">=</span> answer.response_metadata[<span class="st">"token_usage"</span>][<span class="st">"prompt_tokens_details"</span>][</span>
<span id="cb15-11"><a href="#cb15-11"></a>        <span class="st">"cached_tokens"</span></span>
<span id="cb15-12"><a href="#cb15-12"></a>    ]</span>
<span id="cb15-13"><a href="#cb15-13"></a>    <span class="bu">print</span>(<span class="ss">f"캐싱된 토큰: </span><span class="sc">{</span>cached_tokens<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="78f38c75" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a><span class="cf">with</span> get_openai_callback() <span class="im">as</span> cb:</span>
<span id="cb16-2"><a href="#cb16-2"></a>    <span class="co"># 답변 요청</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>    answer <span class="op">=</span> llm.invoke(</span>
<span id="cb16-4"><a href="#cb16-4"></a>        very_long_prompt.<span class="bu">format</span>(<span class="st">"프롬프트 캐싱 기능에 대해 2문장으로 설명하세요"</span>)</span>
<span id="cb16-5"><a href="#cb16-5"></a>    )</span>
<span id="cb16-6"><a href="#cb16-6"></a>    <span class="bu">print</span>(cb)</span>
<span id="cb16-7"><a href="#cb16-7"></a>    <span class="co"># 캐싱된 토큰 출력</span></span>
<span id="cb16-8"><a href="#cb16-8"></a>    cached_tokens <span class="op">=</span> answer.response_metadata[<span class="st">"token_usage"</span>][<span class="st">"prompt_tokens_details"</span>][</span>
<span id="cb16-9"><a href="#cb16-9"></a>        <span class="st">"cached_tokens"</span></span>
<span id="cb16-10"><a href="#cb16-10"></a>    ]</span>
<span id="cb16-11"><a href="#cb16-11"></a>    <span class="bu">print</span>(<span class="ss">f"캐싱된 토큰: </span><span class="sc">{</span>cached_tokens<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="멀티모달-모델이미지-인식" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="멀티모달-모델이미지-인식"><span class="header-section-number">2</span> 멀티모달 모델(이미지 인식)</h2>
<p>멀티모달은 여러 가지 형태의 정보(모달)를 통합하여 처리하는 기술이나 접근 방식을 의미합니다. 이는 다음과 같은 다양한 데이터 유형을 포함할 수 있습니다.</p>
<ul>
<li>텍스트: 문서, 책, 웹 페이지 등의 글자로 된 정보</li>
<li>이미지: 사진, 그래픽, 그림 등 시각적 정보</li>
<li>오디오: 음성, 음악, 소리 효과 등의 청각적 정보</li>
<li>비디오: 동영상 클립, 실시간 스트리밍 등 시각적 및 청각적 정보의 결합</li>
</ul>
<p><code>gpt-4.1</code> 모델은 이미지 인식 기능(Vision) 이 추가되어 있는 모델입니다.</p>
<div id="c149f4af" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="im">from</span> langchain_teddynote.models <span class="im">import</span> MultiModal</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="im">from</span> langchain_teddynote.messages <span class="im">import</span> stream_response</span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="co"># 객체 생성</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>llm <span class="op">=</span> ChatOpenAI(</span>
<span id="cb17-6"><a href="#cb17-6"></a>    temperature<span class="op">=</span><span class="fl">0.1</span>,  <span class="co"># 창의성 (0.0 ~ 2.0)</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>    model_name<span class="op">=</span><span class="st">"gpt-4.1-nano"</span>,  <span class="co"># 모델명</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>)</span>
<span id="cb17-9"><a href="#cb17-9"></a></span>
<span id="cb17-10"><a href="#cb17-10"></a><span class="co"># 멀티모달 객체 생성</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>multimodal_llm <span class="op">=</span> MultiModal(llm)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="61be2cb7" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a><span class="co"># 샘플 이미지 주소(웹사이트로 부터 바로 인식)</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>IMAGE_URL <span class="op">=</span> <span class="st">"https://t3.ftcdn.net/jpg/03/77/33/96/360_F_377339633_Rtv9I77sSmSNcev8bEcnVxTHrXB4nRJ5.jpg"</span></span>
<span id="cb18-3"><a href="#cb18-3"></a></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="co"># 이미지 파일로 부터 질의</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>answer <span class="op">=</span> multimodal_llm.stream(IMAGE_URL)</span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="co"># 스트리밍 방식으로 각 토큰을 출력합니다. (실시간 출력)</span></span>
<span id="cb18-7"><a href="#cb18-7"></a>stream_response(answer)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="5e2778bb" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="co"># 로컬 PC 에 저장되어 있는 이미지의 경로 입력</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>IMAGE_PATH_FROM_FILE <span class="op">=</span> <span class="st">"./images/sample-image.png"</span></span>
<span id="cb19-3"><a href="#cb19-3"></a></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="co"># 이미지 파일로 부터 질의(스트림 방식)</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>answer <span class="op">=</span> multimodal_llm.stream(IMAGE_PATH_FROM_FILE)</span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="co"># 스트리밍 방식으로 각 토큰을 출력합니다. (실시간 출력)</span></span>
<span id="cb19-7"><a href="#cb19-7"></a>stream_response(answer)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="system-user-프롬프트-수정" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="system-user-프롬프트-수정"><span class="header-section-number">3</span> System, User 프롬프트 수정</h2>
<div id="40210ba9" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a>system_prompt <span class="op">=</span> <span class="st">"""당신은 표(재무제표) 를 해석하는 금융 AI 어시스턴트 입니다. </span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="st">당신의 임무는 주어진 테이블 형식의 재무제표를 바탕으로 흥미로운 사실을 정리하여 친절하게 답변하는 것입니다."""</span></span>
<span id="cb20-3"><a href="#cb20-3"></a></span>
<span id="cb20-4"><a href="#cb20-4"></a>user_prompt <span class="op">=</span> <span class="st">"""당신에게 주어진 표는 회사의 재무제표 입니다. 흥미로운 사실을 정리하여 답변하세요."""</span></span>
<span id="cb20-5"><a href="#cb20-5"></a></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="co"># 멀티모달 객체 생성</span></span>
<span id="cb20-7"><a href="#cb20-7"></a>multimodal_llm_with_prompt <span class="op">=</span> MultiModal(</span>
<span id="cb20-8"><a href="#cb20-8"></a>    llm, system_prompt<span class="op">=</span>system_prompt, user_prompt<span class="op">=</span>user_prompt</span>
<span id="cb20-9"><a href="#cb20-9"></a>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="ab602b6b" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a><span class="co"># 로컬 PC 에 저장되어 있는 이미지의 경로 입력</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>IMAGE_PATH_FROM_FILE <span class="op">=</span> <span class="st">"https://storage.googleapis.com/static.fastcampus.co.kr/prod/uploads/202212/080345-661/kwon-01.png"</span></span>
<span id="cb21-3"><a href="#cb21-3"></a></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="co"># 이미지 파일로 부터 질의(스트림 방식)</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>answer <span class="op">=</span> multimodal_llm_with_prompt.stream(IMAGE_PATH_FROM_FILE)</span>
<span id="cb21-6"><a href="#cb21-6"></a></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="co"># 스트리밍 방식으로 각 토큰을 출력합니다. (실시간 출력)</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>stream_response(answer)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>


</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>