<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="문서 검색 도구와 웹 검색 도구를 활용하여 최신 정보를 검색하고 답변을 생성하는 Agentic RAG를 다룬다.">

<title>Kwangmin Kim - Agentic RAG</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - Agentic RAG">
<meta property="og:description" content="문서 검색 도구와 웹 검색 도구를 활용하여 최신 정보를 검색하고 답변을 생성하는 Agentic RAG를 다룬다.">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Kwangmin Kim - Agentic RAG">
<meta name="twitter:description" content="문서 검색 도구와 웹 검색 도구를 활용하여 최신 정보를 검색하고 답변을 생성하는 Agentic RAG를 다룬다.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">Agentic RAG</h1>
            <p class="subtitle lead">에이전트를 활용한 검색 증강 생성</p>
                  <div>
        <div class="description">
          <p>문서 검색 도구와 웹 검색 도구를 활용하여 최신 정보를 검색하고 답변을 생성하는 Agentic RAG를 다룬다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">AI</div>
                <div class="quarto-category">RAG</div>
                <div class="quarto-category">LangChain</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2025년 07월 20일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#agentic-rag" id="toc-agentic-rag" class="nav-link active" data-scroll-target="#agentic-rag"><span class="header-section-number">1</span> Agentic RAG</a>
  <ul class="collapse">
  <li><a href="#도구tools" id="toc-도구tools" class="nav-link" data-scroll-target="#도구tools"><span class="header-section-number">1.1</span> 도구(Tools)</a>
  <ul class="collapse">
  <li><a href="#웹-검색도구-tavily-search" id="toc-웹-검색도구-tavily-search" class="nav-link" data-scroll-target="#웹-검색도구-tavily-search"><span class="header-section-number">1.1.1</span> 웹 검색도구: Tavily Search</a></li>
  <li><a href="#문서-기반-문서-검색-도구-retriever" id="toc-문서-기반-문서-검색-도구-retriever" class="nav-link" data-scroll-target="#문서-기반-문서-검색-도구-retriever"><span class="header-section-number">1.1.2</span> 문서 기반 문서 검색 도구: Retriever</a></li>
  <li><a href="#agent-가-사용할-도구-목록-정의" id="toc-agent-가-사용할-도구-목록-정의" class="nav-link" data-scroll-target="#agent-가-사용할-도구-목록-정의"><span class="header-section-number">1.1.3</span> Agent 가 사용할 도구 목록 정의</a></li>
  </ul></li>
  <li><a href="#agent-생성" id="toc-agent-생성" class="nav-link" data-scroll-target="#agent-생성"><span class="header-section-number">1.2</span> Agent 생성</a></li>
  <li><a href="#에이전트-실행하기" id="toc-에이전트-실행하기" class="nav-link" data-scroll-target="#에이전트-실행하기"><span class="header-section-number">1.3</span> 에이전트 실행하기</a></li>
  <li><a href="#이전-대화내용-기억하는-agent" id="toc-이전-대화내용-기억하는-agent" class="nav-link" data-scroll-target="#이전-대화내용-기억하는-agent"><span class="header-section-number">1.4</span> 이전 대화내용 기억하는 Agent</a></li>
  <li><a href="#agent-템플릿" id="toc-agent-템플릿" class="nav-link" data-scroll-target="#agent-템플릿"><span class="header-section-number">1.5</span> Agent 템플릿</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="agentic-rag" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Agentic RAG</h1>
<ul>
<li>상황에 따라 유동적으로 LLM을 동작 시키는 방법</li>
<li>Agent를 활용한 RAG으로 적절하게 RAG, Agent, Agentic RAG을 사용해야 함. 반드시 agent가 좋은 것은 아님.
<ul>
<li>Agentic RAG의 장점: LLMM 에 tools을 개발해주어 LLM이 알아서 판단해서 문제 해결을 함</li>
<li>Chaining RAG: 특정 문서에서 정보를 추출하여 답변할때 충분한 방법</li>
</ul></li>
<li>LLM에게 파이썬 코드를 실행할 수 있는 tool을 구현해주고 파이썬 코드를 지시사항으로 주게되면 파이썬 코드를 만들어서 실행결과를 반환할 수 있다</li>
<li>문서에서 검색을 하고 검색된 내용을 기반으로 파이썬 코드를 만들어 실행한 후 그 결과를 반환하는 것도 가능</li>
<li>문서 검색을 통해 최신 정보에 접근하여 검색 결과를 가지고 답변을 생성하는 에이전트를 만들어 본다.</li>
<li>질문에 따라 문서를 검색하여 답변하거나, 인터넷 검색 도구를 활용하여 답변하는 에이전트를 만들어 본다.</li>
</ul>
<p><strong>참고</strong></p>
<ul>
<li>RAG 를 수행하되, Agent 를 활용하여 RAG 를 수행한다면 이를 <strong>Agentic RAG</strong> 라고 부릅니다.</li>
</ul>
<section id="도구tools" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="도구tools"><span class="header-section-number">1.1</span> 도구(Tools)</h2>
<p>Agent 가 활용할 도구를 정의하여 Agent 가 추론(reasoning)을 수행할 때 활용하도록 만들 수 있다.</p>
<p>Tavily Search 는 그 중 대표적인 <strong>검색 도구</strong> 다. 검색을 통해 최신 정보에 접근하여 검색 결과를 가지고 답변을 생성할 수 있다. 도구는 이처럼 검색 도구 뿐만아니라 Python 코드를 실행할 수 있는 도구, 직접 정의한 함수를 실행하는 도구 등 다양한 종류와 방법론을 제공한다.</p>
<section id="웹-검색도구-tavily-search" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="웹-검색도구-tavily-search"><span class="header-section-number">1.1.1</span> 웹 검색도구: Tavily Search</h3>
<p>LangChain에는 Tavily 검색 엔진을 도구로 쉽게 사용할 수 있는 내장 도구가 있다.</p>
<p>Tavily Search 를 사용하기 위해서는 API KEY를 발급 받아야 한다.</p>
<ul>
<li><a href="https://app.tavily.com/sign-in">Tavily Search API 발급받기</a></li>
</ul>
<p>발급 받은 API KEY 를 다음과 같이 환경변수에 등록 한다.</p>
<p><code>.env</code> 파일에 다음과 같이 등록한다.</p>
<ul>
<li><code>TAVILY_API_KEY=발급 받은 Tavily API KEY 입력</code></li>
</ul>
<div id="e5889094" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># API 키를 환경변수로 관리하기 위한 설정 파일</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">from</span> dotenv <span class="im">import</span> load_dotenv</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co"># API 키 정보 로드</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>load_dotenv()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="513cdf63" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># LangSmith 추적을 설정한다. https://smith.langchain.com</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co"># !pip install -qU langchain-teddynote</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="im">from</span> langchain_teddynote <span class="im">import</span> logging</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co"># 프로젝트 이름을 입력한다.</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>logging.langsmith(<span class="st">"CH15-Agentic-RAG"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="125cc0a8" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># TavilySearchResults 클래스를 langchain_community.tools.tavily_search 모듈에서 가져온다.</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="im">from</span> langchain_community.tools.tavily_search <span class="im">import</span> TavilySearchResults</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co"># TavilySearchResults 클래스의 인스턴스를 생성한다</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co"># k=6은 검색 결과를 6개까지 가져오겠다는 의미다</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>search <span class="op">=</span> TavilySearchResults(k<span class="op">=</span><span class="dv">6</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><code>search.invoke</code> 함수는 주어진 문자열에 대한 검색을 실행한다.</p>
<p><code>invoke()</code> 함수에 검색하고 싶은 검색어를 넣어 검색을 수행한다.</p>
<div id="2da7e63d" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># 검색 결과를 가져옵니다.</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>search.invoke(<span class="st">"판교 카카오 프렌즈샵 아지트점의 전화번호는 무엇인가요?"</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">#k=6 이지만 검색 결과가 더 적으면 그 검색된 수만큼 반환이 된다. 아래의 예에선 5개가 반환</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>[{'url': 'https://blog.naver.com/PostView.naver?blogId=amour1115&amp;logNo=223386213560',  'content': '카카오 프렌즈 판교 아지트점. . 연중무휴 12:00-21:00. 토, 일 12:00-20:00. . 경기 성남시 분당구 판교역로 166. 카카오 판교 아지트 1층 카카오 프렌즈. 031-301-7225. 존재하지 않는 이미지입니다.'}, {'url': 'https://kr.trip.com/moments/detail/seongnam-121856-121058702/',  'content': '사진찍으면서 실내데이트 즐기고 싶다면 주목📢 판교역에서 꼭 가봐야할 아기자기 귀여운 핫플레이스 카카오 프렌즈 캐릭터들의 포토존이
(...중략...)
🔖인스타에서 핫하다는 목욕하는 춘식이◡̈\n지금 카카오 프랜즈들의 대세는 춘식이인가봐요.\n 🔖소주디스펜서죠르디 39,000원\n🔖전동와인오프너치얼스라이언\n23,000원\n🔖라이언크리미맥주거품기 29,000원\n🔖턴테이블 스피커\n55,000원\n여긴 스텐드들의 집합?💡\n캬아 춘식이 피큐어예요!!!\n'}]</code></pre>
</section>
<section id="문서-기반-문서-검색-도구-retriever" class="level3" data-number="1.1.2">
<h3 data-number="1.1.2" class="anchored" data-anchor-id="문서-기반-문서-검색-도구-retriever"><span class="header-section-number">1.1.2</span> 문서 기반 문서 검색 도구: Retriever</h3>
<ul>
<li>데이터에 대해 조회를 수행할 retriever도 생성한다.</li>
<li>retriever는 자유롭게 커스텀 기능을 추가/삭제할 수 있지만 반드시 마지막 값은 retriever type이어야한다</li>
</ul>
<p><strong>실습에 활용한 문서</strong></p>
<p>소프트웨어정책연구소(SPRi) - 2023년 12월호</p>
<ul>
<li>저자: 유재흥(AI정책연구실 책임연구원), 이지수(AI정책연구실 위촉연구원)</li>
<li>링크: https://spri.kr/posts/view/23669</li>
<li>파일명: <code>SPRI_AI_Brief_2023년12월호_F.pdf</code></li>
</ul>
<p><em>실습을 위해 다운로드 받은 파일을 <code>data</code> 폴더로 복사해 주기 바란다</em></p>
<p>이 코드는 웹 기반 문서 로더, 문서 분할기, 벡터 저장소, 그리고 OpenAI 임베딩을 사용하여 문서 검색 시스템을 구축한다.</p>
<p>여기서는 PDF 문서를 <code>FAISS</code> DB 에 저장하고 조회하는 retriever 를 생성한다.</p>
<div id="2cd0a457" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="im">from</span> langchain.text_splitter <span class="im">import</span> RecursiveCharacterTextSplitter</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="im">from</span> langchain_community.vectorstores <span class="im">import</span> FAISS</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="im">from</span> langchain_openai <span class="im">import</span> OpenAIEmbeddings</span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="im">from</span> langchain.document_loaders <span class="im">import</span> PyPDFLoader</span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co"># PDF 파일 로드. 파일의 경로 입력</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>loader <span class="op">=</span> PyPDFLoader(<span class="st">"data/SPRI_AI_Brief_2023년12월호_F.pdf"</span>)</span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="co"># 텍스트 분할기를 사용하여 문서를 분할한다.</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>text_splitter <span class="op">=</span> RecursiveCharacterTextSplitter(chunk_size<span class="op">=</span><span class="dv">1000</span>, chunk_overlap<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="co"># 문서를 로드하고 분할한다.</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>split_docs <span class="op">=</span> loader.load_and_split(text_splitter)</span>
<span id="cb6-14"><a href="#cb6-14"></a></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="co"># VectorStore를 생성한다.</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>vector <span class="op">=</span> FAISS.from_documents(split_docs, OpenAIEmbeddings())</span>
<span id="cb6-17"><a href="#cb6-17"></a></span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="co"># Retriever를 생성한다. (반드시 마지막 값은 retriever type이어야한다)</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>retriever <span class="op">=</span> vector.as_retriever()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>이 함수는 <code>retriever</code> 객체의 <code>invoke()</code> 를 사용하여 사용자의 질문에 대한 가장 <strong>관련성 높은 문서</strong> 를 찾는 데 사용된다.</p>
<div id="e5c950aa" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># 문서에서 관련성 높은 문서를 가져옵니다.</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>retriever.invoke(<span class="st">"삼성전자가 개발한 생성형 AI 관련 내용을 문서에서 찾아줘"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>[Document(metadata={'source': 'data/SPRI_AI_Brief_2023년12월호_F.pdf', 'page': 12}, page_content='SPRi AI Brief |  \n2023-12 월호\n10삼성전자 , 자체 개발 생성 AI ‘삼성 가우스 ’ 공개\nn삼성전자가 온디바이스에서 작동 가능하며 언어, 코드, 이미지의 3개 모델로 구성된 자체 개발 생성 \nAI 모델 ‘삼성 가우스 ’를 공개\nn삼성전자는 삼성 가우스를 다양한 제품에 단계적으로 탑재할 계획으로 , 온디바이스 작동이 가능한 \n삼성 가우스는 외부로 사용자 정보가 유출될 위험이 없다는 장점을 보유KEY Contents\n£언어, 코드, 이미지의 3개 모델로 구성된 삼성 가우스 ,
(...중략...)
하는데 머문다면 , 에이전트는 사용자의 여행 \n패턴을 분석해 여행지를 제안하고 관심사에 따른 활동을 추천하며 선호하는 스타일의 레스토랑 예약도 가능  \n£AI 에이전트가 의료와 교육, 생산성 , 엔터테인먼트 ·쇼핑 영역의 서비스 대중화를 주도할 것\nn에이전트로 인해 주목할 만한 변화는 고비용 서비스의 대중화로 특히 △의료 △교육 △생산성 △\n엔터테인먼트 ·쇼핑의 4개 영역에서 대규모 변화 예상')]</code></pre>
<p>이제 검색을 수행할 인덱스를 채웠으므로, 이를 에이전트가 제대로 사용할 수 있는 도구로 쉽게 변환할 수 있다.</p>
<p><code>create_retriever_tool</code> 함수로 <code>retriever</code> 를 도구로 변환한다.</p>
<div id="db5521f9" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="im">from</span> langchain.tools.retriever <span class="im">import</span> create_retriever_tool</span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a>retriever_tool <span class="op">=</span> create_retriever_tool(</span>
<span id="cb9-4"><a href="#cb9-4"></a>    retriever,</span>
<span id="cb9-5"><a href="#cb9-5"></a>    name<span class="op">=</span><span class="st">"pdf_search"</span>,  <span class="co"># 도구의 이름을 입력한다. 도구 인지가 잘 되도록 하는 역할을 함</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>    description<span class="op">=</span><span class="st">"use this tool to search information from the PDF document"</span>,  <span class="co"># 도구에 대한 설명을 자세히 기입해야 한다!!</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="agent-가-사용할-도구-목록-정의" class="level3" data-number="1.1.3">
<h3 data-number="1.1.3" class="anchored" data-anchor-id="agent-가-사용할-도구-목록-정의"><span class="header-section-number">1.1.3</span> Agent 가 사용할 도구 목록 정의</h3>
<p>이제 두 가지를 모두 만들었으므로, Agent 가 사용할 도구 목록을 만들 수 있다.</p>
<p><code>tools</code> 리스트는 <code>search</code>와 <code>retriever_tool</code>을 포함한다.</p>
<div id="b7c2a804" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># tools 리스트에 search와 retriever_tool을 추가한다.</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>tools <span class="op">=</span> [search, retriever_tool]</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="agent-생성" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="agent-생성"><span class="header-section-number">1.2</span> Agent 생성</h2>
<p>이제 도구를 정의했으니 에이전트를 생성할 수 있다.</p>
<p>먼저, Agent 가 활용할 LLM을 정의하고, Agent 가 참고할 Prompt 를 정의한다.</p>
<p><strong>참고</strong> - 멀티턴 대화를 지원하지 않는다면 “chat_history” 를 제거해도 좋다.</p>
<div id="524ba5dd" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="im">from</span> langchain_openai <span class="im">import</span> ChatOpenAI</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="im">from</span> langchain_core.prompts <span class="im">import</span> ChatPromptTemplate</span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co"># LLM 정의</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>llm <span class="op">=</span> ChatOpenAI(model<span class="op">=</span><span class="st">"gpt-4o-mini"</span>, temperature<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="co"># Prompt 정의</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>prompt <span class="op">=</span> ChatPromptTemplate.from_messages(</span>
<span id="cb11-9"><a href="#cb11-9"></a>    [</span>
<span id="cb11-10"><a href="#cb11-10"></a>        (</span>
<span id="cb11-11"><a href="#cb11-11"></a>            <span class="st">"system"</span>,</span>
<span id="cb11-12"><a href="#cb11-12"></a>            <span class="st">"You are a helpful assistant. "</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>            <span class="st">"Make sure to use the `pdf_search` tool for searching information from the PDF document. "</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>            <span class="st">"If you can't find the information from the PDF document, use the `search` tool for searching information from the web."</span>,</span>
<span id="cb11-15"><a href="#cb11-15"></a>        ),</span>
<span id="cb11-16"><a href="#cb11-16"></a>        (<span class="st">"placeholder"</span>, <span class="st">"</span><span class="sc">{chat_history}</span><span class="st">"</span>), <span class="co"># 추후에 추가될 multi-turn 기능을 위해 채팅 기록이 저장되어야함.</span></span>
<span id="cb11-17"><a href="#cb11-17"></a>        (<span class="st">"human"</span>, <span class="st">"</span><span class="sc">{input}</span><span class="st">"</span>),</span>
<span id="cb11-18"><a href="#cb11-18"></a>        (<span class="st">"placeholder"</span>, <span class="st">"</span><span class="sc">{agent_scratchpad}</span><span class="st">"</span>),</span>
<span id="cb11-19"><a href="#cb11-19"></a>    ]</span>
<span id="cb11-20"><a href="#cb11-20"></a>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>다음으로는 Tool Calling Agent 를 생성한다.</p>
<div id="3762d4f8" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="im">from</span> langchain.agents <span class="im">import</span> create_tool_calling_agent</span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="co"># tool calling agent 생성</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>agent <span class="op">=</span> create_tool_calling_agent(llm, tools, prompt)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>마지막으로, 생성한 <code>agent</code> 를 실행하는 <code>AgentExecutor</code> 를 생성한다.</p>
<p><strong>참고</strong></p>
<ul>
<li><code>verbose=False</code> 로 설정하여 중간 단계 출력을 생략하였다.</li>
</ul>
<div id="73890071" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="im">from</span> langchain.agents <span class="im">import</span> AgentExecutor</span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="co"># AgentExecutor 생성</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>agent_executor <span class="op">=</span> AgentExecutor(agent<span class="op">=</span>agent, tools<span class="op">=</span>tools, verbose<span class="op">=</span><span class="va">False</span>) <span class="co">#  verbose=True: 중간단계 출력</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="에이전트-실행하기" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="에이전트-실행하기"><span class="header-section-number">1.3</span> 에이전트 실행하기</h2>
<p>이제 몇 가지 질의에 대해 에이전트를 실행할 수 있다!</p>
<p>현재 이러한 모든 질의는 <strong>상태(Stateless) 가 없는</strong> 질의다(이전 상호작용을 기억하지 않는다).</p>
<p><code>agent_executor</code> 객체의 <code>invoke</code> 메소드는 딕셔너리 형태의 인자를 받아 처리한다. 이 예제에서는 <code>input</code> 키에 <code>hi!</code> 값을 할당한 딕셔너리를 인자로 전달하고 있다. 이는 일반적으로 AI 에이전트, 함수 실행기, 또는 명령 처리기 등의 객체에서 입력을 처리하기 위해 사용된다.</p>
<div id="92bf1590" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="im">from</span> langchain_teddynote.messages <span class="im">import</span> AgentStreamParser</span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="co"># 각 단계별 출력을 위한 파서 생성</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>agent_stream_parser <span class="op">=</span> AgentStreamParser()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="7d39e317" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="co"># 질의에 대한 답변을 스트리밍으로 출력 요청</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>result <span class="op">=</span> agent_executor.stream(</span>
<span id="cb15-3"><a href="#cb15-3"></a>    {<span class="st">"input"</span>: <span class="st">"2024년 프로야구 플레이오프 진출한 5개 팀을 검색하여 알려주세요."</span>}</span>
<span id="cb15-4"><a href="#cb15-4"></a>)</span>
<span id="cb15-5"><a href="#cb15-5"></a></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="cf">for</span> step <span class="kw">in</span> result:</span>
<span id="cb15-7"><a href="#cb15-7"></a>    <span class="co"># 중간 단계를 parser 를 사용하여 단계별로 출력</span></span>
<span id="cb15-8"><a href="#cb15-8"></a>    agent_stream_parser.process_agent_steps(step)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>[도구 호출]
Tool: tavily_search_results_json
query: 2024년 프로야구 플레이오프 진출 팀
Log: 
Invoking: `tavily_search_results_json` with `{'query': '2024년 프로야구 플레이오프 진출 팀'}`



[관찰 내용]
Observation: [{'url': 'https://www.yna.co.kr/view/GYH20241003000600044', 'content': '4 days ago · ... 팀의 뒤집기 마법을 선사하고 준플레이오프(준PO·5전 3승제)에 진출했다. kt는 3일 서울 잠실구장에서 열린 2024 신한 SOL뱅크 KBO 포스트시즌 와일드\xa0...'},
(...중략...)
{'url': 'https://namu.wiki/w/KBO%20%ED%94%8C%EB%A0%88%EC%9D%B4%EC%98%A4%ED%94%84/2024%EB%85%84', 'content': '2024 신한 SOL Bank KBO 리그 페넌트레이스 2위 삼성 라이온즈와 준플레이오프 승리팀이 맞붙는 시리즈.'}]

[도구 호출]
Tool: tavily_search_results_json
query: 2024 KBO 포스트시즌 진출 팀
Log: 
Invoking: `tavily_search_results_json` with `{'query': '2024 KBO 포스트시즌 진출 팀'}`

[관찰 내용]
Observation: [{'url': 'https://www.yna.co.kr/view/GYH20241003000600044', 'content': '4 days ago · ... 팀의 뒤집기 마법을 선사하고 준플레이오프(준PO·5전 3승제)에 진출했다. kt는 3일 서울 잠실구장에서 열린 2024 신한 SOL뱅크 KBO 포스트시즌 와일드\xa0...'}, 
(...중략...)
{'url': 'http://m.monthly.chosun.com/client/Mdaily/daily_view.asp?Idx=20426&amp;Newsnumb=20241020426', 'content': '5 days ago · 진출팀은 ▲KIA 타이거즈 ▲삼성 라이온즈 ▲LG 트윈스 ▲두산 베어스 ▲kt wiz다. 2일 두산과 KT는 서울 잠실구장에서 와일드카드 결정전을 치른다.'}]

[최종 답변]
2024년 KBO 프로야구 포스트시즌에 진출한 팀들은 다음과 같습니다:

1. KIA 타이거즈
2. 삼성 라이온즈
3. LG 트윈스
4. 두산 베어스
5. KT 위즈

이 팀들은 포스트시즌에서 경쟁하게 됩니다.</code></pre>
<p><code>agent_executor</code> 객체의 <code>invoke</code> 메소드를 사용하여, 질문을 입력으로 제공한다.</p>
<div id="309be468" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="co"># 질의에 대한 답변을 스트리밍으로 출력 요청</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>result <span class="op">=</span> agent_executor.stream(</span>
<span id="cb17-3"><a href="#cb17-3"></a>    {<span class="st">"input"</span>: <span class="st">"삼성전자가 자체 개발한 생성형 AI 관련된 정보를 문서에서 찾아주세요."</span>}</span>
<span id="cb17-4"><a href="#cb17-4"></a>)</span>
<span id="cb17-5"><a href="#cb17-5"></a></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="cf">for</span> step <span class="kw">in</span> result:</span>
<span id="cb17-7"><a href="#cb17-7"></a>    <span class="co"># 중간 단계를 parser 를 사용하여 단계별로 출력</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>    agent_stream_parser.process_agent_steps(step)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>[도구 호출]
Tool: pdf_search
query: 삼성전자 생성형 AI
Log: 
Invoking: `pdf_search` with `{'query': '삼성전자 생성형 AI'}`

[관찰 내용]
Observation: SPRi AI Brief |  
2023-12 월호
10삼성전자 , 자체 개발 생성 AI ‘삼성 가우스 ’ 공개
n삼성전자가 온디바이스에서 작동 가능하며 언어, 코드, 이미지의 3개 모델로 구성된 자체 개발 생성 
AI 모델 ‘삼성 가우스 ’를 공개
(...중략...)
n판결문은 또한 생성 AI 모델 훈련에 사용된 모든 이미지에 저작권이 있다거나 , 생성 AI로 만든 
이미지가 저작물을 이용해 훈련되었으므로 저작물의 파생 이미지라는 주장은 개연성이  부족하다고  
지적

[최종 답변]
삼성전자가 자체 개발한 생성형 AI 모델 '삼성 가우스'에 대한 정보는 다음과 같습니다:

1. **모델 구성**: 삼성 가우스는 언어, 코드, 이미지의 3개 모델로 구성되어 있습니다. 
   - **언어 모델**: 메일 작성, 문서 요약, 번역 업무 등을 지원합니다.
   - **코드 모델**: AI 코딩 어시스턴트 '코드아이(code.i)'를 통해 대화형 인터페이스로 서비스를 제공하며, 사내 소프트웨어 개발에 최적화되어 있습니다.
   - **이미지 모델**: 창의적인 이미지를 생성하고 기존 이미지를 수정할 수 있으며, 저해상도 이미지를 고해상도로 변환하는 기능도 지원합니다.

2. **온디바이스 작동**: 삼성 가우스는 온디바이스에서 작동하도록 설계되어 있어, 사용자 정보가 외부로 유출될 위험이 없습니다. 이는 개인정보 보호 측면에서 큰 장점으로 작용합니다.

3. **출시 및 계획**: 삼성전자는 2023년 11월 8일 '삼성 AI 포럼 2023'에서 삼성 가우스를 최초 공개하였으며, 다양한 제품에 단계적으로 탑재할 계획입니다.

4. **기술 트렌드**: IT 전문지 테크리퍼블릭에 따르면, 온디바이스 AI가 주요 기술 트렌드로 부상하고 있으며, 2024년부터 삼성 가우스를 탑재한 스마트폰이 메타의 라마(Llama)2를 탑재한 퀄컴 기기 및 구글 어시스턴트를 적용한 구글 픽셀과 경쟁할 것으로 예상됩니다.

이 정보는 삼성전자가 AI 기술을 통해 사용자 경험을 향상시키고, 개인정보 보호를 강화하려는 노력을 보여줍니다.</code></pre>
</section>
<section id="이전-대화내용-기억하는-agent" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="이전-대화내용-기억하는-agent"><span class="header-section-number">1.4</span> 이전 대화내용 기억하는 Agent</h2>
<p>이전의 대화내용을 기억하기 위해서는 <code>RunnableWithMessageHistory</code> 를 사용하여 <code>AgentExecutor</code> 를 감싼다.</p>
<p><code>RunnableWithMessageHistory</code> 에 대한 자세한 내용은 아래 링크를 참고한다.</p>
<p><strong>참고</strong> - <a href="https://wikidocs.net/254682">RunnableWithMessageHistory</a></p>
<div id="feef3f23" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="im">from</span> langchain_community.chat_message_histories <span class="im">import</span> ChatMessageHistory</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="im">from</span> langchain_core.runnables.history <span class="im">import</span> RunnableWithMessageHistory</span>
<span id="cb19-3"><a href="#cb19-3"></a></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="co"># session_id 를 저장할 딕셔너리 생성</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>store <span class="op">=</span> {}</span>
<span id="cb19-6"><a href="#cb19-6"></a></span>
<span id="cb19-7"><a href="#cb19-7"></a></span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="co"># session_id 를 기반으로 세션 기록을 가져오는 함수</span></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="kw">def</span> get_session_history(session_ids):</span>
<span id="cb19-10"><a href="#cb19-10"></a>    <span class="cf">if</span> session_ids <span class="kw">not</span> <span class="kw">in</span> store:  <span class="co"># session_id 가 store에 없는 경우</span></span>
<span id="cb19-11"><a href="#cb19-11"></a>        <span class="co"># 새로운 ChatMessageHistory 객체를 생성하여 store에 저장</span></span>
<span id="cb19-12"><a href="#cb19-12"></a>        store[session_ids] <span class="op">=</span> ChatMessageHistory()</span>
<span id="cb19-13"><a href="#cb19-13"></a>    <span class="cf">return</span> store[session_ids]  <span class="co"># 해당 세션 ID에 대한 세션 기록 반환</span></span>
<span id="cb19-14"><a href="#cb19-14"></a></span>
<span id="cb19-15"><a href="#cb19-15"></a></span>
<span id="cb19-16"><a href="#cb19-16"></a><span class="co"># 채팅 메시지 기록이 추가된 에이전트를 생성한다.</span></span>
<span id="cb19-17"><a href="#cb19-17"></a>agent_with_chat_history <span class="op">=</span> RunnableWithMessageHistory(</span>
<span id="cb19-18"><a href="#cb19-18"></a>    agent_executor,</span>
<span id="cb19-19"><a href="#cb19-19"></a>    <span class="co"># 대화 session_id</span></span>
<span id="cb19-20"><a href="#cb19-20"></a>    get_session_history,</span>
<span id="cb19-21"><a href="#cb19-21"></a>    <span class="co"># 프롬프트의 질문이 입력되는 key: "input"</span></span>
<span id="cb19-22"><a href="#cb19-22"></a>    input_messages_key<span class="op">=</span><span class="st">"input"</span>,</span>
<span id="cb19-23"><a href="#cb19-23"></a>    <span class="co"># 프롬프트의 메시지가 입력되는 key: "chat_history"</span></span>
<span id="cb19-24"><a href="#cb19-24"></a>    history_messages_key<span class="op">=</span><span class="st">"chat_history"</span>,</span>
<span id="cb19-25"><a href="#cb19-25"></a>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="16129b2b" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a><span class="co"># 질의에 대한 답변을 스트리밍으로 출력 요청</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>response <span class="op">=</span> agent_with_chat_history.stream(</span>
<span id="cb20-3"><a href="#cb20-3"></a>    {<span class="st">"input"</span>: <span class="st">"삼성전자가 개발한 생성형 AI 관련된 정보를 문서에서 찾아주세요."</span>},</span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="co"># session_id 설정</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>    config<span class="op">=</span>{<span class="st">"configurable"</span>: {<span class="st">"session_id"</span>: <span class="st">"abc123"</span>}},</span>
<span id="cb20-6"><a href="#cb20-6"></a>)</span>
<span id="cb20-7"><a href="#cb20-7"></a></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="co"># 출력 확인</span></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="cf">for</span> step <span class="kw">in</span> response:</span>
<span id="cb20-10"><a href="#cb20-10"></a>    agent_stream_parser.process_agent_steps(step)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>[도구 호출]
Tool: pdf_search
query: 삼성전자 생성형 AI
Log: 
Invoking: `pdf_search` with `{'query': '삼성전자 생성형 AI'}`

[관찰 내용]
Observation: SPRi AI Brief |  
2023-12 월호
10삼성전자 , 자체 개발 생성 AI ‘삼성 가우스 ’ 공개
n삼성전자가 온디바이스에서 작동 가능하며 언어, 코드, 이미지의 3개 모델로 구성된 자체 개발 생성 
AI 모델 ‘삼성 가우스 ’를 공개
(...중략...)
∙판결문은 소송을 제기한 캘리 맥커넌과 칼라 오르티즈가 미국 저작권청에 예술 작품에 대한 저작권을 
제출하지 않았다는 점을 지적했으며 , 사라 앤더슨은 고소장에 인용된 수백 개의 작품 중 16개 작품에 
대해서만 저작권을 보유
n판결문은 또한 생성 AI 모델 훈련에 사용된 모든 이미지에 저작권이 있다거나 , 생성 AI로 만든 
이미지가 저작물을 이용해 훈련되었으므로 저작물의 파생 이미지라는 주장은 개연성이  부족하다고  
지적

[최종 답변]
삼성전자가 개발한 생성형 AI에 대한 정보는 다음과 같습니다:

1. **삼성 가우스**: 삼성전자는 2023년 11월 8일 '삼성 AI 포럼 2023'에서 자체 개발한 생성형 AI 모델인 '삼성 가우스'를 공개했습니다. 이 모델은 언어, 코드, 이미지의 3개 모델로 구성되어 있으며, 온디바이스에서 작동할 수 있도록 설계되었습니다. 이는 사용자 정보가 외부로 유출될 위험이 없다는 장점을 가지고 있습니다.

2. **모델 구성**:
   - **언어 모델**: 클라우드와 온디바이스에서 다양한 모델로 구성되어 있으며, 메일 작성, 문서 요약, 번역 등의 작업을 지원합니다.
   - **코드 모델**: AI 코딩 어시스턴트인 '코드아이 (code.i)'를 통해 대화형 인터페이스로 서비스를 제공하며, 사내 소프트웨어 개발에 최적화되어 있습니다.
   - **이미지 모델**: 창의적인 이미지를 생성하고 기존 이미지를 수정할 수 있으며, 저해상도 이미지를 고해상도로 변환하는 기능도 지원합니다.

3. **향후 계획**: 삼성전자는 삼성 가우스를 다양한 제품에 단계적으로 탑재할 계획이며, 온디바이스 AI 기술을 활용한 여러 기능을 소개하고 있습니다. 이 기술은 2024년부터 삼성 스마트폰에 탑재될 예정이며, 메타의 라마(Llama)2를 탑재한 퀄컴 기기 및 구글 어시스턴트를 적용한 구글 픽셀(Pixel)과 경쟁할 것으로 예상됩니다.

이 정보는 삼성전자가 AI 기술을 통해 사용자 경험을 향상시키고, 데이터 보안을 강화하려는 노력을 보여줍니다.</code></pre>
<div id="3bc8906b" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a>response <span class="op">=</span> agent_with_chat_history.stream(</span>
<span id="cb22-2"><a href="#cb22-2"></a>    {<span class="st">"input"</span>: <span class="st">"이전의 답변을 영어로 번역한다."</span>},</span>
<span id="cb22-3"><a href="#cb22-3"></a>    <span class="co"># session_id 설정</span></span>
<span id="cb22-4"><a href="#cb22-4"></a>    config<span class="op">=</span>{<span class="st">"configurable"</span>: {<span class="st">"session_id"</span>: <span class="st">"abc123"</span>}},</span>
<span id="cb22-5"><a href="#cb22-5"></a>)</span>
<span id="cb22-6"><a href="#cb22-6"></a></span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="co"># 출력 확인</span></span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="cf">for</span> step <span class="kw">in</span> response:</span>
<span id="cb22-9"><a href="#cb22-9"></a>    agent_stream_parser.process_agent_steps(step)</span>
<span id="cb22-10"><a href="#cb22-10"></a></span>
<span id="cb22-11"><a href="#cb22-11"></a><span class="co"># 이경우 도구 호출이 필요없기 때문에 도구 호출 하지 않음</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>[최종 답변]
Here is the translation of the previous response into English:

1. **Samsung Gauss**: On November 8, 2023, Samsung Electronics unveiled its generative AI model called 'Samsung Gauss' at the 'Samsung AI Forum 2023'. This model consists of three components: language, code, and image models, and is designed to operate on-device. This has the advantage of ensuring that user information is not at risk of being leaked externally.

2. **Model Composition**:
   - **Language Model**: Composed of various models for cloud and on-device use, it supports tasks such as email writing, document summarization, and translation.
   - **Code Model**: Through the AI coding assistant 'code.i', it provides services via an interactive interface, optimized for in-house software development.
   - **Image Model**: Capable of generating creative images and modifying existing ones, it also supports converting low-resolution images to high-resolution.

3. **Future Plans**: Samsung Electronics plans to gradually integrate Samsung Gauss into various products and introduce multiple features utilizing on-device AI technology. This technology is expected to be incorporated into Samsung smartphones starting in 2024 and is anticipated to compete with Qualcomm devices equipped with Meta's Llama 2 and Google Pixel devices using Google Assistant.

This information demonstrates Samsung's efforts to enhance user experience and strengthen data security through AI technology.</code></pre>
</section>
<section id="agent-템플릿" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="agent-템플릿"><span class="header-section-number">1.5</span> Agent 템플릿</h2>
<p>다음은 전체 템플릿 코드이다.</p>
<div id="0f506d47" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1"></a><span class="co"># 필요한 모듈 import</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="im">from</span> langchain_core.prompts <span class="im">import</span> ChatPromptTemplate</span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="im">from</span> langchain_community.tools.tavily_search <span class="im">import</span> TavilySearchResults</span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="im">from</span> langchain_community.vectorstores <span class="im">import</span> FAISS</span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="im">from</span> langchain_community.chat_message_histories <span class="im">import</span> ChatMessageHistory</span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="im">from</span> langchain.text_splitter <span class="im">import</span> RecursiveCharacterTextSplitter</span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="im">from</span> langchain_openai <span class="im">import</span> OpenAIEmbeddings, ChatOpenAI</span>
<span id="cb24-8"><a href="#cb24-8"></a><span class="im">from</span> langchain.document_loaders <span class="im">import</span> PyMuPDFLoader</span>
<span id="cb24-9"><a href="#cb24-9"></a><span class="im">from</span> langchain.tools.retriever <span class="im">import</span> create_retriever_tool</span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="im">from</span> langchain.agents <span class="im">import</span> create_tool_calling_agent, AgentExecutor</span>
<span id="cb24-11"><a href="#cb24-11"></a><span class="im">from</span> langchain_core.runnables.history <span class="im">import</span> RunnableWithMessageHistory</span>
<span id="cb24-12"><a href="#cb24-12"></a><span class="im">from</span> langchain_teddynote.messages <span class="im">import</span> AgentStreamParser</span>
<span id="cb24-13"><a href="#cb24-13"></a></span>
<span id="cb24-14"><a href="#cb24-14"></a><span class="co">########## 1. 도구를 정의합니다 ##########</span></span>
<span id="cb24-15"><a href="#cb24-15"></a></span>
<span id="cb24-16"><a href="#cb24-16"></a><span class="co">### 1-1. Search 도구 </span><span class="al">###</span></span>
<span id="cb24-17"><a href="#cb24-17"></a><span class="co"># TavilySearchResults 클래스의 인스턴스를 생성합니다</span></span>
<span id="cb24-18"><a href="#cb24-18"></a><span class="co"># k=6은 검색 결과를 6개까지 가져오겠다는 의미입니다</span></span>
<span id="cb24-19"><a href="#cb24-19"></a>search <span class="op">=</span> TavilySearchResults(k<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb24-20"><a href="#cb24-20"></a></span>
<span id="cb24-21"><a href="#cb24-21"></a><span class="co">### 1-2. PDF 문서 검색 도구 (Retriever) </span><span class="al">###</span></span>
<span id="cb24-22"><a href="#cb24-22"></a><span class="co"># PDF 파일 로드. 파일의 경로 입력</span></span>
<span id="cb24-23"><a href="#cb24-23"></a>loader <span class="op">=</span> PyMuPDFLoader(<span class="st">"data/SPRI_AI_Brief_2023년12월호_F.pdf"</span>)</span>
<span id="cb24-24"><a href="#cb24-24"></a></span>
<span id="cb24-25"><a href="#cb24-25"></a><span class="co"># 텍스트 분할기를 사용하여 문서를 분할합니다.</span></span>
<span id="cb24-26"><a href="#cb24-26"></a>text_splitter <span class="op">=</span> RecursiveCharacterTextSplitter(chunk_size<span class="op">=</span><span class="dv">1000</span>, chunk_overlap<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb24-27"><a href="#cb24-27"></a></span>
<span id="cb24-28"><a href="#cb24-28"></a><span class="co"># 문서를 로드하고 분할합니다.</span></span>
<span id="cb24-29"><a href="#cb24-29"></a>split_docs <span class="op">=</span> loader.load_and_split(text_splitter)</span>
<span id="cb24-30"><a href="#cb24-30"></a></span>
<span id="cb24-31"><a href="#cb24-31"></a><span class="co"># VectorStore를 생성합니다.</span></span>
<span id="cb24-32"><a href="#cb24-32"></a>vector <span class="op">=</span> FAISS.from_documents(split_docs, OpenAIEmbeddings())</span>
<span id="cb24-33"><a href="#cb24-33"></a></span>
<span id="cb24-34"><a href="#cb24-34"></a><span class="co"># Retriever를 생성합니다.</span></span>
<span id="cb24-35"><a href="#cb24-35"></a>retriever <span class="op">=</span> vector.as_retriever()</span>
<span id="cb24-36"><a href="#cb24-36"></a></span>
<span id="cb24-37"><a href="#cb24-37"></a>retriever_tool <span class="op">=</span> create_retriever_tool(</span>
<span id="cb24-38"><a href="#cb24-38"></a>    retriever,</span>
<span id="cb24-39"><a href="#cb24-39"></a>    name<span class="op">=</span><span class="st">"pdf_search"</span>,  <span class="co"># 도구의 이름을 입력합니다.</span></span>
<span id="cb24-40"><a href="#cb24-40"></a>    description<span class="op">=</span><span class="st">"use this tool to search information from the PDF document"</span>,  <span class="co"># 도구에 대한 설명을 자세히 기입해야 합니다!!</span></span>
<span id="cb24-41"><a href="#cb24-41"></a>)</span>
<span id="cb24-42"><a href="#cb24-42"></a></span>
<span id="cb24-43"><a href="#cb24-43"></a><span class="co">### 1-3. tools 리스트에 도구 목록을 추가합니다 </span><span class="al">###</span></span>
<span id="cb24-44"><a href="#cb24-44"></a><span class="co"># tools 리스트에 search와 retriever_tool을 추가합니다.</span></span>
<span id="cb24-45"><a href="#cb24-45"></a>tools <span class="op">=</span> [search, retriever_tool]</span>
<span id="cb24-46"><a href="#cb24-46"></a></span>
<span id="cb24-47"><a href="#cb24-47"></a><span class="co">########## 2. LLM 을 정의합니다 ##########</span></span>
<span id="cb24-48"><a href="#cb24-48"></a><span class="co"># LLM 모델을 생성합니다.</span></span>
<span id="cb24-49"><a href="#cb24-49"></a>llm <span class="op">=</span> ChatOpenAI(model<span class="op">=</span><span class="st">"gpt-4o"</span>, temperature<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb24-50"><a href="#cb24-50"></a></span>
<span id="cb24-51"><a href="#cb24-51"></a><span class="co">########## 3. Prompt 를 정의합니다 ##########</span></span>
<span id="cb24-52"><a href="#cb24-52"></a></span>
<span id="cb24-53"><a href="#cb24-53"></a><span class="co"># Prompt 를 정의합니다 - 이 부분을 수정할 수 있습니다!</span></span>
<span id="cb24-54"><a href="#cb24-54"></a><span class="co"># Prompt 정의</span></span>
<span id="cb24-55"><a href="#cb24-55"></a>prompt <span class="op">=</span> ChatPromptTemplate.from_messages(</span>
<span id="cb24-56"><a href="#cb24-56"></a>    [</span>
<span id="cb24-57"><a href="#cb24-57"></a>        (</span>
<span id="cb24-58"><a href="#cb24-58"></a>            <span class="st">"system"</span>,</span>
<span id="cb24-59"><a href="#cb24-59"></a>            <span class="st">"You are a helpful assistant. "</span></span>
<span id="cb24-60"><a href="#cb24-60"></a>            <span class="st">"Make sure to use the `pdf_search` tool for searching information from the PDF document. "</span></span>
<span id="cb24-61"><a href="#cb24-61"></a>            <span class="st">"If you can't find the information from the PDF document, use the `search` tool for searching information from the web."</span>,</span>
<span id="cb24-62"><a href="#cb24-62"></a>        ),</span>
<span id="cb24-63"><a href="#cb24-63"></a>        (<span class="st">"placeholder"</span>, <span class="st">"</span><span class="sc">{chat_history}</span><span class="st">"</span>),</span>
<span id="cb24-64"><a href="#cb24-64"></a>        (<span class="st">"human"</span>, <span class="st">"</span><span class="sc">{input}</span><span class="st">"</span>),</span>
<span id="cb24-65"><a href="#cb24-65"></a>        (<span class="st">"placeholder"</span>, <span class="st">"</span><span class="sc">{agent_scratchpad}</span><span class="st">"</span>),</span>
<span id="cb24-66"><a href="#cb24-66"></a>    ]</span>
<span id="cb24-67"><a href="#cb24-67"></a>)</span>
<span id="cb24-68"><a href="#cb24-68"></a></span>
<span id="cb24-69"><a href="#cb24-69"></a><span class="co">########## 4. Agent 를 정의합니다 ##########</span></span>
<span id="cb24-70"><a href="#cb24-70"></a></span>
<span id="cb24-71"><a href="#cb24-71"></a><span class="co"># 에이전트를 생성합니다.</span></span>
<span id="cb24-72"><a href="#cb24-72"></a><span class="co"># llm, tools, prompt를 인자로 사용합니다.</span></span>
<span id="cb24-73"><a href="#cb24-73"></a>agent <span class="op">=</span> create_tool_calling_agent(llm, tools, prompt)</span>
<span id="cb24-74"><a href="#cb24-74"></a></span>
<span id="cb24-75"><a href="#cb24-75"></a><span class="co">########## 5. AgentExecutor 를 정의합니다 ##########</span></span>
<span id="cb24-76"><a href="#cb24-76"></a></span>
<span id="cb24-77"><a href="#cb24-77"></a><span class="co"># AgentExecutor 클래스를 사용하여 agent와 tools를 설정하고, 상세한 로그를 출력하도록 verbose를 True로 설정합니다.</span></span>
<span id="cb24-78"><a href="#cb24-78"></a>agent_executor <span class="op">=</span> AgentExecutor(agent<span class="op">=</span>agent, tools<span class="op">=</span>tools, verbose<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb24-79"><a href="#cb24-79"></a></span>
<span id="cb24-80"><a href="#cb24-80"></a><span class="co">########## 6. 채팅 기록을 수행하는 메모리를 추가합니다. ##########</span></span>
<span id="cb24-81"><a href="#cb24-81"></a></span>
<span id="cb24-82"><a href="#cb24-82"></a><span class="co"># session_id 를 저장할 딕셔너리 생성</span></span>
<span id="cb24-83"><a href="#cb24-83"></a>store <span class="op">=</span> {}</span>
<span id="cb24-84"><a href="#cb24-84"></a></span>
<span id="cb24-85"><a href="#cb24-85"></a></span>
<span id="cb24-86"><a href="#cb24-86"></a><span class="co"># session_id 를 기반으로 세션 기록을 가져오는 함수</span></span>
<span id="cb24-87"><a href="#cb24-87"></a><span class="kw">def</span> get_session_history(session_ids):</span>
<span id="cb24-88"><a href="#cb24-88"></a>    <span class="cf">if</span> session_ids <span class="kw">not</span> <span class="kw">in</span> store:  <span class="co"># session_id 가 store에 없는 경우</span></span>
<span id="cb24-89"><a href="#cb24-89"></a>        <span class="co"># 새로운 ChatMessageHistory 객체를 생성하여 store에 저장</span></span>
<span id="cb24-90"><a href="#cb24-90"></a>        store[session_ids] <span class="op">=</span> ChatMessageHistory()</span>
<span id="cb24-91"><a href="#cb24-91"></a>    <span class="cf">return</span> store[session_ids]  <span class="co"># 해당 세션 ID에 대한 세션 기록 반환</span></span>
<span id="cb24-92"><a href="#cb24-92"></a></span>
<span id="cb24-93"><a href="#cb24-93"></a></span>
<span id="cb24-94"><a href="#cb24-94"></a><span class="co"># 채팅 메시지 기록이 추가된 에이전트를 생성한다.</span></span>
<span id="cb24-95"><a href="#cb24-95"></a>agent_with_chat_history <span class="op">=</span> RunnableWithMessageHistory(</span>
<span id="cb24-96"><a href="#cb24-96"></a>    agent_executor,</span>
<span id="cb24-97"><a href="#cb24-97"></a>    <span class="co"># 대화 session_id</span></span>
<span id="cb24-98"><a href="#cb24-98"></a>    get_session_history,</span>
<span id="cb24-99"><a href="#cb24-99"></a>    <span class="co"># 프롬프트의 질문이 입력되는 key: "input"</span></span>
<span id="cb24-100"><a href="#cb24-100"></a>    input_messages_key<span class="op">=</span><span class="st">"input"</span>,</span>
<span id="cb24-101"><a href="#cb24-101"></a>    <span class="co"># 프롬프트의 메시지가 입력되는 key: "chat_history"</span></span>
<span id="cb24-102"><a href="#cb24-102"></a>    history_messages_key<span class="op">=</span><span class="st">"chat_history"</span>,</span>
<span id="cb24-103"><a href="#cb24-103"></a>)</span>
<span id="cb24-104"><a href="#cb24-104"></a></span>
<span id="cb24-105"><a href="#cb24-105"></a><span class="co">########## 7. Agent 파서를 정의합니다. ##########</span></span>
<span id="cb24-106"><a href="#cb24-106"></a>agent_stream_parser <span class="op">=</span> AgentStreamParser()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="59f2116f" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a><span class="co">########## 8. 에이전트를 실행하고 결과를 확인합니다. ##########</span></span>
<span id="cb25-2"><a href="#cb25-2"></a></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="co"># 질의에 대한 답변을 출력합니다.</span></span>
<span id="cb25-4"><a href="#cb25-4"></a>response <span class="op">=</span> agent_with_chat_history.stream(</span>
<span id="cb25-5"><a href="#cb25-5"></a>    {<span class="st">"input"</span>: <span class="st">"구글이 앤스로픽에 투자한 금액을 문서에서 찾아줘"</span>},</span>
<span id="cb25-6"><a href="#cb25-6"></a>    <span class="co"># 세션 ID를 설정합니다.</span></span>
<span id="cb25-7"><a href="#cb25-7"></a>    <span class="co"># 여기서는 간단한 메모리 내 ChatMessageHistory를 사용하기 때문에 실제로 사용되지 않습니다</span></span>
<span id="cb25-8"><a href="#cb25-8"></a>    config<span class="op">=</span>{<span class="st">"configurable"</span>: {<span class="st">"session_id"</span>: <span class="st">"abc123"</span>}},</span>
<span id="cb25-9"><a href="#cb25-9"></a>)</span>
<span id="cb25-10"><a href="#cb25-10"></a></span>
<span id="cb25-11"><a href="#cb25-11"></a><span class="cf">for</span> step <span class="kw">in</span> response:</span>
<span id="cb25-12"><a href="#cb25-12"></a>    agent_stream_parser.process_agent_steps(step)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>[도구 호출]
Tool: pdf_search
query: 구글 앤스로픽 투자 금액
Log: 
Invoking: `pdf_search` with `{'query': '구글 앤스로픽 투자 금액'}`

[관찰 내용]
Observation: 1. 정책/법제  
2. 기업/산업 
3. 기술/연구 
 4. 인력/교육
구글, 앤스로픽에 20억 달러 투자로 생성 AI 협력 강화 
n 구글이 앤스로픽에 최대 20억 달러 투자에 합의하고 5억 달러를 우선 투자했으며, 앤스로픽은 
구글과 클라우드 서비스 사용 계약도 체결
(...중략...) 
Ⅱ. 주요 행사
   ▹CES 2024 ····························································································································· 19

[최종 답변]
구글은 앤스로픽에 최대 20억 달러를 투자하기로 합의했으며, 이 중 5억 달러를 우선 투자했습니다. 향후 15억 달러를 추가로 투자할 계획입니다.</code></pre>
<div id="ae561d20" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a><span class="co">########## 8. 에이전트를 실행하고 결과를 확인합니다. ##########</span></span>
<span id="cb27-2"><a href="#cb27-2"></a></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="co"># 질의에 대한 답변을 출력합니다.</span></span>
<span id="cb27-4"><a href="#cb27-4"></a>response <span class="op">=</span> agent_with_chat_history.stream(</span>
<span id="cb27-5"><a href="#cb27-5"></a>    {<span class="st">"input"</span>: <span class="st">"이전의 답변을 영어로 번역해 주세요"</span>},</span>
<span id="cb27-6"><a href="#cb27-6"></a>    <span class="co"># 세션 ID를 설정합니다.</span></span>
<span id="cb27-7"><a href="#cb27-7"></a>    <span class="co"># 여기서는 간단한 메모리 내 ChatMessageHistory를 사용하기 때문에 실제로 사용되지 않습니다</span></span>
<span id="cb27-8"><a href="#cb27-8"></a>    config<span class="op">=</span>{<span class="st">"configurable"</span>: {<span class="st">"session_id"</span>: <span class="st">"abc123"</span>}},</span>
<span id="cb27-9"><a href="#cb27-9"></a>)</span>
<span id="cb27-10"><a href="#cb27-10"></a></span>
<span id="cb27-11"><a href="#cb27-11"></a><span class="cf">for</span> step <span class="kw">in</span> response:</span>
<span id="cb27-12"><a href="#cb27-12"></a>    agent_stream_parser.process_agent_steps(step)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>[최종 답변]
Google has agreed to invest up to $2 billion in Anthropic, with an initial investment of $500 million. They plan to invest an additional $1.5 billion in the future.</code></pre>
<div id="eb362b30" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a><span class="co">########## 8. 에이전트를 실행하고 결과를 확인합니다. ##########</span></span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="co"># 질의에 대한 답변을 출력합니다.</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>response <span class="op">=</span> agent_with_chat_history.stream(</span>
<span id="cb29-5"><a href="#cb29-5"></a>    {</span>
<span id="cb29-6"><a href="#cb29-6"></a>        <span class="st">"input"</span>: <span class="st">"2024년 프로야구 플레이오프 진출 5개팀을 검색해서 알려주세요. 한글로 답변하세요"</span></span>
<span id="cb29-7"><a href="#cb29-7"></a>    },</span>
<span id="cb29-8"><a href="#cb29-8"></a>    <span class="co"># 세션 ID를 설정합니다.</span></span>
<span id="cb29-9"><a href="#cb29-9"></a>    <span class="co"># 여기서는 간단한 메모리 내 ChatMessageHistory를 사용하기 때문에 실제로 사용되지 않습니다</span></span>
<span id="cb29-10"><a href="#cb29-10"></a>    config<span class="op">=</span>{<span class="st">"configurable"</span>: {<span class="st">"session_id"</span>: <span class="st">"abc456"</span>}},</span>
<span id="cb29-11"><a href="#cb29-11"></a>)</span>
<span id="cb29-12"><a href="#cb29-12"></a></span>
<span id="cb29-13"><a href="#cb29-13"></a><span class="cf">for</span> step <span class="kw">in</span> response:</span>
<span id="cb29-14"><a href="#cb29-14"></a>    agent_stream_parser.process_agent_steps(step)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>[도구 호출]
Tool: tavily_search_results_json
query: 2024 KBO 리그 플레이오프 진출팀
Log: 
Invoking: `tavily_search_results_json` with `{'query': '2024 KBO 리그 플레이오프 진출팀'}`

[관찰 내용]
Observation: [{'url': 'https://www.gosusports.com/news/baseball/kbo-news-2024-kbo-season-preview/196180/', 'content': "[고수스포츠] 2024 kbo 리그 시즌 프리뷰 ... 플레이오프 진출을 이뤄냈다. nc의 선전에는 '특급 외인' 페디의 활약이 주효했다. 페디는 평균자책점(era 2.00)다승(20승), 탈삼진(209개) 등 3가지 부문에서 모두 1위를 차지하며 kbo리그를 평정했다."},
(...중략...)
kia 타이거즈, 삼성 라이온즈, lg 트윈스, 두산 베어스, kt 위즈다.. kia 타이거즈; 2022년 이후 2년만에 포스트시즌 진출에 성공했다. 9월 6일 포스트시즌 진출 확정 이후 9월 17일 정규시즌 우승도 함께 기록하면서 한국시리즈 직행에 성공했다.'}]

[최종 답변]
2024년 KBO 리그 플레이오프에 진출한 5개 팀은 다음과 같습니다:

1. KIA 타이거즈
2. 삼성 라이온즈
3. LG 트윈스
4. 두산 베어스
5. KT 위즈

이 팀들은 2024년 KBO 포스트시즌에 진출하여 경기를 치르게 됩니다.</code></pre>
<div id="29806097" class="cell" data-execution_count="22">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1"></a><span class="co">########## 8. 에이전트를 실행하고 결과를 확인합니다. ##########</span></span>
<span id="cb31-2"><a href="#cb31-2"></a></span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="co"># 질의에 대한 답변을 출력합니다.</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>response <span class="op">=</span> agent_with_chat_history.stream(</span>
<span id="cb31-5"><a href="#cb31-5"></a>    {<span class="st">"input"</span>: <span class="st">"이전의 답변을 SNS 게시글 형태로 100자 내외로 작성하세요."</span>},</span>
<span id="cb31-6"><a href="#cb31-6"></a>    <span class="co"># 세션 ID를 설정합니다.</span></span>
<span id="cb31-7"><a href="#cb31-7"></a>    <span class="co"># 여기서는 간단한 메모리 내 ChatMessageHistory를 사용하기 때문에 실제로 사용되지 않습니다</span></span>
<span id="cb31-8"><a href="#cb31-8"></a>    config<span class="op">=</span>{<span class="st">"configurable"</span>: {<span class="st">"session_id"</span>: <span class="st">"abc456"</span>}},</span>
<span id="cb31-9"><a href="#cb31-9"></a>)</span>
<span id="cb31-10"><a href="#cb31-10"></a></span>
<span id="cb31-11"><a href="#cb31-11"></a><span class="cf">for</span> step <span class="kw">in</span> response:</span>
<span id="cb31-12"><a href="#cb31-12"></a>    agent_stream_parser.process_agent_steps(step)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>[최종 답변]
2024 KBO 리그 플레이오프 진출팀: KIA 타이거즈, 삼성 라이온즈, LG 트윈스, 두산 베어스, KT 위즈! 치열한 경기가 기대됩니다! #KBO #플레이오프</code></pre>
<div id="5e03858d" class="cell" data-execution_count="23">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1"></a><span class="co">########## 8. 에이전트를 실행하고 결과를 확인합니다. ##########</span></span>
<span id="cb33-2"><a href="#cb33-2"></a></span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="co"># 질의에 대한 답변을 출력합니다.</span></span>
<span id="cb33-4"><a href="#cb33-4"></a>response <span class="op">=</span> agent_with_chat_history.stream(</span>
<span id="cb33-5"><a href="#cb33-5"></a>    {<span class="st">"input"</span>: <span class="st">"이전의 답변에 한국 시리즈 일정을 추가하세요."</span>},</span>
<span id="cb33-6"><a href="#cb33-6"></a>    <span class="co"># 세션 ID를 설정합니다.</span></span>
<span id="cb33-7"><a href="#cb33-7"></a>    <span class="co"># 여기서는 간단한 메모리 내 ChatMessageHistory를 사용하기 때문에 실제로 사용되지 않습니다</span></span>
<span id="cb33-8"><a href="#cb33-8"></a>    config<span class="op">=</span>{<span class="st">"configurable"</span>: {<span class="st">"session_id"</span>: <span class="st">"abc456"</span>}},</span>
<span id="cb33-9"><a href="#cb33-9"></a>)</span>
<span id="cb33-10"><a href="#cb33-10"></a></span>
<span id="cb33-11"><a href="#cb33-11"></a><span class="cf">for</span> step <span class="kw">in</span> response:</span>
<span id="cb33-12"><a href="#cb33-12"></a>    agent_stream_parser.process_agent_steps(step)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>[도구 호출]
Tool: tavily_search_results_json
query: 2024 KBO 한국 시리즈 일정
Log: 
Invoking: `tavily_search_results_json` with `{'query': '2024 KBO 한국 시리즈 일정'}`

[관찰 내용]
Observation: [{'url': 'https://ko.wikipedia.org/wiki/2024년_한국시리즈', 'content': '2024 신한 SOL Bank KBO 한국시리즈는 2024년 10월 21일부터 10월 29일까지 펼쳐질 예정인 2024년 KBO 리그의 챔피언 결정전이다. 대진은 2024년 KBO 리그 정규 시즌 1위 팀으로 2017년 한국시리즈 이후 7년만에 한국시리즈 직행에 성공하며 통합 우승에 도전하는 KIA 타이거즈 와 ...'}, 
(...중략...)
출할 수 있다. 반면, 5위 팀은 두 경기를 모두 이겨야만 준플레이오프에 올라갈 수 있다. 만약 경기가 무승부로 끝나면, 해당 경기는 시리즈별 최종전이 끝난 후 무승부가 발생한 구장에서 이동일 없이 연전으로 진행된다. WIKITREE WIKITREE NOW"}]

[최종 답변]
2024 KBO 리그 플레이오프 진출팀: KIA 타이거즈, 삼성 라이온즈, LG 트윈스, 두산 베어스, KT 위즈! 경기는 10월 2일부터 시작되며, 한국 시리즈는 10월 21일부터 10월 29일까지 진행됩니다. 치열한 경기가 기대됩니다! #KBO #플레이오프 #한국시리즈</code></pre>


</section>
</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>