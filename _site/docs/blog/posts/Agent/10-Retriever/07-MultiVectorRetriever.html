<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="한 문서에 여러 벡터를 생성하여 다양한 관점에서 검색할 수 있는 MultiVectorRetriever의 원리와 구현 방법을 다룬다. DocStore와 VectorStore를 동시에 활용하여 청크 단위 검색과 원본 문서 반환을 유연하게 조합하는 전략을 학습한다.">

<title>Kwangmin Kim - MultiVectorRetriever</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - MultiVectorRetriever">
<meta property="og:description" content="한 문서에 여러 벡터를 생성하여 다양한 관점에서 검색할 수 있는 MultiVectorRetriever의 원리와 구현 방법을 다룬다. DocStore와 VectorStore를 동시에 활용하여 청크 단위 검색과 원본 문서 반환을 유연하게 조합하는 전략을 학습한다.">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Kwangmin Kim - MultiVectorRetriever">
<meta name="twitter:description" content="한 문서에 여러 벡터를 생성하여 다양한 관점에서 검색할 수 있는 MultiVectorRetriever의 원리와 구현 방법을 다룬다. DocStore와 VectorStore를 동시에 활용하여 청크 단위 검색과 원본 문서 반환을 유연하게 조합하는 전략을 학습한다.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">MultiVectorRetriever</h1>
            <p class="subtitle lead">계층적 문서 구조를 활용한 고급 검색 시스템</p>
                  <div>
        <div class="description">
          <p>한 문서에 여러 벡터를 생성하여 다양한 관점에서 검색할 수 있는 MultiVectorRetriever의 원리와 구현 방법을 다룬다. DocStore와 VectorStore를 동시에 활용하여 청크 단위 검색과 원본 문서 반환을 유연하게 조합하는 전략을 학습한다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">AI</div>
                <div class="quarto-category">RAG</div>
                <div class="quarto-category">LangChain</div>
                <div class="quarto-category">Agent</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2024년 05월 08일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#multivectorretriever-개요" id="toc-multivectorretriever-개요" class="nav-link active" data-scroll-target="#multivectorretriever-개요"><span class="header-section-number">1</span> MultiVectorRetriever 개요</a>
  <ul class="collapse">
  <li><a href="#핵심-개념" id="toc-핵심-개념" class="nav-link" data-scroll-target="#핵심-개념"><span class="header-section-number">1.1</span> 핵심 개념</a>
  <ul class="collapse">
  <li><a href="#기본-아키텍처-docstore-vectorstore-이중-구조" id="toc-기본-아키텍처-docstore-vectorstore-이중-구조" class="nav-link" data-scroll-target="#기본-아키텍처-docstore-vectorstore-이중-구조"><span class="header-section-number">1.1.1</span> 기본 아키텍처: “DocStore + VectorStore” 이중 구조</a></li>
  <li><a href="#왜-필요한가" id="toc-왜-필요한가" class="nav-link" data-scroll-target="#왜-필요한가"><span class="header-section-number">1.1.2</span> 왜 필요한가?</a></li>
  </ul></li>
  <li><a href="#parentdocumentretriever와의-차이점" id="toc-parentdocumentretriever와의-차이점" class="nav-link" data-scroll-target="#parentdocumentretriever와의-차이점"><span class="header-section-number">1.2</span> ParentDocumentRetriever와의 차이점</a>
  <ul class="collapse">
  <li><a href="#예시-비교" id="toc-예시-비교" class="nav-link" data-scroll-target="#예시-비교"><span class="header-section-number">1.2.1</span> 예시 비교</a></li>
  </ul></li>
  <li><a href="#고급-활용-전략" id="toc-고급-활용-전략" class="nav-link" data-scroll-target="#고급-활용-전략"><span class="header-section-number">1.3</span> 고급 활용 전략</a>
  <ul class="collapse">
  <li><a href="#요약-기반-서치-최적화" id="toc-요약-기반-서치-최적화" class="nav-link" data-scroll-target="#요약-기반-서치-최적화"><span class="header-section-number">1.3.1</span> 요약 기반 서치 최적화</a></li>
  <li><a href="#다양한-벡터-생성-전략" id="toc-다양한-벡터-생성-전략" class="nav-link" data-scroll-target="#다양한-벡터-생성-전략"><span class="header-section-number">1.3.2</span> 다양한 벡터 생성 전략</a></li>
  </ul></li>
  <li><a href="#실습에-활용한-문서" id="toc-실습에-활용한-문서" class="nav-link" data-scroll-target="#실습에-활용한-문서"><span class="header-section-number">1.4</span> 실습에 활용한 문서</a></li>
  <li><a href="#chunk-원본-문서-검색" id="toc-chunk-원본-문서-검색" class="nav-link" data-scroll-target="#chunk-원본-문서-검색"><span class="header-section-number">1.5</span> Chunk + 원본 문서 검색</a></li>
  <li><a href="#요약본summary을-벡터저장소에-저장" id="toc-요약본summary을-벡터저장소에-저장" class="nav-link" data-scroll-target="#요약본summary을-벡터저장소에-저장"><span class="header-section-number">1.6</span> 요약본(summary)을 벡터저장소에 저장</a></li>
  <li><a href="#가설-쿼리hypothetical-queries를-활용한-문서-탐색" id="toc-가설-쿼리hypothetical-queries를-활용한-문서-탐색" class="nav-link" data-scroll-target="#가설-쿼리hypothetical-queries를-활용한-문서-탐색"><span class="header-section-number">1.7</span> 가설 쿼리(Hypothetical Queries)를 활용한 문서 탐색</a>
  <ul class="collapse">
  <li><a href="#핵심-아이디어" id="toc-핵심-아이디어" class="nav-link" data-scroll-target="#핵심-아이디어"><span class="header-section-number">1.7.1</span> 핵심 아이디어</a></li>
  <li><a href="#왜-효과적인가" id="toc-왜-효과적인가" class="nav-link" data-scroll-target="#왜-효과적인가"><span class="header-section-number">1.7.2</span> 왜 효과적인가?</a></li>
  <li><a href="#작동-원리" id="toc-작동-원리" class="nav-link" data-scroll-target="#작동-원리"><span class="header-section-number">1.7.3</span> 작동 원리</a></li>
  <li><a href="#장단점-분석" id="toc-장단점-분석" class="nav-link" data-scroll-target="#장단점-분석"><span class="header-section-number">1.7.4</span> 장단점 분석</a></li>
  <li><a href="#구현-예제" id="toc-구현-예제" class="nav-link" data-scroll-target="#구현-예제"><span class="header-section-number">1.7.5</span> 구현 예제</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="multivectorretriever-개요" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> MultiVectorRetriever 개요</h1>
<section id="핵심-개념" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="핵심-개념"><span class="header-section-number">1.1</span> 핵심 개념</h2>
<p><strong>MultiVectorRetriever</strong>는 단일 문서에 대해 여러 벡터를 생성하여 다양한 관점에서 검색할 수 있도록 도와주는 고급 검색 시스템이다.</p>
<section id="기본-아키텍처-docstore-vectorstore-이중-구조" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="기본-아키텍처-docstore-vectorstore-이중-구조"><span class="header-section-number">1.1.1</span> 기본 아키텍처: “DocStore + VectorStore” 이중 구조</h3>
<p>이름에서 오해를 사수 있는 부분을 명확히 하자. <strong>“다중 벡터저장소”</strong>는 여러 개의 벡터 데이터베이스를 운영한다는 의미가 아니다. 실제로는 다음 두 가지 데이터 저장소를 함께 운영한다:</p>
<ol type="1">
<li><strong>DocStore</strong>: 원본 문서(규모가 큰 데이터)를 저장하는 공간</li>
<li><strong>VectorStore</strong>: 처리된 벡터 임베딩을 저장하는 공간</li>
</ol>
</section>
<section id="왜-필요한가" class="level3" data-number="1.1.2">
<h3 data-number="1.1.2" class="anchored" data-anchor-id="왜-필요한가"><span class="header-section-number">1.1.2</span> 왜 필요한가?</h3>
<p><strong>계층적 맥락 보존 문제</strong></p>
<p>전통적인 RAG 시스템에서 A 페이지가 1, 2, 3번 chunk로 분할되었을 때: - 가장 유사도가 높은 단일 chunk만 반환됨 (예: 2번 chunk) - 2, 3번 chunk에도 질문과 유사한 내용이 들어있을 수 있음 - <strong>문제</strong>: 제한된 문맥 정보로 인해 LLM이 부정확한 답변을 생성</p>
<p><strong>MultiVectorRetriever의 해결책</strong></p>
<p>단일 chunk만 반환하는 대신, 질문 쿼리의 내용이 모두 담긴 <strong>A 페이지 전체</strong>를 검색 반환한다. 이를 통해: - LLM이 “Lost in the Middle” 리스크를 간접적으로 회피할 수 있음 - 더 정확하고 포괄적인 답변 생성 가능 - 맥락을 유지하면서도 세밀한 검색 가능</p>
</section>
</section>
<section id="parentdocumentretriever와의-차이점" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="parentdocumentretriever와의-차이점"><span class="header-section-number">1.2</span> ParentDocumentRetriever와의 차이점</h2>
<p><strong>기능적 유사성</strong></p>
<ul>
<li>두 Retriever 모두 계층적 문서 구조를 사용하지만, MultiVectorRetriever는 <strong>용도적으로 더 세분화된 기능</strong>을 제공한다.</li>
<li>둘 다 “작게 검색 → 크게 반환”
<ul>
<li>검색: 작은 청크로 검색 (정밀도 ↑)</li>
<li>반환: 큰 문서로 반환 (맥락 ↑)</li>
</ul></li>
<li>구조도 동일:
<ul>
<li>VectorStore: 검색용 작은 청크</li>
<li>DocStore: 반환용 큰 문서</li>
<li>ID 매핑으로 연결</li>
</ul></li>
</ul>
<p><strong>핵심 차이: “작은 청크를 어떻게 만드느냐”</strong></p>
<ul>
<li>MultiVectorRetriever는 ParentDocumentRetriever의 일반화 버전이다.</li>
<li>ParentDocumentRetriever
<ul>
<li>원본 문서를 물리적으로 쪼갬</li>
<li>큰 문서 (Parent) -(분할)→ 작은 청크1, 청크2, 청크3 (Child)</li>
<li>Child는 Parent의 실제 일부분 (계층적 분할): 단순히 크기만 다르게 쪼갬
<ul>
<li><code>parent_splitter = RecursiveCharacterTextSplitter(chunk_size=2000)</code></li>
<li><code>child_splitter = RecursiveCharacterTextSplitter(chunk_size=400)</code></li>
</ul></li>
</ul></li>
<li>MultiVectorRetriever
<ul>
<li>원본 문서(Parent)는 그대로 두고, 검색용 “표현(Chunk)”을 별도 생성</li>
<li>child 생성 방식: 요약본 / 가상질문 / 여러 청크 (내용보전)</li>
<li>큰 문서 (Parent) -(파생)→ 작은 청크1, 청크2, 청크3 (Child)</li>
<li>검색용 표현은 원본과 다른 내용일 수 있음</li>
<li>여러 방법 가능: 요약, 질문 생성, 다중 청크 등</li>
<li><strong>ID 기반 유연한 매핑 시스템</strong>
<ul>
<li>문서 A 페이지에 1, 2, 3 chunk가 있을 때, 각 문서와 chunk에 동일한 ID(예: ‘abc’)를 부여:
<ul>
<li><strong>DocStore</strong>: Parent document → ID ’abc’로 저장</li>
<li><strong>VectorStore</strong>: Child chunks (1, 2, 3) → 모두 ID ’abc’로 저장</li>
</ul></li>
<li>ID로 parent와 child가 강제로 연결되기 때문에 child 문서를 가공 및 변형해도 parent와 연결시킬 수 있다.</li>
</ul></li>
</ul></li>
<li><strong>ID 기반 유연한 매핑 시스템</strong>을 이용한 MultiVectorRetriever의 유연한 반환 전략
<ul>
<li>chunk 1, 2, 3 중 하나가 검색되었을 때, ID ’abc’를 key로 사용하여 다음 옵션들을 선택적으로 제어 가능:
<ol type="1">
<li><strong>Parent Document만 반환</strong>: 전체 맥락 제공</li>
<li><strong>Child Chunk만 반환</strong>: 정밀한 정보만 제공</li>
<li><strong>둘 다 반환</strong>: 세밀한 정보 + 전체 맥락 동시 제공</li>
</ol></li>
</ul></li>
</ul>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>ParentDocumentRetriever</th>
<th>MultiVectorRetriever</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>검색용 청크</strong></td>
<td>원본의 일부 (물리적 분할)</td>
<td>원본의 파생 표현 (요약/질문 등)</td>
</tr>
<tr class="even">
<td><strong>청크와 원본 관계</strong></td>
<td>포함 관계</td>
<td>독립적 (다른 내용 가능)</td>
</tr>
<tr class="odd">
<td><strong>유연성</strong></td>
<td>낮음 (분할만)</td>
<td>높음 (요약/질문/다중 방식)</td>
</tr>
<tr class="even">
<td><strong>사용 시기</strong></td>
<td>단순한 계층 구조</td>
<td>검색 품질 최적화 필요</td>
</tr>
</tbody>
</table>
<section id="예시-비교" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="예시-비교"><span class="header-section-number">1.2.1</span> 예시 비교</h3>
<p><strong>ParentDocumentRetriever:</strong></p>
<pre><code>원본: "AI는 인공지능이다. 머신러닝을 사용한다. 딥러닝도 포함된다."

Child1: "AI는 인공지능이다."
Child2: "머신러닝을 사용한다."
Child3: "딥러닝도 포함된다."

→ Child2로 검색 → 원본 전체 반환</code></pre>
<p><strong>MultiVectorRetriever:</strong></p>
<pre><code>원본: "AI는 인공지능이다. 머신러닝을 사용한다. 딥러닝도 포함된다."

요약: "AI와 머신러닝, 딥러닝의 관계 설명"
가상질문: "AI란 무엇인가? 머신러닝이란?"

→ 요약/질문으로 검색 → 원본 반환</code></pre>
</section>
</section>
<section id="고급-활용-전략" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="고급-활용-전략"><span class="header-section-number">1.3</span> 고급 활용 전략</h2>
<section id="요약-기반-서치-최적화" class="level3" data-number="1.3.1">
<h3 data-number="1.3.1" class="anchored" data-anchor-id="요약-기반-서치-최적화"><span class="header-section-number">1.3.1</span> 요약 기반 서치 최적화</h3>
<ul>
<li>각 chunk의 <strong>요약본</strong>을 생성하여 VectorStore에 임베딩 데이터로 저장:
<ul>
<li>Semantic Match 품질 향상: 쿼리와 검색 대상의 추상화 레벨을 맞춰서 semantic match를 개선</li>
<li>질문자 쿼리와 유사한 요약본을 검색</li>
<li>해당 요약본에 대응되는 <strong>원본 chunk</strong>를 DocStore에서 호출</li>
</ul></li>
<li>예시
<ul>
<li>원본 청크: “2023년 11월 8일 삼성전자가 삼성 AI 포럼에서 삼성 가우스를 공개했다. 정규분포 이론을 정립한 수학자 가우스의 이름을 따왔으며, …”</li>
<li>사용자 질문 쿼리: “삼성의 AI 제품이 뭐야?”</li>
<li>문제
<ul>
<li>원본에는 날짜, 인명, 기술적 세부사항이 섞여있음</li>
<li>임베딩이 이런 잡음에 영향받음</li>
<li>핵심 의미(삼성이 AI 제품을 만들었다)가 희석됨</li>
</ul></li>
<li>해결: 요약본으로 검색
<ul>
<li>요약 청크: “삼성전자가 온디바이스 생성 AI 모델 ’삼성 가우스’를 공개했으며, 언어·코드·이미지 3개 모델로 구성되어 있다.”</li>
<li>사용자 질문 쿼리: “삼성의 AI 제품이 뭐야?”</li>
</ul></li>
</ul></li>
<li>요약본 청크 생성 이점
<ul>
<li>검색 품질 향상</li>
<li>의미 밀도 증가: 핵심 정보만 압축되어 있음</li>
<li>노이즈 제거: 불필요한 세부사항 제거됨</li>
<li>상화 레벨 맞춤: 쿼리와 semantic 유사도가 더 높음<br>
</li>
</ul></li>
<li>요약본 청크 생성 단점
<ul>
<li>비용: LLM으로 요약 생성 필요</li>
<li>시간: 인덱싱 시간 증가</li>
<li>정보손실: 요약 과정에서 중요한 디테일 누락 가능</li>
</ul></li>
<li>언제 사용?
<ul>
<li>문서가 길고 세부사항이 많을 때</li>
<li>사용자 질문이 고수준/추상적일 때</li>
<li>검색 품질이 비용보다 중요할 때</li>
</ul></li>
<li>언제 비추천?
<ul>
<li>정확한 수치/날짜가 중요할 때</li>
<li>문서가 이미 간결할 때</li>
<li>실시간 검색 속도가 중요할 때</li>
</ul></li>
</ul>
</section>
<section id="다양한-벡터-생성-전략" class="level3" data-number="1.3.2">
<h3 data-number="1.3.2" class="anchored" data-anchor-id="다양한-벡터-생성-전략"><span class="header-section-number">1.3.2</span> 다양한 벡터 생성 전략</h3>
<p>LangChain에서는 문서를 다양한 상황에서 효율적으로 쿼리할 수 있는 MultiVectorRetriever를 제공한다. 이 기능을 사용하면 문서를 여러 벡터로 저장하고 관리할 수 있어, 정보 검색의 정확도와 효율성을 대폭 향상시킬 수 있다.</p>
<p><strong>문서당 여러 벡터 생성 방법:</strong></p>
<ol type="1">
<li><p><strong>작은 청크 생성</strong>: 문서를 더 작은 단위로 나눈 후, 각 청크에 대해 별도의 임베딩을 생성한다. 이 방식을 사용하면 문서의 특정 부분에 좋 더 세심한 주의를 기울일 수 있다. 이 과정은 <code>ParentDocumentRetriever</code>를 통해 구현할 수 있어, 세부 정보에 대한 탐색이 용이해진다.</p></li>
<li><p><strong>요약 임베딩</strong>: 각 문서의 요약을 생성하고, 이 요약으로부터 임베딩을 만듭니다. 이 요약 임베딩은 문서의 핵심 내용을 신속하게 파악하는 데 큰 도움이 된다. 문서 전체를 분석하는 대신 핵심적인 요약 부분만을 활용하여 효율성을 극대화할 수 있다.</p></li>
<li><p><strong>가설 질문 활용</strong>: 각 문서에 대해 적합한 가설 질문을 만들고, 이 질문에 기반한 임베딩을 생성한다. 특정 주제나 내용에 대해 깊이 있는 탐색을 원할 때 이 방법이 유용하다. 가설 질문은 문서의 내용을 다양한 관점에서 접근하게 해주며, 더 광범위한 이해를 가능하게 한다.</p></li>
<li><p><strong>수동 추가 방식</strong>: 사용자가 문서 검색 시 고려해야 할 특정 질문이나 쿼리를 직접 추가할 수 있다. 이 방법을 통해 사용자는 검색 과정에서 보다 세밀한 제어를 할 수 있으며, 자신의 요구 사항에 맞춘 맞춤형 검색이 가능해진다.</p></li>
</ol>
</section>
</section>
<section id="실습에-활용한-문서" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="실습에-활용한-문서"><span class="header-section-number">1.4</span> 실습에 활용한 문서</h2>
<p>소프트웨어정책연구소(SPRi) - 2023년 12월호</p>
<ul>
<li>저자: 유재흥(AI정책연구실 책임연구원), 이지수(AI정책연구실 위촉연구원)</li>
<li>링크: https://spri.kr/posts/view/23669</li>
<li>파일명: <code>SPRI_AI_Brief_2023년12월호_F.pdf</code></li>
</ul>
<p><strong>참고</strong>: 위의 파일은 <code>data</code> 폴더 내에 다운로드 받으세요</p>
<div id="1576dbc9" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># API 키를 환경변수로 관리하기 위한 설정 파일</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="im">from</span> dotenv <span class="im">import</span> load_dotenv</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co"># API 키 정보 로드</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>load_dotenv()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="9ace8aff" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># LangSmith 추적을 설정한다. https://smith.langchain.com</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co"># !pip install langchain-teddynote</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="im">from</span> langchain_teddynote <span class="im">import</span> logging</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co"># 프로젝트 이름을 입력한다.</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>logging.langsmith(<span class="st">"CH10-Retriever"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>텍스트 파일에서 데이터를 로드하고, 로드된 문서들을 지정된 크기로 분할하는 전처리 과정을 수행한다.</p>
<p>분할된 문서들은 추후 벡터화 및 검색 등의 작업에 사용될 수 있다.</p>
<div id="ead68adc" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="im">from</span> langchain_community.document_loaders <span class="im">import</span> PyMuPDFLoader</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a>loader <span class="op">=</span> PyMuPDFLoader(<span class="st">"data/SPRI_AI_Brief_2023년12월호_F.pdf"</span>)</span>
<span id="cb5-4"><a href="#cb5-4"></a>docs <span class="op">=</span> loader.load()</span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="bu">print</span>(<span class="bu">len</span>(docs))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>데이터로부터 로드한 원본 도큐먼트는 <code>docs</code> 변수에 담았다.</p>
<pre><code>23</code></pre>
<div id="d700008e" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="bu">print</span>(docs[<span class="dv">5</span>].page_content[:<span class="dv">500</span>])</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>1. 정책/법제  
2. 기업/산업 
3. 기술/연구 
 4. 인력/교육
영국 AI 안전성 정상회의에 참가한 28개국, AI 위험에 공동 대응 선언
n 영국 블레츨리 파크에서 개최된 AI 안전성 정상회의에 참가한 28개국들이 AI 안전 보장을 
위한 협력 방안을 담은 블레츨리 선언을 발표
n 첨단 AI를 개발하는 국가와 기업들은 AI 시스템에 대한 안전 테스트 계획에 합의했으며, 
영국의 AI 안전 연구소가 전 세계 국가와 협력해 테스트를 주도할 예정 
KEY Contents
£ AI 안전성 정상회의 참가국들, 블레츨리 선언 통해 AI 안전 보장을 위한 협력에 합의
n 2023년 11월 1~2일 영국 블레츨리 파크에서 열린 AI 안전성 정상회의(AI Safety Summit)에 
참가한 28개국 대표들이 AI 위험 관리를 위한 ‘블레츨리 선언’을 발표 
∙선언은 AI 안전 보장을 위해 국가, 국제기구, 기업, 시민사회, 학계를 포함한 모든 이해관계자의 협력이 
중요하다고 강조했으며,</code></pre>
<ul>
<li>pdf가 23페이지로 구성되어 있어 23이 반환됨 pdf loader는 패이지 단위로 로드가 된다.</li>
</ul>
</section>
<section id="chunk-원본-문서-검색" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="chunk-원본-문서-검색"><span class="header-section-number">1.5</span> Chunk + 원본 문서 검색</h2>
<ul>
<li>대용량 정보를 검색하는 경우, 더 작은 단위로 정보를 임베딩하는 것이 유용할 수 있다.</li>
<li><code>MultiVectorRetriever</code>를 통해 문서를 여러 벡터로 저장하고 관리할 수 있다.</li>
<li><code>docstore</code>에 원본 문서를 저장하고, <code>vectorstore</code>에 임베딩된 문서를 저장한다.</li>
</ul>
<p>이로써 문서를 더 작은 단위로 나누어 더 정확한 검색이 가능해진다. 때에 따라서는 원본 문서의 내용을 조회할 수 있다.</p>
<div id="d5d4e635" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># 자식 청크를 인덱싱하는 데 사용할 벡터 저장소</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="im">import</span> uuid</span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="im">from</span> langchain.storage <span class="im">import</span> InMemoryStore</span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="im">from</span> langchain_chroma <span class="im">import</span> Chroma</span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="im">from</span> langchain_openai <span class="im">import</span> OpenAIEmbeddings</span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="im">from</span> langchain_text_splitters <span class="im">import</span> RecursiveCharacterTextSplitter</span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="im">from</span> langchain.retrievers.multi_vector <span class="im">import</span> MultiVectorRetriever</span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a>vectorstore <span class="op">=</span> Chroma(</span>
<span id="cb9-10"><a href="#cb9-10"></a>    collection_name<span class="op">=</span><span class="st">"small_bigger_chunks"</span>,</span>
<span id="cb9-11"><a href="#cb9-11"></a>    embedding_function<span class="op">=</span>OpenAIEmbeddings(model<span class="op">=</span><span class="st">"text-embedding-3-small"</span>),</span>
<span id="cb9-12"><a href="#cb9-12"></a>)</span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="co"># 부모 문서의 저장소 계층</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>store <span class="op">=</span> InMemoryStore()</span>
<span id="cb9-15"><a href="#cb9-15"></a></span>
<span id="cb9-16"><a href="#cb9-16"></a>id_key <span class="op">=</span> <span class="st">"doc_id"</span></span>
<span id="cb9-17"><a href="#cb9-17"></a></span>
<span id="cb9-18"><a href="#cb9-18"></a><span class="co"># 검색기 (시작 시 비어 있음)</span></span>
<span id="cb9-19"><a href="#cb9-19"></a>retriever <span class="op">=</span> MultiVectorRetriever(</span>
<span id="cb9-20"><a href="#cb9-20"></a>    vectorstore<span class="op">=</span>vectorstore,</span>
<span id="cb9-21"><a href="#cb9-21"></a>    byte_store<span class="op">=</span>store,</span>
<span id="cb9-22"><a href="#cb9-22"></a>    id_key<span class="op">=</span>id_key,</span>
<span id="cb9-23"><a href="#cb9-23"></a>)</span>
<span id="cb9-24"><a href="#cb9-24"></a></span>
<span id="cb9-25"><a href="#cb9-25"></a><span class="co"># 문서 ID를 생성합니다.</span></span>
<span id="cb9-26"><a href="#cb9-26"></a>doc_ids <span class="op">=</span> [<span class="bu">str</span>(uuid.uuid4()) <span class="cf">for</span> _ <span class="kw">in</span> docs]</span>
<span id="cb9-27"><a href="#cb9-27"></a></span>
<span id="cb9-28"><a href="#cb9-28"></a><span class="co"># 두개의 생성된 id를 확인한다.</span></span>
<span id="cb9-29"><a href="#cb9-29"></a>doc_ids</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>['ff65f8d8-376d-47d2-bbc0-eae1f7e3c381', 'e18fd86b-f01a-445f-bf31-eb8d16259241', 'f099589b-066f-4827-9679-3bf2d2ec28d2', '834e63d6-0dd9-4bfb-8383-ca6a06d731ef', '5a33bffb-ae85-402e-a4bf-81ab376d7744', '319396d0-cc7d-41f9-826c-71bccc8dade6', '9a38995c-94b7-4963-9605-5d27f868b5e7', 'bc32292c-0d19-452f-b970-1074c43fc864', '48de377c-4693-407b-93e6-3f0ea44b5009', '9e27fff9-15d3-4754-bb26-00779158d528', 'd73a5aef-251b-4a30-aadb-2dc973ef1607', '56535934-2a23-4e3e-b6d2-79121dd93005', 'a535c103-0cf8-4c46-b5ea-90c34aad90bc', '48aac7ed-f704-4d65-90bd-3b5b18adc127', '63b42edf-3546-4257-9046-ff3f4687a217', '749f6239-fec3-4893-8959-f641d6d551b3', '4a08aa0e-4e38-460d-90dc-34e3faca6784', '91cfa69e-7ca7-44f9-8795-bc710622af17', '817e7519-3853-450c-bb05-b3f6763d9cd4', '00e3e534-762a-477b-adf4-3d1dbe67b656', '03171c52-bf3d-4d27-bf93-bb2da4ba6d87', 'df37aeb5-0bfd-4fb1-960d-aad8a5ad11cd', '3cf6570c-25c8-4b28-82ec-6804026e844e']</code></pre>
<ul>
<li>총 23개 (parent document 수)의 uid가 생성됨</li>
<li>여기서 큰 청크로 분할하기 위한 <code>parent_text_splitter</code></li>
<li>더 작은 청크로 분할하기 위한 <code>child_text_splitter</code>를 정의한다.</li>
</ul>
<div id="b628cc77" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># RecursiveCharacterTextSplitter 객체를 생성한다.</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>parent_text_splitter <span class="op">=</span> RecursiveCharacterTextSplitter(chunk_size<span class="op">=</span><span class="dv">600</span>)</span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co"># 더 작은 청크를 생성하는 데 사용할 분할기</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>child_text_splitter <span class="op">=</span> RecursiveCharacterTextSplitter(chunk_size<span class="op">=</span><span class="dv">200</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>더 큰 Chunk인 Parent 문서를 생성한다.</p>
<div id="61793def" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>parent_docs <span class="op">=</span> []</span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="cf">for</span> i, doc <span class="kw">in</span> <span class="bu">enumerate</span>(docs):</span>
<span id="cb12-4"><a href="#cb12-4"></a>    <span class="co"># 현재 문서의 ID를 가져옵니다.</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>    _id <span class="op">=</span> doc_ids[i]</span>
<span id="cb12-6"><a href="#cb12-6"></a>    <span class="co"># 현재 문서를 하위 문서로 분할</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>    parent_doc <span class="op">=</span> parent_text_splitter.split_documents([doc])</span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a>    <span class="cf">for</span> _doc <span class="kw">in</span> parent_doc:</span>
<span id="cb12-10"><a href="#cb12-10"></a>        <span class="co"># metadata에 문서 ID 를 저장</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>        _doc.metadata[id_key] <span class="op">=</span> _id</span>
<span id="cb12-12"><a href="#cb12-12"></a>    parent_docs.extend(parent_doc)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li><code>parent_docs</code>에 기입된 <code>doc_id</code>를 확인한다.</li>
<li><code>doc</code>에는 parent doc(page단위 내용)이 담기고</li>
<li><code>parent_docs</code>에는 split chunk들이 담긴다.</li>
<li>위의 코드 청크가 parent doc과 split chunk들에게 동일한 id를 부여하는 기능을 한다.</li>
</ul>
<div id="0036bbe5" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a>child_docs <span class="op">=</span> []</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="cf">for</span> i, doc <span class="kw">in</span> <span class="bu">enumerate</span>(docs):</span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="co"># 현재 문서의 ID를 가져옵니다.</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>    _id <span class="op">=</span> doc_ids[i]</span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="co"># 현재 문서를 하위 문서로 분할</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>    child_doc <span class="op">=</span> child_text_splitter.split_documents([doc])</span>
<span id="cb13-7"><a href="#cb13-7"></a>    <span class="cf">for</span> _doc <span class="kw">in</span> child_doc:</span>
<span id="cb13-8"><a href="#cb13-8"></a>        <span class="co"># metadata에 문서 ID 를 저장</span></span>
<span id="cb13-9"><a href="#cb13-9"></a>        _doc.metadata[id_key] <span class="op">=</span> _id</span>
<span id="cb13-10"><a href="#cb13-10"></a>    child_docs.extend(child_doc)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li><code>child_docs</code>에 기입된 <code>doc_id</code>를 확인한다.</li>
<li>상대적으로 더 작은 Chunk인 Child 문서를 생성한다.</li>
</ul>
<div id="acba34cc" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="co"># 생성된 Child 문서의 메타데이터를 확인한다.</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>child_docs[<span class="dv">0</span>].metadata</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>{‘source’: ‘data/SPRI_AI_Brief_2023년12월호_F.pdf’, ‘file_path’: ‘data/SPRI_AI_Brief_2023년12월호_F.pdf’, ‘page’: 0, ‘total_pages’: 23, ‘format’: ‘PDF 1.4’, ‘title’: ’‘, ’author’: ‘dj’, ‘subject’: ’‘, ’keywords’: ’‘, ’creator’: ‘Hwp 2018 10.0.0.13462’, ‘producer’: ‘Hancom PDF 1.3.0.542’, ‘creationDate’: “D:20231208132838+09’00’”, ‘modDate’: “D:20231208132838+09’00’”, ‘trapped’: ’‘, ’doc_id’: ‘ff65f8d8-376d-47d2-bbc0-eae1f7e3c381’}</p>
<p>각각 분할된 청크의 수를 확인한다.</p>
<div id="02e43a3e" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="bu">print</span>(<span class="ss">f"분할된 parent_docs의 개수: </span><span class="sc">{</span><span class="bu">len</span>(parent_docs)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="bu">print</span>(<span class="ss">f"분할된 child_docs의 개수: </span><span class="sc">{</span><span class="bu">len</span>(child_docs)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>분할된 parent_docs의 개수: 74
분할된 child_docs의 개수: 443</code></pre>
<ul>
<li>보통 표준적인 MultiVectorRetriever 사용법</li>
</ul>
<pre><code># 정상적인 방법
retriever.vectorstore.add_documents(child_docs)   # 검색용: 작은 청크만
retriever.docstore.mset(zip(doc_ids, parent_docs)) # 반환용: 큰 청크

# VectorStore: child_docs (443개) - 검색에 사용
# DocStore: parent_docs (74개) - 반환에 사용</code></pre>
<ul>
<li>하지만, 더 유연하게 구성을 가져갈 수도 있다.
<ul>
<li>벡터저장소엔 parent_docs와 child_docs를 저장하고</li>
<li>docstore엔 문서 원본을 저장한다.</li>
<li>벡터저장소에 새롭게 생성한 작게 쪼개진 하위문서 집합을 추가한다.</li>
<li>다음으로는 상위 문서는 생성한 UUID와 맵핑하여 <code>docstore</code>에 추가한다.</li>
<li><code>mset()</code> 메소드를 통해 문서 ID와 문서 내용을 key-value 쌍으로 문서 저장소에 저장한다.</li>
</ul></li>
</ul>
<div id="c448ad5d" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a><span class="co"># 벡터 저장소에 parent + child 문서를 추가</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>retriever.vectorstore.add_documents(parent_docs)</span>
<span id="cb18-3"><a href="#cb18-3"></a>retriever.vectorstore.add_documents(child_docs)</span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="co"># docstore 에 원본 문서를 저장</span></span>
<span id="cb18-6"><a href="#cb18-6"></a>retriever.docstore.mset(<span class="bu">list</span>(<span class="bu">zip</span>(doc_ids, docs)))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>유사도 검색을 수행한다. 가장 유사도가 높은 첫 번째 문서 조각을 출력한다.</p>
<p>여기서 <code>retriever.vectorstore.similarity_search</code> 메소드는 child + parent 문서 chunk 내에서 검색을 수행한다.</p>
<div id="da3e17fc" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="co"># vectorstore의 유사도 검색을 수행한다. </span></span>
<span id="cb19-2"><a href="#cb19-2"></a>relevant_chunks <span class="op">=</span> retriever.vectorstore.similarity_search(</span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="st">"삼성전자가 만든 생성형 AI 의 이름은?"</span></span>
<span id="cb19-4"><a href="#cb19-4"></a>)</span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="bu">print</span>(<span class="ss">f"검색된 문서의 개수: </span><span class="sc">{</span><span class="bu">len</span>(relevant_chunks)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>검색된 문서의 개수: 4</code></pre>
<ul>
<li>잘게 쪼개진 chunk들에서 검색을 하고 싶으면 <code>retriever.vectorstore</code> 에서 유사도 검색 수행</li>
</ul>
<div id="3c78e325" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a><span class="cf">for</span> chunk <span class="kw">in</span> relevant_chunks:</span>
<span id="cb21-2"><a href="#cb21-2"></a>    <span class="bu">print</span>(chunk.page_content, end<span class="op">=</span><span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb21-3"><a href="#cb21-3"></a>    <span class="bu">print</span>(<span class="st">"&gt;"</span> <span class="op">*</span> <span class="dv">100</span>, end<span class="op">=</span><span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>☞ 출처 : 삼성전자, ‘삼성 AI 포럼’서 자체 개발 생성형 AI ‘삼성 가우스’ 공개, 2023.11.08.
삼성전자, ‘삼성 개발자 콘퍼런스 코리아 2023’ 개최, 2023.11.14.
TechRepublic, Samsung Gauss: Samsung Research Reveals Generative AI, 2023.11.08.

&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

SPRi AI Brief |  
2023-12월호
10
삼성전자, 자체 개발 생성 AI ‘삼성 가우스’ 공개
n 삼성전자가 온디바이스에서 작동 가능하며 언어, 코드, 이미지의 3개 모델로 구성된 자체 개발 생성 
AI 모델 ‘삼성 가우스’를 공개
n 삼성전자는 삼성 가우스를 다양한 제품에 단계적으로 탑재할 계획으로, 온디바이스 작동이 가능한

&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

▹ 삼성전자, 자체 개발 생성 AI ‘삼성 가우스’ 공개 ··························································· 10
   ▹ 구글, 앤스로픽에 20억 달러 투자로 생성 AI 협력 강화 ················································ 11

&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

SPRi AI Brief |  
2023-12월호
10
삼성전자, 자체 개발 생성 AI ‘삼성 가우스’ 공개
n 삼성전자가 온디바이스에서 작동 가능하며 언어, 코드, 이미지의 3개 모델로 구성된 자체 개발 생성 
AI 모델 ‘삼성 가우스’를 공개
n 삼성전자는 삼성 가우스를 다양한 제품에 단계적으로 탑재할 계획으로, 온디바이스 작동이 가능한 
삼성 가우스는 외부로 사용자 정보가 유출될 위험이 없다는 장점을 보유
KEY Contents
£ 언어, 코드, 이미지의 3개 모델로 구성된 삼성 가우스, 온디바이스 작동 지원
n 삼성전자가 2023년 11월 8일 열린 ‘삼성 AI 포럼 2023’ 행사에서 자체 개발한 생성 AI 모델 
‘삼성 가우스’를 최초 공개
∙정규분포 이론을 정립한 천재 수학자 가우스(Gauss)의 이름을 본뜬 삼성 가우스는 다양한 상황에 
최적화된 크기의 모델 선택이 가능
∙삼성 가우스는 라이선스나 개인정보를 침해하지 않는 안전한 데이터를 통해 학습되었으며, 
온디바이스에서 작동하도록 설계되어 외부로 사용자의 정보가 유출되지 않는 장점을 보유
∙삼성전자는 삼성 가우스를 활용한 온디바이스 AI 기술도 소개했으며, 생성 AI 모델을 다양한 제품에

&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code></pre>
<p>이번에는 <code>retriever.invoke()</code> 메소드를 사용하여 쿼리를 실행한다.</p>
<p><code>retriever.invoke()</code> 메소드는 원본 문서의 전체 내용을 검색한다.</p>
<ul>
<li>잘게 쪼개진 chunk들의 parent_doc에서 검색을 하고 싶으면 <code>retriever</code> 에서 유사도 검색 수행</li>
<li>parent와 child는 상대적인 개념으로 parent가 반드시 가공전 원본 문서를 의미하지는 않는다.</li>
</ul>
<div id="da3ba568" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a>relevant_docs <span class="op">=</span> retriever.invoke(<span class="st">"삼성전자가 만든 생성형 AI 의 이름은?"</span>)</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="bu">print</span>(<span class="ss">f"검색된 문서의 개수: </span><span class="sc">{</span><span class="bu">len</span>(relevant_docs)<span class="sc">}</span><span class="ss">"</span>, end<span class="op">=</span><span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="bu">print</span>(<span class="st">"="</span> <span class="op">*</span> <span class="dv">100</span>, end<span class="op">=</span><span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="bu">print</span>(relevant_docs[<span class="dv">0</span>].page_content)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>검색된 문서의 개수: 2

====================================================================================================

SPRi AI Brief |  
2023-12월호
10
삼성전자, 자체 개발 생성 AI ‘삼성 가우스’ 공개
n 삼성전자가 온디바이스에서 작동 가능하며 언어, 코드, 이미지의 3개 모델로 구성된 자체 개발 생성 
AI 모델 ‘삼성 가우스’를 공개
n 삼성전자는 삼성 가우스를 다양한 제품에 단계적으로 탑재할 계획으로, 온디바이스 작동이 가능한 
삼성 가우스는 외부로 사용자 정보가 유출될 위험이 없다는 장점을 보유
KEY Contents
£ 언어, 코드, 이미지의 3개 모델로 구성된 삼성 가우스, 온디바이스 작동 지원
n 삼성전자가 2023년 11월 8일 열린 ‘삼성 AI 포럼 2023’ 행사에서 자체 개발한 생성 AI 모델 
‘삼성 가우스’를 최초 공개
∙정규분포 이론을 정립한 천재 수학자 가우스(Gauss)의 이름을 본뜬 삼성 가우스는 다양한 상황에 
최적화된 크기의 모델 선택이 가능
∙삼성 가우스는 라이선스나 개인정보를 침해하지 않는 안전한 데이터를 통해 학습되었으며, 
온디바이스에서 작동하도록 설계되어 외부로 사용자의 정보가 유출되지 않는 장점을 보유
∙삼성전자는 삼성 가우스를 활용한 온디바이스 AI 기술도 소개했으며, 생성 AI 모델을 다양한 제품에 
단계적으로 탑재할 계획
n 삼성 가우스는 △텍스트를 생성하는 언어모델 △코드를 생성하는 코드 모델 △이미지를 생성하는 
이미지 모델의 3개 모델로 구성
∙언어 모델은 클라우드와 온디바이스 대상 다양한 모델로 구성되며, 메일 작성, 문서 요약, 번역 업무의 
처리를 지원
∙코드 모델 기반의 AI 코딩 어시스턴트 ‘코드아이(code.i)’는 대화형 인터페이스로 서비스를 제공하며 
사내 소프트웨어 개발에 최적화
∙이미지 모델은 창의적인 이미지를 생성하고 기존 이미지를 원하는 대로 바꿀 수 있도록 지원하며 
저해상도 이미지의 고해상도 전환도 지원
n IT 전문지 테크리퍼블릭(TechRepublic)은 온디바이스 AI가 주요 기술 트렌드로 부상했다며, 
2024년부터 가우스를 탑재한 삼성 스마트폰이 메타의 라마(Llama)2를 탑재한 퀄컴 기기 및 구글 
어시스턴트를 적용한 구글 픽셀(Pixel)과 경쟁할 것으로 예상
☞ 출처 : 삼성전자, ‘삼성 AI 포럼’서 자체 개발 생성형 AI ‘삼성 가우스’ 공개, 2023.11.08.
삼성전자, ‘삼성 개발자 콘퍼런스 코리아 2023’ 개최, 2023.11.14.
TechRepublic, Samsung Gauss: Samsung Research Reveals Generative AI, 2023.11.08.</code></pre>
<ul>
<li>리트리버(retriever)가 벡터 데이터베이스에서 기본적으로 수행하는 검색 유형은 유사도 검색이다.</li>
<li>LangChain Vector Stores는 <a href="https://api.python.langchain.com/en/latest/vectorstores/langchain_core.vectorstores.VectorStore.html#langchain_core.vectorstores.VectorStore.max_marginal_relevance_search">Max Marginal Relevance</a>를 통한 검색도 지원하므로, 이를 대신 사용하고 싶다면 다음과 같이 <code>search_type</code> 속성을 설정하면 된다.</li>
<li><code>retriever</code> 객체의 <code>search_type</code> 속성을 <code>SearchType.mmr</code>로 설정한다.
<ul>
<li>이는 검색 시 MMR(Maximal Marginal Relevance) 알고리즘을 사용하도록 지정하는 것</li>
</ul></li>
</ul>
<div id="0028b464" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a><span class="im">from</span> langchain.retrievers.multi_vector <span class="im">import</span> SearchType</span>
<span id="cb25-2"><a href="#cb25-2"></a></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="co"># 검색 유형을 MMR(Maximal Marginal Relevance)로 설정</span></span>
<span id="cb25-4"><a href="#cb25-4"></a>retriever.search_type <span class="op">=</span> SearchType.mmr</span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="co"># 관련 문서 전체를 검색</span></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="bu">print</span>(retriever.invoke(<span class="st">"삼성전자가 만든 생성형 AI 의 이름은?"</span>)[<span class="dv">0</span>].page_content)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>SPRi AI Brief |  
2023-12월호
10
삼성전자, 자체 개발 생성 AI ‘삼성 가우스’ 공개
n 삼성전자가 온디바이스에서 작동 가능하며 언어, 코드, 이미지의 3개 모델로 구성된 자체 개발 생성 
AI 모델 ‘삼성 가우스’를 공개
n 삼성전자는 삼성 가우스를 다양한 제품에 단계적으로 탑재할 계획으로, 온디바이스 작동이 가능한 
삼성 가우스는 외부로 사용자 정보가 유출될 위험이 없다는 장점을 보유
KEY Contents
£ 언어, 코드, 이미지의 3개 모델로 구성된 삼성 가우스, 온디바이스 작동 지원
n 삼성전자가 2023년 11월 8일 열린 ‘삼성 AI 포럼 2023’ 행사에서 자체 개발한 생성 AI 모델 
‘삼성 가우스’를 최초 공개
∙정규분포 이론을 정립한 천재 수학자 가우스(Gauss)의 이름을 본뜬 삼성 가우스는 다양한 상황에 
최적화된 크기의 모델 선택이 가능
∙삼성 가우스는 라이선스나 개인정보를 침해하지 않는 안전한 데이터를 통해 학습되었으며, 
온디바이스에서 작동하도록 설계되어 외부로 사용자의 정보가 유출되지 않는 장점을 보유
∙삼성전자는 삼성 가우스를 활용한 온디바이스 AI 기술도 소개했으며, 생성 AI 모델을 다양한 제품에 
단계적으로 탑재할 계획
n 삼성 가우스는 △텍스트를 생성하는 언어모델 △코드를 생성하는 코드 모델 △이미지를 생성하는 
이미지 모델의 3개 모델로 구성
∙언어 모델은 클라우드와 온디바이스 대상 다양한 모델로 구성되며, 메일 작성, 문서 요약, 번역 업무의 
처리를 지원
∙코드 모델 기반의 AI 코딩 어시스턴트 ‘코드아이(code.i)’는 대화형 인터페이스로 서비스를 제공하며 
사내 소프트웨어 개발에 최적화
∙이미지 모델은 창의적인 이미지를 생성하고 기존 이미지를 원하는 대로 바꿀 수 있도록 지원하며 
저해상도 이미지의 고해상도 전환도 지원
n IT 전문지 테크리퍼블릭(TechRepublic)은 온디바이스 AI가 주요 기술 트렌드로 부상했다며, 
2024년부터 가우스를 탑재한 삼성 스마트폰이 메타의 라마(Llama)2를 탑재한 퀄컴 기기 및 구글 
어시스턴트를 적용한 구글 픽셀(Pixel)과 경쟁할 것으로 예상
☞ 출처 : 삼성전자, ‘삼성 AI 포럼’서 자체 개발 생성형 AI ‘삼성 가우스’ 공개, 2023.11.08.
삼성전자, ‘삼성 개발자 콘퍼런스 코리아 2023’ 개최, 2023.11.14.
TechRepublic, Samsung Gauss: Samsung Research Reveals Generative AI, 2023.11.08.</code></pre>
<div id="521820a6" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a><span class="im">from</span> langchain.retrievers.multi_vector <span class="im">import</span> SearchType</span>
<span id="cb27-2"><a href="#cb27-2"></a></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="co"># 검색 유형을 similarity_score_threshold로 설정</span></span>
<span id="cb27-4"><a href="#cb27-4"></a>retriever.search_type <span class="op">=</span> SearchType.similarity_score_threshold</span>
<span id="cb27-5"><a href="#cb27-5"></a>retriever.search_kwargs <span class="op">=</span> {<span class="st">"score_threshold"</span>: <span class="fl">0.3</span>}</span>
<span id="cb27-6"><a href="#cb27-6"></a></span>
<span id="cb27-7"><a href="#cb27-7"></a><span class="co"># 관련 문서 전체를 검색</span></span>
<span id="cb27-8"><a href="#cb27-8"></a><span class="bu">print</span>(retriever.invoke(<span class="st">"삼성전자가 만든 생성형 AI 의 이름은?"</span>)[<span class="dv">0</span>].page_content)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>SPRi AI Brief |  
2023-12월호
10
삼성전자, 자체 개발 생성 AI ‘삼성 가우스’ 공개
n 삼성전자가 온디바이스에서 작동 가능하며 언어, 코드, 이미지의 3개 모델로 구성된 자체 개발 생성 
AI 모델 ‘삼성 가우스’를 공개
n 삼성전자는 삼성 가우스를 다양한 제품에 단계적으로 탑재할 계획으로, 온디바이스 작동이 가능한 
삼성 가우스는 외부로 사용자 정보가 유출될 위험이 없다는 장점을 보유
KEY Contents
£ 언어, 코드, 이미지의 3개 모델로 구성된 삼성 가우스, 온디바이스 작동 지원
n 삼성전자가 2023년 11월 8일 열린 ‘삼성 AI 포럼 2023’ 행사에서 자체 개발한 생성 AI 모델 
‘삼성 가우스’를 최초 공개
∙정규분포 이론을 정립한 천재 수학자 가우스(Gauss)의 이름을 본뜬 삼성 가우스는 다양한 상황에 
최적화된 크기의 모델 선택이 가능
∙삼성 가우스는 라이선스나 개인정보를 침해하지 않는 안전한 데이터를 통해 학습되었으며, 
온디바이스에서 작동하도록 설계되어 외부로 사용자의 정보가 유출되지 않는 장점을 보유
∙삼성전자는 삼성 가우스를 활용한 온디바이스 AI 기술도 소개했으며, 생성 AI 모델을 다양한 제품에 
단계적으로 탑재할 계획
n 삼성 가우스는 △텍스트를 생성하는 언어모델 △코드를 생성하는 코드 모델 △이미지를 생성하는 
이미지 모델의 3개 모델로 구성
∙언어 모델은 클라우드와 온디바이스 대상 다양한 모델로 구성되며, 메일 작성, 문서 요약, 번역 업무의 
처리를 지원
∙코드 모델 기반의 AI 코딩 어시스턴트 ‘코드아이(code.i)’는 대화형 인터페이스로 서비스를 제공하며 
사내 소프트웨어 개발에 최적화
∙이미지 모델은 창의적인 이미지를 생성하고 기존 이미지를 원하는 대로 바꿀 수 있도록 지원하며 
저해상도 이미지의 고해상도 전환도 지원
n IT 전문지 테크리퍼블릭(TechRepublic)은 온디바이스 AI가 주요 기술 트렌드로 부상했다며, 
2024년부터 가우스를 탑재한 삼성 스마트폰이 메타의 라마(Llama)2를 탑재한 퀄컴 기기 및 구글 
어시스턴트를 적용한 구글 픽셀(Pixel)과 경쟁할 것으로 예상
☞ 출처 : 삼성전자, ‘삼성 AI 포럼’서 자체 개발 생성형 AI ‘삼성 가우스’ 공개, 2023.11.08.
삼성전자, ‘삼성 개발자 콘퍼런스 코리아 2023’ 개최, 2023.11.14.
TechRepublic, Samsung Gauss: Samsung Research Reveals Generative AI, 2023.11.08.</code></pre>
<div id="ecdf1d3c" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a><span class="im">from</span> langchain.retrievers.multi_vector <span class="im">import</span> SearchType</span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="co"># 검색 유형을 similarity로 설정, k값을 1로 설정</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>retriever.search_type <span class="op">=</span> SearchType.similarity</span>
<span id="cb29-5"><a href="#cb29-5"></a>retriever.search_kwargs <span class="op">=</span> {<span class="st">"k"</span>: <span class="dv">1</span>}</span>
<span id="cb29-6"><a href="#cb29-6"></a></span>
<span id="cb29-7"><a href="#cb29-7"></a><span class="co"># 관련 문서 전체를 검색</span></span>
<span id="cb29-8"><a href="#cb29-8"></a><span class="bu">print</span>(<span class="bu">len</span>(retriever.invoke(<span class="st">"삼성전자가 만든 생성형 AI 의 이름은?"</span>)))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>1</code></pre>
</section>
<section id="요약본summary을-벡터저장소에-저장" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="요약본summary을-벡터저장소에-저장"><span class="header-section-number">1.6</span> 요약본(summary)을 벡터저장소에 저장</h2>
<ul>
<li>요약은 종종 청크(chunk)의 내용을 보다 정확하게 추출할 수 있어 더 나은 검색 결과를 얻을 수 있다.</li>
<li>요약은 핵심 내용만을 담고 있어 LLM의 할루시네이션을 방지할 수 있다.</li>
<li>여기서는 요약을 생성하는 방법과 이를 임베딩하는 방법에 대해 설명한다.</li>
</ul>
<div id="76c57a34" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1"></a><span class="co"># PDF 파일을 로드하고 텍스트를 분할하기 위한 라이브러리 임포트</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="im">from</span> langchain_community.document_loaders <span class="im">import</span> PyMuPDFLoader</span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="im">from</span> langchain_text_splitters <span class="im">import</span> RecursiveCharacterTextSplitter</span>
<span id="cb31-4"><a href="#cb31-4"></a></span>
<span id="cb31-5"><a href="#cb31-5"></a><span class="co"># PDF 파일 로더 초기화</span></span>
<span id="cb31-6"><a href="#cb31-6"></a>loader <span class="op">=</span> PyMuPDFLoader(<span class="st">"data/SPRI_AI_Brief_2023년12월호_F.pdf"</span>)</span>
<span id="cb31-7"><a href="#cb31-7"></a></span>
<span id="cb31-8"><a href="#cb31-8"></a><span class="co"># 텍스트 분할</span></span>
<span id="cb31-9"><a href="#cb31-9"></a>text_splitter <span class="op">=</span> RecursiveCharacterTextSplitter(chunk_size<span class="op">=</span><span class="dv">600</span>, chunk_overlap<span class="op">=</span><span class="dv">50</span>)</span>
<span id="cb31-10"><a href="#cb31-10"></a></span>
<span id="cb31-11"><a href="#cb31-11"></a><span class="co"># PDF 파일 로드 및 텍스트 분할 실행</span></span>
<span id="cb31-12"><a href="#cb31-12"></a>split_docs <span class="op">=</span> loader.load_and_split(text_splitter)</span>
<span id="cb31-13"><a href="#cb31-13"></a></span>
<span id="cb31-14"><a href="#cb31-14"></a><span class="co"># 분할된 문서의 개수 출력</span></span>
<span id="cb31-15"><a href="#cb31-15"></a><span class="bu">print</span>(<span class="ss">f"분할된 문서의 개수: </span><span class="sc">{</span><span class="bu">len</span>(split_docs)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>분할된 문서의 개수: 61</code></pre>
<div id="b3868e13" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1"></a><span class="im">from</span> langchain_core.documents <span class="im">import</span> Document</span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="im">from</span> langchain_core.output_parsers <span class="im">import</span> StrOutputParser</span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="im">from</span> langchain_core.prompts <span class="im">import</span> ChatPromptTemplate</span>
<span id="cb33-4"><a href="#cb33-4"></a><span class="im">from</span> langchain_openai <span class="im">import</span> ChatOpenAI</span>
<span id="cb33-5"><a href="#cb33-5"></a></span>
<span id="cb33-6"><a href="#cb33-6"></a></span>
<span id="cb33-7"><a href="#cb33-7"></a>summary_chain <span class="op">=</span> (</span>
<span id="cb33-8"><a href="#cb33-8"></a>    {<span class="st">"doc"</span>: <span class="kw">lambda</span> x: x.page_content}</span>
<span id="cb33-9"><a href="#cb33-9"></a>    <span class="co"># 문서 요약을 위한 프롬프트 템플릿 생성</span></span>
<span id="cb33-10"><a href="#cb33-10"></a>    <span class="op">|</span> ChatPromptTemplate.from_messages(</span>
<span id="cb33-11"><a href="#cb33-11"></a>        [</span>
<span id="cb33-12"><a href="#cb33-12"></a>            (<span class="st">"system"</span>, <span class="st">"You are an expert in summarizing documents in Korean."</span>),</span>
<span id="cb33-13"><a href="#cb33-13"></a>            (</span>
<span id="cb33-14"><a href="#cb33-14"></a>                <span class="st">"user"</span>,</span>
<span id="cb33-15"><a href="#cb33-15"></a>                <span class="st">"Summarize the following documents in 3 sentences in bullet points format.</span><span class="ch">\n\n</span><span class="sc">{doc}</span><span class="st">"</span>,</span>
<span id="cb33-16"><a href="#cb33-16"></a>            ),</span>
<span id="cb33-17"><a href="#cb33-17"></a>        ]</span>
<span id="cb33-18"><a href="#cb33-18"></a>    )</span>
<span id="cb33-19"><a href="#cb33-19"></a>    <span class="co"># OpenAI의 ChatGPT 모델을 사용하여 요약 생성</span></span>
<span id="cb33-20"><a href="#cb33-20"></a>    <span class="op">|</span> ChatOpenAI(temperature<span class="op">=</span><span class="dv">0</span>, model<span class="op">=</span><span class="st">"gpt-4o-mini"</span>)</span>
<span id="cb33-21"><a href="#cb33-21"></a>    <span class="op">|</span> StrOutputParser()</span>
<span id="cb33-22"><a href="#cb33-22"></a>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li><code>chain.batch</code> 메소드를 사용하여 <code>docs</code> 리스트의 문서들을 일괄 요약한다.</li>
<li>여기서 <code>max_concurrency</code> 매개변수를 10으로 설정하여 최대 10개의 문서를 동시에 처리할 수 있도록 한다.</li>
</ul>
<div id="ff0f5b42" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1"></a><span class="co"># 문서 배치 처리</span></span>
<span id="cb34-2"><a href="#cb34-2"></a>summaries <span class="op">=</span> summary_chain.batch(split_docs, {<span class="st">"max_concurrency"</span>: <span class="dv">10</span>})</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="45bcc928" class="cell" data-execution_count="22">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1"></a><span class="bu">len</span>(summaries)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>61</code></pre>
<ul>
<li>61개의 요약본이 생김</li>
<li>요약된 내용을 출력하여 결과를 확인한다.</li>
</ul>
<div id="6021ad31" class="cell" data-execution_count="23">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1"></a><span class="co"># 원본 문서의 내용을 출력한다.</span></span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="bu">print</span>(split_docs[<span class="dv">33</span>].page_content, end<span class="op">=</span><span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>)</span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="co"># 요약을 출력한다.</span></span>
<span id="cb37-4"><a href="#cb37-4"></a><span class="bu">print</span>(<span class="st">"[요약]"</span>)</span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="bu">print</span>(summaries[<span class="dv">33</span>])</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>SPRi AI Brief |  
2023-12월호
10
삼성전자, 자체 개발 생성 AI ‘삼성 가우스’ 공개
n 삼성전자가 온디바이스에서 작동 가능하며 언어, 코드, 이미지의 3개 모델로 구성된 자체 개발 생성 
AI 모델 ‘삼성 가우스’를 공개
n 삼성전자는 삼성 가우스를 다양한 제품에 단계적으로 탑재할 계획으로, 온디바이스 작동이 가능한 
삼성 가우스는 외부로 사용자 정보가 유출될 위험이 없다는 장점을 보유
KEY Contents
£ 언어, 코드, 이미지의 3개 모델로 구성된 삼성 가우스, 온디바이스 작동 지원
n 삼성전자가 2023년 11월 8일 열린 ‘삼성 AI 포럼 2023’ 행사에서 자체 개발한 생성 AI 모델 
‘삼성 가우스’를 최초 공개
∙정규분포 이론을 정립한 천재 수학자 가우스(Gauss)의 이름을 본뜬 삼성 가우스는 다양한 상황에 
최적화된 크기의 모델 선택이 가능
∙삼성 가우스는 라이선스나 개인정보를 침해하지 않는 안전한 데이터를 통해 학습되었으며, 
온디바이스에서 작동하도록 설계되어 외부로 사용자의 정보가 유출되지 않는 장점을 보유
∙삼성전자는 삼성 가우스를 활용한 온디바이스 AI 기술도 소개했으며, 생성 AI 모델을 다양한 제품에

[요약]
- 삼성전자가 온디바이스에서 작동 가능한 생성 AI 모델 '삼성 가우스'를 공개하였으며, 이 모델은 언어, 코드, 이미지의 3개 모델로 구성되어 있다.
- '삼성 가우스'는 정규분포 이론을 정립한 수학자 가우스의 이름을 따왔으며, 다양한 상황에 최적화된 모델 선택이 가능하다.
- 삼성전자는 이 AI 모델이 사용자 정보를 외부로 유출하지 않도록 설계되었으며, 향후 다양한 제품에 단계적으로 탑재할 계획이다.</code></pre>
<ul>
<li><code>Chroma</code> 벡터 저장소를 초기화하여 자식 청크(child chunks)를 인덱싱한다. 이때 <code>OpenAIEmbeddings</code>를 임베딩 함수로 사용한다.</li>
<li>문서 ID를 나타내는 키로 <code>"doc_id"</code>를 사용한다.</li>
</ul>
<div id="93046137" class="cell" data-execution_count="24">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1"></a><span class="im">import</span> uuid</span>
<span id="cb39-2"><a href="#cb39-2"></a></span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="co"># 요약 정보를 저장할 벡터 저장소를 생성한다.</span></span>
<span id="cb39-4"><a href="#cb39-4"></a>summary_vectorstore <span class="op">=</span> Chroma(</span>
<span id="cb39-5"><a href="#cb39-5"></a>    collection_name<span class="op">=</span><span class="st">"summaries"</span>,</span>
<span id="cb39-6"><a href="#cb39-6"></a>    embedding_function<span class="op">=</span>OpenAIEmbeddings(model<span class="op">=</span><span class="st">"text-embedding-3-small"</span>),</span>
<span id="cb39-7"><a href="#cb39-7"></a>)</span>
<span id="cb39-8"><a href="#cb39-8"></a></span>
<span id="cb39-9"><a href="#cb39-9"></a><span class="co"># 부모 문서를 저장할 저장소를 생성한다.</span></span>
<span id="cb39-10"><a href="#cb39-10"></a>store <span class="op">=</span> InMemoryStore()</span>
<span id="cb39-11"><a href="#cb39-11"></a></span>
<span id="cb39-12"><a href="#cb39-12"></a><span class="co"># 문서 ID를 저장할 키 이름을 지정한다.</span></span>
<span id="cb39-13"><a href="#cb39-13"></a>id_key <span class="op">=</span> <span class="st">"doc_id"</span></span>
<span id="cb39-14"><a href="#cb39-14"></a></span>
<span id="cb39-15"><a href="#cb39-15"></a><span class="co"># 검색기를 초기화한다. (시작 시 비어 있음)</span></span>
<span id="cb39-16"><a href="#cb39-16"></a>retriever <span class="op">=</span> MultiVectorRetriever(</span>
<span id="cb39-17"><a href="#cb39-17"></a>    vectorstore<span class="op">=</span>summary_vectorstore,  <span class="co"># 벡터 저장소</span></span>
<span id="cb39-18"><a href="#cb39-18"></a>    byte_store<span class="op">=</span>store,  <span class="co"># 바이트 저장소</span></span>
<span id="cb39-19"><a href="#cb39-19"></a>    id_key<span class="op">=</span>id_key,  <span class="co"># 문서 ID 키</span></span>
<span id="cb39-20"><a href="#cb39-20"></a>)</span>
<span id="cb39-21"><a href="#cb39-21"></a><span class="co"># 문서 ID를 생성합니다.</span></span>
<span id="cb39-22"><a href="#cb39-22"></a>doc_ids <span class="op">=</span> [<span class="bu">str</span>(uuid.uuid4()) <span class="cf">for</span> _ <span class="kw">in</span> split_docs]</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>요약된 문서와 메타데이터(여기서는 생성한 요약본에 대한 <code>Document ID</code>이다)를 저장한다.</p>
<div id="1f35561f" class="cell" data-execution_count="25">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1"></a>summary_docs <span class="op">=</span> [</span>
<span id="cb40-2"><a href="#cb40-2"></a>    <span class="co"># 요약된 내용을 페이지 콘텐츠로 하고, 문서 ID를 메타데이터로 포함하는 Document 객체를 생성한다.</span></span>
<span id="cb40-3"><a href="#cb40-3"></a>    Document(page_content<span class="op">=</span>s, metadata<span class="op">=</span>{id_key: doc_ids[i]})</span>
<span id="cb40-4"><a href="#cb40-4"></a>    <span class="cf">for</span> i, s <span class="kw">in</span> <span class="bu">enumerate</span>(summaries)</span>
<span id="cb40-5"><a href="#cb40-5"></a>]</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>요약본의 문서의 개수는 원본 문서의 개수와 일치한다.</p>
<div id="adac7f8c" class="cell" data-execution_count="26">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1"></a><span class="co"># 요약본의 문서의 개수</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="bu">len</span>(summary_docs)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>61</code></pre>
<ul>
<li><code>retriever.vectorstore.add_documents(summary_docs)</code>를 통해 <code>summary_docs</code>를 벡터 저장소에 추가한다.</li>
<li><code>retriever.docstore.mset(list(zip(doc_ids, docs)))</code>를 사용하여 <code>doc_ids</code>와 <code>docs</code>를 매핑하여 문서 저장소에 저장한다.</li>
</ul>
<div id="ddffd951" class="cell" data-execution_count="27">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1"></a>retriever.vectorstore.add_documents(</span>
<span id="cb43-2"><a href="#cb43-2"></a>    summary_docs</span>
<span id="cb43-3"><a href="#cb43-3"></a>)  <span class="co"># 요약된 문서를 벡터 저장소에 추가한다.</span></span>
<span id="cb43-4"><a href="#cb43-4"></a></span>
<span id="cb43-5"><a href="#cb43-5"></a><span class="co"># 문서 ID와 문서를 매핑하여 문서 저장소에 저장합니다.</span></span>
<span id="cb43-6"><a href="#cb43-6"></a>retriever.docstore.mset(<span class="bu">list</span>(<span class="bu">zip</span>(doc_ids, split_docs)))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><code>vectorstore</code> 객체의 <code>similarity_search</code> 메소드를 사용하여 유사도 검색을 수행한다.</p>
<div id="4e8ce603" class="cell" data-execution_count="28">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1"></a><span class="co"># 유사도 검색을 수행한다.</span></span>
<span id="cb44-2"><a href="#cb44-2"></a>result_docs <span class="op">=</span> summary_vectorstore.similarity_search(</span>
<span id="cb44-3"><a href="#cb44-3"></a>    <span class="st">"삼성전자가 만든 생성형 AI 의 이름은?"</span></span>
<span id="cb44-4"><a href="#cb44-4"></a>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="84b66e0a" class="cell" data-execution_count="29">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1"></a><span class="co"># 1개의 결과 문서를 출력한다. (요약본)</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="bu">print</span>(result_docs[<span class="dv">0</span>].page_content)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>- 삼성전자가 온디바이스에서 작동 가능한 생성 AI 모델 '삼성 가우스'를 공개하였으며, 이 모델은 언어, 코드, 이미지의 3개 모델로 구성되어 있다.
- '삼성 가우스'는 정규분포 이론을 정립한 수학자 가우스의 이름을 따왔으며, 다양한 상황에 최적화된 모델 선택이 가능하다.
- 삼성전자는 이 AI 모델이 사용자 정보를 외부로 유출하지 않도록 설계되었으며, 향후 다양한 제품에 단계적으로 탑재할 계획이다.</code></pre>
<p><code>retriever</code> 객체의 <code>invoke()</code> 사용하여 질문과 관련된 문서를 검색한다.</p>
<div id="089b508b" class="cell" data-execution_count="30">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1"></a><span class="co"># 관련된 원본 문서를 검색하여 가져옵니다.</span></span>
<span id="cb47-2"><a href="#cb47-2"></a>retrieved_docs <span class="op">=</span> retriever.invoke(<span class="st">"삼성전자가 만든 생성형 AI 의 이름은?"</span>)</span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="bu">print</span>(retrieved_docs[<span class="dv">0</span>].page_content)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>SPRi AI Brief |  
2023-12월호
10
삼성전자, 자체 개발 생성 AI ‘삼성 가우스’ 공개
n 삼성전자가 온디바이스에서 작동 가능하며 언어, 코드, 이미지의 3개 모델로 구성된 자체 개발 생성 
AI 모델 ‘삼성 가우스’를 공개
n 삼성전자는 삼성 가우스를 다양한 제품에 단계적으로 탑재할 계획으로, 온디바이스 작동이 가능한 
삼성 가우스는 외부로 사용자 정보가 유출될 위험이 없다는 장점을 보유
KEY Contents
£ 언어, 코드, 이미지의 3개 모델로 구성된 삼성 가우스, 온디바이스 작동 지원
n 삼성전자가 2023년 11월 8일 열린 ‘삼성 AI 포럼 2023’ 행사에서 자체 개발한 생성 AI 모델 
‘삼성 가우스’를 최초 공개
∙정규분포 이론을 정립한 천재 수학자 가우스(Gauss)의 이름을 본뜬 삼성 가우스는 다양한 상황에 
최적화된 크기의 모델 선택이 가능
∙삼성 가우스는 라이선스나 개인정보를 침해하지 않는 안전한 데이터를 통해 학습되었으며, 
온디바이스에서 작동하도록 설계되어 외부로 사용자의 정보가 유출되지 않는 장점을 보유
∙삼성전자는 삼성 가우스를 활용한 온디바이스 AI 기술도 소개했으며, 생성 AI 모델을 다양한 제품에</code></pre>
</section>
<section id="가설-쿼리hypothetical-queries를-활용한-문서-탐색" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="가설-쿼리hypothetical-queries를-활용한-문서-탐색"><span class="header-section-number">1.7</span> 가설 쿼리(Hypothetical Queries)를 활용한 문서 탐색</h2>
<section id="핵심-아이디어" class="level3" data-number="1.7.1">
<h3 data-number="1.7.1" class="anchored" data-anchor-id="핵심-아이디어"><span class="header-section-number">1.7.1</span> 핵심 아이디어</h3>
<p><strong>사용자가 물어볼 만한 질문을 미리 생성해서 검색 인덱스로 활용</strong>하자는 전략이다.</p>
</section>
<section id="왜-효과적인가" class="level3" data-number="1.7.2">
<h3 data-number="1.7.2" class="anchored" data-anchor-id="왜-효과적인가"><span class="header-section-number">1.7.2</span> 왜 효과적인가?</h3>
<p><strong>1. 짧은 텍스트 간 매칭의 우수성</strong></p>
<p>일반적으로 다음과 같은 검색 성능 순서가 관찰된다: - <strong>질문 ↔︎ 질문</strong> (최고) &gt; 질문 ↔︎ 문단 &gt; 질문 ↔︎ 긴 문서 (최저)</p>
<p><strong>2. 임베딩 정보 손실 문제</strong></p>
<p>긴 문서를 임베딩할 때: 1. 문서 → 임베딩 과정에서 <strong>1차 정보 손실</strong> 2. 검색 매칭 과정에서 <strong>2차 정보 손실</strong></p>
<p>따라서 임베딩 대상을 짧게 유지하는 것이 정보 손실을 최소화한다.</p>
<p><strong>3. 가설 질문 방식의 장점</strong></p>
<pre><code>전통적 방식:
사용자 질문: "삼성의 AI 제품은?"
    ↓ (의미 공간에서 멀리 떨어짐)
원본 문서: "2023년 11월 8일 삼성전자가 삼성 AI 포럼에서..."

가설 질문 방식:
사용자 질문: "삼성의 AI 제품은?"
    ↓ (의미 공간에서 매우 가까움)
미리 생성한 질문: "삼성전자가 개발한 AI 기술은?"
    ↓ (ID로 연결)
원본 문서: "2023년 11월 8일 삼성전자가..."</code></pre>
<p><strong>질문 ↔︎ 질문</strong> 매칭이므로 의미적 유사도가 훨씬 높다.</p>
</section>
<section id="작동-원리" class="level3" data-number="1.7.3">
<h3 data-number="1.7.3" class="anchored" data-anchor-id="작동-원리"><span class="header-section-number">1.7.3</span> 작동 원리</h3>
<ol type="1">
<li><strong>문서마다 가상 질문 생성</strong> (LLM 활용)
<ul>
<li>문서 내용을 읽고 “이 문서로 답할 수 있는 질문”을 3~5개 생성</li>
</ul></li>
<li><strong>질문을 VectorStore에 저장</strong>
<ul>
<li>원본 문서는 DocStore에 보관</li>
<li>가상 질문들만 임베딩하여 검색 대상으로 활용</li>
</ul></li>
<li><strong>검색 시</strong>
<ul>
<li>사용자 질문 → 가상 질문들과 유사도 검색</li>
<li>매칭된 가상 질문의 ID로 원본 문서 반환</li>
</ul></li>
</ol>
</section>
<section id="장단점-분석" class="level3" data-number="1.7.4">
<h3 data-number="1.7.4" class="anchored" data-anchor-id="장단점-분석"><span class="header-section-number">1.7.4</span> 장단점 분석</h3>
<p><strong>장점:</strong> - 검색 정확도 향상: 질문-질문 매칭의 높은 의미 유사도 - 다양한 관점 포착: 한 문서에 대해 여러 각도의 질문 생성 가능 - 사용자 의도 파악 개선: 실제 사용자 질문 패턴과 유사</p>
<p><strong>단점:</strong> - 비용 증가: LLM으로 질문 생성 필요 (문서당 3~5개 질문) - 시간 소요: 인덱싱 시간 증가 - 질문 품질 의존: LLM이 생성한 질문의 품질에 성능 좌우</p>
<p><strong>언제 사용할까?</strong> - 사용자 질문 패턴이 명확할 때 (FAQ, 고객 지원 등) - 검색 품질이 매우 중요할 때 - 인덱싱 비용보다 검색 성능이 우선일 때</p>
<p><strong>언제 비추천?</strong> - 문서가 자주 변경될 때 (재생성 비용) - 실시간 인덱싱이 필요할 때 - 비용이 제약 조건일 때</p>
</section>
<section id="구현-예제" class="level3" data-number="1.7.5">
<h3 data-number="1.7.5" class="anchored" data-anchor-id="구현-예제"><span class="header-section-number">1.7.5</span> 구현 예제</h3>
<p>아래는 <code>Function Calling</code>을 활용하여 가설 질문을 생성하는 예제다.</p>
<div id="603c57db" class="cell" data-execution_count="31">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1"></a>functions <span class="op">=</span> [</span>
<span id="cb50-2"><a href="#cb50-2"></a>    {</span>
<span id="cb50-3"><a href="#cb50-3"></a>        <span class="st">"name"</span>: <span class="st">"hypothetical_questions"</span>,  <span class="co"># 함수의 이름을 지정한다.</span></span>
<span id="cb50-4"><a href="#cb50-4"></a>        <span class="st">"description"</span>: <span class="st">"Generate hypothetical questions"</span>,  <span class="co"># 함수에 대한 설명을 작성한다.</span></span>
<span id="cb50-5"><a href="#cb50-5"></a>        <span class="st">"parameters"</span>: {  <span class="co"># 함수의 매개변수를 정의한다.</span></span>
<span id="cb50-6"><a href="#cb50-6"></a>            <span class="st">"type"</span>: <span class="st">"object"</span>,  <span class="co"># 매개변수의 타입을 객체로 지정한다.</span></span>
<span id="cb50-7"><a href="#cb50-7"></a>            <span class="st">"properties"</span>: {  <span class="co"># 객체의 속성을 정의한다.</span></span>
<span id="cb50-8"><a href="#cb50-8"></a>                <span class="st">"questions"</span>: {  <span class="co"># 'questions' 속성을 정의한다.</span></span>
<span id="cb50-9"><a href="#cb50-9"></a>                    <span class="st">"type"</span>: <span class="st">"array"</span>,  <span class="co"># 'questions'의 타입을 배열로 지정합니다.</span></span>
<span id="cb50-10"><a href="#cb50-10"></a>                    <span class="st">"items"</span>: {</span>
<span id="cb50-11"><a href="#cb50-11"></a>                        <span class="st">"type"</span>: <span class="st">"string"</span></span>
<span id="cb50-12"><a href="#cb50-12"></a>                    },  <span class="co"># 배열의 요소 타입을 문자열로 지정합니다.</span></span>
<span id="cb50-13"><a href="#cb50-13"></a>                },</span>
<span id="cb50-14"><a href="#cb50-14"></a>            },</span>
<span id="cb50-15"><a href="#cb50-15"></a>            <span class="st">"required"</span>: [<span class="st">"questions"</span>],  <span class="co"># 필수 매개변수로 'questions'를 지정합니다.</span></span>
<span id="cb50-16"><a href="#cb50-16"></a>        },</span>
<span id="cb50-17"><a href="#cb50-17"></a>    }</span>
<span id="cb50-18"><a href="#cb50-18"></a>]</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><code>ChatPromptTemplate</code>을 사용하여 주어진 문서를 기반으로 3개의 가상 질문을 생성하는 프롬프트 템플릿을 정의한다.</p>
<ul>
<li><code>functions</code>와 <code>function_call</code>을 설정하여 가상 질문 생성 함수를 호출한다.</li>
<li><code>JsonKeyOutputFunctionsParser</code>를 사용하여 생성된 가상 질문을 파싱하고, <code>questions</code> 키에 해당하는 값을 추출한다.</li>
</ul>
<div id="6f23a91f" class="cell" data-execution_count="32">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1"></a><span class="im">from</span> langchain_core.prompts <span class="im">import</span> ChatPromptTemplate</span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="im">from</span> langchain.output_parsers.openai_functions <span class="im">import</span> JsonKeyOutputFunctionsParser</span>
<span id="cb51-3"><a href="#cb51-3"></a><span class="im">from</span> langchain_openai <span class="im">import</span> ChatOpenAI</span>
<span id="cb51-4"><a href="#cb51-4"></a></span>
<span id="cb51-5"><a href="#cb51-5"></a>hypothetical_query_chain <span class="op">=</span> (</span>
<span id="cb51-6"><a href="#cb51-6"></a>    {<span class="st">"doc"</span>: <span class="kw">lambda</span> x: x.page_content}</span>
<span id="cb51-7"><a href="#cb51-7"></a>    <span class="co"># 아래 문서를 사용하여 답변할 수 있는 가상의 질문을 정확히 3개 생성하도록 요청합니다. 이 숫자는 조정될 수 있습니다.</span></span>
<span id="cb51-8"><a href="#cb51-8"></a>    <span class="op">|</span> ChatPromptTemplate.from_template(</span>
<span id="cb51-9"><a href="#cb51-9"></a>        <span class="st">"Generate a list of exactly 3 hypothetical questions that the below document could be used to answer. "</span></span>
<span id="cb51-10"><a href="#cb51-10"></a>        <span class="st">"Potential users are those interested in the AI industry. Create questions that they would be interested in. "</span></span>
<span id="cb51-11"><a href="#cb51-11"></a>        <span class="st">"Output should be written in Korean:</span><span class="ch">\n\n</span><span class="sc">{doc}</span><span class="st">"</span></span>
<span id="cb51-12"><a href="#cb51-12"></a>    )</span>
<span id="cb51-13"><a href="#cb51-13"></a>    <span class="op">|</span> ChatOpenAI(max_retries<span class="op">=</span><span class="dv">0</span>, model<span class="op">=</span><span class="st">"gpt-4o-mini"</span>).bind(</span>
<span id="cb51-14"><a href="#cb51-14"></a>        functions<span class="op">=</span>functions, function_call<span class="op">=</span>{<span class="st">"name"</span>: <span class="st">"hypothetical_questions"</span>}</span>
<span id="cb51-15"><a href="#cb51-15"></a>    )</span>
<span id="cb51-16"><a href="#cb51-16"></a>    <span class="co"># 출력에서 "questions" 키에 해당하는 값을 추출합니다.</span></span>
<span id="cb51-17"><a href="#cb51-17"></a>    <span class="op">|</span> JsonKeyOutputFunctionsParser(key_name<span class="op">=</span><span class="st">"questions"</span>)</span>
<span id="cb51-18"><a href="#cb51-18"></a>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>문서에 대한 답변을 출력 - 출력은 생성한 3개의 가설 쿼리(Hypothetical Queries) 가 담겨 있다.</p>
<div id="08d97008" class="cell" data-execution_count="33">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1"></a><span class="co"># 주어진 문서에 대해 체인을 실행합니다.</span></span>
<span id="cb52-2"><a href="#cb52-2"></a>hypothetical_query_chain.invoke(split_docs[<span class="dv">33</span>])</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>['삼성 가우스가 다른 생성 AI 모델에 비해 어떤 경쟁력을 가질 수 있을까?', '온디바이스 작동이 가능한 삼성 가우스가 개인 정보 보호에 미치는 영향은 무엇일까?', '삼성전자가 삼성 가우스를 다양한 제품에 단계적으로 탑재하려는 이유는 무엇일까?']</code></pre>
<p><code>chain.batch</code> 메소드를 사용하여 <code>split_docs</code> 데이터에 대해 동시에 여러 개의 요청을 처리한다.</p>
<div id="a34963da" class="cell" data-execution_count="34">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1"></a><span class="co"># 문서 목록에 대해 가설 질문을 배치 생성</span></span>
<span id="cb54-2"><a href="#cb54-2"></a>hypothetical_questions <span class="op">=</span> hypothetical_query_chain.batch(</span>
<span id="cb54-3"><a href="#cb54-3"></a>    split_docs, {<span class="st">"max_concurrency"</span>: <span class="dv">10</span>}</span>
<span id="cb54-4"><a href="#cb54-4"></a>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="0cfc26e9" class="cell" data-execution_count="35">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1"></a>hypothetical_questions[<span class="dv">33</span>]</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>['삼성 가우스가 다른 생성 AI 모델과 비교했을 때, 사용자 개인 정보 보호에 있어 어떤 장점을 제공할까요?', '삼성전자가 삼성 가우스를 다양한 제품에 탑재하기로 결정한 이유는 무엇일까요?', '온디바이스에서 작동하는 삼성 가우스의 기능이 AI 산업의 미래에 어떤 영향을 미칠까요?']</code></pre>
<p>생성한 가설 쿼리(Hypothetical Queries)를 벡터저장소에 저장하는 과정이다.</p>
<div id="66f16a87" class="cell" data-execution_count="36">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1"></a><span class="co"># 자식 청크를 인덱싱하는 데 사용할 벡터 저장소</span></span>
<span id="cb57-2"><a href="#cb57-2"></a>hypothetical_vectorstore <span class="op">=</span> Chroma(</span>
<span id="cb57-3"><a href="#cb57-3"></a>    collection_name<span class="op">=</span><span class="st">"hypo-questions"</span>, embedding_function<span class="op">=</span>OpenAIEmbeddings()</span>
<span id="cb57-4"><a href="#cb57-4"></a>)</span>
<span id="cb57-5"><a href="#cb57-5"></a><span class="co"># 부모 문서의 저장소 계층</span></span>
<span id="cb57-6"><a href="#cb57-6"></a>store <span class="op">=</span> InMemoryStore()</span>
<span id="cb57-7"><a href="#cb57-7"></a></span>
<span id="cb57-8"><a href="#cb57-8"></a>id_key <span class="op">=</span> <span class="st">"doc_id"</span></span>
<span id="cb57-9"><a href="#cb57-9"></a><span class="co"># 검색기 (시작 시 비어 있음)</span></span>
<span id="cb57-10"><a href="#cb57-10"></a>retriever <span class="op">=</span> MultiVectorRetriever(</span>
<span id="cb57-11"><a href="#cb57-11"></a>    vectorstore<span class="op">=</span>hypothetical_vectorstore,</span>
<span id="cb57-12"><a href="#cb57-12"></a>    byte_store<span class="op">=</span>store,</span>
<span id="cb57-13"><a href="#cb57-13"></a>    id_key<span class="op">=</span>id_key,</span>
<span id="cb57-14"><a href="#cb57-14"></a>)</span>
<span id="cb57-15"><a href="#cb57-15"></a>doc_ids <span class="op">=</span> [<span class="bu">str</span>(uuid.uuid4()) <span class="cf">for</span> _ <span class="kw">in</span> split_docs]  <span class="co"># 문서 ID 생성</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><code>question_docs</code> 리스트에 메타데이터(문서 ID)를 추가한다.</p>
<div id="ce99cbf1" class="cell" data-execution_count="37">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1"></a>question_docs <span class="op">=</span> []</span>
<span id="cb58-2"><a href="#cb58-2"></a><span class="co"># hypothetical_questions 저장</span></span>
<span id="cb58-3"><a href="#cb58-3"></a><span class="cf">for</span> i, question_list <span class="kw">in</span> <span class="bu">enumerate</span>(hypothetical_questions):</span>
<span id="cb58-4"><a href="#cb58-4"></a>    question_docs.extend(</span>
<span id="cb58-5"><a href="#cb58-5"></a>        <span class="co"># 질문 리스트의 각 질문에 대해 Document 객체를 생성하고, 메타데이터에 해당 질문의 문서 ID를 포함시킵니다.</span></span>
<span id="cb58-6"><a href="#cb58-6"></a>        [Document(page_content<span class="op">=</span>s, metadata<span class="op">=</span>{id_key: doc_ids[i]}) <span class="cf">for</span> s <span class="kw">in</span> question_list]</span>
<span id="cb58-7"><a href="#cb58-7"></a>    )</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>가설 쿼리를 문서에 추가하고, 원본 문서를 <code>docstore</code>에 추가한다.</p>
<div id="0c58733f" class="cell" data-execution_count="38">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1"></a><span class="co"># hypothetical_questions 문서를 벡터 저장소에 추가합니다.</span></span>
<span id="cb59-2"><a href="#cb59-2"></a>retriever.vectorstore.add_documents(question_docs)</span>
<span id="cb59-3"><a href="#cb59-3"></a></span>
<span id="cb59-4"><a href="#cb59-4"></a><span class="co"># 문서 ID와 문서를 매핑하여 문서 저장소에 저장합니다.</span></span>
<span id="cb59-5"><a href="#cb59-5"></a>retriever.docstore.mset(<span class="bu">list</span>(<span class="bu">zip</span>(doc_ids, split_docs)))</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><code>vectorstore</code> 객체의 <code>similarity_search</code> 메소드를 사용하여 유사도 검색을 수행한다.</p>
<div id="13b9a39a" class="cell" data-execution_count="39">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1"></a><span class="co"># 유사한 문서를 벡터 저장소에서 검색합니다.</span></span>
<span id="cb60-2"><a href="#cb60-2"></a>result_docs <span class="op">=</span> hypothetical_vectorstore.similarity_search(</span>
<span id="cb60-3"><a href="#cb60-3"></a>    <span class="st">"삼성전자가 만든 생성형 AI 의 이름은?"</span></span>
<span id="cb60-4"><a href="#cb60-4"></a>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>아래는 유사도 검색 결과를 확인한다.</p>
<p>여기서는 생성한 가설 쿼리만 추가해 놓은 상태이므로, 생성한 가설 쿼리 중 유사도가 가장 높은 문서를 반환한다.</p>
<div id="fcaf8ed7" class="cell" data-execution_count="40">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1"></a><span class="co"># 유사도 검색 결과를 출력한다.</span></span>
<span id="cb61-2"><a href="#cb61-2"></a><span class="cf">for</span> doc <span class="kw">in</span> result_docs:</span>
<span id="cb61-3"><a href="#cb61-3"></a>    <span class="bu">print</span>(doc.page_content)</span>
<span id="cb61-4"><a href="#cb61-4"></a>    <span class="bu">print</span>(doc.metadata)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>삼성전자가 AI 기술을 활용하여 개발한 새로운 제품이나 서비스는 무엇일까요?
{'doc_id': '61bcf671-1f5c-4d75-850e-42d4c88c2c87'}
삼성의 Generative AI 기술이 향후 AI 시장에서 어떤 경쟁력을 가질 것으로 예상되나요?
{'doc_id': '61bcf671-1f5c-4d75-850e-42d4c88c2c87'}
삼성 개발자 콘퍼런스 코리아 2023에서 발표된 내용이 AI 산업에 어떤 영향을 미칠까요?
{'doc_id': '61bcf671-1f5c-4d75-850e-42d4c88c2c87'}
온디바이스에서 작동하는 삼성 가우스의 기능이 AI 산업의 미래에 어떤 영향을 미칠까요?
{'doc_id': 'b7e88e61-8c28-400e-a4fb-f6bd25e5e40b'}</code></pre>
<p><code>retriever</code> 객체의 <code>invoke</code> 메소드를 사용하여 쿼리와 관련된 문서를 검색한다.</p>
<div id="3cf9d591" class="cell" data-execution_count="41">
<details class="code-fold">
<summary>코드</summary>
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1"></a><span class="co"># 관련된 문서를 검색하여 가져옵니다.</span></span>
<span id="cb63-2"><a href="#cb63-2"></a>retrieved_docs <span class="op">=</span> retriever.invoke(result_docs[<span class="dv">1</span>].page_content)</span>
<span id="cb63-3"><a href="#cb63-3"></a></span>
<span id="cb63-4"><a href="#cb63-4"></a><span class="co"># 검색된 문서를 출력합니다.</span></span>
<span id="cb63-5"><a href="#cb63-5"></a><span class="cf">for</span> doc <span class="kw">in</span> retrieved_docs:</span>
<span id="cb63-6"><a href="#cb63-6"></a>    <span class="bu">print</span>(doc.page_content)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<pre><code>삼성전자, ‘삼성 개발자 콘퍼런스 코리아 2023’ 개최, 2023.11.14.
TechRepublic, Samsung Gauss: Samsung Research Reveals Generative AI, 2023.11.08.
SPRi AI Brief |  
2023-12월호
10
삼성전자, 자체 개발 생성 AI ‘삼성 가우스’ 공개
n 삼성전자가 온디바이스에서 작동 가능하며 언어, 코드, 이미지의 3개 모델로 구성된 자체 개발 생성 
AI 모델 ‘삼성 가우스’를 공개
n 삼성전자는 삼성 가우스를 다양한 제품에 단계적으로 탑재할 계획으로, 온디바이스 작동이 가능한 
삼성 가우스는 외부로 사용자 정보가 유출될 위험이 없다는 장점을 보유
KEY Contents
£ 언어, 코드, 이미지의 3개 모델로 구성된 삼성 가우스, 온디바이스 작동 지원
n 삼성전자가 2023년 11월 8일 열린 ‘삼성 AI 포럼 2023’ 행사에서 자체 개발한 생성 AI 모델 
‘삼성 가우스’를 최초 공개
∙정규분포 이론을 정립한 천재 수학자 가우스(Gauss)의 이름을 본뜬 삼성 가우스는 다양한 상황에 
최적화된 크기의 모델 선택이 가능
∙삼성 가우스는 라이선스나 개인정보를 침해하지 않는 안전한 데이터를 통해 학습되었으며, 
온디바이스에서 작동하도록 설계되어 외부로 사용자의 정보가 유출되지 않는 장점을 보유
∙삼성전자는 삼성 가우스를 활용한 온디바이스 AI 기술도 소개했으며, 생성 AI 모델을 다양한 제품에</code></pre>


</section>
</section>
</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>