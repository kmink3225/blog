<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="프롬프트 정성적 평가를 3단계로 체계화한다: 목적 확인, 구조 분석, 효율성 평가. 1단계(목적 확인): 핵심 키워드 6개 추출 표, 정보 흐름 3단계 분석 (역할→구조→제약), “five words” 제약 유무 비교로 출력 형식 변화 확인 (4단어 vs 12단어). 2단계(구조 분석): 실험 1(Question Generator) 섹션 순서 변경 실험 결과 “차이 없음”, 실험 2(번역 Task) “한국어로 번역해줘” 위치 변경 시 튜터 모드 vs 번역 모드로 완전히 다른 결과, 독립적 섹션 vs 프레이밍 섹션 패턴 대조 표, LLM 내부 처리 추정. 3단계(효율성 평가): 원본(100 토큰) vs 간단 버전(20 토큰) vs 최적화 버전(60 토큰, -40% 절약) 비교, 5개 입력 테스트 결과 표 (반말 준수율 100%→20%, 카테고리 구분 100%→0%), 제거 시 문제 발생 요소 분석, 연간 $5,760 절약 사례. 루브릭: 5점 척도 평가 기준 (목적/구조/효율성), 3가지 버전 평가 예시 (원본 13점, 간단 11점, 최적화 15점). 점수 측정 방법 3가지: 사람(30분/개, 높은 정확도), LLM(10초/개, 메타 프롬프트+JSON 출력), 하이브리드(50개→3.2시간, 87% 시간 절약, LLM 스크리닝+사람 정밀 검증). 신뢰도 향상: 복수 평가자(표준편차 0.58), 캘리브레이션 세션 상세 예시 (4명 평가자, 1차 표준편차 2.16→2차 0.5, 효율성 기준 통일 과정, 실제 테스트 절차 합의). 질문 생성기 프롬프트를 일관된 예시로 사용하여 모든 단계 설명.">

<title>Kwangmin Kim - 프롬프트 정성적 평가: 3단계 분석과 루브릭 기반 측정</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - 프롬프트 정성적 평가: 3단계 분석과 루브릭 기반 측정">
<meta property="og:description" content="프롬프트 정성적 평가를 3단계로 체계화한다: 목적 확인, 구조 분석, 효율성 평가. 1단계(목적 확인): 핵심 키워드 6개 추출 표, 정보 흐름 3단계 분석 (역할→구조→제약), “five words” 제약 유무 비교로 출력 형식 변화 확인 (4단어 vs 12단어). 2단계(구조 분석): 실험 1(Question Generator) 섹션 순서 변경 실험 결과 “차이 없음”, 실험 2(번역 Task) “한국어로 번역해줘” 위치 변경 시 튜터 모드 vs 번역 모드로 완전히 다른 결과, 독립적 섹션 vs 프레이밍 섹션 패턴 대조 표, LLM 내부 처리 추정. 3단계(효율성 평가): 원본(100 토큰) vs 간단 버전(20 토큰) vs 최적화 버전(60 토큰, -40% 절약) 비교, 5개 입력 테스트 결과 표 (반말 준수율 100%→20%, 카테고리 구분 100%→0%), 제거 시 문제 발생 요소 분석, 연간 $5,760 절약 사례. 루브릭: 5점 척도 평가 기준 (목적/구조/효율성), 3가지 버전 평가 예시 (원본 13점, 간단 11점, 최적화 15점). 점수 측정 방법 3가지: 사람(30분/개, 높은 정확도), LLM(10초/개, 메타 프롬프트+JSON 출력), 하이브리드(50개→3.2시간, 87% 시간 절약, LLM 스크리닝+사람 정밀 검증). 신뢰도 향상: 복수 평가자(표준편차 0.58), 캘리브레이션 세션 상세 예시 (4명 평가자, 1차 표준편차 2.16→2차 0.5, 효율성 기준 통일 과정, 실제 테스트 절차 합의). 질문 생성기 프롬프트를 일관된 예시로 사용하여 모든 단계 설명.">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Kwangmin Kim - 프롬프트 정성적 평가: 3단계 분석과 루브릭 기반 측정">
<meta name="twitter:description" content="프롬프트 정성적 평가를 3단계로 체계화한다: 목적 확인, 구조 분석, 효율성 평가. 1단계(목적 확인): 핵심 키워드 6개 추출 표, 정보 흐름 3단계 분석 (역할→구조→제약), “five words” 제약 유무 비교로 출력 형식 변화 확인 (4단어 vs 12단어). 2단계(구조 분석): 실험 1(Question Generator) 섹션 순서 변경 실험 결과 “차이 없음”, 실험 2(번역 Task) “한국어로 번역해줘” 위치 변경 시 튜터 모드 vs 번역 모드로 완전히 다른 결과, 독립적 섹션 vs 프레이밍 섹션 패턴 대조 표, LLM 내부 처리 추정. 3단계(효율성 평가): 원본(100 토큰) vs 간단 버전(20 토큰) vs 최적화 버전(60 토큰, -40% 절약) 비교, 5개 입력 테스트 결과 표 (반말 준수율 100%→20%, 카테고리 구분 100%→0%), 제거 시 문제 발생 요소 분석, 연간 $5,760 절약 사례. 루브릭: 5점 척도 평가 기준 (목적/구조/효율성), 3가지 버전 평가 예시 (원본 13점, 간단 11점, 최적화 15점). 점수 측정 방법 3가지: 사람(30분/개, 높은 정확도), LLM(10초/개, 메타 프롬프트+JSON 출력), 하이브리드(50개→3.2시간, 87% 시간 절약, LLM 스크리닝+사람 정밀 검증). 신뢰도 향상: 복수 평가자(표준편차 0.58), 캘리브레이션 세션 상세 예시 (4명 평가자, 1차 표준편차 2.16→2차 0.5, 효율성 기준 통일 과정, 실제 테스트 절차 합의). 질문 생성기 프롬프트를 일관된 예시로 사용하여 모든 단계 설명.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">프롬프트 정성적 평가: 3단계 분석과 루브릭 기반 측정</h1>
            <p class="subtitle lead">목적-구조-효율성 평가와 사람/LLM/하이브리드 측정 방법론</p>
                  <div>
        <div class="description">
          <p>프롬프트 정성적 평가를 3단계로 체계화한다: 목적 확인, 구조 분석, 효율성 평가. 1단계(목적 확인): 핵심 키워드 6개 추출 표, 정보 흐름 3단계 분석 (역할→구조→제약), “five words” 제약 유무 비교로 출력 형식 변화 확인 (4단어 vs 12단어). 2단계(구조 분석): 실험 1(Question Generator) 섹션 순서 변경 실험 결과 “차이 없음”, 실험 2(번역 Task) “한국어로 번역해줘” 위치 변경 시 튜터 모드 vs 번역 모드로 완전히 다른 결과, 독립적 섹션 vs 프레이밍 섹션 패턴 대조 표, LLM 내부 처리 추정. 3단계(효율성 평가): 원본(100 토큰) vs 간단 버전(20 토큰) vs 최적화 버전(60 토큰, -40% 절약) 비교, 5개 입력 테스트 결과 표 (반말 준수율 100%→20%, 카테고리 구분 100%→0%), 제거 시 문제 발생 요소 분석, 연간 $5,760 절약 사례. 루브릭: 5점 척도 평가 기준 (목적/구조/효율성), 3가지 버전 평가 예시 (원본 13점, 간단 11점, 최적화 15점). 점수 측정 방법 3가지: 사람(30분/개, 높은 정확도), LLM(10초/개, 메타 프롬프트+JSON 출력), 하이브리드(50개→3.2시간, 87% 시간 절약, LLM 스크리닝+사람 정밀 검증). 신뢰도 향상: 복수 평가자(표준편차 0.58), 캘리브레이션 세션 상세 예시 (4명 평가자, 1차 표준편차 2.16→2차 0.5, 효율성 기준 통일 과정, 실제 테스트 절차 합의). 질문 생성기 프롬프트를 일관된 예시로 사용하여 모든 단계 설명.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">AI</div>
                <div class="quarto-category">Prompt Engineering</div>
                <div class="quarto-category">Testing</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2026년 02월 05일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#이-파트의-위치" id="toc-이-파트의-위치" class="nav-link active" data-scroll-target="#이-파트의-위치"><span class="header-section-number">1</span> 이 파트의 위치</a></li>
  <li><a href="#단계의-필요성" id="toc-단계의-필요성" class="nav-link" data-scroll-target="#단계의-필요성"><span class="header-section-number">2</span> 3 단계의 필요성</a>
  <ul class="collapse">
  <li><a href="#목적-확인" id="toc-목적-확인" class="nav-link" data-scroll-target="#목적-확인"><span class="header-section-number">2.1</span> 목적 확인</a></li>
  <li><a href="#구조-분석" id="toc-구조-분석" class="nav-link" data-scroll-target="#구조-분석"><span class="header-section-number">2.2</span> 구조 분석</a></li>
  <li><a href="#효율성-평가" id="toc-효율성-평가" class="nav-link" data-scroll-target="#효율성-평가"><span class="header-section-number">2.3</span> 효율성 평가</a></li>
  </ul></li>
  <li><a href="#루브릭-3-단계를-반복" id="toc-루브릭-3-단계를-반복" class="nav-link" data-scroll-target="#루브릭-3-단계를-반복"><span class="header-section-number">3</span> 루브릭: 3 단계를 반복</a>
  <ul class="collapse">
  <li><a href="#정성적-평가-루브릭-5점-scale" id="toc-정성적-평가-루브릭-5점-scale" class="nav-link" data-scroll-target="#정성적-평가-루브릭-5점-scale"><span class="header-section-number">3.1</span> 정성적 평가 루브릭 (5점 Scale)</a></li>
  <li><a href="#루브릭-점수-측정-방법" id="toc-루브릭-점수-측정-방법" class="nav-link" data-scroll-target="#루브릭-점수-측정-방법"><span class="header-section-number">3.2</span> 루브릭 점수 측정 방법</a></li>
  <li><a href="#루브릭-점수-신뢰도-높이는-방법" id="toc-루브릭-점수-신뢰도-높이는-방법" class="nav-link" data-scroll-target="#루브릭-점수-신뢰도-높이는-방법"><span class="header-section-number">3.3</span> 루브릭 점수 신뢰도 높이는 방법</a></li>
  <li><a href="#질문-생성기-프롬프트-평가-예시" id="toc-질문-생성기-프롬프트-평가-예시" class="nav-link" data-scroll-target="#질문-생성기-프롬프트-평가-예시"><span class="header-section-number">3.4</span> 질문 생성기 프롬프트 평가 예시</a></li>
  <li><a href="#루브릭-사용-워크플로우" id="toc-루브릭-사용-워크플로우" class="nav-link" data-scroll-target="#루브릭-사용-워크플로우"><span class="header-section-number">3.5</span> 루브릭 사용 워크플로우</a></li>
  <li><a href="#왜-루브릭이-중요한가" id="toc-왜-루브릭이-중요한가" class="nav-link" data-scroll-target="#왜-루브릭이-중요한가"><span class="header-section-number">3.6</span> 왜 루브릭이 중요한가?</a></li>
  <li><a href="#루브릭의-한계와-보완" id="toc-루브릭의-한계와-보완" class="nav-link" data-scroll-target="#루브릭의-한계와-보완"><span class="header-section-number">3.7</span> 루브릭의 한계와 보완</a></li>
  </ul></li>
  <li><a href="#결론" id="toc-결론" class="nav-link" data-scroll-target="#결론"><span class="header-section-number">4</span> 결론</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="이-파트의-위치" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="이-파트의-위치"><span class="header-section-number">1</span> 이 파트의 위치</h2>
<ul>
<li>테스트의 두 축을 정성적과 정량적으로 나누고 정성적 메트릭이 먼저 통과되어야 정량적 메트릭이 의미를 가진다고 가정한다.</li>
<li>그 정성적 축을 실제로 사용하는 것에 대한 논의를 포함하는 내용을 다루어 본다.</li>
<li>정성적 루부릭을 4개의 단계로 구성하는 방법론을 설명한다.
<ul>
<li>정성적 축을 3단계로 구성한다:
<ul>
<li>목적 확인</li>
<li>구조 분석</li>
<li>효율성 평가<br>
</li>
</ul></li>
<li>종합 평가: 이 세 단계를 한 번에 반복할 수 있도록 하는 루브릭을 마지막에 다루어 본다.</li>
</ul></li>
</ul>
</section>
<section id="단계의-필요성" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="단계의-필요성"><span class="header-section-number">2</span> 3 단계의 필요성</h2>
<ul>
<li>질적 분석을 한 번의 평가로 끝내는 건 가능하지만 평가자의 경험과 감각에 의존한다.
<ul>
<li>“이 프롬프트가 좋은지 나쁜지”를 전체적으로 느끼고 판단하는 주관적인 방법이다.<br>
</li>
<li>문제는 그런 감각이 사람마다 다르다는 것이다.</li>
<li>같은 프롬프트를 두 사람이 보면, 한 사람은 “구조가 이상하다”고, 다른 사람은 “길이가 문제”라고 볼 수 있다.<br>
</li>
<li>둘 다 맞을 수도 있고, 둘 다 핵심을 놓친 것일 수도 있다.<br>
</li>
</ul></li>
<li>질적 분석 평가 단계를 여러 단계로 이런 종류의 불일치를 줄이기 위한 것이다.<br>
</li>
<li>각 단계의 구성 항목도 중요하지만 그 순서도 중요하다.
<ul>
<li>첫 단계는 “이 프롬프트가 무엇을 하려는지”,<br>
</li>
<li>두 번째는 “그 의도를 실현하는 구조가 적절한지”,<br>
</li>
<li>세 번째는 “그 구조가 필요 이상으로 복잡한지 (즉 정규화의 대상인지 평가)”.<br>
</li>
</ul></li>
<li>목적이 불분명하면 구조를 평가할 수 없고, 구조가 확인되지 않으면 효율성을 평가하는 건 의미가 없다.</li>
</ul>
<section id="목적-확인" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="목적-확인"><span class="header-section-number">2.1</span> 목적 확인</h3>
<ul>
<li>what to ask: 프롬프트를 읽고, 이 프롬프트가 모델에게 무엇을 요구하는지를 먼저 파악한다.
<ul>
<li>이건 프롬프트를 작성한 사람의 의도를 재구성하는 행위<br>
</li>
<li>작성자가 원했던 것과 프롬프트가 실제로 전달하는 것이 일치하는지를 확인하는 것</li>
</ul></li>
<li>질문 생성기 프롬프트를 한 번 본다.</li>
</ul>
<pre><code>You have a mind, and your role is to generate possible
three questions a user may want to ask next based on User
input: 개발자로 살아남으려면??

The questions must be from the perspective of me,
the user asking you a question.

## Response template
Predicted user question as followed:
  High certainty
  Moderate certainty, yet intriguing
  Low certainty, but strong potential for user engagement

### Ending
Always answer in half speech form of Korean 반말.
Don't be over five words.
Only provide three questions.</code></pre>
<p>목적 확인에서 하는 건 두 가지이다.</p>
<section id="핵심-단어와-구문-추출" class="level4" data-number="2.1.1">
<h4 data-number="2.1.1" class="anchored" data-anchor-id="핵심-단어와-구문-추출"><span class="header-section-number">2.1.1</span> 핵심 단어와 구문 추출</h4>
<p>이 프롬프트에서 모델의 행동을 실제로 결정하는 키워드를 표로 정리한다.</p>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 18%">
<col style="width: 56%">
</colgroup>
<thead>
<tr class="header">
<th>키워드</th>
<th>역할</th>
<th>빠지면 어떻게 되나?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“generate three questions”</td>
<td>출력 개수 제한</td>
<td>1개 또는 5개 이상 생성 가능</td>
</tr>
<tr class="even">
<td>“based on User input”</td>
<td>입력 맥락 연결</td>
<td>입력 무시하고 일반적 질문 생성</td>
</tr>
<tr class="odd">
<td>“High/Moderate/Low certainty”</td>
<td>질문 각도 구분</td>
<td>3개가 비슷한 각도로 중복</td>
</tr>
<tr class="even">
<td>“half speech form of Korean 반말”</td>
<td>언어 형식</td>
<td>존댓말(“합니까?”) 혼입</td>
</tr>
<tr class="odd">
<td>“five words”</td>
<td>길이 제약</td>
<td>문장 형태로 길어짐 (10단어 이상)</td>
</tr>
<tr class="even">
<td>“Only provide three questions”</td>
<td>출력 정제</td>
<td>설명/주석 추가 (“예를 들어…”)</td>
</tr>
</tbody>
</table>
<p><strong>실제 테스트 예시:</strong></p>
<p><strong>“five words” 제약이 있을 때:</strong></p>
<pre><code>High certainty: 부산 뭐 할까?  (4단어 ✓)
Moderate certainty: 어디 먼저 갈까?  (4단어 ✓)
Low certainty: 혼자 가도 괜찮아?  (4단어 ✓)</code></pre>
<p><strong>“five words” 제약이 없을 때:</strong></p>
<pre><code>High certainty: 부산에서 할 수 있는 재미있는 활동은 뭐가 있을까?  (12단어 ✗)
Moderate certainty: 부산 여행 코스 중에서 어디를 먼저 가는 게 좋을까?  (14단어 ✗)
Low certainty: 부산에 혼자 여행 가도 괜찮을까?  (7단어 ✗)</code></pre>
<p>→ 제약 하나가 출력 형식 전체를 바꾼다.</p>
</section>
<section id="문장-구성-분석-정보-흐름" class="level4" data-number="2.1.2">
<h4 data-number="2.1.2" class="anchored" data-anchor-id="문장-구성-분석-정보-흐름"><span class="header-section-number">2.1.2</span> 문장 구성 분석: 정보 흐름</h4>
<p>프롬프트의 정보 흐름을 3단계로 분해한다.</p>
<p><strong>논리 흐름 구조: 정보의 범위를 단계적으로 구체화 시킨다.</strong></p>
<pre><code>[1단계: 역할 정의] (넓음)
"You have a mind, and your role is to generate..."
→ LLM에게 "누구인지" 알려줌

[2단계: 출력 형태] (중간)
"Response template: High certainty / Moderate certainty / Low certainty"
→ "무엇을 만들지" 구조 제시

[3단계: 형식 제약] (좁음)
"Ending: 반말, 5단어, 3개만"
→ "어떤 형태로" 세부 규칙</code></pre>
<p><strong>논리 흐름 분석 표:</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>단계</th>
<th>역할</th>
<th>정보의 범위</th>
<th>LLM 내부 처리</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>역할 정의</td>
<td>가장 넓음</td>
<td>“질문 생성기구나” 프레임 설정</td>
</tr>
<tr class="even">
<td>2</td>
<td>출력 구조</td>
<td>중간</td>
<td>“3가지 각도로 나눠야지” 계획 수립</td>
</tr>
<tr class="odd">
<td>3</td>
<td>형식 제약</td>
<td>가장 좁음</td>
<td>“반말 5단어로 짧게” 실행 조정</td>
</tr>
</tbody>
</table>
<p><strong>왜 이 순서인가?</strong></p>
<p>일반 → 구체 순서는 LLM이 맥락을 점진적으로 좁히며 생성하는 방식과 일치한다.</p>
<p><strong>순서가 바뀌면:</strong></p>
<pre><code>[잘못된 순서 예시]
1. "반말 5단어로 답하라" (제약 먼저)
2. "질문 생성기다" (역할 나중)
→ LLM은 "뭘 반말로 5단어로?" 혼란</code></pre>
<p><strong>목적 확인 후 수정하면:</strong></p>
<pre><code>개발자 A: "핵심 키워드 표 보니 'five words'가 길이 제약이네."
개발자 B: "그럼 이건 못 지워. 형식 유지 필수."
→ 즉시 판단, 불필요한 실험 방지</code></pre>
<p>목적 확인은 <strong>“이 프롬프트의 어떤 부분이 결과를 결정하는가”</strong>를 먼저 파악하는 단계다.<br>
핵심을 알아야 수정해도 안전하다.</p>
</section>
</section>
<section id="구조-분석" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="구조-분석"><span class="header-section-number">2.2</span> 구조 분석</h3>
<ul>
<li>목적이 파악되면, 그 목적을 실현하는 구조가 적절한지를 본다.<br>
</li>
<li>구조를 바꾸고, 결과가 달라지는지 본다.<br>
</li>
<li>변수를 하나만 바꾸고 나머지는 동일하게 유지한다.<br>
</li>
<li>이 실험을 두 번 한다.<br>
</li>
<li>두 번째 실험의 결과가 첫 번째와 달라지는 부분에서 구조 분석이 실제로 무엇을 찾는지가 보인다.</li>
</ul>
<section id="실험-1-question-generator" class="level4" data-number="2.2.1">
<h4 data-number="2.2.1" class="anchored" data-anchor-id="실험-1-question-generator"><span class="header-section-number">2.2.1</span> 실험 1: Question Generator</h4>
<ul>
<li><strong>실험 설계:</strong> 두 버전을 만든다. 텍스트는 한 글자도 바꾸지 않고, 섹션 순서만 변경한다.
<ul>
<li><strong>Type 1 (원본):</strong> Introduction -&gt; Response template (출력 형태) -&gt; Ending (형식 제약)</li>
<li><strong>Type 2 (순서 변경):</strong> Introduction -&gt; Ending (형식 제약) -&gt; Response template (출력 형태)</li>
</ul></li>
<li><strong>테스트 입력:</strong> “부산 여행”
<ul>
<li><strong>Type 1 결과:</strong>
<ul>
<li>High certainty: 부산 뭐 할까?<br>
</li>
<li>Moderate certainty: 어디 먼저 갈까?<br>
</li>
<li>Low certainty: 혼자 가도 괜찮아?<br>
</li>
</ul></li>
<li><strong>Type 2 결과:</strong>
<ul>
<li>High certainty: 부산 뭐 할까?<br>
</li>
<li>Moderate certainty: 어디 먼저 갈까?<br>
</li>
<li>Low certainty: 혼자 가도 괜찮아?<br>
</li>
</ul></li>
</ul></li>
<li><strong>비교결과: 차이 없음</strong></li>
</ul>
<table class="table">
<thead>
<tr class="header">
<th>평가 항목</th>
<th>Type 1</th>
<th>Type 2</th>
<th>차이</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>질문 개수</td>
<td>3개</td>
<td>3개</td>
<td>없음</td>
</tr>
<tr class="even">
<td>반말 준수</td>
<td>100%</td>
<td>100%</td>
<td>없음</td>
</tr>
<tr class="odd">
<td>각도 다양성</td>
<td>다름</td>
<td>다름</td>
<td>없음</td>
</tr>
<tr class="even">
<td>5단어 제약</td>
<td>준수</td>
<td>준수</td>
<td>없음</td>
</tr>
<tr class="odd">
<td>출력 형식</td>
<td>카테고리 구분</td>
<td>카테고리 구분</td>
<td>없음</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>왜 차이가 없는가?</strong>: Response template과 Ending이 <strong>독립적인 역할</strong>을 하기 때문이다.</li>
</ul>
<table class="table">
<thead>
<tr class="header">
<th>섹션</th>
<th>역할</th>
<th>다른 섹션과의 의존성</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Response template</td>
<td>출력 구조 정의 (High/Moderate/Low)</td>
<td>독립적</td>
</tr>
<tr class="even">
<td>Ending</td>
<td>형식 제약 (반말, 5단어, 3개만)</td>
<td>독립적</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>LLM 내부 처리 (추정):</strong></li>
</ul>
<pre><code>Type 1 읽기 순서:
1. Introduction → "질문 생성기구나"
2. Response template → "3가지 카테고리로 나눠야지"
3. Ending → "반말 5단어로 제약하자"

Type 2 읽기 순서:
1. Introduction → "질문 생성기구나"
2. Ending → "반말 5단어로 제약하자"
3. Response template → "3가지 카테고리로 나눠야지"</code></pre>
<ul>
<li>실험 발견
<ul>
<li>두 경우 모두 <strong>동일한 정보</strong>를 얻으므로, 순서와 무관하게 같은 결과를 생성한다.<br>
</li>
<li>이 프롬프트는 <strong>섹션 순서에 민감하지 않다</strong>.<br>
</li>
<li>각 섹션이 독립적으로 작동하기 때문에, 순서를 바꿔도 안전하다.</li>
</ul></li>
</ul>
</section>
<section id="실험-2-번역-task" class="level4" data-number="2.2.2">
<h4 data-number="2.2.2" class="anchored" data-anchor-id="실험-2-번역-task"><span class="header-section-number">2.2.2</span> 실험 2: 번역 Task</h4>
<ul>
<li><strong>실험 설계:</strong> David에게 한국어를 가르치는 튜터 프롬프트다. “한국어로 번역해줘” 문장의 위치만 변경한다.</li>
<li><strong>Type 1 (지시문 마지막):</strong></li>
</ul>
<pre><code>0. Please list out all the target words at first.
1. Use beginner-level Korean language. For instructions, please also
   provide a set of English instructions in parentheses after
   the Korean instructions.
2. Encourage David to speak more than you do.
3. Provide feedback on grammar, help apply new concepts,
   and expand vocabulary.
4. Adapt your teaching style based on David's responses
   and progress.
5. Use Korean for target vocabulary and example sentences.
   Use English for explanations and instructions.

한국어로 번역해줘.</code></pre>
<ul>
<li><strong>Type 2 (지시문 맨 앞):</strong></li>
</ul>
<pre><code>한국어로 번역해줘

0. Please list out all the target words at first.
1. Use beginner-level Korean language. For instructions, please also
   provide a set of English instructions in parentheses after
   the Korean instructions.
2. Encourage David to speak more than you do.
3. Provide feedback on grammar, help apply new concepts,
   and expand vocabulary.
4. Adapt your teaching style based on David's responses
   and progress.
5. Use Korean for target vocabulary and example sentences.
   Use English for explanations and instructions.</code></pre>
<p><strong>테스트 입력:</strong> 영어 텍스트 5개 문단 * <strong>Type 1 결과:</strong></p>
<pre><code>[튜터 모드로 작동]
- 규칙 0-5를 따름
- 초급 한국어 사용
- 영어 설명 병기
- David의 학습 격려
- 마지막에 "전체를 한국어로 번역해줄까?" 질문 추가</code></pre>
<ul>
<li><strong>Type 2 결과:</strong></li>
</ul>
<pre><code>[번역 모드로 작동]
- 규칙 0-5를 "번역할 때의 규칙"으로 해석
- 전체 텍스트를 초급 한국어로 번역
- 튜터 역할보다 번역 작업에 집중
- David 학습 격려 없음</code></pre>
<p><strong>비교 표:</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>평가 항목</th>
<th>Type 1 (마지막)</th>
<th>Type 2 (맨 앞)</th>
<th>차이</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>주요 역할</td>
<td>튜터</td>
<td>번역기</td>
<td><strong>있음</strong></td>
</tr>
<tr class="even">
<td>규칙 해석</td>
<td>튜터의 교육 방식</td>
<td>번역 시 제약조건</td>
<td><strong>있음</strong></td>
</tr>
<tr class="odd">
<td>David 격려</td>
<td>✓ 있음</td>
<td>✗ 없음</td>
<td><strong>있음</strong></td>
</tr>
<tr class="even">
<td>영어 설명 병기</td>
<td>✓ 있음</td>
<td>△ 일부만</td>
<td><strong>있음</strong></td>
</tr>
<tr class="odd">
<td>작업 초점</td>
<td>학습 대화</td>
<td>텍스트 번역</td>
<td><strong>있음</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>실험결과: 차이 있음</strong>
<ul>
<li><strong>차이 발생 이유</strong> :“한국어로 번역해줘”는 단순 지시문이 아니라 <strong>전체 맥락의 프레임</strong>을 결정하는 문장이다.<br>
</li>
</ul></li>
<li><strong>LLM 내부 처리 (추정):</strong></li>
</ul>
<pre><code>Type 1 읽기 순서:
1. 규칙 0-5 → "튜터 역할 규칙들이구나"
2. "한국어로 번역해줘" → "이 규칙들을 한국어로 설명해야겠네"
→ 프레임: "한국어 튜터"

Type 2 읽기 순서:
1. "한국어로 번역해줘" → "번역 작업이구나"
2. 규칙 0-5 → "번역할 때 이 규칙들을 적용해야겠네"
→ 프레임: "규칙 기반의 한국어 번역기"</code></pre>
<p><strong>프레이밍 효과:</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>위치</th>
<th>프레임 설정</th>
<th>이후 규칙 해석</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>맨 앞</td>
<td>번역 작업</td>
<td>규칙 = 번역 제약조건</td>
</tr>
<tr class="even">
<td>맨 뒤</td>
<td>튜터 역할</td>
<td>규칙 = 교육 방식, 번역은 부가 요청</td>
</tr>
</tbody>
</table>
<p><strong>실험 후 발견:</strong></p>
<ul>
<li>이 프롬프트는 <strong>섹션 순서에 매우 민감하다</strong>.<br>
</li>
<li>“한국어로 번역해줘”가 <strong>전체 맥락을 프레이밍</strong>하기 때문에, 위치가 달라지면 모든 규칙의 의미가 바뀐다.</li>
</ul>
</section>
<section id="두-예시-prompt의-대조" class="level4" data-number="2.2.3">
<h4 data-number="2.2.3" class="anchored" data-anchor-id="두-예시-prompt의-대조"><span class="header-section-number">2.2.3</span> 두 예시 Prompt의 대조</h4>
<table class="table">
<thead>
<tr class="header">
<th>비교 항목</th>
<th>Question Generation Prompt</th>
<th>번역 Task Prompt</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>섹션 관계</td>
<td>독립적</td>
<td>의존적 (프레이밍)</td>
</tr>
<tr class="even">
<td>순서 변경 결과</td>
<td>차이 없음</td>
<td>차이 있음</td>
</tr>
<tr class="odd">
<td>핵심 발견</td>
<td>섹션 역할이 분리됨</td>
<td>한 문장이 전체 맥락 결정</td>
</tr>
<tr class="even">
<td>구조 안정성</td>
<td>높음 (순서 바꿔도 안전)</td>
<td>낮음 (순서 중요)</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>구조 분석이 찾는 것:</strong> 모든 프롬프트가 구조 순서에 같은 방식으로 반응하지 않는다.</li>
<li><strong>독립적 섹션 (예시 1 패턴):</strong>
<ul>
<li>각 섹션이 다른 역할 담당<br>
</li>
<li>순서와 무관하게 안정적<br>
</li>
<li>수정 시 위험 낮음<br>
</li>
</ul></li>
<li><strong>프레이밍 섹션 (예시 2 패턴):</strong>
<ul>
<li>한 문장/섹션이 전체 맥락 결정<br>
</li>
<li>위치가 달라지면 의미 바뀜<br>
</li>
<li>수정 시 신중해야 함<br>
</li>
</ul></li>
<li><strong>구조 분석의 필요성</strong>
<ul>
<li>이 프롬프트에서 어떤 부분이 전체를 프레이밍하는 문장인지 확인<br>
</li>
<li>그 부분의 위치가 결과를 바꾸는 변수이고, 그 외의 부분은 순서가 달라져도 괜찮을 수 있다.<br>
</li>
<li>한 번은 “차이 없음”, 한 번은 “차이 있음”. 둘을 비교해야 왜 결과가 달라지는지가 깊이 보인다.</li>
<li>구조 분석 없이 섹션 순서 변경 시 발생할 수 있는 문제 예시:</li>
</ul>
<pre><code>개발자: "Ending을 앞으로 옮기자. 더 읽기 쉬울 것 같아."
→ 실험 1 패턴: 문제 없음
→ 실험 2 패턴: 전체 의미 바뀜

3일 후: "왜 결과가 이상해졌지?"
→ 원인 파악에 2일 추가 소요</code></pre>
<ul>
<li><strong>구조 분석 후 수정하면:</strong></li>
</ul>
<pre><code>개발자: "구조 실험 결과, 이 프롬프트는 순서 민감형이네."
PM: "그럼 섹션 위치 변경은 위험해. 다른 방법 찾자."
→ 안전한 수정 방향 즉시 선택</code></pre></li>
<li>구조 분석은 <strong>“이 프롬프트에서 어떤 부분이 전체 성능을 결정하는가”</strong>를 찾는 단계다.<br>
</li>
<li>프레이밍 문장을 찾으면, 그 부분은 건드리지 않고 다른 부분만 최적화할 수 있다.</li>
<li>변경된 건 단 하나이다. “한국어로 번역해줘”라는 문장이 아래에서 위로 올라온 것.</li>
<li>나머지 텍스트는 한 글자도 바뀌지 않는다.</li>
<li>결과: 차이 있음. 왜인지를 본다.
<ul>
<li>실험 1과 달라지는 점이 바로 여기에 있다.<br>
</li>
<li>“한국어로 번역해줘”는 단순한 지시문이 아니다.<br>
</li>
<li>이 문장은 프롬프트 전체의 맥락을 프레이밍하는 문장이다.<br>
</li>
<li>이것이 먼저 오면, 모델은 “번역 작업이다”라는 프레임 안에서 이후 규칙들을 읽는다.<br>
</li>
<li>이것이 뒤에 오면, 모델은 먼저 튜터 규칙들을 일반적인 지시사항으로 읽고, 그 후에 번역이라는 작업이 추가된다.<br>
</li>
<li>모델이 규칙들을 “번역의 규칙”으로 읽는지, 아니면 “튜터의 규칙”으로 읽는지가 달라진다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="효율성-평가" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="효율성-평가"><span class="header-section-number">2.3</span> 효율성 평가</h3>
<ul>
<li>구조의 복잡성 평가<br>
</li>
<li>효율성 평가 기준: <strong>“프롬프트의 불필요한 정보의 유무”</strong> 그리고 <strong>“컨텍스트 풍부함 정도”</strong></li>
<li>확인 방법: 프롬프트를 줄여서, 결과가 유지되는지 본다.</li>
</ul>
<section id="원본-vs-간단-버전-비교" class="level4" data-number="2.3.1">
<h4 data-number="2.3.1" class="anchored" data-anchor-id="원본-vs-간단-버전-비교"><span class="header-section-number">2.3.1</span> 원본 vs 간단 버전 비교</h4>
<p><strong>원본 프롬프트 (Full Version):</strong></p>
<pre><code>You have a mind, and your role is to generate possible
three questions a user may want to ask next based on User
input: 개발자로 살아남으려면??

The questions must be from the perspective of me,
the user asking you a question.

## Response template
Predicted user question as followed:
  High certainty
  Moderate certainty, yet intriguing
  Low certainty, but strong potential for user engagement

### Ending
Always answer in half speech form of Korean 반말.
Don't be over five words.
Only provide three questions.</code></pre>
<p><strong>간단 버전 (Minimal Version):</strong></p>
<pre><code>Please generate three questions based on
User input: 개발자로 살아남으려면? in Korean. Be short.</code></pre>
<p><strong>차이점 요약:</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>요소</th>
<th>원본</th>
<th>간단 버전</th>
<th>제거됨</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>역할 정의</td>
<td>“You have a mind, your role is…”</td>
<td>없음</td>
<td>✓</td>
</tr>
<tr class="even">
<td>관점 지정</td>
<td>“from the perspective of me, the user”</td>
<td>없음</td>
<td>✓</td>
</tr>
<tr class="odd">
<td>카테고리 구조</td>
<td>High/Moderate/Low certainty</td>
<td>없음</td>
<td>✓</td>
</tr>
<tr class="even">
<td>반말 지정</td>
<td>“half speech form of Korean 반말”</td>
<td>“in Korean”</td>
<td>✓</td>
</tr>
<tr class="odd">
<td>길이 제약</td>
<td>“Don’t be over five words”</td>
<td>“Be short”</td>
<td>△</td>
</tr>
<tr class="even">
<td>개수 제약</td>
<td>“Only provide three questions”</td>
<td>“three questions”</td>
<td>✓</td>
</tr>
</tbody>
</table>
</section>
<section id="테스트-결과-비교" class="level4" data-number="2.3.2">
<h4 data-number="2.3.2" class="anchored" data-anchor-id="테스트-결과-비교"><span class="header-section-number">2.3.2</span> 테스트 결과 비교</h4>
<p><strong>테스트 입력 5개:</strong><br>
1. “부산 여행”<br>
2. “주식 투자”<br>
3. “헬스 다이어트”<br>
4. “강아지 훈련”<br>
5. “영어 공부”</p>
<p><strong>결과 비교 표:</strong></p>
<table class="table">
<colgroup>
<col style="width: 15%">
<col style="width: 25%">
<col style="width: 35%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>입력</th>
<th>원본 결과</th>
<th>간단 버전 결과</th>
<th>차이 분석</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>부산 여행</td>
<td>High: 부산 뭐 할까?<br>Mod: 어디 먼저 갈까?<br>Low: 혼자 가도 괜찮아?</td>
<td>1. 부산에서 뭐 먹을까요?<br>2. 숙소 어디가 좋아요?<br>3. 언제 가는 게 좋을까요?</td>
<td>✗ 존댓말 혼입<br>✗ 6-7단어<br>✓ 각도 다름</td>
</tr>
<tr class="even">
<td>주식 투자</td>
<td>High: 주식 어떻게 시작해?<br>Mod: 어떤 종목 살까?<br>Low: 지금 사도 괜찮아?</td>
<td>1. 어떤 주식이 좋을까요?<br>2. 주식 시작 방법 알려주세요<br>3. 안전한 투자 방법은?</td>
<td>✗ 존댓말 혼입<br>✗ 5-7단어<br>△ 각도 약함</td>
</tr>
<tr class="odd">
<td>헬스 다이어트</td>
<td>High: 헬스 언제 해?<br>Mod: 뭐 먹어야 해?<br>Low: 얼마나 걸릴까?</td>
<td>1. 헬스 어떻게 시작하나요?<br>2. 식단은 어떻게 해요?<br>3. 운동 시간은?</td>
<td>✗ 존댓말 혼입<br>✓ 4-6단어<br>✓ 각도 다름</td>
</tr>
<tr class="even">
<td>강아지 훈련</td>
<td>High: 강아지 훈련 뭐부터?<br>Mod: 배변 어떻게 가르쳐?<br>Low: 훈련사 부를까?</td>
<td>1. 강아지 훈련 방법은?<br>2. 언제 시작해야 하나요?<br>3. 비용은 얼마나?</td>
<td>△ 반말/존댓말 혼합<br>✓ 4-6단어<br>✓ 각도 다름</td>
</tr>
<tr class="odd">
<td>영어 공부</td>
<td>High: 영어 어떻게 공부해?<br>Mod: 어디서 배울까?<br>Low: 독학 가능해?</td>
<td>1. 영어 공부 방법?<br>2. 학원 vs 독학?<br>3. 얼마나 걸려요?</td>
<td>△ 반말/존댓말 혼합<br>✓ 3-5단어<br>✓ 각도 다름</td>
</tr>
</tbody>
</table>
<p><strong>통계 요약:</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>평가 기준</th>
<th>원본 성공률</th>
<th>간단 버전 성공률</th>
<th>차이</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>반말 준수</td>
<td>100% (5/5)</td>
<td>20% (1/5)</td>
<td><strong>-80%p</strong></td>
</tr>
<tr class="even">
<td>5단어 이내</td>
<td>100% (5/5)</td>
<td>60% (3/5)</td>
<td><strong>-40%p</strong></td>
</tr>
<tr class="odd">
<td>각도 다양성</td>
<td>100% (5/5)</td>
<td>80% (4/5)</td>
<td>-20%p</td>
</tr>
<tr class="even">
<td>카테고리 구분</td>
<td>100% (5/5)</td>
<td>0% (0/5)</td>
<td><strong>-100%p</strong></td>
</tr>
<tr class="odd">
<td>3개 질문</td>
<td>100% (5/5)</td>
<td>100% (5/5)</td>
<td>0%p</td>
</tr>
</tbody>
</table>
</section>
<section id="발견-어떤-부분이-꼭-필요한가" class="level4" data-number="2.3.3">
<h4 data-number="2.3.3" class="anchored" data-anchor-id="발견-어떤-부분이-꼭-필요한가"><span class="header-section-number">2.3.3</span> 발견: 어떤 부분이 꼭 필요한가?</h4>
<p><strong>제거했을 때 문제 발생한 요소:</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>제거된 요소</th>
<th>영향</th>
<th>문제 발생률</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“반말” 명시</td>
<td>존댓말 혼입</td>
<td>80% (4/5)</td>
</tr>
<tr class="even">
<td>“5단어” 제약</td>
<td>질문 길어짐</td>
<td>40% (2/5)</td>
</tr>
<tr class="odd">
<td><strong>카테고리 구조</strong></td>
<td>High/Mod/Low 구분 사라짐</td>
<td>100% (5/5)</td>
</tr>
<tr class="even">
<td>역할 정의</td>
<td>큰 영향 없음</td>
<td>0% (0/5)</td>
</tr>
</tbody>
</table>
<p><strong>제거해도 괜찮은 요소:</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>요소</th>
<th>이유</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“You have a mind”</td>
<td>역할은 “question generator”로 충분</td>
</tr>
<tr class="even">
<td>“from the perspective of me”</td>
<td>맥락상 자명함</td>
</tr>
</tbody>
</table>
<p><strong>최적화된 버전 제안:</strong></p>
<p>간단 버전과 원본의 중간 형태로, 핵심만 남긴다.</p>
<pre><code>Generate three questions based on user input in Korean.

User input: 개발자로 살아남으려면?

Format:
High certainty: [question]
Moderate certainty: [question]
Low certainty: [question]

Rules:
- Use 반말 (casual Korean)
- Max 5 words per question
- Three different angles</code></pre>
<p><strong>최적화 버전 테스트 결과:</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>평가 기준</th>
<th>최적화 버전 성공률</th>
<th>원본 대비</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>반말 준수</td>
<td>100% (5/5)</td>
<td>동일</td>
</tr>
<tr class="even">
<td>5단어 이내</td>
<td>100% (5/5)</td>
<td>동일</td>
</tr>
<tr class="odd">
<td>각도 다양성</td>
<td>100% (5/5)</td>
<td>동일</td>
</tr>
<tr class="even">
<td>카테고리 구분</td>
<td>100% (5/5)</td>
<td>동일</td>
</tr>
<tr class="odd">
<td><strong>토큰 수</strong></td>
<td><strong>약 60 토큰</strong></td>
<td><strong>-40% 절약</strong></td>
</tr>
</tbody>
</table>
</section>
<section id="효율성-vs-명확성-트레이드오프" class="level4" data-number="2.3.4">
<h4 data-number="2.3.4" class="anchored" data-anchor-id="효율성-vs-명확성-트레이드오프"><span class="header-section-number">2.3.4</span> 효율성 vs 명확성 트레이드오프</h4>
<table class="table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>길이</th>
<th>장점</th>
<th>단점</th>
<th>적합한 경우</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>긴 프롬프트 (원본)</td>
<td>명확한 지시<br>오해 방지</td>
<td>토큰 비용 높음<br>읽기 부담</td>
<td>복잡한 작업<br>정확성 중요</td>
</tr>
<tr class="even">
<td>중간 (최적화)</td>
<td>핵심만 전달<br>비용 절감</td>
<td>적절한 밸런스</td>
<td><strong>대부분 권장</strong></td>
</tr>
<tr class="odd">
<td>짧은 (간단)</td>
<td>매우 저렴<br>빠른 실행</td>
<td>형식 불안정<br>결과 예측 어려움</td>
<td>간단한 작업<br>형식 덜 중요</td>
</tr>
</tbody>
</table>
<p><strong>왜 프롬프트 효율성 평가가 중요한가?</strong></p>
<p><strong>효율성 평가 없이 프롬프트 사용하면:</strong></p>
<pre><code>개발자: "프롬프트 작동 잘 되네. 배포하자."
→ 일 평균 10만 회 호출
→ 월 토큰 비용: $1,200

3개월 후 리뷰:
PM: "프롬프트 비용이 너무 높아요. 줄일 수 없나요?"
개발자: "음... 어떤 부분을 줄여야 안전한지 모르겠는데..."
→ 2주 테스트, 실패 3번, 결국 40% 절감 성공
→ 3개월간 불필요하게 $1,440 낭비</code></pre>
<p><strong>효율성 평가 후 배포하면:</strong></p>
<pre><code>개발자: "테스트 결과, 40% 줄여도 성능 동일."
PM: "좋아요. 최적화 버전으로 배포."
→ 월 토큰 비용: $720
→ 연간 $5,760 절약

추가 이점:
- 응답 속도 15% 개선
- API 호출 타임아웃 감소</code></pre>
<p>효율성 평가는 <strong>“이 프롬프트의 어떤 부분이 실제로 기여하는가”</strong>를 찾는 단계다.<br>
군더더기를 제거하면, 비용 절감과 성능 유지를 동시에 달성한다.</p>
</section>
</section>
</section>
<section id="루브릭-3-단계를-반복" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="루브릭-3-단계를-반복"><span class="header-section-number">3</span> 루브릭: 3 단계를 반복</h2>
<ul>
<li>세 단계(목적 확인, 구조 분석, 효율성 평가)를 체계적으로 반복할 수 있는 평가 기준을 정리<br>
</li>
<li>세 단계를 직접 해본 후에 루브릭을 봐야, 각 항목의 필요성과 당위성이 명확해진다.</li>
</ul>
<section id="정성적-평가-루브릭-5점-scale" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="정성적-평가-루브릭-5점-scale"><span class="header-section-number">3.1</span> 정성적 평가 루브릭 (5점 Scale)</h3>
<section id="목적-확인-purpose-clarity" class="level4" data-number="3.1.1">
<h4 data-number="3.1.1" class="anchored" data-anchor-id="목적-확인-purpose-clarity"><span class="header-section-number">3.1.1</span> 목적 확인 (Purpose Clarity)</h4>
<table class="table">
<colgroup>
<col style="width: 27%">
<col style="width: 45%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>점수</th>
<th>평가 기준</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5점</td>
<td>핵심 키워드 명확, 정보 흐름 논리적, 역할-구조-제약 순서 완벽</td>
<td>질문 생성기 원본 프롬프트</td>
</tr>
<tr class="even">
<td>4점</td>
<td>핵심 키워드 있음, 흐름 대체로 논리적, 순서 약간 어색</td>
<td>역할 정의 없지만 나머지 명확</td>
</tr>
<tr class="odd">
<td>3점</td>
<td>키워드 일부 모호, 흐름 이해 가능하나 최적 아님</td>
<td>“짧게 답해”만 있고 구체적 제약 없음</td>
</tr>
<tr class="even">
<td>2점</td>
<td>키워드 불명확, 흐름 뒤죽박죽, 의도 파악 어려움</td>
<td>제약조건이 역할 앞에 옴</td>
</tr>
<tr class="odd">
<td>1점</td>
<td>키워드 없음, 의도 전혀 알 수 없음</td>
<td>“뭔가 생성해줘” 수준</td>
</tr>
</tbody>
</table>
</section>
<section id="구조-분석-structure-robustness" class="level4" data-number="3.1.2">
<h4 data-number="3.1.2" class="anchored" data-anchor-id="구조-분석-structure-robustness"><span class="header-section-number">3.1.2</span> 구조 분석 (Structure Robustness)</h4>
<table class="table">
<colgroup>
<col style="width: 27%">
<col style="width: 45%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>점수</th>
<th>평가 기준</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5점</td>
<td>섹션 독립적, 순서 변경해도 안정적, 프레이밍 문장 없음</td>
<td>Question Generator (실험 1)</td>
</tr>
<tr class="even">
<td>4점</td>
<td>대부분 독립적, 1-2개 섹션만 순서 민감</td>
<td>일부 제약조건이 순서 의존</td>
</tr>
<tr class="odd">
<td>3점</td>
<td>일부 섹션 의존적, 순서 바뀌면 결과 약간 달라짐</td>
<td>출력 형식과 제약이 약하게 연결됨</td>
</tr>
<tr class="even">
<td>2점</td>
<td>섹션 강하게 의존적, 순서 중요, 프레이밍 문장 있음</td>
<td>번역 Task (실험 2)</td>
</tr>
<tr class="odd">
<td>1점</td>
<td>모든 섹션 의존적, 순서 조금만 바뀌어도 무너짐</td>
<td>복잡한 다단계 프롬프트</td>
</tr>
</tbody>
</table>
</section>
<section id="효율성-평가-efficiency" class="level4" data-number="3.1.3">
<h4 data-number="3.1.3" class="anchored" data-anchor-id="효율성-평가-efficiency"><span class="header-section-number">3.1.3</span> 효율성 평가 (Efficiency)</h4>
<table class="table">
<colgroup>
<col style="width: 27%">
<col style="width: 45%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>점수</th>
<th>평가 기준</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5점</td>
<td>최소한의 길이로 100% 성능, 불필요한 부분 없음</td>
<td>최적화 버전 (60 토큰)</td>
</tr>
<tr class="even">
<td>4점</td>
<td>약간 긴 편이나 대부분 필요, 10-20% 줄일 수 있음</td>
<td>원본에서 역할 정의만 제거</td>
</tr>
<tr class="odd">
<td>3점</td>
<td>불필요한 부분 30-40%, 줄여도 성능 유지</td>
<td>원본 프롬프트 (100 토큰)</td>
</tr>
<tr class="even">
<td>2점</td>
<td>절반이 군더더기, 50% 이상 줄일 수 있음</td>
<td>과도한 예시와 설명 포함</td>
</tr>
<tr class="odd">
<td>1점</td>
<td>대부분 불필요, 핵심만 남기면 80% 절약 가능</td>
<td>간단 버전으로도 충분한 경우</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="루브릭-점수-측정-방법" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="루브릭-점수-측정-방법"><span class="header-section-number">3.2</span> 루브릭 점수 측정 방법</h3>
<ul>
<li>3가지 방법이 있고, 상황에 따라 선택한다</li>
</ul>
<section id="사람이-측정-manual-evaluation" class="level4" data-number="3.2.1">
<h4 data-number="3.2.1" class="anchored" data-anchor-id="사람이-측정-manual-evaluation"><span class="header-section-number">3.2.1</span> 사람이 측정 (Manual Evaluation)</h4>
<p>프로게스:<br>
1. 평가자가 프롬프트를 읽는다<br>
2. 3단계(목적 확인, 구조 분석, 효율성 평가)를 직접 수행한다<br>
3. 각 단계별로 루브릭 기준과 비교하여 점수를 매긴다<br>
4. 점수 근거를 기록한다</p>
<p><strong>실제 평가 시나리오:</strong></p>
<pre><code>평가자 A (시니어 개발자):

[목적 확인 단계]
1. 프롬프트 읽기 → 핵심 키워드 표 작성
   - "generate three questions" ✓
   - "반말" ✓
   - "5 words" ✓
2. 정보 흐름 확인 → 역할→구조→제약 순서 ✓
3. 루브릭 비교 → 5점 기준 모두 충족
→ 목적 확인: 5점

[구조 분석 단계]
1. 섹션 순서 변경 실험 (Type 1 vs Type 2)
2. 결과 비교 → 차이 없음
3. 루브릭 비교 → "섹션 독립적, 순서 변경해도 안정적"
→ 구조 분석: 5점

[효율성 평가 단계]
1. 간단 버전 테스트 → 형식 80% 무너짐
2. 토큰 수 계산 → 100 토큰, 40% 줄일 수 있음
3. 루브릭 비교 → "불필요한 부분 30-40%"
→ 효율성: 3점

총점: 13/15점
소요 시간: 약 30분</code></pre>
<ul>
<li><strong>장점:</strong>
<ul>
<li>도메인 지식 반영 가능<br>
</li>
<li>미묘한 뉘앙스 파악<br>
</li>
<li>특수한 상황 고려<br>
</li>
</ul></li>
<li><strong>단점:</strong>
<ul>
<li>시간 많이 소요 (프롬프트당 30분)<br>
</li>
<li>평가자 간 평가기준이 비일관적 (평가 결과 불일치 가능성 높음)<br>
</li>
<li>확장성 낮음 (100개 프롬프트 = 50시간)<br>
</li>
<li>비용 높음 (평가자 인건비)</li>
</ul></li>
<li><strong>적합한 경우:</strong>
<ul>
<li>중요한 프로덕션 프롬프트<br>
</li>
<li>초기 프로토타입 단계<br>
</li>
<li>팀 내 루브릭 캘리브레이션</li>
</ul></li>
</ul>
</section>
<section id="llm이-측정-automated-evaluation" class="level4" data-number="3.2.2">
<h4 data-number="3.2.2" class="anchored" data-anchor-id="llm이-측정-automated-evaluation"><span class="header-section-number">3.2.2</span> LLM이 측정 (Automated Evaluation)</h4>
<p><strong>프로세스:</strong><br>
1. 메타 프롬프트 작성 (루브릭을 LLM에게 전달)<br>
2. 평가 대상 프롬프트를 입력<br>
3. LLM이 3단계 평가 수행 + 점수 산출<br>
4. 점수와 근거를 JSON으로 반환</p>
<p><strong>메타 프롬프트 예시:</strong></p>
<pre><code>You are a prompt evaluation expert. Evaluate the following prompt 
using this rubric:

## Rubric

### Purpose Clarity (5 points)
- 5: Clear keywords, logical flow, perfect role-structure-constraint order
- 4: Keywords present, mostly logical flow, slightly awkward order
- 3: Some keywords ambiguous, flow understandable but not optimal
- 2: Unclear keywords, chaotic flow, hard to understand intent
- 1: No keywords, intent completely unclear

### Structure Robustness (5 points)
- 5: Independent sections, stable with order changes, no framing sentences
- 4: Mostly independent, 1-2 sections order-sensitive
- 3: Some sections dependent, results change slightly with order
- 2: Strongly dependent sections, order critical, framing sentences present
- 1: All sections dependent, breaks easily with order changes

### Efficiency (5 points)
- 5: Minimal length with 100% performance, no unnecessary parts
- 4: Slightly long but mostly necessary, 10-20% reducible
- 3: 30-40% unnecessary, performance maintained when reduced
- 2: Half is filler, 50%+ reducible
- 1: Mostly unnecessary, 80% savings possible with core only

## Prompt to Evaluate

[평가 대상 프롬프트 삽입]

## Output Format

Return JSON:
{
  "purpose_clarity": {
    "score": &lt;1-5&gt;,
    "reasoning": "&lt;이유&gt;"
  },
  "structure_robustness": {
    "score": &lt;1-5&gt;,
    "reasoning": "&lt;이유&gt;"
  },
  "efficiency": {
    "score": &lt;1-5&gt;,
    "reasoning": "&lt;이유&gt;"
  },
  "total_score": &lt;3-15&gt;,
  "summary": "&lt;종합 평가&gt;"
}</code></pre>
<p><strong>LLM 평가 결과 예시:</strong></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource json number-lines code-with-copy"><code class="sourceCode json"><span id="cb22-1"><a href="#cb22-1"></a><span class="fu">{</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>  <span class="dt">"purpose_clarity"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb22-3"><a href="#cb22-3"></a>    <span class="dt">"score"</span><span class="fu">:</span> <span class="dv">5</span><span class="fu">,</span></span>
<span id="cb22-4"><a href="#cb22-4"></a>    <span class="dt">"reasoning"</span><span class="fu">:</span> <span class="st">"핵심 키워드 명확 ('generate three questions', '반말', 'five words'). 역할→구조→제약 흐름 완벽."</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>  <span class="fu">},</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>  <span class="dt">"structure_robustness"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>    <span class="dt">"score"</span><span class="fu">:</span> <span class="dv">5</span><span class="fu">,</span></span>
<span id="cb22-8"><a href="#cb22-8"></a>    <span class="dt">"reasoning"</span><span class="fu">:</span> <span class="st">"Response template과 Ending 섹션이 독립적. 순서 변경 실험 결과 차이 없음."</span></span>
<span id="cb22-9"><a href="#cb22-9"></a>  <span class="fu">},</span></span>
<span id="cb22-10"><a href="#cb22-10"></a>  <span class="dt">"efficiency"</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb22-11"><a href="#cb22-11"></a>    <span class="dt">"score"</span><span class="fu">:</span> <span class="dv">3</span><span class="fu">,</span></span>
<span id="cb22-12"><a href="#cb22-12"></a>    <span class="dt">"reasoning"</span><span class="fu">:</span> <span class="st">"100 토큰 중 약 40 토큰 줄일 수 있음 ('You have a mind', 'from the perspective' 불필요)."</span></span>
<span id="cb22-13"><a href="#cb22-13"></a>  <span class="fu">},</span></span>
<span id="cb22-14"><a href="#cb22-14"></a>  <span class="dt">"total_score"</span><span class="fu">:</span> <span class="dv">13</span><span class="fu">,</span></span>
<span id="cb22-15"><a href="#cb22-15"></a>  <span class="dt">"summary"</span><span class="fu">:</span> <span class="st">"명확하고 구조적으로 안정적이나, 일부 불필요한 표현 제거 시 40% 효율 개선 가능."</span></span>
<span id="cb22-16"><a href="#cb22-16"></a><span class="fu">}</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>장점:</strong><br>
- 빠름 (프롬프트당 10초)<br>
- 확장성 높음 (1000개도 가능)<br>
- 일관성 있음 (같은 프롬프트 → 같은 점수)<br>
- 비용 저렴 (평가당 $0.01)<br>
<strong>단점:</strong><br>
- 도메인 지식 제한적<br>
- 실제 테스트 없이 추론만으로 평가<br>
- 복잡한 프롬프트 오판 가능<br>
- LLM 자체의 한계 (예: 토큰 수 정확히 세지 못함)<br>
<strong>적합한 경우:</strong><br>
- 대량 프롬프트 평가 (100개 이상)<br>
- 빠른 스크리닝 필요<br>
- 지속적 모니터링 (CI/CD 파이프라인)</p>
</section>
<section id="하이브리드-human-llm" class="level4" data-number="3.2.3">
<h4 data-number="3.2.3" class="anchored" data-anchor-id="하이브리드-human-llm"><span class="header-section-number">3.2.3</span> 하이브리드 (Human + LLM)</h4>
<p><strong>프로세스:</strong><br>
1. <strong>1차: LLM 자동 평가</strong> (스크리닝)<br>
- 전체 프롬프트를 LLM이 평가<br>
- 낮은 점수 (≤10점) 필터링<br>
2. <strong>2차: 사람 수동 평가</strong> (정밀 검증)<br>
- 높은 점수 프롬프트만 사람이 재평가<br>
- LLM 평가와 비교하여 최종 결정<br>
3. <strong>피드백 루프</strong><br>
- 사람의 평가 결과를 메타 프롬프트에 반영<br>
- LLM 평가 정확도 지속 개선</p>
<p><strong>실무 적용 사례:</strong></p>
<pre><code>시나리오: 50개 프롬프트 평가 필요

[1단계: LLM 스크리닝 (10분)]
- 50개 프롬프트 → LLM 자동 평가
- 결과: 15개 ≤10점, 35개 &gt;10점

[2단계: 사람 정밀 평가 (3시간)]
- 35개 고득점 프롬프트만 사람이 재평가
- 결과: 5개는 LLM 오판 (실제 7-8점)
         30개는 LLM 평가 정확

[3단계: 최종 선정]
- 30개 검증된 프롬프트 중 상위 10개 선정
- 5개 오판 프롬프트는 개선 대상으로 분류

총 시간: 3.2시간
순수 사람 평가 시: 25시간 (50개 × 30분)
→ 87% 시간 절약</code></pre>
<p><strong>장단점 비교:</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>방법</th>
<th>속도</th>
<th>정확도</th>
<th>비용</th>
<th>확장성</th>
<th>적합한 규모</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>사람</td>
<td>느림</td>
<td>높음</td>
<td>높음</td>
<td>낮음</td>
<td>1-10개</td>
</tr>
<tr class="even">
<td>LLM</td>
<td>빠름</td>
<td>중간</td>
<td>낮음</td>
<td>높음</td>
<td>100개 이상</td>
</tr>
<tr class="odd">
<td>하이브리드</td>
<td>중간</td>
<td>높음</td>
<td>중간</td>
<td>중간</td>
<td>10-100개</td>
</tr>
</tbody>
</table>
<p><strong>왜 하이브리드가 현실적인가?</strong> * <strong>순수 사람 평가의 문제:</strong> 고차원 평가 but 너무 느리고 비용 높음</p>
<pre><code>PM: "50개 프롬프트 평가해주세요."
개발자: "하나에 30분이면... 25시간이요?"
PM: "3일 걸리네요. 더 빠른 방법 없나요?"</code></pre>
<ul>
<li><strong>순수 LLM 평가의 문제:</strong> 빠르고 저렴 but 신뢰도 및 전문성 문제</li>
</ul>
<pre><code>LLM 평가: "이 프롬프트 14점입니다."
개발자: "실제 테스트하니 7점 수준인데..."
PM: "LLM이 토큰 수도 제대로 못 세네요."
→ 신뢰도 문제</code></pre>
<ul>
<li><strong>하이브리드 적용 시:</strong></li>
</ul>
<pre><code>LLM: "50개 중 35개가 10점 이상입니다."
개발자: "35개만 직접 확인하면 되겠네요."
PM: "3시간이면 충분하겠어요. 시작하죠."
→ 효율 + 정확도 균형</code></pre>
</section>
</section>
<section id="루브릭-점수-신뢰도-높이는-방법" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="루브릭-점수-신뢰도-높이는-방법"><span class="header-section-number">3.3</span> 루브릭 점수 신뢰도 높이는 방법</h3>
<section id="복수-평가자-inter-rater-reliability" class="level4" data-number="3.3.1">
<h4 data-number="3.3.1" class="anchored" data-anchor-id="복수-평가자-inter-rater-reliability"><span class="header-section-number">3.3.1</span> 복수 평가자 (Inter-Rater Reliability)</h4>
<pre><code>3명의 평가자가 동일 프롬프트 평가:

평가자 A: 목적 5점, 구조 5점, 효율 3점 → 총 13점
평가자 B: 목적 4점, 구조 5점, 효율 3점 → 총 12점
평가자 C: 목적 5점, 구조 4점, 효율 3점 → 총 12점

평균: 12.3점
표준편차: 0.58 (낮음 → 신뢰도 높음)</code></pre>
</section>
<section id="캘리브레이션-세션" class="level4" data-number="3.3.2">
<h4 data-number="3.3.2" class="anchored" data-anchor-id="캘리브레이션-세션"><span class="header-section-number">3.3.2</span> 캘리브레이션 세션</h4>
<ul>
<li><strong>목표:</strong> 팀원 간 평가 기준 통일<br>
</li>
<li><strong>시나리오:</strong> 팀원 4명이 동일 프롬프트를 평가<br>
</li>
<li><strong>평가 대상 프롬프트 (고객 문의 응답 생성기):</strong></li>
</ul>
<pre><code>You are a customer service agent. Generate a helpful response 
to the customer's question.

Customer question: 배송이 늦어지고 있어요. 언제 도착하나요?

Guidelines:
- Be polite and empathetic
- Provide actionable information
- Keep response under 100 words</code></pre>
<p><strong>1차 평가 결과 (기준 통일 전):</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>평가자</th>
<th>목적</th>
<th>구조</th>
<th>효율성</th>
<th>총점</th>
<th>효율성 평가 이유</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A (시니어)</td>
<td>4</td>
<td>5</td>
<td>4</td>
<td>13</td>
<td>“100 단어 제약이 있어서 최적화됨”</td>
</tr>
<tr class="even">
<td>B (주니어)</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>10</td>
<td>“길이 제약 명확해서 효율적”</td>
</tr>
<tr class="odd">
<td>C (PM)</td>
<td>5</td>
<td>4</td>
<td>5</td>
<td>14</td>
<td>“매우 짧고 핵심만 있음”</td>
</tr>
<tr class="even">
<td>D (QA)</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>9</td>
<td>“가이드라인을 더 줄일 수 있을 것 같음”</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>표준편차: 2.16 (높음)</strong> → 평가 기준 불일치<br>
</li>
<li><strong>토론 세션을 갖는다 예를 들어 1시간</strong><br>
</li>
<li><strong>1단계: 차이점 발견</strong></li>
</ul>
<pre><code>팀 리드: "같은 프롬프트인데 9점부터 14점까지 나왔네요. 
         왜 이렇게 차이가 날까요?"

평가자 C: "저는 이 프롬프트가 매우 효율적이라고 봤어요. 
          딱 필요한 것만 있잖아요."

평가자 D: "저는 가이드라인 3개가 너무 일반적이라고 생각했어요. 
          'Be polite'는 customer service agent 역할에 이미 포함된 거 아닌가요?"

평가자 A: "아, 저도 그 부분은 생각 못 했네요. 
          저는 '100 words' 제약이 있어서 4점 줬어요."</code></pre>
<p><strong>2단계: 효율성 3점 기준 혼란 확인</strong></p>
<pre><code>팀 리드: "특히 효율성 점수가 3, 4, 4, 5로 다 다르네요. 
         각자 어떤 기준으로 매겼나요?"

평가자 A: "저는 토큰 수를 봤어요. 약 40 토큰이고, 
          역할 정의를 조금 줄이면 10-20% 절약 → 4점"

평가자 B: "저는... 솔직히 느낌이었어요. 
          '길이 제약이 있으니까 효율적이겠지' → 4점"

평가자 C: "저는 원본이 이미 최소한이라고 봤어요. 
          더 줄이면 의미가 손상될 것 같아서 → 5점"

평가자 D: "저는 간단 버전을 상상해봤어요. 
          'Generate polite response under 100 words'만으로도 될 것 같아서 
          30% 이상 줄일 수 있다 → 3점"</code></pre>
<p><strong>문제 발견:</strong> 각자 다른 방법으로 효율성을 평가함<br>
- A: 토큰 수 계산 (정량적)<br>
- B: 직관적 느낌 (주관적)<br>
- C: 의미 손상 가능성 (보수적)<br>
- D: 간단 버전 상상 (실험 없음)</p>
<p><strong>3단계: 기준 합의</strong></p>
<pre><code>팀 리드: "루브릭을 다시 보죠."

[효율성 3점 기준]
- 불필요한 부분 30-40%
- 줄여도 성능 유지

팀 리드: "'불필요한 부분 30-40%'를 어떻게 판단할까요?"

평가자 D: "직접 테스트해야 할 것 같아요. 
          간단 버전 만들어서 실제로 돌려보고 비교해야죠."

평가자 A: "동의합니다. 그럼 절차를 정의하죠.

[합의된 효율성 평가 절차]
1. 간단 버전 작성 (핵심만 남김)
2. 5개 입력으로 원본 vs 간단 버전 테스트
3. 성공률 비교:
   - 원본 100% vs 간단 60-80% → 3점
   - 원본 100% vs 간단 80-90% → 4점
   - 원본 100% vs 간단 90-100% → 5점
4. 토큰 수 비교:
   - 30-40% 감소 → 3점 기준 확인
   - 10-20% 감소 → 4점 기준 확인

평가자 C: "좋아요. 이제 명확하네요."</code></pre>
<p><strong>4단계: 실제 테스트 (합의된 절차 적용)</strong></p>
<p><strong>간단 버전 작성:</strong></p>
<pre><code>Customer service agent. Answer customer questions 
politely under 100 words.

Question: 배송이 늦어지고 있어요. 언제 도착하나요?</code></pre>
<p><strong>5개 테스트 입력:</strong></p>
<table class="table">
<colgroup>
<col style="width: 16%">
<col style="width: 27%">
<col style="width: 38%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>입력</th>
<th>원본 결과</th>
<th>간단 버전 결과</th>
<th>평가</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“환불 어떻게 해요?”</td>
<td>공감 표현 + 절차 안내 + 100단어 이내 ✓</td>
<td>절차만 안내, 공감 표현 약함</td>
<td>△</td>
</tr>
<tr class="even">
<td>“배송 추적이 안 돼요”</td>
<td>공감 + 해결책 + 간결 ✓</td>
<td>해결책만, 너무 짧음</td>
<td>△</td>
</tr>
<tr class="odd">
<td>“불량품이에요”</td>
<td>사과 + 교환 절차 + 적절한 길이 ✓</td>
<td>교환 절차만, 사과 없음</td>
<td>✗</td>
</tr>
<tr class="even">
<td>“할인 쿠폰 사용법”</td>
<td>친절한 안내 + 단계별 설명 ✓</td>
<td>단계만 나열, 불친절</td>
<td>△</td>
</tr>
<tr class="odd">
<td>“계정 비밀번호 찾기”</td>
<td>안내 + 보안 주의사항 ✓</td>
<td>안내만, 보안 주의 없음</td>
<td>✗</td>
</tr>
</tbody>
</table>
<p><strong>결과:</strong> - 원본: 5/5 성공 (100%) - 간단 버전: 1/5 성공 (20%) - 공감/사과 표현 부족, 보안 주의사항 누락</p>
<p><strong>토큰 수:</strong> - 원본: 40 토큰 - 간단 버전: 20 토큰 (50% 감소)</p>
<p><strong>5단계: 재평가 (기준 통일 후)</strong></p>
<pre><code>평가자 A: "테스트 결과, 간단 버전은 20% 성공률이네요. 
          가이드라인이 실제로 필요했어요. 효율성 5점으로 수정합니다."

평가자 B: "저도 5점입니다. 각 가이드라인이 다 의미가 있었네요."

평가자 C: "5점 유지. 제 평가가 맞았네요."

평가자 D: "제가 틀렸네요. 'Be polite'가 없으니 공감 표현이 사라졌어요. 
          5점으로 수정합니다."</code></pre>
<p><strong>2차 평가 결과 (기준 통일 후):</strong></p>
<table class="table">
<colgroup>
<col style="width: 16%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 16%">
<col style="width: 12%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th>평가자</th>
<th>목적</th>
<th>구조</th>
<th>효율성</th>
<th>총점</th>
<th>효율성 평가 이유</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A (시니어)</td>
<td>4</td>
<td>5</td>
<td>5</td>
<td>14</td>
<td>“테스트 결과 간단 버전 20% 성공 → 원본 최적”</td>
</tr>
<tr class="even">
<td>B (주니어)</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>13</td>
<td>“가이드라인 제거 시 품질 저하 확인”</td>
</tr>
<tr class="odd">
<td>C (PM)</td>
<td>5</td>
<td>4</td>
<td>5</td>
<td>14</td>
<td>“원본 평가 유지, 테스트로 검증됨”</td>
</tr>
<tr class="even">
<td>D (QA)</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>13</td>
<td>“가이드라인이 실제로 필요했음을 확인”</td>
</tr>
</tbody>
</table>
<p><strong>표준편차: 0.5 (낮음)</strong> → 신뢰도 향상</p>
<p><strong>캘리브레이션 효과:</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>지표</th>
<th>1차 평가</th>
<th>2차 평가</th>
<th>개선</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>평균 점수</td>
<td>11.5점</td>
<td>13.5점</td>
<td>+2점</td>
</tr>
<tr class="even">
<td>표준편차</td>
<td>2.16</td>
<td>0.5</td>
<td>-77%</td>
</tr>
<tr class="odd">
<td>최대-최소 차이</td>
<td>5점</td>
<td>1점</td>
<td>-80%</td>
</tr>
<tr class="even">
<td>평가 소요 시간</td>
<td>15분/명</td>
<td>25분/명</td>
<td>+67% (but 신뢰도↑)</td>
</tr>
</tbody>
</table>
<p><strong>핵심 교훈:</strong></p>
<pre><code>팀 리드: "이제 다음 프롬프트부터는 다들 같은 기준으로 평가하겠네요."

평가자 D: "특히 '실제 테스트'가 중요하다는 걸 배웠어요. 
          상상만으로는 안 되네요."

평가자 B: "저도요. 이제 평가할 때 간단 버전 만들어서 
          꼭 테스트해보겠습니다."

평가자 A: "캘리브레이션 세션이 1시간 걸렸지만, 
          앞으로 100개 프롬프트 평가할 때 시간 절약될 거예요."</code></pre>
<p><strong>캘리브레이션 후 팀 표준 문서:</strong></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb35-1"><a href="#cb35-1"></a><span class="fu"># 효율성 평가 표준 절차 (ver 1.0)</span></span>
<span id="cb35-2"><a href="#cb35-2"></a></span>
<span id="cb35-3"><a href="#cb35-3"></a><span class="fu">## 3점 판단 기준</span></span>
<span id="cb35-4"><a href="#cb35-4"></a><span class="ss">1. </span>간단 버전 작성 (제거할 요소 선택)</span>
<span id="cb35-5"><a href="#cb35-5"></a><span class="ss">2. </span>5개 입력 테스트 (다양한 상황)</span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="ss">3. </span>성공률 측정:</span>
<span id="cb35-7"><a href="#cb35-7"></a><span class="ss">   - </span>60-80% → 3점 (원본에 불필요한 부분 있음)</span>
<span id="cb35-8"><a href="#cb35-8"></a><span class="ss">   - </span>80-90% → 4점 (약간 최적화 가능)</span>
<span id="cb35-9"><a href="#cb35-9"></a><span class="ss">   - </span>90-100% → 5점 (이미 최적)</span>
<span id="cb35-10"><a href="#cb35-10"></a><span class="ss">4. </span>토큰 수 확인 (보조 지표)</span>
<span id="cb35-11"><a href="#cb35-11"></a><span class="ss">5. </span>평가 근거 기록 (재현 가능하도록)</span>
<span id="cb35-12"><a href="#cb35-12"></a></span>
<span id="cb35-13"><a href="#cb35-13"></a><span class="fu">## 주의사항</span></span>
<span id="cb35-14"><a href="#cb35-14"></a><span class="ss">- </span>직관만으로 판단 금지</span>
<span id="cb35-15"><a href="#cb35-15"></a><span class="ss">- </span>반드시 실제 테스트 수행</span>
<span id="cb35-16"><a href="#cb35-16"></a><span class="ss">- </span>팀원과 평가 결과 공유</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="평가-가이드-문서화" class="level4" data-number="3.3.3">
<h4 data-number="3.3.3" class="anchored" data-anchor-id="평가-가이드-문서화"><span class="header-section-number">3.3.3</span> 평가 가이드 문서화</h4>
<pre><code>효율성 3점 판단 기준 (상세화):

1. 간단 버전 작성 (핵심만 남김)
2. 5개 입력으로 테스트
3. 성공률 비교:
   - 원본 100% vs 간단 버전 60-80% → 3점
   - 원본 100% vs 간단 버전 80-90% → 4점
   - 원본 100% vs 간단 버전 &lt;60% → 2점
4. 토큰 수 감소율:
   - 30-40% 감소 가능 → 3점
   - 10-20% 감소 가능 → 4점
   - 50%+ 감소 가능 → 2점</code></pre>
</section>
</section>
<section id="질문-생성기-프롬프트-평가-예시" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="질문-생성기-프롬프트-평가-예시"><span class="header-section-number">3.4</span> 질문 생성기 프롬프트 평가 예시</h3>
<p>위 루브릭으로 3가지 버전을 평가한다.</p>
<p><strong>평가 결과 표:</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>버전</th>
<th>목적 확인</th>
<th>구조 분석</th>
<th>효율성 평가</th>
<th>총점</th>
<th>비고</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>원본 (Full)</td>
<td>5점</td>
<td>5점</td>
<td>3점</td>
<td>13/15</td>
<td>명확하고 안정적, 다소 김</td>
</tr>
<tr class="even">
<td>간단 (Minimal)</td>
<td>2점</td>
<td>4점</td>
<td>5점</td>
<td>11/15</td>
<td>짧지만 형식 불안정</td>
</tr>
<tr class="odd">
<td>최적화 (Optimized)</td>
<td>5점</td>
<td>5점</td>
<td>5점</td>
<td><strong>15/15</strong></td>
<td>이상적 균형</td>
</tr>
</tbody>
</table>
<p><strong>세부 평가 근거:</strong></p>
<p><strong>원본 버전:</strong> - 목적 확인 5점: 핵심 키워드 완벽, 역할→구조→제약 흐름 논리적 - 구조 분석 5점: Response template과 Ending 독립적, 순서 변경 안전 - 효율성 3점: 100 토큰 중 40% 줄일 수 있음 (역할 정의, 관점 지정 불필요)</p>
<p><strong>간단 버전:</strong> - 목적 확인 2점: “Be short”만으로 제약 불명확, 카테고리 구조 없음 - 구조 분석 4점: 짧아서 섹션 의존성 낮음, 하지만 형식 제어 약함 - 효율성 5점: 20 토큰으로 최소화, 더 줄일 곳 없음</p>
<p><strong>최적화 버전:</strong> - 목적 확인 5점: 핵심만 남김, 명확한 규칙, 논리적 흐름 - 구조 분석 5점: 섹션 독립적, 안정적 구조 - 효율성 5점: 60 토큰으로 성능 100% 유지, 이상적 길이</p>
</section>
<section id="루브릭-사용-워크플로우" class="level3" data-number="3.5">
<h3 data-number="3.5" class="anchored" data-anchor-id="루브릭-사용-워크플로우"><span class="header-section-number">3.5</span> 루브릭 사용 워크플로우</h3>
<p><strong>프롬프트 작성 → 테스트 → 루브릭 평가 → 개선 → 재평가</strong></p>
<p><strong>실무 적용 시나리오:</strong></p>
<pre><code>Day 1: 새 프롬프트 작성
       → 루브릭 자가 평가: 목적 4점, 구조 3점, 효율성 2점

Day 2: 구조 개선 (프레이밍 문장 위치 조정)
       → 재평가: 목적 4점, 구조 5점, 효율성 2점

Day 3: 효율성 개선 (불필요한 예시 제거)
       → 재평가: 목적 4점, 구조 5점, 효율성 4점

Day 4: 목적 개선 (핵심 키워드 명확화)
       → 최종 평가: 목적 5점, 구조 5점, 효율성 4점
       → 총 14/15점, 배포 승인</code></pre>
<p><strong>팀 리뷰 시나리오:</strong></p>
<pre><code>개발자 A: "제 프롬프트 리뷰 부탁드립니다."

개발자 B (루브릭 적용):
- 목적 확인: 4점 (키워드는 있는데 흐름이 약간 어색해요)
- 구조 분석: 3점 (Ending을 앞으로 옮기면 어떨까요? 실험해보세요)
- 효율성: 2점 (예시가 너무 많아요. 1개면 충분할 것 같습니다)

개발자 A: "구체적 피드백 감사합니다. 바로 수정하겠습니다."
→ 주관적 "좋아요/별로에요" 대신 객관적 점수와 개선 방향 제시</code></pre>
</section>
<section id="왜-루브릭이-중요한가" class="level3" data-number="3.6">
<h3 data-number="3.6" class="anchored" data-anchor-id="왜-루브릭이-중요한가"><span class="header-section-number">3.6</span> 왜 루브릭이 중요한가?</h3>
<p><strong>루브릭 없이 평가하면:</strong></p>
<pre><code>팀원 A: "이 프롬프트 어때요?"
팀원 B: "음... 괜찮은 것 같은데요?"
팀원 C: "저는 좀 긴 것 같아요."
팀원 D: "뭐가 긴데요? 저는 적당한데..."
→ 1시간 토론, 결론 없음</code></pre>
<p><strong>루브릭으로 평가하면:</strong></p>
<pre><code>팀원 A: "루브릭 평가 결과 공유합니다."
        목적 5점, 구조 4점, 효율성 3점

팀원 B: "효율성 3점이네요. 어떤 부분을 줄일까요?"
팀원 C: "역할 정의 부분이 불필요해 보입니다."
팀원 D: "동의합니다. 제거 후 재테스트하죠."
→ 10분 논의, 즉시 개선 방향 결정</code></pre>
<p>루브릭은 <strong>주관적 느낌을 객관적 점수</strong>로 바꿔준다.<br>
“좋다/나쁘다” → “어떤 부분이 몇 점이고, 왜 그런지”로 구체화된다.</p>
</section>
<section id="루브릭의-한계와-보완" class="level3" data-number="3.7">
<h3 data-number="3.7" class="anchored" data-anchor-id="루브릭의-한계와-보완"><span class="header-section-number">3.7</span> 루브릭의 한계와 보완</h3>
<p><strong>루브릭이 완벽하지 않은 경우:</strong></p>
<table class="table">
<colgroup>
<col style="width: 27%">
<col style="width: 27%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th>상황</th>
<th>문제</th>
<th>해결 방법</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>도메인 특수성</td>
<td>일반 루브릭으로 측정 어려움</td>
<td>도메인별 추가 기준 마련</td>
</tr>
<tr class="even">
<td>평가자 숙련도</td>
<td>초보자는 점수 매기기 어려움</td>
<td>예시 기반 가이드 제공</td>
</tr>
<tr class="odd">
<td>복잡한 프롬프트</td>
<td>다단계 프롬프트 평가 한계</td>
<td>단계별로 분리 평가</td>
</tr>
</tbody>
</table>
<p><strong>보완 방법:</strong></p>
<ol type="1">
<li><strong>예시 라이브러리</strong>: 각 점수대별 실제 프롬프트 예시 축적</li>
<li><strong>팀 캘리브레이션</strong>: 같은 프롬프트를 함께 평가하며 기준 통일</li>
<li><strong>정량적 검증</strong>: 루브릭 점수와 실제 성능 지표 상관관계 확인</li>
</ol>
</section>
</section>
<section id="결론" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="결론"><span class="header-section-number">4</span> 결론</h2>
<ul>
<li>앞서, 정성적과 정량적 방식으로 프롬프트의 품질을 평가한다는 것을 살펴보았다.</li>
<li>이번 블로그에서는 그 중 <strong>정성적 축을 실제로 사용</strong>한다: “이 프롬프트가 의도대로 작동하는지”를 세 단계(목적 확인, 구조 분석, 효율성 평가)로 본다.</li>
<li>그리고 그 세 단계를 <strong>루브릭으로 정리</strong>하여 반복 평가할 수 있게 만든다.<br>
</li>
<li>이후 다른 축, 즉 <strong>“얼마나 안정적으로 작동하는지”</strong>(정량적 평가)를 다룬다.</li>
</ul>


</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>