<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="전통적인 소프트웨어 개발과 달리 프롬프트 엔지니어링에는 명확한 정답이 없다. 같은 질문에도 무수히 많은 “괜찮은” 답변이 확률적으로 출력된다. 그렇다면 프롬프트의 성능을 어떻게 평가해야 하는가? 이 글은 프롬프트 평가의 4가지 핵심 가치를 다룬다: (1) 품질 보증: 회귀 테스트와 팀 협업의 기반 (2) 성능 최적화: A/B 테스트와 데이터 기반 개선 (3) 비용 효율성: 토큰 비용과 품질의 트레이드오프 정량화 (4) 사용자 경험: 대리 지표(proxy metric)로 만족도 측정 동시에 평가의 근본적 딜레마들도 살펴본다: 기준의 주관성, 정답 데이터셋의 부재, 맥락 의존성, 순환 논리의 위험. 마지막으로 LLM-as-a-Judge 방법론이 어떻게 이러한 딜레마를 실용적으로 해결하는지 설명한다. (MT-Bench 연구: GPT-4가 인간 평가와 80% 이상 일치)">

<title>Kwangmin Kim - 프롬프트 평가의 필요성과 정당성</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - 프롬프트 평가의 필요성과 정당성">
<meta property="og:description" content="전통적인 소프트웨어 개발과 달리 프롬프트 엔지니어링에는 명확한 정답이 없다. 같은 질문에도 무수히 많은 “괜찮은” 답변이 확률적으로 출력된다. 그렇다면 프롬프트의 성능을 어떻게 평가해야 하는가? 이 글은 프롬프트 평가의 4가지 핵심 가치를 다룬다: (1) 품질 보증: 회귀 테스트와 팀 협업의 기반 (2) 성능 최적화: A/B 테스트와 데이터 기반 개선 (3) 비용 효율성: 토큰 비용과 품질의 트레이드오프 정량화 (4) 사용자 경험: 대리 지표(proxy metric)로 만족도 측정 동시에 평가의 근본적 딜레마들도 살펴본다: 기준의 주관성, 정답 데이터셋의 부재, 맥락 의존성, 순환 논리의 위험. 마지막으로 LLM-as-a-Judge 방법론이 어떻게 이러한 딜레마를 실용적으로 해결하는지 설명한다. (MT-Bench 연구: GPT-4가 인간 평가와 80% 이상 일치)">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Kwangmin Kim - 프롬프트 평가의 필요성과 정당성">
<meta name="twitter:description" content="전통적인 소프트웨어 개발과 달리 프롬프트 엔지니어링에는 명확한 정답이 없다. 같은 질문에도 무수히 많은 “괜찮은” 답변이 확률적으로 출력된다. 그렇다면 프롬프트의 성능을 어떻게 평가해야 하는가? 이 글은 프롬프트 평가의 4가지 핵심 가치를 다룬다: (1) 품질 보증: 회귀 테스트와 팀 협업의 기반 (2) 성능 최적화: A/B 테스트와 데이터 기반 개선 (3) 비용 효율성: 토큰 비용과 품질의 트레이드오프 정량화 (4) 사용자 경험: 대리 지표(proxy metric)로 만족도 측정 동시에 평가의 근본적 딜레마들도 살펴본다: 기준의 주관성, 정답 데이터셋의 부재, 맥락 의존성, 순환 논리의 위험. 마지막으로 LLM-as-a-Judge 방법론이 어떻게 이러한 딜레마를 실용적으로 해결하는지 설명한다. (MT-Bench 연구: GPT-4가 인간 평가와 80% 이상 일치)">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">프롬프트 평가의 필요성과 정당성</h1>
            <p class="subtitle lead">왜 평가해야 하는가, 그리고 어떻게 평가할 것인가</p>
                  <div>
        <div class="description">
          <p>전통적인 소프트웨어 개발과 달리 프롬프트 엔지니어링에는 명확한 정답이 없다. 같은 질문에도 무수히 많은 “괜찮은” 답변이 확률적으로 출력된다. 그렇다면 프롬프트의 성능을 어떻게 평가해야 하는가? 이 글은 프롬프트 평가의 4가지 핵심 가치를 다룬다: (1) 품질 보증: 회귀 테스트와 팀 협업의 기반 (2) 성능 최적화: A/B 테스트와 데이터 기반 개선 (3) 비용 효율성: 토큰 비용과 품질의 트레이드오프 정량화 (4) 사용자 경험: 대리 지표(proxy metric)로 만족도 측정 동시에 평가의 근본적 딜레마들도 살펴본다: 기준의 주관성, 정답 데이터셋의 부재, 맥락 의존성, 순환 논리의 위험. 마지막으로 LLM-as-a-Judge 방법론이 어떻게 이러한 딜레마를 실용적으로 해결하는지 설명한다. (MT-Bench 연구: GPT-4가 인간 평가와 80% 이상 일치)</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">AI</div>
                <div class="quarto-category">Agent</div>
                <div class="quarto-category">Prompt Engineering</div>
                <div class="quarto-category">Evaluation</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2025년 02월 06일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#들어가며" id="toc-들어가며" class="nav-link active" data-scroll-target="#들어가며"><span class="header-section-number">1</span> 들어가며</a>
  <ul class="collapse">
  <li><a href="#평가-기준의-모호성-텍스트-vs-의미" id="toc-평가-기준의-모호성-텍스트-vs-의미" class="nav-link" data-scroll-target="#평가-기준의-모호성-텍스트-vs-의미"><span class="header-section-number">1.1</span> 평가 기준의 모호성: 텍스트 vs 의미</a></li>
  <li><a href="#평가의-실무적-딜레마" id="toc-평가의-실무적-딜레마" class="nav-link" data-scroll-target="#평가의-실무적-딜레마"><span class="header-section-number">1.2</span> 평가의 실무적 딜레마</a></li>
  </ul></li>
  <li><a href="#프롬프트-평가의-4-가지-핵심-가치" id="toc-프롬프트-평가의-4-가지-핵심-가치" class="nav-link" data-scroll-target="#프롬프트-평가의-4-가지-핵심-가치"><span class="header-section-number">2</span> 프롬프트 평가의 4 가지 핵심 가치</a>
  <ul class="collapse">
  <li><a href="#품질-보증-quality-assurance의-체계화" id="toc-품질-보증-quality-assurance의-체계화" class="nav-link" data-scroll-target="#품질-보증-quality-assurance의-체계화"><span class="header-section-number">2.1</span> 품질 보증 (Quality Assurance)의 체계화</a></li>
  <li><a href="#성능-최적화의-과학화" id="toc-성능-최적화의-과학화" class="nav-link" data-scroll-target="#성능-최적화의-과학화"><span class="header-section-number">2.2</span> 성능 최적화의 과학화</a></li>
  <li><a href="#비용-효율성의-정량화" id="toc-비용-효율성의-정량화" class="nav-link" data-scroll-target="#비용-효율성의-정량화"><span class="header-section-number">2.3</span> 비용 효율성의 정량화</a></li>
  <li><a href="#사용자-경험-ux의-측정-가능화" id="toc-사용자-경험-ux의-측정-가능화" class="nav-link" data-scroll-target="#사용자-경험-ux의-측정-가능화"><span class="header-section-number">2.4</span> 사용자 경험 (UX)의 측정 가능화</a></li>
  </ul></li>
  <li><a href="#가지-가치의-상호작용" id="toc-가지-가치의-상호작용" class="nav-link" data-scroll-target="#가지-가치의-상호작용"><span class="header-section-number">3</span> 4 가지 가치의 상호작용</a></li>
  <li><a href="#평가의-딜레마-객관화할-수-없는-것을-측정하는-것에-대한-어려움" id="toc-평가의-딜레마-객관화할-수-없는-것을-측정하는-것에-대한-어려움" class="nav-link" data-scroll-target="#평가의-딜레마-객관화할-수-없는-것을-측정하는-것에-대한-어려움"><span class="header-section-number">4</span> 평가의 딜레마: 객관화할 수 없는 것을 측정하는 것에 대한 어려움</a>
  <ul class="collapse">
  <li><a href="#기준의-주관성-문제" id="toc-기준의-주관성-문제" class="nav-link" data-scroll-target="#기준의-주관성-문제"><span class="header-section-number">4.1</span> 기준의 주관성 문제</a></li>
  <li><a href="#정답-데이터셋의-부재" id="toc-정답-데이터셋의-부재" class="nav-link" data-scroll-target="#정답-데이터셋의-부재"><span class="header-section-number">4.2</span> 정답 데이터셋의 부재</a></li>
  <li><a href="#평가자의-평가-누가-평가자를-판단하는가" id="toc-평가자의-평가-누가-평가자를-판단하는가" class="nav-link" data-scroll-target="#평가자의-평가-누가-평가자를-판단하는가"><span class="header-section-number">4.3</span> 평가자의 평가: 누가 평가자를 판단하는가</a></li>
  <li><a href="#맥락-의존성의-함정" id="toc-맥락-의존성의-함정" class="nav-link" data-scroll-target="#맥락-의존성의-함정"><span class="header-section-number">4.4</span> 맥락 의존성의 함정</a></li>
  <li><a href="#순환-논리의-위험" id="toc-순환-논리의-위험" class="nav-link" data-scroll-target="#순환-논리의-위험"><span class="header-section-number">4.5</span> 순환 논리의 위험</a></li>
  </ul></li>
  <li><a href="#딜레마를-넘어서-llm-as-a-judge의-실용적-접근" id="toc-딜레마를-넘어서-llm-as-a-judge의-실용적-접근" class="nav-link" data-scroll-target="#딜레마를-넘어서-llm-as-a-judge의-실용적-접근"><span class="header-section-number">5</span> 딜레마를 넘어서: LLM-as-a-Judge의 실용적 접근</a>
  <ul class="collapse">
  <li><a href="#llm-as-a-judge-방법론-등장" id="toc-llm-as-a-judge-방법론-등장" class="nav-link" data-scroll-target="#llm-as-a-judge-방법론-등장"><span class="header-section-number">5.1</span> “LLM-as-a-Judge”** 방법론 등장</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="들어가며" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="들어가며"><span class="header-section-number">1</span> 들어가며</h2>
<p>프롬프트 엔지니어링을 실무에 적용하다 보면 ’정답이 없는 프롬프트’를 평가 해야하는데 생각보다 쉽지 않다.</p>
<p>전통적인 소프트웨어 개발에서는 상대적으로 명확한 평가 기준이 있다. * 명확한 테스트 케이스와 예상 출력값이 있다.<br>
* 따라서, 함수에 특정 입력을 넣었을 때 특정 출력이 나와야 한다는 것이 분명하다.<br>
* 예를 들어, 2 + 2는 4여야 하고, 사용자 인증 함수는 올바른 비밀번호에 대해 true를 반환해야 한다.<br>
* 이런 명확성 덕분에 structured test(unit test, integration test, system level test)를 수행하고, 코드가 의도대로 작동하는지 기계적으로 검증할 수 있다.</p>
<p>하지만 생성형 AI를 다루는 프롬프트 엔지니어링은 근본적으로 다른 세계다. * 같은 질문에도 무수히 많은 “괜찮은” 답변이 확률적으로 출력된다.<br>
* 예를 들어 “Python 리스트를 정렬하는 방법” 질문에 대해, 어떤 답변은 <code>sorted()</code> 함수를 소개하고, 어떤 답변은 <code>.sort()</code> 메서드를 설명하고, 어떤 답변은 두 가지를 비교하며 설명한다.<br>
* 어느 것이 “정답”인가? 맥락에 따라 다르다. 초보자에게는 단순한 설명이, 숙련자에게는 비교 분석이 더 나을 수 있다.</p>
<p><em>프롬프트 평가는 본질적으로 불완전하지만, 불완전함을 인식한 상태에서라도 반드시 해야 하는 실무적 필수 요소다.</em></p>
<p>그렇다면 프롬프트의 성능을 어떤 기준으로 평가해야 하는가?</p>
<section id="평가-기준의-모호성-텍스트-vs-의미" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="평가-기준의-모호성-텍스트-vs-의미"><span class="header-section-number">1.1</span> 평가 기준의 모호성: 텍스트 vs 의미</h3>
<p><strong>“답변이 텍스트 형태이므로 텍스트 자체를 기준으로 평가해야 할까?”</strong></p>
<ul>
<li>텍스트의 표면적 특성을 측정</li>
<li>답변의 길이의 적절성</li>
<li>전문 용어의 사용 빈도</li>
<li>문장/문단 구조의 복잡도</li>
<li>특정 키워드가 포함 유무</li>
</ul>
<p>이런 표면적 지표만으로는 품질을 제대로 파악하기 어렵다. 예를 들어, 답변이 500단어라는 사실 자체는 좋고 나쁨을 말해주지 않는다. 어떤 질문에는 50단어면 충분하고, 어떤 질문에는 1000단어도 부족하다. 전문 용어 사용도 마찬가지다. 의학 전문가에게는 정확한 의학 용어를 쓰는 것이 신뢰를 주지만, 일반인에게는 쉬운 설명이 더 효과적이다.</p>
<p>더 심각한 문제는 텍스트 지표가 hallucination(환각)을 잡아내지 못한다. 문법적으로 완벽하고 구조도 훌륭한 500단어 답변이 사실은 완전히 틀린 정보일 수 있다.</p>
<p><strong>“답변이 질문에 얼마나 정확하게 답했는지를 기준으로 평가해야 할까?”</strong></p>
<ul>
<li>“정확성” 평가도 생각보다 복잡하다.</li>
<li>정확성에는 여러 층위가 있다. 이를테면, :
<ul>
<li><strong>사실적 정확성(Factual Accuracy)</strong>: 답변에 포함된 정보가 객관적으로 맞는가? “지구는 태양 주위를 돈다”는 맞고, “태양이 지구 주위를 돈다”는 틀리다.<br>
</li>
<li><strong>의도 정확성(Intent Accuracy)</strong>: 답변이 사용자가 정말로 원하는 것을 제공하는가? 사용자가 “파이썬 리스트 정렬”이라고 물었을 때, 코드 예제를 원하는 건가 개념 설명을 원하는 건가? 맥락을 제대로 파악해야 한다.<br>
</li>
<li><strong>절차적 정확성(Procedural Accuracy)</strong>: 답변이 실행 가능한가? 특히 코드나 레시피 같은 절차적 지시를 다룰 때, 단계가 빠지거나 순서가 잘못되면 “정확”하더라도 쓸모없다.<br>
</li>
</ul></li>
<li>만약 사용자가 애매하거나 불완전한 질문을 던진다면?
<ul>
<li>예를 들어 “어제 본 그 영화 제목이 뭐였지?”라고 물으면, AI는 당연히 모른다.</li>
<li>이때 AI는 “모른다” 또는 환각을 내뱉는다. 하지만 사용자 입장에서는 어느 것도 도움이 되지 않는다.<br>
</li>
<li>더 나은 답변은 함께 질문을 구체화 시키는 제안 또는 대안을 제시하는 것이다.</li>
<li>하지만, 이것도 “정확한” 답변은 아니다. 단지, 더 유용할 뿐이다.<br>
</li>
</ul></li>
<li>이러한 질문들은 단순히 기술적인 문제가 아니라 철학적이고 실용적인 문제에 가깝다.</li>
</ul>
<p>프롬프트 평가는 결국 “AI가 생성한 텍스트의 품질을 어떻게 정의하고 측정할 것인가”라는 근본적인 물음으로 귀결된다. 그리고 이 물음에 대한 답은 사용 사례, 사용자 특성, 상황 맥락에 따라 달라진다.</p>
</section>
<section id="평가의-실무적-딜레마" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="평가의-실무적-딜레마"><span class="header-section-number">1.2</span> 평가의 실무적 딜레마</h3>
<p>실무에서는 이런 철학적 질문이 매우 구체적인 의사결정 문제로 나타난다. 예를 들어:</p>
<ul>
<li><strong>A/B 테스트 상황</strong>: 두 가지 프롬프트 버전이 있는데, 어느 것을 배포할 것인가? 판단 기준이 필요하다.</li>
<li><strong>모델 업데이트 후</strong>: 새 버전의 LLM이 나왔는데, 기존 프롬프트가 여전히 잘 작동하는가? 퇴화(regression)를 감지해야 한다.</li>
<li><strong>비용 최적화</strong>: 프롬프트를 짧게 만들어 토큰 비용을 줄이고 싶은데, 품질 손실은 얼마나 되는가? 트레이드오프를 측정해야 한다.</li>
<li><strong>팀 협업</strong>: 여러 사람이 프롬프트를 작성할 때, “이게 더 좋다”는 주장을 어떻게 뒷받침할 것인가? 공통 언어가 필요하다.</li>
</ul>
<p>이 모든 상황에서 체계적인 평가 방법론이 없으면 주관적 판단에 의존하게 되고, 결과적으로 품질이 들쭉날쭉해진다.</p>
</section>
</section>
<section id="프롬프트-평가의-4-가지-핵심-가치" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="프롬프트-평가의-4-가지-핵심-가치"><span class="header-section-number">2</span> 프롬프트 평가의 4 가지 핵심 가치</h2>
<p>이 네 가지는 각각 독립적이면서도 서로 긴밀하게 연결되어 있으며, 실무에서 구체적인 비즈니스 가치로 전환되는데 도움이 될 수 있다.</p>
<section id="품질-보증-quality-assurance의-체계화" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="품질-보증-quality-assurance의-체계화"><span class="header-section-number">2.1</span> 품질 보증 (Quality Assurance)의 체계화</h3>
<ul>
<li>실무에서 프롬프트가 만들어진 후 끊임없이 변화하는 환경에 노출된다.<br>
</li>
<li>LLM의 모델 업데이트로 같은 프롬프트가 다른 결과를 낼 수 있다. OpenAI의 GPT-4가 GPT-4 Turbo로 업데이트되었을 때, 많은 개발자들이 기존에 잘 작동하던 프롬프트가 갑자기 이상한 답변을 내놓는 것을 경험했다.<br>
</li>
<li>체계적인 평가 기준이 없으면 이런 변화를 감지조차 할 수 없다.</li>
<li>평가 체계가 있다면 구체적으로 문제를 진단할 수 있다.<br>
</li>
<li><strong>회귀 테스트(regression testing)</strong>를 가능하게 한다.
<ul>
<li>회귀 테스트: 전통적인 소프트웨어 개발에서 새로운 코드 변경 후에도 여전히 올바르게 작동하는지 확인<br>
</li>
<li>프롬프트를 수정할 때도 다른 측면에서 품질 저하가 없는지 확인해야 한다.<br>
</li>
<li>예를 들어, 프롬프트를 짧게 줄여서 비용을 절감했는데, 알고 보니 정확도가 크게 떨어졌을 때 평가 시스템이 없으면 이를 배포 후에야 사용자 불만으로 알게 된다.</li>
</ul></li>
</ul>
<p>품질 보증은 또한 <strong>팀 협업의 기반</strong>이 된다. 공통된 평가 기준이 없기 때문에 발생하는 논쟁의 예를 보면:</p>
<ul>
<li>A: “이 프롬프트가 더 나은 것 같은데요.”<br>
</li>
<li>B: “저는 이전 버전이 더 명확한 것 같은데요.”<br>
</li>
<li>A: “하지만 제 버전이 더 자연스러워요.”<br>
</li>
<li>B: “자연스러움보다는 정확성이 중요하지 않나요?”</li>
</ul>
<p>하지만, 합의를 통해 “명확성 8점, 자연스러움 7점, 정확성 9점”처럼 구체적인 지표가 있다면, 데이터 기반 의사결정을 할 수 있다.</p>
</section>
<section id="성능-최적화의-과학화" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="성능-최적화의-과학화"><span class="header-section-number">2.2</span> 성능 최적화의 과학화</h3>
<ul>
<li>프롬프트 엔지니어링은 종종 예술처럼 여겨지지만, 과학적인 최적화 과정으로 만든다.</li>
<li><strong>평가 지표</strong>가 있어야 최적화를 “측정 가능한” 작업으로 만들어 <strong>A/B 테스트</strong>를 수행할 수 있다.</li>
<li>예를 들어, 당신이 고객 지원 챗봇의 응답 시간을 줄이고 싶다고 하자.
<ul>
<li>버전 A(역할 지시 없음): 평균 정확도 85%, 명확성 7.5점<br>
</li>
<li>버전 B(역할 지시 있음): 평균 정확도 88%, 명확성 8.2점<br>
</li>
<li>역할 지시가 3%p의 정확도 향상과 0.7점의 명확성 향상을 가져온다.</li>
<li>이는 재현 가능한 패턴이 되고, 다른 프롬프트에도 적용할 수 있는 전략이 된다.<br>
</li>
</ul></li>
<li>더 정교한 <strong>다차원 최적화</strong>도 가능하다:
<ul>
<li>역할 지시(role)의 유무와 내용<br>
</li>
<li>출력 형식(format) 지정<br>
</li>
<li>예시(examples) 제공 여부<br>
</li>
<li>사고 과정(chain-of-thought) 유도<br>
</li>
<li>제약 조건(constraints) 명시<br>
</li>
</ul></li>
<li>각 차원의 조합을 체계적으로 평가하면, 어떤 요소가 어떤 상황에서 효과적인지 데이터로 파악할 수 있다.</li>
<li>예를 들어, “우리 사용 사례에서는 few-shot 예시가 정확도를 12% 향상시키지만, 응답 길이를 30% 증가시킨다”처럼 트레이드오프를 정량화할 수 있다.<br>
</li>
<li>성능 최적화는 감이나 직관이 아니라, 데이터 기반의 체계적인 개선 과정으로 프롬프트 엔지니어링을 “엔지니어링”답게 만드는 핵심이다.<br>
</li>
<li>성능 최적화는 <strong>반복적 개선 프로세스</strong>를 가능하게 만들기 때문이다:
<ol type="1">
<li>초기 프롬프트 작성<br>
</li>
<li>평가 지표로 성능 측정<br>
</li>
<li>약점 파악 (예: 정확도는 높지만 명확성이 낮음)<br>
</li>
<li>약점을 개선하는 방향으로 수정<br>
</li>
<li>다시 평가하여 개선 효과 확인<br>
</li>
<li>반복</li>
</ol></li>
</ul>
</section>
<section id="비용-효율성의-정량화" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="비용-효율성의-정량화"><span class="header-section-number">2.3</span> 비용 효율성의 정량화</h3>
<ul>
<li>생성형 AI를 운영하는 데는 실제 비용이 발생한다.</li>
<li>API는 토큰 단위로 과금되고 긴 프롬프트와 긴 응답은 더 많은 비용을 발생시킨다.<br>
</li>
<li>만약 당신의 프롬프트가 평균 1,000 토큰이고, 응답이 평균 500 토큰이라면, 한 번의 호출에 약 $0.025가 든다.</li>
<li>하루에 10만 건의 요청을 처리한다면 하루 $2,500, 연간 약 $900,000이다. 10억 원이 넘는다.<br>
</li>
<li>이런 처리 수준은 더 이상 프롬프트 최적화 수준이 아닌 비즈니스 문제가 된다.</li>
<li>만약 프롬프트를 50%로 줄일 수 있다면 입력 비용이 50% 감소하여 연간 약 1억 8천만 원을 절감할 수 있다.</li>
<li>하지만, 여기서 중요한 핵심은 <strong>품질은 유지의 유무</strong>이다.<br>
</li>
<li>평가 시스템이 없으면 이 질문에 답할 수 없다. 하지만 평가 체계가 있다면:
<ul>
<li>1,000 토큰 프롬프트: 정확도 90%, 명확성 8.5점<br>
</li>
<li>500 토큰 프롬프트: 정확도 87%, 명확성 8.0점<br>
</li>
</ul></li>
<li>이 비용과 성능의 Trade-off를 명확히 가늠하여 의사결정을 할 수 있다.
<ul>
<li>고객 서비스 관련 기능이면 신중해야 한다.</li>
<li>하지만 내부용 서비스라면 충분히 받아들일 만한 트레이드오프일 수 있다.<br>
</li>
</ul></li>
<li><strong>“충분히 좋은” 수준의 정의</strong>
<ul>
<li>모든 응답이 완벽할 필요는 없다.</li>
<li>Pareto 원칙(80/20 법칙): 80점짜리 답변을 생성하는 데는 적은 비용이 들지만, 95점짜리 답변을 만들려면 몇 배의 비용이 든다.</li>
<li>사용 사례가 80점으로 충분하다면 오버엔지니어링하지 말아야 한다.<br>
</li>
<li>평가 시스템은 이 “충분함”의 임계값을 찾는 데 도움을 준다.</li>
</ul></li>
</ul>
</section>
<section id="사용자-경험-ux의-측정-가능화" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="사용자-경험-ux의-측정-가능화"><span class="header-section-number">2.4</span> 사용자 경험 (UX)의 측정 가능화</h3>
<ul>
<li>모든 프롬프트는 사용자에게 가치를 제공하기 위해 존재한다.</li>
<li>사용자가 만족 여부의 측정이 궁극적인 평가 기준이다.
<ul>
<li>전통적인 방법: <strong>직접 피드백 수집</strong> (각 응답에 thumbs up/down 버튼을 제공, 주기적 설문조사, 등)</li>
<li>하지만 전통적인 방법에는 여러 가지 한계가 있다:
<ol type="1">
<li><strong>낮은 응답률</strong>: 대부분의 사용자는 피드백을 주지 않는다. 극단적으로 만족하거나 불만족할 때만 반응한다.<br>
</li>
<li><strong>지연된 발견</strong>: 문제를 사용자가 경험한 후에야 알 수 있다.<br>
</li>
<li><strong>확장성 부족</strong>: 모든 응답마다 피드백을 받을 수는 없다.<br>
</li>
<li><strong>맥락 손실</strong>: “나쁨”이라는 평가만 있고, 왜 나쁜지 알 수 없다.<br>
</li>
</ol></li>
<li>프롬프트 평가 체계: 전통적 평가 방법을 보완하는 <strong>대리 지표(proxy metric)</strong> 역할을 한다.
<ul>
<li>사용자가 만족할 만한 응답의 특성을 정의하고 (예: 명확성, 정확성, 공감, 정중함, 완성도), 이를 자동으로 측정한다.<br>
</li>
<li>물론 자동 평가가 실제 사용자 만족도와 100% 일치하지는 않는다.<br>
</li>
<li>하지만 연구에 따르면 80% 이상의 상관관계를 보인다면, 충분히 유용한 선행 지표가 된다.
<ol type="1">
<li><strong>“Judging LLM-as-a-Judge with MT-Bench and Chatbot Arena”</strong> (2023)
<ul>
<li><strong>저자</strong>: Lianmin Zheng et al.&nbsp;(UC Berkeley, LMSYS)<br>
</li>
<li><strong>출판</strong>: NeurIPS 2023 Datasets and Benchmarks Track<br>
</li>
<li><strong>arXiv</strong>: <a href="https://arxiv.org/abs/2306.05685">2306.05685</a><br>
</li>
<li><strong>핵심 결과</strong>: GPT-4를 judge로 사용했을 때 <strong>인간 평가와 80% 이상의 일치율(agreement)</strong>을 달성했다고 보고<br>
</li>
<li><strong>요약</strong>: “strong LLM judges like GPT-4 can match both controlled and crowdsourced human preferences well, achieving <strong>over 80% agreement, the same level of agreement between humans</strong>”</li>
<li><strong>GitHub</strong>: <a href="https://github.com/lm-sys/FastChat/tree/main/fastchat/llm_judge">FastChat LLM Judge</a><br>
</li>
</ul></li>
<li><strong>“G-Eval: NLG Evaluation using GPT-4 with Better Human Alignment”</strong> (2023)
<ul>
<li><strong>저자</strong>: Yang Liu et al.&nbsp;(Microsoft Research)<br>
</li>
<li><strong>출판</strong>: arXiv preprint<br>
</li>
<li><strong>arXiv</strong>: <a href="https://arxiv.org/abs/2303.16634">2303.16634</a><br>
</li>
<li><strong>핵심 결과</strong>: GPT-4 기반의 G-Eval이 텍스트 요약 작업에서 인간 평가와 <strong>Spearman correlation 0.514</strong>를 달성하여, 기존의 모든 자동 평가 방법을 크게 능가</li>
<li><strong>방법론</strong>: Chain-of-Thought와 form-filling 패러다임 사용<br>
</li>
<li><strong>GitHub</strong>: <a href="https://github.com/nlpyang/geval">G-Eval Code</a><br>
</li>
</ul></li>
</ol></li>
</ul></li>
</ul></li>
<li><strong>실시간 모니터링</strong> 가능
<ul>
<li>품질 지표를 지속적으로 추적하면서, 특정 임계값 아래로 떨어지면 알림을 받을 수 있고 문제가 확산되기 전에 대응할 수 있다.</li>
<li>예를 들어:
<ul>
<li>“지난 1시간 동안 명확성 점수가 평균 7.2에서 5.8로 떨어졌습니다”<br>
</li>
<li>“특정 유형의 질문(기술 지원)에서 완성도 점수가 유독 낮습니다”<br>
</li>
</ul></li>
</ul></li>
<li><strong>사용자 세그먼트 및 Personalization 서비스</strong>의 발판 마련
<ul>
<li>모든 사용자가 같은 것을 원하지 않는다:
<ul>
<li>전문가 vs 초보자: 전문가는 정확하고 간결한 답변을, 초보자는 친절하고 자세한 설명을 선호<br>
</li>
<li>급한 상황 vs 여유로운 상황: 긴급 문의는 즉각적인 해결책을, 탐색적 질문은 포괄적인 정보를 원함<br>
</li>
<li>문화적 차이: 직접적인 의사소통을 선호하는 문화권 vs 간접적이고 공손한 표현을 중시하는 문화권</li>
</ul></li>
</ul></li>
</ul>
</section>
</section>
<section id="가지-가치의-상호작용" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="가지-가치의-상호작용"><span class="header-section-number">3</span> 4 가지 가치의 상호작용</h2>
<ul>
<li>이 4가지는 독립적이지 않다. 서로 긴밀하게 연결되어 있고, 때로는 충돌하기도 한다.
<ul>
<li><strong>품질과 비용의 트레이드오프</strong>: 최고 품질을 추구하면 비용이 증가한다. 비용을 최소화하면 품질이 하락할 수 있다. 평가 시스템은 이 균형점을 찾는 데 도움을 준다.<br>
</li>
<li><strong>성능과 사용자 경험의 정렬</strong>: 기술적으로 최적화된 프롬프트가 항상 사용자가 선호하는 것은 아니다. 때로는 약간 덜 효율적이지만 더 친근한 답변이 사용자 만족도를 높일 수 있다.<br>
</li>
<li><strong>품질 보증과 혁신의 균형</strong>: 너무 엄격한 품질 기준은 실험과 혁신을 막을 수 있다. 평가 시스템은 “안전한 실험 공간”을 제공한다. 새로운 프롬프트를 작은 사용자 그룹에 테스트하고, 평가 지표로 성능을 확인한 후 점진적으로 확대할 수 있다.</li>
</ul></li>
</ul>
</section>
<section id="평가의-딜레마-객관화할-수-없는-것을-측정하는-것에-대한-어려움" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="평가의-딜레마-객관화할-수-없는-것을-측정하는-것에-대한-어려움"><span class="header-section-number">4</span> 평가의 딜레마: 객관화할 수 없는 것을 측정하는 것에 대한 어려움</h2>
<section id="기준의-주관성-문제" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="기준의-주관성-문제"><span class="header-section-number">4.1</span> 기준의 주관성 문제</h3>
<ul>
<li>’좋은 답변, 충분한 등’의 수학적 명제가 아닌 표현은 주관적인 표현이므로 참/거짓 및 정량화하기 어렵다</li>
<li>예를 들어, 의료 AI Chatbot을 개발한다 했을 때 환자가 “머리가 아파요”라고 입력한다면:
<ul>
<li><strong>시나리오 1 - 긴급 상황 판단이 필요한 경우</strong>: “머리 통증과 함께 다음 증상이 있나요? (1) 시야 흐림 (2) 구토 (3) 목 경직. 이 증상들은 응급 상황일 수 있습니다”<br>
</li>
<li><strong>시나리오 2 - 일반적인 안내가 필요한 경우</strong>: “두통의 원인은 다양합니다. 스트레스, 수면 부족, 탈수, 긴장성 두통 등이 흔한 원인입니다. 충분한 수분 섭취와 휴식을 권장합니다”<br>
</li>
<li><strong>시나리오 3 - 즉각적인 행동 유도가 필요한 경우</strong>: “근처 병원이나 약국 위치를 찾아드릴까요? 아니면 예약 가능한 의사를 찾아드릴까요?”</li>
</ul></li>
</ul>
<p>어느 것이 “좋은” 답변인가? 맥락에 달려 있다. 환자의 증상 심각도, 의료 시스템 접근성, 시간대, 환자의 의료 지식 수준 등 여러 요인이 영향을 미친다. 하나의 절대적인 “정답 답변”은 존재하지 않는다.</p>
</section>
<section id="정답-데이터셋의-부재" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="정답-데이터셋의-부재"><span class="header-section-number">4.2</span> 정답 데이터셋의 부재</h3>
<ul>
<li>전통적인 기계학습에서는 레이블된 데이터셋이 있다.</li>
<li>하지만 생성형 AI의 경우, 무한히 많은 “괜찮은 답변”이 존재한다.</li>
<li>예를 들어, “파이썬에서 리스트를 역순으로 만드는 방법”이라는 질문에 대해:</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># 방법 1: reverse() 메서드</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>my_list.reverse()</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co"># 방법 2: reversed() 함수  </span></span>
<span id="cb1-5"><a href="#cb1-5"></a>new_list <span class="op">=</span> <span class="bu">list</span>(<span class="bu">reversed</span>(my_list))</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co"># 방법 3: 슬라이싱</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>new_list <span class="op">=</span> my_list[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co"># 방법 4: 반복문</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>new_list <span class="op">=</span> []</span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(my_list)<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb1-13"><a href="#cb1-13"></a>    new_list.append(my_list[i])</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>이 4가지 방법 모두 정확하다. 어떤 답변이 “최선”인가? 사용자의 파이썬 숙련도, 코드 가독성 선호도, 성능 요구사항에 따라 다르다.
<ul>
<li>초보자에게는 방법 1이 가장 직관적이지만</li>
<li>원본 리스트를 보존해야 한다면 방법 2나 3이 낫다.</li>
<li>교육 목적이라면 방법 4처럼 기본 원리를 보여주는 것이 가치있을 수 있다.</li>
</ul></li>
</ul>
<p>그렇다면 무엇과 비교해서 평가해야 하는가? 미리 만들어둔 “완벽한 답변”과 비교할 수 없다. 왜냐하면 완벽한 답변 자체가 맥락에 따라 달라지기 때문이다.</p>
</section>
<section id="평가자의-평가-누가-평가자를-판단하는가" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="평가자의-평가-누가-평가자를-판단하는가"><span class="header-section-number">4.3</span> 평가자의 평가: 누가 평가자를 판단하는가</h3>
<ul>
<li>더 근본적인 문제는 “평가 기준 자체를 누가 평가하는가”이다.</li>
<li>“명확성”이라는 평가 기준을 만들었을 때 “명확성” 개념이 실제 사용자의 “명확성” 개념과 일치한다는 보장이 있는가?</li>
<li>실제로 이런 난이도 높은 불일치 문제는 자주 발생한다.
<ul>
<li>개발팀은 “기술적으로 정확한” 답변을 명확하다고 생각하지만, 비전문가 사용자는 “이해하기 쉬운” 답변을 명확하다고 느낀다.</li>
<li>전자는 “OAuth 2.0의 인증 플로우는 Authorization Code Grant 방식을 사용합니다”라고 설명하는 것을 선호하지만,</li>
<li>후자는 “로그인 버튼을 누르면 권한을 요청하는 창이 뜨고, 승인하면 앱이 당신의 정보에 접근할 수 있게 됩니다”라는 설명을 선호한다.</li>
</ul></li>
</ul>
</section>
<section id="맥락-의존성의-함정" class="level3" data-number="4.4">
<h3 data-number="4.4" class="anchored" data-anchor-id="맥락-의존성의-함정"><span class="header-section-number">4.4</span> 맥락 의존성의 함정</h3>
<ul>
<li>또 다른 난점: 맥락 의존성</li>
<li>같은 프롬프트라도 다른 맥락에서는 다르게 평가되어야 한다.<br>
</li>
<li>고객 지원 챗봇을 다시 예로 들면:</li>
</ul>
<p><strong>상황 A - 오전 9시, 일반 문의</strong>:<br>
사용자: “환불 정책이 어떻게 되나요?”<br>
AI: “환불은 구매 후 30일 이내에 가능합니다. 제품이 미개봉 상태여야 하며, 영수증이 필요합니다. 환불 신청은 웹사이트의 ’주문 내역’에서 하실 수 있습니다.”<br>
→ 이 답변은 <strong>완벽하다</strong>. 명확하고, 완전하고, 실행 가능하다.</p>
<p><strong>상황 B - 새벽 2시, 긴급 문의</strong>:<br>
사용자: “환불 정책이 어떻게 되나요?”<br>
AI: “환불은 구매 후 30일 이내에 가능합니다. 제품이 미개봉 상태여야 하며, 영수증이 필요합니다. 환불 신청은 웹사이트의 ’주문 내역’에서 하실 수 있습니다.”<br>
→ 이 답변은 <strong>불충분할 수 있다</strong>. 새벽 시간에 문의한다는 것은 급한 상황일 가능성이 높다. “고객센터는 평일 오전 9시에 시작되며, 긴급 상황이시라면 24시간 이메일 지원(support@…)으로 문의해주세요”라는 추가 정보가 필요하다.</p>
<p>같은 답변이 맥락에 따라 우수할 수도, 부족할 수도 있다. 평가 시스템이 이런 맥락을 포착할 수 있어야 한다.</p>
</section>
<section id="순환-논리의-위험" class="level3" data-number="4.5">
<h3 data-number="4.5" class="anchored" data-anchor-id="순환-논리의-위험"><span class="header-section-number">4.5</span> 순환 논리의 위험</h3>
<ul>
<li>“AI로 AI를 평가한다”는 접근에는 순환 논리의 위험이 있다.</li>
<li>GPT-4가 생성한 답변을 GPT-4가 평가한다면? 모델의 편향(bias)이 평가에도 반영될 수 있다.</li>
<li>예를 들어, GPT-4가 특정 스타일의 답변을 선호한다면, 그 스타일의 답변에 높은 점수를 줄 것이다. 하지만 그 스타일이 실제로 사용자에게 좋은지는 별개의 문제다.<br>
</li>
<li>이는 특히 다양성(diversity)과 창의성(creativity) 평가에서 문제가 된다.</li>
<li>모델이 “안전하고 예측 가능한” 답변을 선호하도록 학습되었다면, 창의적이지만 예상 밖의 답변에 낮은 점수를 줄 수 있다.</li>
<li>하지만 어떤 사용 사례에서는 바로 그 창의성이 가치있을 수 있다.</li>
</ul>
</section>
</section>
<section id="딜레마를-넘어서-llm-as-a-judge의-실용적-접근" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="딜레마를-넘어서-llm-as-a-judge의-실용적-접근"><span class="header-section-number">5</span> 딜레마를 넘어서: LLM-as-a-Judge의 실용적 접근</h2>
<ul>
<li>이 모든 딜레마에도 불구하고, 우리는 여전히 프롬프트를 평가해야 한다.</li>
<li>완벽한 평가 시스템을 기다릴 수 없다.</li>
<li>비즈니스는 계속되고, 의사결정은 매일 내려져야 한다.</li>
</ul>
<section id="llm-as-a-judge-방법론-등장" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="llm-as-a-judge-방법론-등장"><span class="header-section-number">5.1</span> “LLM-as-a-Judge”** 방법론 등장</h3>
<ul>
<li>AI를 평가하는 데 AI를 사용한다.<br>
</li>
<li>이는 완벽하지 않다는 것을 인정하면서도, 실용적으로 충분히 유용하다는 것을 입증한 접근법이다.<br>
</li>
<li>언뜻 순환 논리처럼 보이지만, 실제로는 매우 합리적이다.
<ul>
<li>인간도 다른 인간의 글쓰기를 평가한다.<br>
</li>
<li>선생님이 학생의 에세이를 평가하고,<br>
</li>
<li>편집자가 작가의 원고를 평가한다.<br>
</li>
</ul></li>
<li>핵심은 <strong>검증(validation)</strong>
<ul>
<li>평가자와 피평가자가 같은 종류의 지능을 가졌다고 해서 평가가 무의미한 것은 아니다.</li>
<li>오히려 같은 종류의 지능이기 때문에 더 정교한 평가가 가능할 수 있다.<br>
</li>
<li>LLM의 평가가 인간 전문가의 평가와 얼마나 일치하는지 측정하고, 충분한 일치도(예: 80% 이상)가 확인되면 대규모로 사용하는 것이다. 완벽하지 않지만, 수동 평가보다 훨씬 빠르고 저렴하며 확장 가능하다.</li>
</ul></li>
</ul>
<p><em>프롬프트 평가는 완벽할 수 없다. 하지만 그렇다고 평가하지 않을 수도 없다. 우리가 할 수 있는 최선은, 평가 방법의 한계를 인식하면서도, 지속적으로 개선해나가는 것이다. 그 구체적인 방법을 찾아야한다.</em></p>


</section>
</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>