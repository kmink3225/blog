<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="Retrieval Augmented Generation (RAG)의 정의부터 실전 구현까지 체계적으로 설명한다. Lewis et al.&nbsp;(2020) “Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks” 연구를 바탕으로 외부 지식베이스 검색(Retrieval)과 답변 생성(Generation)의 결합 원리, 벡터 임베딩과 유사도 검색 메커니즘, 문서 청킹(Chunking) 전략(토큰 기반, 문장 기반, 의미론적, 구조 기반)을 분석한다. Indexing과 Query 단계의 2단계 프로세스, BM25/Dense/Hybrid 검색 방법, Re-ranking 최적화를 제시하고, 간단한 Q&amp;A 시스템, 고객 지원 챗봇, 문서 분석 도구 등 실무 예시와 Python 구현 코드(벡터 DB, 임베딩 모델 활용)를 통해 실전 구축 방법을 상세히 다룬다. 청크 크기 최적화, top_k 설정, 검색 품질 평가(Precision, Recall, MRR), 할루시네이션 방지 전략과 출처 추적 패턴을 제시한다.">

<title>Kwangmin Kim - RAG (Retrieval Augmented Generation): 외부 지식과 생성의 결합</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - RAG (Retrieval Augmented Generation): 외부 지식과 생성의 결합">
<meta property="og:description" content="Retrieval Augmented Generation (RAG)의 정의부터 실전 구현까지 체계적으로 설명한다. Lewis et al.&nbsp;(2020) “Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks” 연구를 바탕으로 외부 지식베이스 검색(Retrieval)과 답변 생성(Generation)의 결합 원리, 벡터 임베딩과 유사도 검색 메커니즘, 문서 청킹(Chunking) 전략(토큰 기반, 문장 기반, 의미론적, 구조 기반)을 분석한다. Indexing과 Query 단계의 2단계 프로세스, BM25/Dense/Hybrid 검색 방법, Re-ranking 최적화를 제시하고, 간단한 Q&amp;A 시스템, 고객 지원 챗봇, 문서 분석 도구 등 실무 예시와 Python 구현 코드(벡터 DB, 임베딩 모델 활용)를 통해 실전 구축 방법을 상세히 다룬다. 청크 크기 최적화, top_k 설정, 검색 품질 평가(Precision, Recall, MRR), 할루시네이션 방지 전략과 출처 추적 패턴을 제시한다.">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Kwangmin Kim - RAG (Retrieval Augmented Generation): 외부 지식과 생성의 결합">
<meta name="twitter:description" content="Retrieval Augmented Generation (RAG)의 정의부터 실전 구현까지 체계적으로 설명한다. Lewis et al.&nbsp;(2020) “Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks” 연구를 바탕으로 외부 지식베이스 검색(Retrieval)과 답변 생성(Generation)의 결합 원리, 벡터 임베딩과 유사도 검색 메커니즘, 문서 청킹(Chunking) 전략(토큰 기반, 문장 기반, 의미론적, 구조 기반)을 분석한다. Indexing과 Query 단계의 2단계 프로세스, BM25/Dense/Hybrid 검색 방법, Re-ranking 최적화를 제시하고, 간단한 Q&amp;A 시스템, 고객 지원 챗봇, 문서 분석 도구 등 실무 예시와 Python 구현 코드(벡터 DB, 임베딩 모델 활용)를 통해 실전 구축 방법을 상세히 다룬다. 청크 크기 최적화, top_k 설정, 검색 품질 평가(Precision, Recall, MRR), 할루시네이션 방지 전략과 출처 추적 패턴을 제시한다.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">RAG (Retrieval Augmented Generation): 외부 지식과 생성의 결합</h1>
            <p class="subtitle lead">검색과 생성을 결합하여 LLM의 지식 한계를 극복하는 핵심 기법</p>
                  <div>
        <div class="description">
          <p>Retrieval Augmented Generation (RAG)의 정의부터 실전 구현까지 체계적으로 설명한다. Lewis et al.&nbsp;(2020) “Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks” 연구를 바탕으로 외부 지식베이스 검색(Retrieval)과 답변 생성(Generation)의 결합 원리, 벡터 임베딩과 유사도 검색 메커니즘, 문서 청킹(Chunking) 전략(토큰 기반, 문장 기반, 의미론적, 구조 기반)을 분석한다. Indexing과 Query 단계의 2단계 프로세스, BM25/Dense/Hybrid 검색 방법, Re-ranking 최적화를 제시하고, 간단한 Q&amp;A 시스템, 고객 지원 챗봇, 문서 분석 도구 등 실무 예시와 Python 구현 코드(벡터 DB, 임베딩 모델 활용)를 통해 실전 구축 방법을 상세히 다룬다. 청크 크기 최적화, top_k 설정, 검색 품질 평가(Precision, Recall, MRR), 할루시네이션 방지 전략과 출처 추적 패턴을 제시한다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Prompt Engineering</div>
                <div class="quarto-category">LLM</div>
                <div class="quarto-category">AI</div>
                <div class="quarto-category">Agent</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2025년 02월 05일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#들어가며" id="toc-들어가며" class="nav-link active" data-scroll-target="#들어가며"><span class="header-section-number">1</span> 들어가며</a></li>
  <li><a href="#rag란" id="toc-rag란" class="nav-link" data-scroll-target="#rag란"><span class="header-section-number">2</span> RAG란?</a>
  <ul class="collapse">
  <li><a href="#핵심-개념" id="toc-핵심-개념" class="nav-link" data-scroll-target="#핵심-개념"><span class="header-section-number">2.1</span> 핵심 개념</a></li>
  <li><a href="#전통적-접근법과의-차이" id="toc-전통적-접근법과의-차이" class="nav-link" data-scroll-target="#전통적-접근법과의-차이"><span class="header-section-number">2.2</span> 전통적 접근법과의 차이</a></li>
  <li><a href="#rag의-장점" id="toc-rag의-장점" class="nav-link" data-scroll-target="#rag의-장점"><span class="header-section-number">2.3</span> RAG의 장점</a></li>
  <li><a href="#rag의-제약" id="toc-rag의-제약" class="nav-link" data-scroll-target="#rag의-제약"><span class="header-section-number">2.4</span> RAG의 제약</a></li>
  </ul></li>
  <li><a href="#rag의-2단계-프로세스" id="toc-rag의-2단계-프로세스" class="nav-link" data-scroll-target="#rag의-2단계-프로세스"><span class="header-section-number">3</span> RAG의 2단계 프로세스</a>
  <ul class="collapse">
  <li><a href="#indexing-오프라인" id="toc-indexing-오프라인" class="nav-link" data-scroll-target="#indexing-오프라인"><span class="header-section-number">3.1</span> Indexing (오프라인)</a></li>
  <li><a href="#query-온라인상-사용자-질문" id="toc-query-온라인상-사용자-질문" class="nav-link" data-scroll-target="#query-온라인상-사용자-질문"><span class="header-section-number">3.2</span> Query (온라인상 사용자 질문)</a></li>
  </ul></li>
  <li><a href="#완전한-rag-시스템-구현" id="toc-완전한-rag-시스템-구현" class="nav-link" data-scroll-target="#완전한-rag-시스템-구현"><span class="header-section-number">4</span> 완전한 RAG 시스템 구현</a>
  <ul class="collapse">
  <li><a href="#실행-결과-예시" id="toc-실행-결과-예시" class="nav-link" data-scroll-target="#실행-결과-예시"><span class="header-section-number">4.1</span> 실행 결과 예시</a></li>
  </ul></li>
  <li><a href="#rag-시스템-최적화-기법" id="toc-rag-시스템-최적화-기법" class="nav-link" data-scroll-target="#rag-시스템-최적화-기법"><span class="header-section-number">5</span> RAG 시스템 최적화 기법</a>
  <ul class="collapse">
  <li><a href="#검색-품질-저하" id="toc-검색-품질-저하" class="nav-link" data-scroll-target="#검색-품질-저하"><span class="header-section-number">5.1</span> 검색 품질 저하</a></li>
  <li><a href="#검색-순위가-최적이-아님" id="toc-검색-순위가-최적이-아님" class="nav-link" data-scroll-target="#검색-순위가-최적이-아님"><span class="header-section-number">5.2</span> 검색 순위가 최적이 아님</a></li>
  <li><a href="#쿼리가-모호하거나-부적절함" id="toc-쿼리가-모호하거나-부적절함" class="nav-link" data-scroll-target="#쿼리가-모호하거나-부적절함"><span class="header-section-number">5.3</span> 쿼리가 모호하거나 부적절함</a></li>
  </ul></li>
  <li><a href="#긴-문서-처리-전략" id="toc-긴-문서-처리-전략" class="nav-link" data-scroll-target="#긴-문서-처리-전략"><span class="header-section-number">6</span> 긴 문서 처리 전략</a>
  <ul class="collapse">
  <li><a href="#문제-단일-문서가-컨텍스트-길이를-초과" id="toc-문제-단일-문서가-컨텍스트-길이를-초과" class="nav-link" data-scroll-target="#문제-단일-문서가-컨텍스트-길이를-초과"><span class="header-section-number">6.1</span> 문제: 단일 문서가 컨텍스트 길이를 초과</a></li>
  </ul></li>
  <li><a href="#실시간-업데이트-처리" id="toc-실시간-업데이트-처리" class="nav-link" data-scroll-target="#실시간-업데이트-처리"><span class="header-section-number">7</span> 실시간 업데이트 처리</a>
  <ul class="collapse">
  <li><a href="#문제-지식베이스가-자주-변경됨" id="toc-문제-지식베이스가-자주-변경됨" class="nav-link" data-scroll-target="#문제-지식베이스가-자주-변경됨"><span class="header-section-number">7.1</span> 문제: 지식베이스가 자주 변경됨</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="들어가며" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="들어가며"><span class="header-section-number">1</span> 들어가며</h2>
<p>대형 언어 모델(LLM)이 아무리 방대한 지식을 학습했더라도, 다음과 같은 근본적인 한계가 있다:</p>
<ol type="1">
<li><strong>지식의 시간적 한계</strong>: 학습 데이터의 컷오프 이후 정보를 모름</li>
<li><strong>도메인 특화 지식 부족</strong>: 기업 내부 문서, 전문 분야 지식 부재</li>
<li><strong>할루시네이션</strong>: 확신 있게 틀린 정보를 생성</li>
<li><strong>출처 불명확</strong>: 어디서 얻은 정보인지 추적 불가</li>
</ol>
<p>예를 들어, “우리 회사의 최신 휴가 정책은?”이라는 질문에 LLM은 답할 수 없다. 이 정보는 학습 데이터에 없기 때문이다.</p>
<p><strong>Retrieval Augmented Generation (RAG)</strong>은 이러한 문제를 해결한다. 외부 데이터베이스에서 관련 정보를 검색한 후, 그 정보를 바탕으로 답변을 생성하는 방식이다. 이는 LLM에게 “참고 자료”를 제공하는 것과 같다.</p>
<p>이번 포스트에서는 RAG의 원리부터 실전 구축까지 상세히 다룬다.</p>
</section>
<section id="rag란" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="rag란"><span class="header-section-number">2</span> RAG란?</h2>
<section id="핵심-개념" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="핵심-개념"><span class="header-section-number">2.1</span> 핵심 개념</h3>
<p><strong>RAG (Retrieval Augmented Generation)</strong>는 질문에 답하기 전에: 1. 먼저 외부 지식베이스에서 관련 정보를 <strong>검색(Retrieve)</strong> 2. 검색된 정보를 바탕으로 답변을 <strong>생성(Generate)</strong></p>
<pre><code>Question → [Retriever] → Relevant Documents → [LLM + Documents] → Answer
              ↓                                        ↑
           Knowledge Base ─────────────────────────────┘</code></pre>
</section>
<section id="전통적-접근법과의-차이" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="전통적-접근법과의-차이"><span class="header-section-number">2.2</span> 전통적 접근법과의 차이</h3>
<p><strong>Before RAG (모델 지식만 사용)</strong>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>question <span class="op">=</span> <span class="st">"Anthropic의 CEO는 누구인가?"</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co"># 모델이 학습한 지식에만 의존</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>answer <span class="op">=</span> llm.generate(question)</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co"># → "저는 확실하지 않습니다..." (또는 할루시네이션)</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>After RAG (외부 지식 활용)</strong>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>question <span class="op">=</span> <span class="st">"Anthropic의 CEO는 누구인가?"</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co"># Step 1: 관련 문서 검색</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>docs <span class="op">=</span> retrieve_from_knowledge_base(question)</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co"># → ["Anthropic was founded by Dario Amodei...", ...]</span></span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co"># Step 2: 문서와 함께 답변 생성</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>context <span class="op">=</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>.join(docs)</span>
<span id="cb3-9"><a href="#cb3-9"></a>prompt <span class="op">=</span> <span class="ss">f"Context: </span><span class="sc">{</span>context<span class="sc">}</span><span class="ch">\n\n</span><span class="ss">Question: </span><span class="sc">{</span>question<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>answer <span class="op">=</span> llm.generate(prompt)</span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co"># → "Dario Amodei가 Anthropic의 CEO입니다."</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="rag의-장점" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="rag의-장점"><span class="header-section-number">2.3</span> RAG의 장점</h3>
<ul>
<li><strong>최신 정보 활용</strong>: 지식베이스만 업데이트하면 최신 정보 사용 가능<br>
</li>
<li><strong>도메인 특화</strong>: 회사 내부 문서, 전문 지식 추가 가능<br>
</li>
<li><strong>할루시네이션 감소</strong>: 실제 문서 기반 답변으로 신뢰도 향상<br>
</li>
<li><strong>출처 추적</strong>: 어떤 문서에서 정보를 가져왔는지 명확<br>
</li>
<li><strong>비용 효율적</strong>: 모델 재학습 없이 지식 확장<br>
</li>
<li><strong>개인정보 보호</strong>: 민감 정보를 모델에 넣지 않고 DB에만 저장</li>
</ul>
</section>
<section id="rag의-제약" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="rag의-제약"><span class="header-section-number">2.4</span> RAG의 제약</h3>
<ul>
<li><strong>검색 품질 의존</strong>: 잘못된 문서 검색 시 잘못된 답변<br>
</li>
<li><strong>지연 시간</strong>: 검색 단계로 인한 추가 레이턴시<br>
</li>
<li><strong>인프라 필요</strong>: Vector DB, 임베딩 모델 등 추가 시스템<br>
</li>
<li><strong>컨텍스트 길이 제한</strong>: 검색된 문서가 너무 많으면 처리 불가<br>
</li>
<li><strong>복잡도 증가</strong>: 단순 LLM 호출보다 구현 복잡</li>
</ul>
</section>
</section>
<section id="rag의-2단계-프로세스" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="rag의-2단계-프로세스"><span class="header-section-number">3</span> RAG의 2단계 프로세스</h2>
<section id="indexing-오프라인" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="indexing-오프라인"><span class="header-section-number">3.1</span> Indexing (오프라인)</h3>
<p>지식베이스를 준비하는 단계다. 사용자가 질문하기 전에 미리 수행된다.</p>
<pre><code>Documents → [Chunking] → Chunks → [Embedding] → Vectors → [Store] → Vector DB</code></pre>
<section id="문서-수집" class="level4" data-number="3.1.1">
<h4 data-number="3.1.1" class="anchored" data-anchor-id="문서-수집"><span class="header-section-number">3.1.1</span> 문서 수집</h4>
<p>다양한 소스에서 문서를 수집한다:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="im">from</span> typing <span class="im">import</span> List, Dict</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">class</span> DocumentLoader:</span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="co">"""</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">    다양한 소스에서 문서 로드</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">    """</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>    </span>
<span id="cb5-8"><a href="#cb5-8"></a>    <span class="kw">def</span> load_from_files(<span class="va">self</span>, file_paths: List[<span class="bu">str</span>]) <span class="op">-&gt;</span> List[Dict]:</span>
<span id="cb5-9"><a href="#cb5-9"></a>        <span class="co">"""파일에서 문서 로드"""</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>        documents <span class="op">=</span> []</span>
<span id="cb5-11"><a href="#cb5-11"></a>        </span>
<span id="cb5-12"><a href="#cb5-12"></a>        <span class="cf">for</span> path <span class="kw">in</span> file_paths:</span>
<span id="cb5-13"><a href="#cb5-13"></a>            <span class="cf">if</span> path.endswith(<span class="st">'.pdf'</span>):</span>
<span id="cb5-14"><a href="#cb5-14"></a>                text <span class="op">=</span> <span class="va">self</span>.extract_from_pdf(path)</span>
<span id="cb5-15"><a href="#cb5-15"></a>            <span class="cf">elif</span> path.endswith(<span class="st">'.docx'</span>):</span>
<span id="cb5-16"><a href="#cb5-16"></a>                text <span class="op">=</span> <span class="va">self</span>.extract_from_docx(path)</span>
<span id="cb5-17"><a href="#cb5-17"></a>            <span class="cf">elif</span> path.endswith(<span class="st">'.txt'</span>):</span>
<span id="cb5-18"><a href="#cb5-18"></a>                <span class="cf">with</span> <span class="bu">open</span>(path, <span class="st">'r'</span>, encoding<span class="op">=</span><span class="st">'utf-8'</span>) <span class="im">as</span> f:</span>
<span id="cb5-19"><a href="#cb5-19"></a>                    text <span class="op">=</span> f.read()</span>
<span id="cb5-20"><a href="#cb5-20"></a>            <span class="cf">else</span>:</span>
<span id="cb5-21"><a href="#cb5-21"></a>                <span class="cf">continue</span></span>
<span id="cb5-22"><a href="#cb5-22"></a>            </span>
<span id="cb5-23"><a href="#cb5-23"></a>            documents.append({</span>
<span id="cb5-24"><a href="#cb5-24"></a>                <span class="st">'text'</span>: text,</span>
<span id="cb5-25"><a href="#cb5-25"></a>                <span class="st">'metadata'</span>: {</span>
<span id="cb5-26"><a href="#cb5-26"></a>                    <span class="st">'source'</span>: path,</span>
<span id="cb5-27"><a href="#cb5-27"></a>                    <span class="st">'type'</span>: path.split(<span class="st">'.'</span>)[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb5-28"><a href="#cb5-28"></a>                }</span>
<span id="cb5-29"><a href="#cb5-29"></a>            })</span>
<span id="cb5-30"><a href="#cb5-30"></a>        </span>
<span id="cb5-31"><a href="#cb5-31"></a>        <span class="cf">return</span> documents</span>
<span id="cb5-32"><a href="#cb5-32"></a>    </span>
<span id="cb5-33"><a href="#cb5-33"></a>    <span class="kw">def</span> load_from_web(<span class="va">self</span>, urls: List[<span class="bu">str</span>]) <span class="op">-&gt;</span> List[Dict]:</span>
<span id="cb5-34"><a href="#cb5-34"></a>        <span class="co">"""웹페이지에서 문서 로드"""</span></span>
<span id="cb5-35"><a href="#cb5-35"></a>        <span class="im">import</span> requests</span>
<span id="cb5-36"><a href="#cb5-36"></a>        <span class="im">from</span> bs4 <span class="im">import</span> BeautifulSoup</span>
<span id="cb5-37"><a href="#cb5-37"></a>        </span>
<span id="cb5-38"><a href="#cb5-38"></a>        documents <span class="op">=</span> []</span>
<span id="cb5-39"><a href="#cb5-39"></a>        </span>
<span id="cb5-40"><a href="#cb5-40"></a>        <span class="cf">for</span> url <span class="kw">in</span> urls:</span>
<span id="cb5-41"><a href="#cb5-41"></a>            response <span class="op">=</span> requests.get(url)</span>
<span id="cb5-42"><a href="#cb5-42"></a>            soup <span class="op">=</span> BeautifulSoup(response.content, <span class="st">'html.parser'</span>)</span>
<span id="cb5-43"><a href="#cb5-43"></a>            </span>
<span id="cb5-44"><a href="#cb5-44"></a>            <span class="co"># 본문 추출 (사이트마다 다를 수 있음)</span></span>
<span id="cb5-45"><a href="#cb5-45"></a>            text <span class="op">=</span> soup.get_text()</span>
<span id="cb5-46"><a href="#cb5-46"></a>            </span>
<span id="cb5-47"><a href="#cb5-47"></a>            documents.append({</span>
<span id="cb5-48"><a href="#cb5-48"></a>                <span class="st">'text'</span>: text,</span>
<span id="cb5-49"><a href="#cb5-49"></a>                <span class="st">'metadata'</span>: {</span>
<span id="cb5-50"><a href="#cb5-50"></a>                    <span class="st">'source'</span>: url,</span>
<span id="cb5-51"><a href="#cb5-51"></a>                    <span class="st">'type'</span>: <span class="st">'web'</span></span>
<span id="cb5-52"><a href="#cb5-52"></a>                }</span>
<span id="cb5-53"><a href="#cb5-53"></a>            })</span>
<span id="cb5-54"><a href="#cb5-54"></a>        </span>
<span id="cb5-55"><a href="#cb5-55"></a>        <span class="cf">return</span> documents</span>
<span id="cb5-56"><a href="#cb5-56"></a>    </span>
<span id="cb5-57"><a href="#cb5-57"></a>    <span class="kw">def</span> load_from_database(<span class="va">self</span>, query: <span class="bu">str</span>) <span class="op">-&gt;</span> List[Dict]:</span>
<span id="cb5-58"><a href="#cb5-58"></a>        <span class="co">"""데이터베이스에서 문서 로드"""</span></span>
<span id="cb5-59"><a href="#cb5-59"></a>        <span class="co"># SQL 쿼리 실행</span></span>
<span id="cb5-60"><a href="#cb5-60"></a>        <span class="co"># results = db.execute(query)</span></span>
<span id="cb5-61"><a href="#cb5-61"></a>        <span class="co"># return results</span></span>
<span id="cb5-62"><a href="#cb5-62"></a>        <span class="cf">pass</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="문서-청킹-chunking" class="level4" data-number="3.1.2">
<h4 data-number="3.1.2" class="anchored" data-anchor-id="문서-청킹-chunking"><span class="header-section-number">3.1.2</span> 문서 청킹 (Chunking)</h4>
<p>긴 문서를 작은 청크로 나눈다.</p>
<p><strong>왜 청킹이 필요한가?</strong> - LLM 컨텍스트 길이 제한 - 검색 정확도 향상 (작은 단위가 더 정확) - 문맥의 범위 및 관련성 높은 부분만 선택 가능</p>
<p><strong>청킹 전략</strong>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">class</span> TextChunker:</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="co">"""</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">    다양한 청킹 전략 구현</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">    """</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>    </span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="kw">def</span> chunk_by_tokens(</span>
<span id="cb6-7"><a href="#cb6-7"></a>        <span class="va">self</span>, </span>
<span id="cb6-8"><a href="#cb6-8"></a>        text: <span class="bu">str</span>, </span>
<span id="cb6-9"><a href="#cb6-9"></a>        chunk_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">512</span>,</span>
<span id="cb6-10"><a href="#cb6-10"></a>        overlap: <span class="bu">int</span> <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>    ) <span class="op">-&gt;</span> List[<span class="bu">str</span>]:</span>
<span id="cb6-12"><a href="#cb6-12"></a>        <span class="co">"""</span></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="co">        토큰 기반 청킹 (가장 일반적)</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="co">        </span></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="co">        Args:</span></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="co">            chunk_size: 청크당 토큰 수</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="co">            overlap: 청크 간 겹치는 토큰 수</span></span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="co">        """</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>        <span class="co"># 토큰화 (tiktoken 사용)</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>        <span class="im">import</span> tiktoken</span>
<span id="cb6-21"><a href="#cb6-21"></a>        </span>
<span id="cb6-22"><a href="#cb6-22"></a>        encoding <span class="op">=</span> tiktoken.get_encoding(<span class="st">"cl100k_base"</span>)</span>
<span id="cb6-23"><a href="#cb6-23"></a>        tokens <span class="op">=</span> encoding.encode(text)</span>
<span id="cb6-24"><a href="#cb6-24"></a>        </span>
<span id="cb6-25"><a href="#cb6-25"></a>        chunks <span class="op">=</span> []</span>
<span id="cb6-26"><a href="#cb6-26"></a>        start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-27"><a href="#cb6-27"></a>        </span>
<span id="cb6-28"><a href="#cb6-28"></a>        <span class="cf">while</span> start <span class="op">&lt;</span> <span class="bu">len</span>(tokens):</span>
<span id="cb6-29"><a href="#cb6-29"></a>            end <span class="op">=</span> start <span class="op">+</span> chunk_size</span>
<span id="cb6-30"><a href="#cb6-30"></a>            chunk_tokens <span class="op">=</span> tokens[start:end]</span>
<span id="cb6-31"><a href="#cb6-31"></a>            chunk_text <span class="op">=</span> encoding.decode(chunk_tokens)</span>
<span id="cb6-32"><a href="#cb6-32"></a>            chunks.append(chunk_text)</span>
<span id="cb6-33"><a href="#cb6-33"></a>            </span>
<span id="cb6-34"><a href="#cb6-34"></a>            start <span class="op">+=</span> chunk_size <span class="op">-</span> overlap  <span class="co"># 오버랩 적용</span></span>
<span id="cb6-35"><a href="#cb6-35"></a>        </span>
<span id="cb6-36"><a href="#cb6-36"></a>        <span class="cf">return</span> chunks</span>
<span id="cb6-37"><a href="#cb6-37"></a>    </span>
<span id="cb6-38"><a href="#cb6-38"></a>    <span class="kw">def</span> chunk_by_sentences(</span>
<span id="cb6-39"><a href="#cb6-39"></a>        <span class="va">self</span>, </span>
<span id="cb6-40"><a href="#cb6-40"></a>        text: <span class="bu">str</span>, </span>
<span id="cb6-41"><a href="#cb6-41"></a>        sentences_per_chunk: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span>,</span>
<span id="cb6-42"><a href="#cb6-42"></a>        overlap_sentences: <span class="bu">int</span> <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-43"><a href="#cb6-43"></a>    ) <span class="op">-&gt;</span> List[<span class="bu">str</span>]:</span>
<span id="cb6-44"><a href="#cb6-44"></a>        <span class="co">"""</span></span>
<span id="cb6-45"><a href="#cb6-45"></a><span class="co">        문장 기반 청킹 (의미 보존)</span></span>
<span id="cb6-46"><a href="#cb6-46"></a><span class="co">        """</span></span>
<span id="cb6-47"><a href="#cb6-47"></a>        <span class="im">import</span> re</span>
<span id="cb6-48"><a href="#cb6-48"></a>        </span>
<span id="cb6-49"><a href="#cb6-49"></a>        <span class="co"># 문장 분리</span></span>
<span id="cb6-50"><a href="#cb6-50"></a>        sentences <span class="op">=</span> re.split(<span class="vs">r'(?&lt;=[.!?])\s+'</span>, text)</span>
<span id="cb6-51"><a href="#cb6-51"></a>        </span>
<span id="cb6-52"><a href="#cb6-52"></a>        chunks <span class="op">=</span> []</span>
<span id="cb6-53"><a href="#cb6-53"></a>        start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-54"><a href="#cb6-54"></a>        </span>
<span id="cb6-55"><a href="#cb6-55"></a>        <span class="cf">while</span> start <span class="op">&lt;</span> <span class="bu">len</span>(sentences):</span>
<span id="cb6-56"><a href="#cb6-56"></a>            end <span class="op">=</span> start <span class="op">+</span> sentences_per_chunk</span>
<span id="cb6-57"><a href="#cb6-57"></a>            chunk <span class="op">=</span> <span class="st">' '</span>.join(sentences[start:end])</span>
<span id="cb6-58"><a href="#cb6-58"></a>            chunks.append(chunk)</span>
<span id="cb6-59"><a href="#cb6-59"></a>            </span>
<span id="cb6-60"><a href="#cb6-60"></a>            start <span class="op">+=</span> sentences_per_chunk <span class="op">-</span> overlap_sentences</span>
<span id="cb6-61"><a href="#cb6-61"></a>        </span>
<span id="cb6-62"><a href="#cb6-62"></a>        <span class="cf">return</span> chunks</span>
<span id="cb6-63"><a href="#cb6-63"></a>    </span>
<span id="cb6-64"><a href="#cb6-64"></a>    <span class="kw">def</span> chunk_by_semantic(</span>
<span id="cb6-65"><a href="#cb6-65"></a>        <span class="va">self</span>, </span>
<span id="cb6-66"><a href="#cb6-66"></a>        text: <span class="bu">str</span>,</span>
<span id="cb6-67"><a href="#cb6-67"></a>        similarity_threshold: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.7</span></span>
<span id="cb6-68"><a href="#cb6-68"></a>    ) <span class="op">-&gt;</span> List[<span class="bu">str</span>]:</span>
<span id="cb6-69"><a href="#cb6-69"></a>        <span class="co">"""</span></span>
<span id="cb6-70"><a href="#cb6-70"></a><span class="co">        의미론적 청킹 (문장 간 유사도 기반)</span></span>
<span id="cb6-71"><a href="#cb6-71"></a><span class="co">        </span></span>
<span id="cb6-72"><a href="#cb6-72"></a><span class="co">        문장들을 임베딩하고, 유사도가 낮아지는 지점에서 분리</span></span>
<span id="cb6-73"><a href="#cb6-73"></a><span class="co">        """</span></span>
<span id="cb6-74"><a href="#cb6-74"></a>        <span class="im">import</span> re</span>
<span id="cb6-75"><a href="#cb6-75"></a>        </span>
<span id="cb6-76"><a href="#cb6-76"></a>        sentences <span class="op">=</span> re.split(<span class="vs">r'(?&lt;=[.!?])\s+'</span>, text)</span>
<span id="cb6-77"><a href="#cb6-77"></a>        </span>
<span id="cb6-78"><a href="#cb6-78"></a>        <span class="cf">if</span> <span class="bu">len</span>(sentences) <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb6-79"><a href="#cb6-79"></a>            <span class="cf">return</span> [text]</span>
<span id="cb6-80"><a href="#cb6-80"></a>        </span>
<span id="cb6-81"><a href="#cb6-81"></a>        <span class="co"># 각 문장 임베딩</span></span>
<span id="cb6-82"><a href="#cb6-82"></a>        embeddings <span class="op">=</span> [<span class="va">self</span>.embed_text(s) <span class="cf">for</span> s <span class="kw">in</span> sentences]</span>
<span id="cb6-83"><a href="#cb6-83"></a>        </span>
<span id="cb6-84"><a href="#cb6-84"></a>        chunks <span class="op">=</span> []</span>
<span id="cb6-85"><a href="#cb6-85"></a>        current_chunk <span class="op">=</span> [sentences[<span class="dv">0</span>]]</span>
<span id="cb6-86"><a href="#cb6-86"></a>        </span>
<span id="cb6-87"><a href="#cb6-87"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(sentences)):</span>
<span id="cb6-88"><a href="#cb6-88"></a>            <span class="co"># 이전 문장과의 유사도 계산</span></span>
<span id="cb6-89"><a href="#cb6-89"></a>            similarity <span class="op">=</span> <span class="va">self</span>.cosine_similarity(</span>
<span id="cb6-90"><a href="#cb6-90"></a>                embeddings[i<span class="op">-</span><span class="dv">1</span>], </span>
<span id="cb6-91"><a href="#cb6-91"></a>                embeddings[i]</span>
<span id="cb6-92"><a href="#cb6-92"></a>            )</span>
<span id="cb6-93"><a href="#cb6-93"></a>            </span>
<span id="cb6-94"><a href="#cb6-94"></a>            <span class="cf">if</span> similarity <span class="op">&gt;=</span> similarity_threshold:</span>
<span id="cb6-95"><a href="#cb6-95"></a>                <span class="co"># 유사도 높음 → 같은 청크</span></span>
<span id="cb6-96"><a href="#cb6-96"></a>                current_chunk.append(sentences[i])</span>
<span id="cb6-97"><a href="#cb6-97"></a>            <span class="cf">else</span>:</span>
<span id="cb6-98"><a href="#cb6-98"></a>                <span class="co"># 유사도 낮음 → 새 청크 시작</span></span>
<span id="cb6-99"><a href="#cb6-99"></a>                chunks.append(<span class="st">' '</span>.join(current_chunk))</span>
<span id="cb6-100"><a href="#cb6-100"></a>                current_chunk <span class="op">=</span> [sentences[i]]</span>
<span id="cb6-101"><a href="#cb6-101"></a>        </span>
<span id="cb6-102"><a href="#cb6-102"></a>        <span class="co"># 마지막 청크 추가</span></span>
<span id="cb6-103"><a href="#cb6-103"></a>        <span class="cf">if</span> current_chunk:</span>
<span id="cb6-104"><a href="#cb6-104"></a>            chunks.append(<span class="st">' '</span>.join(current_chunk))</span>
<span id="cb6-105"><a href="#cb6-105"></a>        </span>
<span id="cb6-106"><a href="#cb6-106"></a>        <span class="cf">return</span> chunks</span>
<span id="cb6-107"><a href="#cb6-107"></a>    </span>
<span id="cb6-108"><a href="#cb6-108"></a>    <span class="kw">def</span> chunk_by_structure(<span class="va">self</span>, text: <span class="bu">str</span>, format_type: <span class="bu">str</span>) <span class="op">-&gt;</span> List[<span class="bu">str</span>]:</span>
<span id="cb6-109"><a href="#cb6-109"></a>        <span class="co">"""</span></span>
<span id="cb6-110"><a href="#cb6-110"></a><span class="co">        문서 구조 기반 청킹 (마크다운, HTML 등)</span></span>
<span id="cb6-111"><a href="#cb6-111"></a><span class="co">        """</span></span>
<span id="cb6-112"><a href="#cb6-112"></a>        <span class="cf">if</span> format_type <span class="op">==</span> <span class="st">'markdown'</span>:</span>
<span id="cb6-113"><a href="#cb6-113"></a>            <span class="co"># 헤더 기준으로 분리</span></span>
<span id="cb6-114"><a href="#cb6-114"></a>            <span class="im">import</span> re</span>
<span id="cb6-115"><a href="#cb6-115"></a>            chunks <span class="op">=</span> re.split(<span class="vs">r'\n#+\s'</span>, text)</span>
<span id="cb6-116"><a href="#cb6-116"></a>            <span class="cf">return</span> [c.strip() <span class="cf">for</span> c <span class="kw">in</span> chunks <span class="cf">if</span> c.strip()]</span>
<span id="cb6-117"><a href="#cb6-117"></a>        </span>
<span id="cb6-118"><a href="#cb6-118"></a>        <span class="cf">elif</span> format_type <span class="op">==</span> <span class="st">'html'</span>:</span>
<span id="cb6-119"><a href="#cb6-119"></a>            <span class="im">from</span> bs4 <span class="im">import</span> BeautifulSoup</span>
<span id="cb6-120"><a href="#cb6-120"></a>            soup <span class="op">=</span> BeautifulSoup(text, <span class="st">'html.parser'</span>)</span>
<span id="cb6-121"><a href="#cb6-121"></a>            </span>
<span id="cb6-122"><a href="#cb6-122"></a>            <span class="co"># 섹션별로 분리</span></span>
<span id="cb6-123"><a href="#cb6-123"></a>            chunks <span class="op">=</span> []</span>
<span id="cb6-124"><a href="#cb6-124"></a>            <span class="cf">for</span> section <span class="kw">in</span> soup.find_all([<span class="st">'section'</span>, <span class="st">'article'</span>, <span class="st">'div'</span>]):</span>
<span id="cb6-125"><a href="#cb6-125"></a>                chunk_text <span class="op">=</span> section.get_text()</span>
<span id="cb6-126"><a href="#cb6-126"></a>                <span class="cf">if</span> chunk_text.strip():</span>
<span id="cb6-127"><a href="#cb6-127"></a>                    chunks.append(chunk_text.strip())</span>
<span id="cb6-128"><a href="#cb6-128"></a>            </span>
<span id="cb6-129"><a href="#cb6-129"></a>            <span class="cf">return</span> chunks</span>
<span id="cb6-130"><a href="#cb6-130"></a>        </span>
<span id="cb6-131"><a href="#cb6-131"></a>        <span class="cf">else</span>:</span>
<span id="cb6-132"><a href="#cb6-132"></a>            <span class="co"># 기본: 문단 기준</span></span>
<span id="cb6-133"><a href="#cb6-133"></a>            paragraphs <span class="op">=</span> text.split(<span class="st">'</span><span class="ch">\n\n</span><span class="st">'</span>)</span>
<span id="cb6-134"><a href="#cb6-134"></a>            <span class="cf">return</span> [p.strip() <span class="cf">for</span> p <span class="kw">in</span> paragraphs <span class="cf">if</span> p.strip()]</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>청킹 파라미터 선택 가이드</strong>:</p>
<table class="table">
<thead>
<tr class="header">
<th>청크 크기</th>
<th>장점</th>
<th>단점</th>
<th>권장 용도</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>작음 (128-256)</td>
<td>검색 정확도 높음</td>
<td>컨텍스트 부족</td>
<td>Q&amp;A, 팩트 체크</td>
</tr>
<tr class="even">
<td>중간 (512-1024)</td>
<td>균형 잡힘</td>
<td>-</td>
<td>일반적 사용 ⭐</td>
</tr>
<tr class="odd">
<td>큼 (2048+)</td>
<td>컨텍스트 풍부</td>
<td>노이즈 증가</td>
<td>요약, 분석</td>
</tr>
</tbody>
</table>
<p><strong>Chunking간 오버랩 범위</strong>: - 0-50 토큰: 표준 - 50-100 토큰: 문맥 연결 중요 시 - 100+ 토큰: 과도, 비효율적</p>
</section>
<section id="임베딩-생성" class="level4" data-number="3.1.3">
<h4 data-number="3.1.3" class="anchored" data-anchor-id="임베딩-생성"><span class="header-section-number">3.1.3</span> 임베딩 생성</h4>
<p>각 청크를 벡터로 변환한다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">class</span> EmbeddingGenerator:</span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="co">"""</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="co">    텍스트를 벡터로 변환</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="co">    """</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    </span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, model_name: <span class="bu">str</span> <span class="op">=</span> <span class="st">"text-embedding-3-large"</span>):</span>
<span id="cb7-7"><a href="#cb7-7"></a>        <span class="co">"""</span></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="co">        OpenAI Embeddings 사용 예시</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="co">        다른 옵션: sentence-transformers, Cohere, etc.</span></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="co">        """</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>        <span class="im">import</span> openai</span>
<span id="cb7-12"><a href="#cb7-12"></a>        <span class="va">self</span>.client <span class="op">=</span> openai.OpenAI()</span>
<span id="cb7-13"><a href="#cb7-13"></a>        <span class="va">self</span>.model <span class="op">=</span> model_name</span>
<span id="cb7-14"><a href="#cb7-14"></a>    </span>
<span id="cb7-15"><a href="#cb7-15"></a>    <span class="kw">def</span> embed_text(<span class="va">self</span>, text: <span class="bu">str</span>) <span class="op">-&gt;</span> List[<span class="bu">float</span>]:</span>
<span id="cb7-16"><a href="#cb7-16"></a>        <span class="co">"""</span></span>
<span id="cb7-17"><a href="#cb7-17"></a><span class="co">        단일 텍스트 임베딩</span></span>
<span id="cb7-18"><a href="#cb7-18"></a><span class="co">        """</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>        response <span class="op">=</span> <span class="va">self</span>.client.embeddings.create(</span>
<span id="cb7-20"><a href="#cb7-20"></a>            <span class="bu">input</span><span class="op">=</span>text,</span>
<span id="cb7-21"><a href="#cb7-21"></a>            model<span class="op">=</span><span class="va">self</span>.model</span>
<span id="cb7-22"><a href="#cb7-22"></a>        )</span>
<span id="cb7-23"><a href="#cb7-23"></a>        </span>
<span id="cb7-24"><a href="#cb7-24"></a>        <span class="cf">return</span> response.data[<span class="dv">0</span>].embedding</span>
<span id="cb7-25"><a href="#cb7-25"></a>    </span>
<span id="cb7-26"><a href="#cb7-26"></a>    <span class="kw">def</span> embed_batch(<span class="va">self</span>, texts: List[<span class="bu">str</span>], batch_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">100</span>) <span class="op">-&gt;</span> List[List[<span class="bu">float</span>]]:</span>
<span id="cb7-27"><a href="#cb7-27"></a>        <span class="co">"""</span></span>
<span id="cb7-28"><a href="#cb7-28"></a><span class="co">        배치 임베딩 (효율성)</span></span>
<span id="cb7-29"><a href="#cb7-29"></a><span class="co">        """</span></span>
<span id="cb7-30"><a href="#cb7-30"></a>        embeddings <span class="op">=</span> []</span>
<span id="cb7-31"><a href="#cb7-31"></a>        </span>
<span id="cb7-32"><a href="#cb7-32"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(texts), batch_size):</span>
<span id="cb7-33"><a href="#cb7-33"></a>            batch <span class="op">=</span> texts[i:i<span class="op">+</span>batch_size]</span>
<span id="cb7-34"><a href="#cb7-34"></a>            </span>
<span id="cb7-35"><a href="#cb7-35"></a>            response <span class="op">=</span> <span class="va">self</span>.client.embeddings.create(</span>
<span id="cb7-36"><a href="#cb7-36"></a>                <span class="bu">input</span><span class="op">=</span>batch,</span>
<span id="cb7-37"><a href="#cb7-37"></a>                model<span class="op">=</span><span class="va">self</span>.model</span>
<span id="cb7-38"><a href="#cb7-38"></a>            )</span>
<span id="cb7-39"><a href="#cb7-39"></a>            </span>
<span id="cb7-40"><a href="#cb7-40"></a>            batch_embeddings <span class="op">=</span> [item.embedding <span class="cf">for</span> item <span class="kw">in</span> response.data]</span>
<span id="cb7-41"><a href="#cb7-41"></a>            embeddings.extend(batch_embeddings)</span>
<span id="cb7-42"><a href="#cb7-42"></a>        </span>
<span id="cb7-43"><a href="#cb7-43"></a>        <span class="cf">return</span> embeddings</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>임베딩 모델 선택</strong>:</p>
<table class="table">
<thead>
<tr class="header">
<th>모델</th>
<th>차원</th>
<th>성능</th>
<th>비용</th>
<th>추천 용도</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>text-embedding-3-small</td>
<td>1536</td>
<td>중</td>
<td>낮음</td>
<td>개발/테스트</td>
</tr>
<tr class="even">
<td>text-embedding-3-large</td>
<td>3072</td>
<td>높음</td>
<td>중간</td>
<td>프로덕션 ⭐</td>
</tr>
<tr class="odd">
<td>sentence-transformers</td>
<td>384-768</td>
<td>중</td>
<td>무료</td>
<td>로컬/오픈소스</td>
</tr>
<tr class="even">
<td>Cohere embed-v3</td>
<td>1024</td>
<td>높음</td>
<td>중간</td>
<td>다국어 지원</td>
</tr>
</tbody>
</table>
</section>
<section id="vector-db-저장" class="level4" data-number="3.1.4">
<h4 data-number="3.1.4" class="anchored" data-anchor-id="vector-db-저장"><span class="header-section-number">3.1.4</span> Vector DB 저장</h4>
<p>임베딩을 검색 가능한 형태로 저장한다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="im">import</span> chromadb</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="im">from</span> typing <span class="im">import</span> List, Dict</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">class</span> VectorStore:</span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="co">"""</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="co">    ChromaDB를 사용한 벡터 저장소</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="co">    """</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>    </span>
<span id="cb8-9"><a href="#cb8-9"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, collection_name: <span class="bu">str</span> <span class="op">=</span> <span class="st">"documents"</span>):</span>
<span id="cb8-10"><a href="#cb8-10"></a>        <span class="va">self</span>.client <span class="op">=</span> chromadb.Client()</span>
<span id="cb8-11"><a href="#cb8-11"></a>        <span class="va">self</span>.collection <span class="op">=</span> <span class="va">self</span>.client.get_or_create_collection(</span>
<span id="cb8-12"><a href="#cb8-12"></a>            name<span class="op">=</span>collection_name,</span>
<span id="cb8-13"><a href="#cb8-13"></a>            metadata<span class="op">=</span>{<span class="st">"hnsw:space"</span>: <span class="st">"cosine"</span>}  <span class="co"># 코사인 유사도</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>        )</span>
<span id="cb8-15"><a href="#cb8-15"></a>    </span>
<span id="cb8-16"><a href="#cb8-16"></a>    <span class="kw">def</span> add_documents(</span>
<span id="cb8-17"><a href="#cb8-17"></a>        <span class="va">self</span>, </span>
<span id="cb8-18"><a href="#cb8-18"></a>        texts: List[<span class="bu">str</span>],</span>
<span id="cb8-19"><a href="#cb8-19"></a>        embeddings: List[List[<span class="bu">float</span>]],</span>
<span id="cb8-20"><a href="#cb8-20"></a>        metadatas: List[Dict] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb8-21"><a href="#cb8-21"></a>        ids: List[<span class="bu">str</span>] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-22"><a href="#cb8-22"></a>    ):</span>
<span id="cb8-23"><a href="#cb8-23"></a>        <span class="co">"""</span></span>
<span id="cb8-24"><a href="#cb8-24"></a><span class="co">        문서 추가</span></span>
<span id="cb8-25"><a href="#cb8-25"></a><span class="co">        """</span></span>
<span id="cb8-26"><a href="#cb8-26"></a>        <span class="cf">if</span> ids <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb8-27"><a href="#cb8-27"></a>            ids <span class="op">=</span> [<span class="ss">f"doc_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(texts))]</span>
<span id="cb8-28"><a href="#cb8-28"></a>        </span>
<span id="cb8-29"><a href="#cb8-29"></a>        <span class="cf">if</span> metadatas <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb8-30"><a href="#cb8-30"></a>            metadatas <span class="op">=</span> [{} <span class="cf">for</span> _ <span class="kw">in</span> texts]</span>
<span id="cb8-31"><a href="#cb8-31"></a>        </span>
<span id="cb8-32"><a href="#cb8-32"></a>        <span class="va">self</span>.collection.add(</span>
<span id="cb8-33"><a href="#cb8-33"></a>            documents<span class="op">=</span>texts,</span>
<span id="cb8-34"><a href="#cb8-34"></a>            embeddings<span class="op">=</span>embeddings,</span>
<span id="cb8-35"><a href="#cb8-35"></a>            metadatas<span class="op">=</span>metadatas,</span>
<span id="cb8-36"><a href="#cb8-36"></a>            ids<span class="op">=</span>ids</span>
<span id="cb8-37"><a href="#cb8-37"></a>        )</span>
<span id="cb8-38"><a href="#cb8-38"></a>    </span>
<span id="cb8-39"><a href="#cb8-39"></a>    <span class="kw">def</span> query(</span>
<span id="cb8-40"><a href="#cb8-40"></a>        <span class="va">self</span>, </span>
<span id="cb8-41"><a href="#cb8-41"></a>        query_embedding: List[<span class="bu">float</span>],</span>
<span id="cb8-42"><a href="#cb8-42"></a>        n_results: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb8-43"><a href="#cb8-43"></a>    ) <span class="op">-&gt;</span> Dict:</span>
<span id="cb8-44"><a href="#cb8-44"></a>        <span class="co">"""</span></span>
<span id="cb8-45"><a href="#cb8-45"></a><span class="co">        유사 문서 검색</span></span>
<span id="cb8-46"><a href="#cb8-46"></a><span class="co">        """</span></span>
<span id="cb8-47"><a href="#cb8-47"></a>        results <span class="op">=</span> <span class="va">self</span>.collection.query(</span>
<span id="cb8-48"><a href="#cb8-48"></a>            query_embeddings<span class="op">=</span>[query_embedding],</span>
<span id="cb8-49"><a href="#cb8-49"></a>            n_results<span class="op">=</span>n_results</span>
<span id="cb8-50"><a href="#cb8-50"></a>        )</span>
<span id="cb8-51"><a href="#cb8-51"></a>        </span>
<span id="cb8-52"><a href="#cb8-52"></a>        <span class="cf">return</span> results</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Vector DB 선택 가이드</strong>:</p>
<table class="table">
<thead>
<tr class="header">
<th>DB</th>
<th>장점</th>
<th>단점</th>
<th>추천 시나리오</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>ChromaDB</strong></td>
<td>간단, 로컬 가능</td>
<td>스케일 제한</td>
<td>개발, 중소규모</td>
</tr>
<tr class="even">
<td><strong>Pinecone</strong></td>
<td>관리형, 빠름</td>
<td>비용, 벤더락인</td>
<td>프로덕션, 고성능</td>
</tr>
<tr class="odd">
<td><strong>Weaviate</strong></td>
<td>오픈소스, 기능풍부</td>
<td>설정 복잡</td>
<td>커스터마이징 필요</td>
</tr>
<tr class="even">
<td><strong>Qdrant</strong></td>
<td>빠름, Rust 기반</td>
<td>상대적 신생</td>
<td>고성능 필요</td>
</tr>
<tr class="odd">
<td><strong>FAISS</strong></td>
<td>매우 빠름, Meta</td>
<td>DB 아님(라이브러리)</td>
<td>연구, 벤치마크</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="query-온라인상-사용자-질문" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="query-온라인상-사용자-질문"><span class="header-section-number">3.2</span> Query (온라인상 사용자 질문)</h3>
<p>사용자 질문에 실시간으로 답변하는 단계다.</p>
<pre><code>Question → [Embed] → Query Vector → [Search] → Top-K Docs → [LLM + Context] → Answer
              ↓                        ↓
         Embedding Model            Vector DB</code></pre>
<section id="질문-임베딩" class="level4" data-number="3.2.1">
<h4 data-number="3.2.1" class="anchored" data-anchor-id="질문-임베딩"><span class="header-section-number">3.2.1</span> 질문 임베딩</h4>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">def</span> embed_query(query: <span class="bu">str</span>) <span class="op">-&gt;</span> List[<span class="bu">float</span>]:</span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="co">"""</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="co">    사용자 질문을 벡터로 변환</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co">    문서와 동일한 임베딩 모델 사용 필수!</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="co">    """</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>    embedding_generator <span class="op">=</span> EmbeddingGenerator()</span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="cf">return</span> embedding_generator.embed_text(query)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="유사-문서-검색" class="level4" data-number="3.2.2">
<h4 data-number="3.2.2" class="anchored" data-anchor-id="유사-문서-검색"><span class="header-section-number">3.2.2</span> 유사 문서 검색</h4>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">def</span> retrieve_documents(</span>
<span id="cb11-2"><a href="#cb11-2"></a>    query: <span class="bu">str</span>,</span>
<span id="cb11-3"><a href="#cb11-3"></a>    vector_store: VectorStore,</span>
<span id="cb11-4"><a href="#cb11-4"></a>    top_k: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>) <span class="op">-&gt;</span> List[Dict]:</span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="co">"""</span></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="co">    질문과 가장 유사한 문서 검색</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="co">    """</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>    <span class="co"># 질문 임베딩</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>    query_embedding <span class="op">=</span> embed_query(query)</span>
<span id="cb11-11"><a href="#cb11-11"></a>    </span>
<span id="cb11-12"><a href="#cb11-12"></a>    <span class="co"># 검색</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>    results <span class="op">=</span> vector_store.query(</span>
<span id="cb11-14"><a href="#cb11-14"></a>        query_embedding<span class="op">=</span>query_embedding,</span>
<span id="cb11-15"><a href="#cb11-15"></a>        n_results<span class="op">=</span>top_k</span>
<span id="cb11-16"><a href="#cb11-16"></a>    )</span>
<span id="cb11-17"><a href="#cb11-17"></a>    </span>
<span id="cb11-18"><a href="#cb11-18"></a>    <span class="co"># 결과 포맷팅</span></span>
<span id="cb11-19"><a href="#cb11-19"></a>    documents <span class="op">=</span> []</span>
<span id="cb11-20"><a href="#cb11-20"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(results[<span class="st">'documents'</span>][<span class="dv">0</span>])):</span>
<span id="cb11-21"><a href="#cb11-21"></a>        documents.append({</span>
<span id="cb11-22"><a href="#cb11-22"></a>            <span class="st">'text'</span>: results[<span class="st">'documents'</span>][<span class="dv">0</span>][i],</span>
<span id="cb11-23"><a href="#cb11-23"></a>            <span class="st">'metadata'</span>: results[<span class="st">'metadatas'</span>][<span class="dv">0</span>][i],</span>
<span id="cb11-24"><a href="#cb11-24"></a>            <span class="st">'distance'</span>: results[<span class="st">'distances'</span>][<span class="dv">0</span>][i]</span>
<span id="cb11-25"><a href="#cb11-25"></a>        })</span>
<span id="cb11-26"><a href="#cb11-26"></a>    </span>
<span id="cb11-27"><a href="#cb11-27"></a>    <span class="cf">return</span> documents</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>top_k 선택 가이드</strong>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="co"># top_k가 너무 작으면: 필요한 정보 누락</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>top_k <span class="op">=</span> <span class="dv">1</span>  <span class="co"># 단순 팩트 체크에만 적합</span></span>
<span id="cb12-3"><a href="#cb12-3"></a></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="co"># top_k가 적당하면: 균형 (권장)</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>top_k <span class="op">=</span> <span class="dv">3</span><span class="op">-</span><span class="dv">5</span>  <span class="co"># 대부분의 경우 ⭐</span></span>
<span id="cb12-6"><a href="#cb12-6"></a></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="co"># top_k가 너무 크면: 노이즈 증가, 컨텍스트 오염</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>top_k <span class="op">=</span> <span class="dv">20</span><span class="op">+</span>  <span class="co"># 비효율적, 성능 저하</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="프롬프트-구성" class="level4" data-number="3.2.3">
<h4 data-number="3.2.3" class="anchored" data-anchor-id="프롬프트-구성"><span class="header-section-number">3.2.3</span> 프롬프트 구성</h4>
<p>검색된 문서를 프롬프트에 포함한다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">def</span> construct_rag_prompt(query: <span class="bu">str</span>, documents: List[Dict]) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="co">"""</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="co">    RAG 프롬프트 구성</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="co">    """</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="co"># 문서들을 컨텍스트로 결합</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>    context_parts <span class="op">=</span> []</span>
<span id="cb13-7"><a href="#cb13-7"></a>    <span class="cf">for</span> i, doc <span class="kw">in</span> <span class="bu">enumerate</span>(documents, <span class="dv">1</span>):</span>
<span id="cb13-8"><a href="#cb13-8"></a>        source <span class="op">=</span> doc[<span class="st">'metadata'</span>].get(<span class="st">'source'</span>, <span class="st">'Unknown'</span>)</span>
<span id="cb13-9"><a href="#cb13-9"></a>        text <span class="op">=</span> doc[<span class="st">'text'</span>]</span>
<span id="cb13-10"><a href="#cb13-10"></a>        context_parts.append(<span class="ss">f"[Document </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">] (Source: </span><span class="sc">{</span>source<span class="sc">}</span><span class="ss">)</span><span class="ch">\n</span><span class="sc">{</span>text<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb13-11"><a href="#cb13-11"></a>    </span>
<span id="cb13-12"><a href="#cb13-12"></a>    context <span class="op">=</span> <span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>.join(context_parts)</span>
<span id="cb13-13"><a href="#cb13-13"></a>    </span>
<span id="cb13-14"><a href="#cb13-14"></a>    <span class="co"># 프롬프트 템플릿</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>    prompt <span class="op">=</span> <span class="ss">f"""다음 문서들을 참고하여 질문에 답변하세요.</span></span>
<span id="cb13-16"><a href="#cb13-16"></a></span>
<span id="cb13-17"><a href="#cb13-17"></a><span class="ss">    &lt;documents&gt;</span></span>
<span id="cb13-18"><a href="#cb13-18"></a><span class="ss">    </span><span class="sc">{</span>context<span class="sc">}</span></span>
<span id="cb13-19"><a href="#cb13-19"></a><span class="ss">    &lt;/documents&gt;</span></span>
<span id="cb13-20"><a href="#cb13-20"></a></span>
<span id="cb13-21"><a href="#cb13-21"></a><span class="ss">    &lt;question&gt;</span></span>
<span id="cb13-22"><a href="#cb13-22"></a><span class="ss">    </span><span class="sc">{</span>query<span class="sc">}</span></span>
<span id="cb13-23"><a href="#cb13-23"></a><span class="ss">    &lt;/question&gt;</span></span>
<span id="cb13-24"><a href="#cb13-24"></a></span>
<span id="cb13-25"><a href="#cb13-25"></a><span class="ss">    답변 작성 시 주의사항:</span></span>
<span id="cb13-26"><a href="#cb13-26"></a><span class="ss">    1. 문서의 정보만을 사용하여 답변하세요.</span></span>
<span id="cb13-27"><a href="#cb13-27"></a><span class="ss">    2. 문서에 없는 정보는 추측하지 마세요.</span></span>
<span id="cb13-28"><a href="#cb13-28"></a><span class="ss">    3. 가능하면 어느 문서에서 정보를 가져왔는지 명시하세요.</span></span>
<span id="cb13-29"><a href="#cb13-29"></a><span class="ss">    4. 문서에서 답을 찾을 수 없다면 솔직히 "문서에서 관련 정보를 찾을 수 없습니다"라고 답하세요.</span></span>
<span id="cb13-30"><a href="#cb13-30"></a></span>
<span id="cb13-31"><a href="#cb13-31"></a><span class="ss">    답변:"""</span></span>
<span id="cb13-32"><a href="#cb13-32"></a>    </span>
<span id="cb13-33"><a href="#cb13-33"></a>    <span class="cf">return</span> prompt</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>좋은 RAG 프롬프트의 특징</strong>: - 문서와 질문을 명확히 구분 - “문서 기반 답변”을 명시적으로 지시 - 할루시네이션 방지 지침 포함 - 출처 언급 유도</p>
</section>
<section id="답변-생성" class="level4" data-number="3.2.4">
<h4 data-number="3.2.4" class="anchored" data-anchor-id="답변-생성"><span class="header-section-number">3.2.4</span> 답변 생성</h4>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a><span class="im">import</span> anthropic</span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">def</span> generate_answer(prompt: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="co">"""</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="co">    LLM으로 최종 답변 생성</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="co">    """</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>    client <span class="op">=</span> anthropic.Anthropic(api_key<span class="op">=</span><span class="st">"your-api-key"</span>)</span>
<span id="cb14-8"><a href="#cb14-8"></a>    </span>
<span id="cb14-9"><a href="#cb14-9"></a>    message <span class="op">=</span> client.messages.create(</span>
<span id="cb14-10"><a href="#cb14-10"></a>        model<span class="op">=</span><span class="st">"claude-sonnet-4-20250514"</span>,</span>
<span id="cb14-11"><a href="#cb14-11"></a>        max_tokens<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb14-12"><a href="#cb14-12"></a>        temperature<span class="op">=</span><span class="dv">0</span>,  <span class="co"># 사실 기반 답변이므로 낮은 temperature</span></span>
<span id="cb14-13"><a href="#cb14-13"></a>        messages<span class="op">=</span>[{<span class="st">"role"</span>: <span class="st">"user"</span>, <span class="st">"content"</span>: prompt}]</span>
<span id="cb14-14"><a href="#cb14-14"></a>    )</span>
<span id="cb14-15"><a href="#cb14-15"></a>    </span>
<span id="cb14-16"><a href="#cb14-16"></a>    <span class="cf">return</span> message.content[<span class="dv">0</span>].text</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
</section>
<section id="완전한-rag-시스템-구현" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="완전한-rag-시스템-구현"><span class="header-section-number">4</span> 완전한 RAG 시스템 구현</h2>
<p>이제 모든 단계를 결합한 완전한 RAG 시스템을 구현해보자.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="im">import</span> anthropic</span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="im">import</span> chromadb</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="im">import</span> openai</span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="im">from</span> typing <span class="im">import</span> List, Dict</span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="im">import</span> tiktoken</span>
<span id="cb15-6"><a href="#cb15-6"></a></span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="kw">class</span> SimpleRAGSystem:</span>
<span id="cb15-8"><a href="#cb15-8"></a>    <span class="co">"""</span></span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="co">    간단하지만 완전한 RAG 시스템</span></span>
<span id="cb15-10"><a href="#cb15-10"></a><span class="co">    """</span></span>
<span id="cb15-11"><a href="#cb15-11"></a>    </span>
<span id="cb15-12"><a href="#cb15-12"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb15-13"><a href="#cb15-13"></a>        <span class="va">self</span>,</span>
<span id="cb15-14"><a href="#cb15-14"></a>        anthropic_api_key: <span class="bu">str</span>,</span>
<span id="cb15-15"><a href="#cb15-15"></a>        openai_api_key: <span class="bu">str</span>,</span>
<span id="cb15-16"><a href="#cb15-16"></a>        collection_name: <span class="bu">str</span> <span class="op">=</span> <span class="st">"rag_docs"</span></span>
<span id="cb15-17"><a href="#cb15-17"></a>    ):</span>
<span id="cb15-18"><a href="#cb15-18"></a>        <span class="co"># LLM 클라이언트</span></span>
<span id="cb15-19"><a href="#cb15-19"></a>        <span class="va">self</span>.llm_client <span class="op">=</span> anthropic.Anthropic(api_key<span class="op">=</span>anthropic_api_key)</span>
<span id="cb15-20"><a href="#cb15-20"></a>        </span>
<span id="cb15-21"><a href="#cb15-21"></a>        <span class="co"># 임베딩 클라이언트</span></span>
<span id="cb15-22"><a href="#cb15-22"></a>        <span class="va">self</span>.embedding_client <span class="op">=</span> openai.OpenAI(api_key<span class="op">=</span>openai_api_key)</span>
<span id="cb15-23"><a href="#cb15-23"></a>        </span>
<span id="cb15-24"><a href="#cb15-24"></a>        <span class="co"># Vector DB</span></span>
<span id="cb15-25"><a href="#cb15-25"></a>        <span class="va">self</span>.chroma_client <span class="op">=</span> chromadb.Client()</span>
<span id="cb15-26"><a href="#cb15-26"></a>        <span class="va">self</span>.collection <span class="op">=</span> <span class="va">self</span>.chroma_client.get_or_create_collection(</span>
<span id="cb15-27"><a href="#cb15-27"></a>            name<span class="op">=</span>collection_name,</span>
<span id="cb15-28"><a href="#cb15-28"></a>            metadata<span class="op">=</span>{<span class="st">"hnsw:space"</span>: <span class="st">"cosine"</span>}</span>
<span id="cb15-29"><a href="#cb15-29"></a>        )</span>
<span id="cb15-30"><a href="#cb15-30"></a>        </span>
<span id="cb15-31"><a href="#cb15-31"></a>        <span class="co"># 토크나이저</span></span>
<span id="cb15-32"><a href="#cb15-32"></a>        <span class="va">self</span>.tokenizer <span class="op">=</span> tiktoken.get_encoding(<span class="st">"cl100k_base"</span>)</span>
<span id="cb15-33"><a href="#cb15-33"></a>    </span>
<span id="cb15-34"><a href="#cb15-34"></a>    <span class="kw">def</span> chunk_text(</span>
<span id="cb15-35"><a href="#cb15-35"></a>        <span class="va">self</span>, </span>
<span id="cb15-36"><a href="#cb15-36"></a>        text: <span class="bu">str</span>, </span>
<span id="cb15-37"><a href="#cb15-37"></a>        chunk_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">512</span>,</span>
<span id="cb15-38"><a href="#cb15-38"></a>        overlap: <span class="bu">int</span> <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb15-39"><a href="#cb15-39"></a>    ) <span class="op">-&gt;</span> List[<span class="bu">str</span>]:</span>
<span id="cb15-40"><a href="#cb15-40"></a>        <span class="co">"""</span></span>
<span id="cb15-41"><a href="#cb15-41"></a><span class="co">        텍스트를 청크로 분할</span></span>
<span id="cb15-42"><a href="#cb15-42"></a><span class="co">        """</span></span>
<span id="cb15-43"><a href="#cb15-43"></a>        tokens <span class="op">=</span> <span class="va">self</span>.tokenizer.encode(text)</span>
<span id="cb15-44"><a href="#cb15-44"></a>        chunks <span class="op">=</span> []</span>
<span id="cb15-45"><a href="#cb15-45"></a>        start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb15-46"><a href="#cb15-46"></a>        </span>
<span id="cb15-47"><a href="#cb15-47"></a>        <span class="cf">while</span> start <span class="op">&lt;</span> <span class="bu">len</span>(tokens):</span>
<span id="cb15-48"><a href="#cb15-48"></a>            end <span class="op">=</span> start <span class="op">+</span> chunk_size</span>
<span id="cb15-49"><a href="#cb15-49"></a>            chunk_tokens <span class="op">=</span> tokens[start:end]</span>
<span id="cb15-50"><a href="#cb15-50"></a>            chunk_text <span class="op">=</span> <span class="va">self</span>.tokenizer.decode(chunk_tokens)</span>
<span id="cb15-51"><a href="#cb15-51"></a>            chunks.append(chunk_text)</span>
<span id="cb15-52"><a href="#cb15-52"></a>            start <span class="op">+=</span> chunk_size <span class="op">-</span> overlap</span>
<span id="cb15-53"><a href="#cb15-53"></a>        </span>
<span id="cb15-54"><a href="#cb15-54"></a>        <span class="cf">return</span> chunks</span>
<span id="cb15-55"><a href="#cb15-55"></a>    </span>
<span id="cb15-56"><a href="#cb15-56"></a>    <span class="kw">def</span> embed_texts(<span class="va">self</span>, texts: List[<span class="bu">str</span>]) <span class="op">-&gt;</span> List[List[<span class="bu">float</span>]]:</span>
<span id="cb15-57"><a href="#cb15-57"></a>        <span class="co">"""</span></span>
<span id="cb15-58"><a href="#cb15-58"></a><span class="co">        텍스트 배치 임베딩</span></span>
<span id="cb15-59"><a href="#cb15-59"></a><span class="co">        """</span></span>
<span id="cb15-60"><a href="#cb15-60"></a>        response <span class="op">=</span> <span class="va">self</span>.embedding_client.embeddings.create(</span>
<span id="cb15-61"><a href="#cb15-61"></a>            <span class="bu">input</span><span class="op">=</span>texts,</span>
<span id="cb15-62"><a href="#cb15-62"></a>            model<span class="op">=</span><span class="st">"text-embedding-3-large"</span></span>
<span id="cb15-63"><a href="#cb15-63"></a>        )</span>
<span id="cb15-64"><a href="#cb15-64"></a>        </span>
<span id="cb15-65"><a href="#cb15-65"></a>        <span class="cf">return</span> [item.embedding <span class="cf">for</span> item <span class="kw">in</span> response.data]</span>
<span id="cb15-66"><a href="#cb15-66"></a>    </span>
<span id="cb15-67"><a href="#cb15-67"></a>    <span class="kw">def</span> index_documents(</span>
<span id="cb15-68"><a href="#cb15-68"></a>        <span class="va">self</span>, </span>
<span id="cb15-69"><a href="#cb15-69"></a>        documents: List[Dict[<span class="bu">str</span>, <span class="bu">str</span>]],</span>
<span id="cb15-70"><a href="#cb15-70"></a>        chunk_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">512</span>,</span>
<span id="cb15-71"><a href="#cb15-71"></a>        overlap: <span class="bu">int</span> <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb15-72"><a href="#cb15-72"></a>    ):</span>
<span id="cb15-73"><a href="#cb15-73"></a>        <span class="co">"""</span></span>
<span id="cb15-74"><a href="#cb15-74"></a><span class="co">        문서들을 인덱싱</span></span>
<span id="cb15-75"><a href="#cb15-75"></a><span class="co">        </span></span>
<span id="cb15-76"><a href="#cb15-76"></a><span class="co">        Args:</span></span>
<span id="cb15-77"><a href="#cb15-77"></a><span class="co">            documents: [{"text": "...", "metadata": {...}}, ...]</span></span>
<span id="cb15-78"><a href="#cb15-78"></a><span class="co">        """</span></span>
<span id="cb15-79"><a href="#cb15-79"></a>        <span class="bu">print</span>(<span class="ss">f"📚 </span><span class="sc">{</span><span class="bu">len</span>(documents)<span class="sc">}</span><span class="ss">개 문서 인덱싱 시작..."</span>)</span>
<span id="cb15-80"><a href="#cb15-80"></a>        </span>
<span id="cb15-81"><a href="#cb15-81"></a>        all_chunks <span class="op">=</span> []</span>
<span id="cb15-82"><a href="#cb15-82"></a>        all_metadatas <span class="op">=</span> []</span>
<span id="cb15-83"><a href="#cb15-83"></a>        all_ids <span class="op">=</span> []</span>
<span id="cb15-84"><a href="#cb15-84"></a>        </span>
<span id="cb15-85"><a href="#cb15-85"></a>        chunk_counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb15-86"><a href="#cb15-86"></a>        </span>
<span id="cb15-87"><a href="#cb15-87"></a>        <span class="cf">for</span> doc_idx, doc <span class="kw">in</span> <span class="bu">enumerate</span>(documents):</span>
<span id="cb15-88"><a href="#cb15-88"></a>            text <span class="op">=</span> doc[<span class="st">'text'</span>]</span>
<span id="cb15-89"><a href="#cb15-89"></a>            metadata <span class="op">=</span> doc.get(<span class="st">'metadata'</span>, {})</span>
<span id="cb15-90"><a href="#cb15-90"></a>            </span>
<span id="cb15-91"><a href="#cb15-91"></a>            <span class="co"># 청킹</span></span>
<span id="cb15-92"><a href="#cb15-92"></a>            chunks <span class="op">=</span> <span class="va">self</span>.chunk_text(text, chunk_size, overlap)</span>
<span id="cb15-93"><a href="#cb15-93"></a>            </span>
<span id="cb15-94"><a href="#cb15-94"></a>            <span class="bu">print</span>(<span class="ss">f"  문서 </span><span class="sc">{</span>doc_idx <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">: </span><span class="sc">{</span><span class="bu">len</span>(chunks)<span class="sc">}</span><span class="ss">개 청크 생성"</span>)</span>
<span id="cb15-95"><a href="#cb15-95"></a>            </span>
<span id="cb15-96"><a href="#cb15-96"></a>            <span class="cf">for</span> chunk_idx, chunk <span class="kw">in</span> <span class="bu">enumerate</span>(chunks):</span>
<span id="cb15-97"><a href="#cb15-97"></a>                all_chunks.append(chunk)</span>
<span id="cb15-98"><a href="#cb15-98"></a>                </span>
<span id="cb15-99"><a href="#cb15-99"></a>                <span class="co"># 메타데이터에 청크 정보 추가</span></span>
<span id="cb15-100"><a href="#cb15-100"></a>                chunk_metadata <span class="op">=</span> metadata.copy()</span>
<span id="cb15-101"><a href="#cb15-101"></a>                chunk_metadata.update({</span>
<span id="cb15-102"><a href="#cb15-102"></a>                    <span class="st">'doc_index'</span>: doc_idx,</span>
<span id="cb15-103"><a href="#cb15-103"></a>                    <span class="st">'chunk_index'</span>: chunk_idx,</span>
<span id="cb15-104"><a href="#cb15-104"></a>                    <span class="st">'chunk_id'</span>: <span class="ss">f"doc</span><span class="sc">{</span>doc_idx<span class="sc">}</span><span class="ss">_chunk</span><span class="sc">{</span>chunk_idx<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb15-105"><a href="#cb15-105"></a>                })</span>
<span id="cb15-106"><a href="#cb15-106"></a>                all_metadatas.append(chunk_metadata)</span>
<span id="cb15-107"><a href="#cb15-107"></a>                </span>
<span id="cb15-108"><a href="#cb15-108"></a>                all_ids.append(<span class="ss">f"chunk_</span><span class="sc">{</span>chunk_counter<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-109"><a href="#cb15-109"></a>                chunk_counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb15-110"><a href="#cb15-110"></a>        </span>
<span id="cb15-111"><a href="#cb15-111"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">🔢 총 </span><span class="sc">{</span><span class="bu">len</span>(all_chunks)<span class="sc">}</span><span class="ss">개 청크 생성"</span>)</span>
<span id="cb15-112"><a href="#cb15-112"></a>        <span class="bu">print</span>(<span class="ss">f"🧮 임베딩 생성 중..."</span>)</span>
<span id="cb15-113"><a href="#cb15-113"></a>        </span>
<span id="cb15-114"><a href="#cb15-114"></a>        <span class="co"># 임베딩 생성 (배치로 처리)</span></span>
<span id="cb15-115"><a href="#cb15-115"></a>        batch_size <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb15-116"><a href="#cb15-116"></a>        all_embeddings <span class="op">=</span> []</span>
<span id="cb15-117"><a href="#cb15-117"></a>        </span>
<span id="cb15-118"><a href="#cb15-118"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(all_chunks), batch_size):</span>
<span id="cb15-119"><a href="#cb15-119"></a>            batch <span class="op">=</span> all_chunks[i:i<span class="op">+</span>batch_size]</span>
<span id="cb15-120"><a href="#cb15-120"></a>            embeddings <span class="op">=</span> <span class="va">self</span>.embed_texts(batch)</span>
<span id="cb15-121"><a href="#cb15-121"></a>            all_embeddings.extend(embeddings)</span>
<span id="cb15-122"><a href="#cb15-122"></a>            <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>i <span class="op">+</span> <span class="bu">len</span>(batch)<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span><span class="bu">len</span>(all_chunks)<span class="sc">}</span><span class="ss"> 완료"</span>)</span>
<span id="cb15-123"><a href="#cb15-123"></a>        </span>
<span id="cb15-124"><a href="#cb15-124"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">💾 Vector DB에 저장 중..."</span>)</span>
<span id="cb15-125"><a href="#cb15-125"></a>        </span>
<span id="cb15-126"><a href="#cb15-126"></a>        <span class="co"># Vector DB에 저장</span></span>
<span id="cb15-127"><a href="#cb15-127"></a>        <span class="va">self</span>.collection.add(</span>
<span id="cb15-128"><a href="#cb15-128"></a>            documents<span class="op">=</span>all_chunks,</span>
<span id="cb15-129"><a href="#cb15-129"></a>            embeddings<span class="op">=</span>all_embeddings,</span>
<span id="cb15-130"><a href="#cb15-130"></a>            metadatas<span class="op">=</span>all_metadatas,</span>
<span id="cb15-131"><a href="#cb15-131"></a>            ids<span class="op">=</span>all_ids</span>
<span id="cb15-132"><a href="#cb15-132"></a>        )</span>
<span id="cb15-133"><a href="#cb15-133"></a>        </span>
<span id="cb15-134"><a href="#cb15-134"></a>        <span class="bu">print</span>(<span class="ss">f"✅ 인덱싱 완료!</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb15-135"><a href="#cb15-135"></a>    </span>
<span id="cb15-136"><a href="#cb15-136"></a>    <span class="kw">def</span> retrieve(<span class="va">self</span>, query: <span class="bu">str</span>, top_k: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span>) <span class="op">-&gt;</span> List[Dict]:</span>
<span id="cb15-137"><a href="#cb15-137"></a>        <span class="co">"""</span></span>
<span id="cb15-138"><a href="#cb15-138"></a><span class="co">        질문과 관련된 문서 검색</span></span>
<span id="cb15-139"><a href="#cb15-139"></a><span class="co">        """</span></span>
<span id="cb15-140"><a href="#cb15-140"></a>        <span class="co"># 질문 임베딩</span></span>
<span id="cb15-141"><a href="#cb15-141"></a>        query_embedding <span class="op">=</span> <span class="va">self</span>.embed_texts([query])[<span class="dv">0</span>]</span>
<span id="cb15-142"><a href="#cb15-142"></a>        </span>
<span id="cb15-143"><a href="#cb15-143"></a>        <span class="co"># 검색</span></span>
<span id="cb15-144"><a href="#cb15-144"></a>        results <span class="op">=</span> <span class="va">self</span>.collection.query(</span>
<span id="cb15-145"><a href="#cb15-145"></a>            query_embeddings<span class="op">=</span>[query_embedding],</span>
<span id="cb15-146"><a href="#cb15-146"></a>            n_results<span class="op">=</span>top_k</span>
<span id="cb15-147"><a href="#cb15-147"></a>        )</span>
<span id="cb15-148"><a href="#cb15-148"></a>        </span>
<span id="cb15-149"><a href="#cb15-149"></a>        <span class="co"># 결과 포맷팅</span></span>
<span id="cb15-150"><a href="#cb15-150"></a>        documents <span class="op">=</span> []</span>
<span id="cb15-151"><a href="#cb15-151"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(results[<span class="st">'documents'</span>][<span class="dv">0</span>])):</span>
<span id="cb15-152"><a href="#cb15-152"></a>            documents.append({</span>
<span id="cb15-153"><a href="#cb15-153"></a>                <span class="st">'text'</span>: results[<span class="st">'documents'</span>][<span class="dv">0</span>][i],</span>
<span id="cb15-154"><a href="#cb15-154"></a>                <span class="st">'metadata'</span>: results[<span class="st">'metadatas'</span>][<span class="dv">0</span>][i],</span>
<span id="cb15-155"><a href="#cb15-155"></a>                <span class="st">'distance'</span>: results[<span class="st">'distances'</span>][<span class="dv">0</span>][i]</span>
<span id="cb15-156"><a href="#cb15-156"></a>            })</span>
<span id="cb15-157"><a href="#cb15-157"></a>        </span>
<span id="cb15-158"><a href="#cb15-158"></a>        <span class="cf">return</span> documents</span>
<span id="cb15-159"><a href="#cb15-159"></a>    </span>
<span id="cb15-160"><a href="#cb15-160"></a>    <span class="kw">def</span> generate_answer(<span class="va">self</span>, query: <span class="bu">str</span>, documents: List[Dict]) <span class="op">-&gt;</span> Dict:</span>
<span id="cb15-161"><a href="#cb15-161"></a>        <span class="co">"""</span></span>
<span id="cb15-162"><a href="#cb15-162"></a><span class="co">        검색된 문서를 바탕으로 답변 생성</span></span>
<span id="cb15-163"><a href="#cb15-163"></a><span class="co">        """</span></span>
<span id="cb15-164"><a href="#cb15-164"></a>        <span class="co"># 컨텍스트 구성</span></span>
<span id="cb15-165"><a href="#cb15-165"></a>        context_parts <span class="op">=</span> []</span>
<span id="cb15-166"><a href="#cb15-166"></a>        <span class="cf">for</span> i, doc <span class="kw">in</span> <span class="bu">enumerate</span>(documents, <span class="dv">1</span>):</span>
<span id="cb15-167"><a href="#cb15-167"></a>            source <span class="op">=</span> doc[<span class="st">'metadata'</span>].get(<span class="st">'source'</span>, <span class="st">'Unknown'</span>)</span>
<span id="cb15-168"><a href="#cb15-168"></a>            chunk_id <span class="op">=</span> doc[<span class="st">'metadata'</span>].get(<span class="st">'chunk_id'</span>, <span class="st">'Unknown'</span>)</span>
<span id="cb15-169"><a href="#cb15-169"></a>            text <span class="op">=</span> doc[<span class="st">'text'</span>]</span>
<span id="cb15-170"><a href="#cb15-170"></a>            distance <span class="op">=</span> doc[<span class="st">'distance'</span>]</span>
<span id="cb15-171"><a href="#cb15-171"></a>            </span>
<span id="cb15-172"><a href="#cb15-172"></a>            context_parts.append(</span>
<span id="cb15-173"><a href="#cb15-173"></a>                <span class="ss">f"[Document </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">] (Source: </span><span class="sc">{</span>source<span class="sc">}</span><span class="ss">, ID: </span><span class="sc">{</span>chunk_id<span class="sc">}</span><span class="ss">, "</span></span>
<span id="cb15-174"><a href="#cb15-174"></a>                <span class="ss">f"Relevance: </span><span class="sc">{</span><span class="dv">1</span><span class="op">-</span>distance<span class="sc">:.3f}</span><span class="ss">)</span><span class="ch">\n</span><span class="sc">{</span>text<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb15-175"><a href="#cb15-175"></a>            )</span>
<span id="cb15-176"><a href="#cb15-176"></a>        </span>
<span id="cb15-177"><a href="#cb15-177"></a>        context <span class="op">=</span> <span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>.join(context_parts)</span>
<span id="cb15-178"><a href="#cb15-178"></a>        </span>
<span id="cb15-179"><a href="#cb15-179"></a>        <span class="co"># 프롬프트 구성</span></span>
<span id="cb15-180"><a href="#cb15-180"></a>        prompt <span class="op">=</span> <span class="ss">f"""다음 문서들을 참고하여 질문에 답변하세요.</span></span>
<span id="cb15-181"><a href="#cb15-181"></a></span>
<span id="cb15-182"><a href="#cb15-182"></a><span class="ss">        &lt;documents&gt;</span></span>
<span id="cb15-183"><a href="#cb15-183"></a><span class="ss">        </span><span class="sc">{</span>context<span class="sc">}</span></span>
<span id="cb15-184"><a href="#cb15-184"></a><span class="ss">        &lt;/documents&gt;</span></span>
<span id="cb15-185"><a href="#cb15-185"></a></span>
<span id="cb15-186"><a href="#cb15-186"></a><span class="ss">        &lt;question&gt;</span></span>
<span id="cb15-187"><a href="#cb15-187"></a><span class="ss">        </span><span class="sc">{</span>query<span class="sc">}</span></span>
<span id="cb15-188"><a href="#cb15-188"></a><span class="ss">        &lt;/question&gt;</span></span>
<span id="cb15-189"><a href="#cb15-189"></a></span>
<span id="cb15-190"><a href="#cb15-190"></a><span class="ss">        답변 작성 시 주의사항:</span></span>
<span id="cb15-191"><a href="#cb15-191"></a><span class="ss">        1. 문서의 정보만을 사용하여 답변하세요.</span></span>
<span id="cb15-192"><a href="#cb15-192"></a><span class="ss">        2. 문서에 없는 정보는 추측하지 마세요.</span></span>
<span id="cb15-193"><a href="#cb15-193"></a><span class="ss">        3. 가능하면 어느 문서에서 정보를 가져왔는지 명시하세요 (예: "Document 1에 따르면...").</span></span>
<span id="cb15-194"><a href="#cb15-194"></a><span class="ss">        4. 문서에서 답을 찾을 수 없다면 "제공된 문서에서 관련 정보를 찾을 수 없습니다"라고 답하세요.</span></span>
<span id="cb15-195"><a href="#cb15-195"></a></span>
<span id="cb15-196"><a href="#cb15-196"></a><span class="ss">        답변:"""</span></span>
<span id="cb15-197"><a href="#cb15-197"></a>        </span>
<span id="cb15-198"><a href="#cb15-198"></a>        <span class="co"># LLM 호출</span></span>
<span id="cb15-199"><a href="#cb15-199"></a>        message <span class="op">=</span> <span class="va">self</span>.llm_client.messages.create(</span>
<span id="cb15-200"><a href="#cb15-200"></a>            model<span class="op">=</span><span class="st">"claude-sonnet-4-20250514"</span>,</span>
<span id="cb15-201"><a href="#cb15-201"></a>            max_tokens<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb15-202"><a href="#cb15-202"></a>            temperature<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb15-203"><a href="#cb15-203"></a>            messages<span class="op">=</span>[{<span class="st">"role"</span>: <span class="st">"user"</span>, <span class="st">"content"</span>: prompt}]</span>
<span id="cb15-204"><a href="#cb15-204"></a>        )</span>
<span id="cb15-205"><a href="#cb15-205"></a>        </span>
<span id="cb15-206"><a href="#cb15-206"></a>        answer <span class="op">=</span> message.content[<span class="dv">0</span>].text</span>
<span id="cb15-207"><a href="#cb15-207"></a>        </span>
<span id="cb15-208"><a href="#cb15-208"></a>        <span class="cf">return</span> {</span>
<span id="cb15-209"><a href="#cb15-209"></a>            <span class="st">'answer'</span>: answer,</span>
<span id="cb15-210"><a href="#cb15-210"></a>            <span class="st">'sources'</span>: documents,</span>
<span id="cb15-211"><a href="#cb15-211"></a>            <span class="st">'prompt'</span>: prompt</span>
<span id="cb15-212"><a href="#cb15-212"></a>        }</span>
<span id="cb15-213"><a href="#cb15-213"></a>    </span>
<span id="cb15-214"><a href="#cb15-214"></a>    <span class="kw">def</span> query(<span class="va">self</span>, question: <span class="bu">str</span>, top_k: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span>, verbose: <span class="bu">bool</span> <span class="op">=</span> <span class="va">True</span>) <span class="op">-&gt;</span> Dict:</span>
<span id="cb15-215"><a href="#cb15-215"></a>        <span class="co">"""</span></span>
<span id="cb15-216"><a href="#cb15-216"></a><span class="co">        RAG 전체 파이프라인 실행</span></span>
<span id="cb15-217"><a href="#cb15-217"></a><span class="co">        """</span></span>
<span id="cb15-218"><a href="#cb15-218"></a>        <span class="cf">if</span> verbose:</span>
<span id="cb15-219"><a href="#cb15-219"></a>            <span class="bu">print</span>(<span class="ss">f"❓ 질문: </span><span class="sc">{</span>question<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb15-220"><a href="#cb15-220"></a>            <span class="bu">print</span>(<span class="ss">f"🔍 관련 문서 검색 중 (top_k=</span><span class="sc">{</span>top_k<span class="sc">}</span><span class="ss">)..."</span>)</span>
<span id="cb15-221"><a href="#cb15-221"></a>        </span>
<span id="cb15-222"><a href="#cb15-222"></a>        <span class="co"># Step 1: 검색</span></span>
<span id="cb15-223"><a href="#cb15-223"></a>        documents <span class="op">=</span> <span class="va">self</span>.retrieve(question, top_k<span class="op">=</span>top_k)</span>
<span id="cb15-224"><a href="#cb15-224"></a>        </span>
<span id="cb15-225"><a href="#cb15-225"></a>        <span class="cf">if</span> verbose:</span>
<span id="cb15-226"><a href="#cb15-226"></a>            <span class="bu">print</span>(<span class="ss">f"✅ </span><span class="sc">{</span><span class="bu">len</span>(documents)<span class="sc">}</span><span class="ss">개 문서 검색 완료</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb15-227"><a href="#cb15-227"></a>            <span class="cf">for</span> i, doc <span class="kw">in</span> <span class="bu">enumerate</span>(documents, <span class="dv">1</span>):</span>
<span id="cb15-228"><a href="#cb15-228"></a>                relevance <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> doc[<span class="st">'distance'</span>]</span>
<span id="cb15-229"><a href="#cb15-229"></a>                chunk_id <span class="op">=</span> doc[<span class="st">'metadata'</span>].get(<span class="st">'chunk_id'</span>, <span class="st">'Unknown'</span>)</span>
<span id="cb15-230"><a href="#cb15-230"></a>                <span class="bu">print</span>(<span class="ss">f"  [</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">] </span><span class="sc">{</span>chunk_id<span class="sc">}</span><span class="ss"> (관련도: </span><span class="sc">{</span>relevance<span class="sc">:.3f}</span><span class="ss">)"</span>)</span>
<span id="cb15-231"><a href="#cb15-231"></a>                <span class="bu">print</span>(<span class="ss">f"      </span><span class="sc">{</span>doc[<span class="st">'text'</span>][:<span class="dv">100</span>]<span class="sc">}</span><span class="ss">..."</span>)</span>
<span id="cb15-232"><a href="#cb15-232"></a>            <span class="bu">print</span>()</span>
<span id="cb15-233"><a href="#cb15-233"></a>        </span>
<span id="cb15-234"><a href="#cb15-234"></a>        <span class="co"># Step 2: 답변 생성</span></span>
<span id="cb15-235"><a href="#cb15-235"></a>        <span class="cf">if</span> verbose:</span>
<span id="cb15-236"><a href="#cb15-236"></a>            <span class="bu">print</span>(<span class="ss">f"💬 답변 생성 중..."</span>)</span>
<span id="cb15-237"><a href="#cb15-237"></a>        </span>
<span id="cb15-238"><a href="#cb15-238"></a>        result <span class="op">=</span> <span class="va">self</span>.generate_answer(question, documents)</span>
<span id="cb15-239"><a href="#cb15-239"></a>        </span>
<span id="cb15-240"><a href="#cb15-240"></a>        <span class="cf">if</span> verbose:</span>
<span id="cb15-241"><a href="#cb15-241"></a>            <span class="bu">print</span>(<span class="ss">f"✅ 답변 생성 완료</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb15-242"><a href="#cb15-242"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">80</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-243"><a href="#cb15-243"></a>            <span class="bu">print</span>(<span class="ss">f"답변:"</span>)</span>
<span id="cb15-244"><a href="#cb15-244"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">80</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-245"><a href="#cb15-245"></a>            <span class="bu">print</span>(result[<span class="st">'answer'</span>])</span>
<span id="cb15-246"><a href="#cb15-246"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">80</span><span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb15-247"><a href="#cb15-247"></a>        </span>
<span id="cb15-248"><a href="#cb15-248"></a>        <span class="cf">return</span> result</span>
<span id="cb15-249"><a href="#cb15-249"></a></span>
<span id="cb15-250"><a href="#cb15-250"></a></span>
<span id="cb15-251"><a href="#cb15-251"></a><span class="co"># 사용 예시</span></span>
<span id="cb15-252"><a href="#cb15-252"></a><span class="kw">def</span> main():</span>
<span id="cb15-253"><a href="#cb15-253"></a>    <span class="co"># RAG 시스템 초기화</span></span>
<span id="cb15-254"><a href="#cb15-254"></a>    rag <span class="op">=</span> SimpleRAGSystem(</span>
<span id="cb15-255"><a href="#cb15-255"></a>        anthropic_api_key<span class="op">=</span><span class="st">"your-anthropic-key"</span>,</span>
<span id="cb15-256"><a href="#cb15-256"></a>        openai_api_key<span class="op">=</span><span class="st">"your-openai-key"</span>,</span>
<span id="cb15-257"><a href="#cb15-257"></a>        collection_name<span class="op">=</span><span class="st">"company_docs"</span></span>
<span id="cb15-258"><a href="#cb15-258"></a>    )</span>
<span id="cb15-259"><a href="#cb15-259"></a>    </span>
<span id="cb15-260"><a href="#cb15-260"></a>    <span class="co"># 문서 준비</span></span>
<span id="cb15-261"><a href="#cb15-261"></a>    documents <span class="op">=</span> [</span>
<span id="cb15-262"><a href="#cb15-262"></a>        {</span>
<span id="cb15-263"><a href="#cb15-263"></a>            <span class="st">"text"</span>: <span class="st">"""</span></span>
<span id="cb15-264"><a href="#cb15-264"></a><span class="st">Anthropic is an AI safety and research company based in San Francisco. </span></span>
<span id="cb15-265"><a href="#cb15-265"></a><span class="st">The company was founded in 2021 by former members of OpenAI, including </span></span>
<span id="cb15-266"><a href="#cb15-266"></a><span class="st">Dario Amodei (CEO) and Daniela Amodei (President).</span></span>
<span id="cb15-267"><a href="#cb15-267"></a></span>
<span id="cb15-268"><a href="#cb15-268"></a><span class="st">Anthropic's mission is to build reliable, interpretable, and steerable </span></span>
<span id="cb15-269"><a href="#cb15-269"></a><span class="st">AI systems. The company is best known for developing Claude, a family </span></span>
<span id="cb15-270"><a href="#cb15-270"></a><span class="st">of large language models designed with a focus on safety and helpfulness.</span></span>
<span id="cb15-271"><a href="#cb15-271"></a></span>
<span id="cb15-272"><a href="#cb15-272"></a><span class="st">Claude is built using Constitutional AI (CAI), a method developed by </span></span>
<span id="cb15-273"><a href="#cb15-273"></a><span class="st">Anthropic that trains AI systems to be helpful, harmless, and honest.</span></span>
<span id="cb15-274"><a href="#cb15-274"></a><span class="st">            """</span>,</span>
<span id="cb15-275"><a href="#cb15-275"></a>            <span class="st">"metadata"</span>: {</span>
<span id="cb15-276"><a href="#cb15-276"></a>                <span class="st">"source"</span>: <span class="st">"company_overview.txt"</span>,</span>
<span id="cb15-277"><a href="#cb15-277"></a>                <span class="st">"date"</span>: <span class="st">"2024-01"</span></span>
<span id="cb15-278"><a href="#cb15-278"></a>            }</span>
<span id="cb15-279"><a href="#cb15-279"></a>        },</span>
<span id="cb15-280"><a href="#cb15-280"></a>        {</span>
<span id="cb15-281"><a href="#cb15-281"></a>            <span class="st">"text"</span>: <span class="st">"""</span></span>
<span id="cb15-282"><a href="#cb15-282"></a><span class="st">In 2023, Anthropic launched Claude 2, which featured improved performance </span></span>
<span id="cb15-283"><a href="#cb15-283"></a><span class="st">and a larger context window of 100,000 tokens. The company has also </span></span>
<span id="cb15-284"><a href="#cb15-284"></a><span class="st">developed Claude Pro, a paid subscription service offering priority </span></span>
<span id="cb15-285"><a href="#cb15-285"></a><span class="st">access and enhanced capabilities.</span></span>
<span id="cb15-286"><a href="#cb15-286"></a></span>
<span id="cb15-287"><a href="#cb15-287"></a><span class="st">Anthropic has raised significant funding, including a $4 billion </span></span>
<span id="cb15-288"><a href="#cb15-288"></a><span class="st">investment from Amazon in 2023. The company partners with various </span></span>
<span id="cb15-289"><a href="#cb15-289"></a><span class="st">organizations to deploy Claude in different applications, including </span></span>
<span id="cb15-290"><a href="#cb15-290"></a><span class="st">customer service, content generation, and research assistance.</span></span>
<span id="cb15-291"><a href="#cb15-291"></a></span>
<span id="cb15-292"><a href="#cb15-292"></a><span class="st">In 2024, Anthropic released Claude 3 family (Opus, Sonnet, Haiku) and </span></span>
<span id="cb15-293"><a href="#cb15-293"></a><span class="st">later Claude 3.5 Sonnet, which showed significant improvements in </span></span>
<span id="cb15-294"><a href="#cb15-294"></a><span class="st">reasoning and coding capabilities.</span></span>
<span id="cb15-295"><a href="#cb15-295"></a><span class="st">            """</span>,</span>
<span id="cb15-296"><a href="#cb15-296"></a>            <span class="st">"metadata"</span>: {</span>
<span id="cb15-297"><a href="#cb15-297"></a>                <span class="st">"source"</span>: <span class="st">"company_history.txt"</span>,</span>
<span id="cb15-298"><a href="#cb15-298"></a>                <span class="st">"date"</span>: <span class="st">"2024-06"</span></span>
<span id="cb15-299"><a href="#cb15-299"></a>            }</span>
<span id="cb15-300"><a href="#cb15-300"></a>        },</span>
<span id="cb15-301"><a href="#cb15-301"></a>        {</span>
<span id="cb15-302"><a href="#cb15-302"></a>            <span class="st">"text"</span>: <span class="st">"""</span></span>
<span id="cb15-303"><a href="#cb15-303"></a><span class="st">Claude's architecture is based on transformer models, similar to GPT, </span></span>
<span id="cb15-304"><a href="#cb15-304"></a><span class="st">but with several key differences in training methodology. The Constitutional </span></span>
<span id="cb15-305"><a href="#cb15-305"></a><span class="st">AI approach uses a set of principles (a "constitution") to guide the AI's </span></span>
<span id="cb15-306"><a href="#cb15-306"></a><span class="st">behavior during training.</span></span>
<span id="cb15-307"><a href="#cb15-307"></a></span>
<span id="cb15-308"><a href="#cb15-308"></a><span class="st">The training process involves two main phases: supervised learning and </span></span>
<span id="cb15-309"><a href="#cb15-309"></a><span class="st">reinforcement learning from human feedback (RLHF). However, Anthropic's </span></span>
<span id="cb15-310"><a href="#cb15-310"></a><span class="st">approach reduces reliance on human feedback by having the model critique </span></span>
<span id="cb15-311"><a href="#cb15-311"></a><span class="st">and revise its own responses based on constitutional principles.</span></span>
<span id="cb15-312"><a href="#cb15-312"></a></span>
<span id="cb15-313"><a href="#cb15-313"></a><span class="st">This approach aims to create AI systems that are more aligned with human </span></span>
<span id="cb15-314"><a href="#cb15-314"></a><span class="st">values and less likely to produce harmful outputs.</span></span>
<span id="cb15-315"><a href="#cb15-315"></a><span class="st">            """</span>,</span>
<span id="cb15-316"><a href="#cb15-316"></a>            <span class="st">"metadata"</span>: {</span>
<span id="cb15-317"><a href="#cb15-317"></a>                <span class="st">"source"</span>: <span class="st">"technical_details.txt"</span>,</span>
<span id="cb15-318"><a href="#cb15-318"></a>                <span class="st">"date"</span>: <span class="st">"2024-03"</span></span>
<span id="cb15-319"><a href="#cb15-319"></a>            }</span>
<span id="cb15-320"><a href="#cb15-320"></a>        }</span>
<span id="cb15-321"><a href="#cb15-321"></a>    ]</span>
<span id="cb15-322"><a href="#cb15-322"></a>    </span>
<span id="cb15-323"><a href="#cb15-323"></a>    <span class="co"># 문서 인덱싱</span></span>
<span id="cb15-324"><a href="#cb15-324"></a>    rag.index_documents(documents, chunk_size<span class="op">=</span><span class="dv">256</span>, overlap<span class="op">=</span><span class="dv">30</span>)</span>
<span id="cb15-325"><a href="#cb15-325"></a>    </span>
<span id="cb15-326"><a href="#cb15-326"></a>    <span class="co"># 질문들</span></span>
<span id="cb15-327"><a href="#cb15-327"></a>    questions <span class="op">=</span> [</span>
<span id="cb15-328"><a href="#cb15-328"></a>        <span class="st">"Anthropic의 CEO는 누구인가?"</span>,</span>
<span id="cb15-329"><a href="#cb15-329"></a>        <span class="st">"Claude는 어떻게 학습되었나?"</span>,</span>
<span id="cb15-330"><a href="#cb15-330"></a>        <span class="st">"Anthropic은 언제 설립되었나?"</span>,</span>
<span id="cb15-331"><a href="#cb15-331"></a>        <span class="st">"Claude 3의 특징은 무엇인가?"</span>,</span>
<span id="cb15-332"><a href="#cb15-332"></a>        <span class="st">"Anthropic의 직원 수는 몇 명인가?"</span>  <span class="co"># 문서에 없는 정보</span></span>
<span id="cb15-333"><a href="#cb15-333"></a>    ]</span>
<span id="cb15-334"><a href="#cb15-334"></a>    </span>
<span id="cb15-335"><a href="#cb15-335"></a>    <span class="co"># 각 질문에 대해 RAG 실행</span></span>
<span id="cb15-336"><a href="#cb15-336"></a>    <span class="cf">for</span> question <span class="kw">in</span> questions:</span>
<span id="cb15-337"><a href="#cb15-337"></a>        <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> <span class="st">"="</span><span class="op">*</span><span class="dv">100</span>)</span>
<span id="cb15-338"><a href="#cb15-338"></a>        result <span class="op">=</span> rag.query(question, top_k<span class="op">=</span><span class="dv">3</span>, verbose<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-339"><a href="#cb15-339"></a>        <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">100</span> <span class="op">+</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb15-340"><a href="#cb15-340"></a></span>
<span id="cb15-341"><a href="#cb15-341"></a></span>
<span id="cb15-342"><a href="#cb15-342"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb15-343"><a href="#cb15-343"></a>    main()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="실행-결과-예시" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="실행-결과-예시"><span class="header-section-number">4.1</span> 실행 결과 예시</h3>
<pre><code>📚 3개 문서 인덱싱 시작...
  문서 1: 3개 청크 생성
  문서 2: 3개 청크 생성
  문서 3: 3개 청크 생성

🔢 총 9개 청크 생성
🧮 임베딩 생성 중...
  9/9 완료

💾 Vector DB에 저장 중...
✅ 인덱싱 완료!

====================================================================================================
❓ 질문: Anthropic의 CEO는 누구인가?

🔍 관련 문서 검색 중 (top_k=3)...
✅ 3개 문서 검색 완료

  [1] doc0_chunk0 (관련도: 0.876)
      Anthropic is an AI safety and research company based in San Francisco. 
The company was founded...
  [2] doc1_chunk0 (관련도: 0.745)
      In 2023, Anthropic launched Claude 2, which featured improved performance...
  [3] doc2_chunk0 (관련도: 0.698)
      Claude's architecture is based on transformer models, similar to GPT...

💬 답변 생성 중...
✅ 답변 생성 완료

================================================================================
답변:
================================================================================
Document 1에 따르면, Anthropic의 CEO는 Dario Amodei입니다. 그는 OpenAI의 
전 멤버로서 2021년에 Anthropic을 공동 설립했습니다.
================================================================================

====================================================================================================</code></pre>
</section>
</section>
<section id="rag-시스템-최적화-기법" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="rag-시스템-최적화-기법"><span class="header-section-number">5</span> RAG 시스템 최적화 기법</h2>
<p>기본 RAG 시스템을 구축했다면, 이제 성능을 개선할 차례다. 실무에서는 단순한 Naive RAG만으로는 부족한 경우가 많다.</p>
<section id="검색-품질-저하" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="검색-품질-저하"><span class="header-section-number">5.1</span> 검색 품질 저하</h3>
<p><strong>증상</strong>: 관련 없는 문서가 검색되거나, 관련 있는 문서를 놓침</p>
<p><strong>원인</strong>: - 의미론적 유사도만으로는 부족 - 키워드 기반 매칭 필요 - 문서의 중요도 무시</p>
<p><strong>해결책</strong>: Hybrid Search (하이브리드 검색)</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a><span class="im">from</span> typing <span class="im">import</span> List, Dict, Tuple</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="kw">class</span> HybridSearchRAG:</span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="co">"""</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="co">    의미론적 검색 + 키워드 검색을 결합한 하이브리드 RAG</span></span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="co">    """</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>    </span>
<span id="cb17-9"><a href="#cb17-9"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb17-10"><a href="#cb17-10"></a>        <span class="co"># 벡터 검색 (Dense)</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>        <span class="va">self</span>.vector_store <span class="op">=</span> <span class="va">None</span>  <span class="co"># ChromaDB 등</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>        </span>
<span id="cb17-13"><a href="#cb17-13"></a>        <span class="co"># 키워드 검색 (Sparse) - BM25</span></span>
<span id="cb17-14"><a href="#cb17-14"></a>        <span class="va">self</span>.bm25_index <span class="op">=</span> <span class="va">None</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>        <span class="va">self</span>.documents <span class="op">=</span> []</span>
<span id="cb17-16"><a href="#cb17-16"></a>    </span>
<span id="cb17-17"><a href="#cb17-17"></a>    <span class="kw">def</span> index_documents(<span class="va">self</span>, documents: List[Dict]):</span>
<span id="cb17-18"><a href="#cb17-18"></a>        <span class="co">"""</span></span>
<span id="cb17-19"><a href="#cb17-19"></a><span class="co">        문서를 벡터 DB와 BM25 인덱스에 모두 저장</span></span>
<span id="cb17-20"><a href="#cb17-20"></a><span class="co">        """</span></span>
<span id="cb17-21"><a href="#cb17-21"></a>        <span class="co"># 1. Vector DB 인덱싱 (기존과 동일)</span></span>
<span id="cb17-22"><a href="#cb17-22"></a>        <span class="va">self</span>._index_to_vector_db(documents)</span>
<span id="cb17-23"><a href="#cb17-23"></a>        </span>
<span id="cb17-24"><a href="#cb17-24"></a>        <span class="co"># 2. BM25 인덱싱</span></span>
<span id="cb17-25"><a href="#cb17-25"></a>        <span class="va">self</span>._index_to_bm25(documents)</span>
<span id="cb17-26"><a href="#cb17-26"></a>    </span>
<span id="cb17-27"><a href="#cb17-27"></a>    <span class="kw">def</span> _index_to_bm25(<span class="va">self</span>, documents: List[Dict]):</span>
<span id="cb17-28"><a href="#cb17-28"></a>        <span class="co">"""</span></span>
<span id="cb17-29"><a href="#cb17-29"></a><span class="co">        BM25 인덱스 구축</span></span>
<span id="cb17-30"><a href="#cb17-30"></a><span class="co">        """</span></span>
<span id="cb17-31"><a href="#cb17-31"></a>        <span class="im">from</span> rank_bm25 <span class="im">import</span> BM25Okapi</span>
<span id="cb17-32"><a href="#cb17-32"></a>        </span>
<span id="cb17-33"><a href="#cb17-33"></a>        <span class="co"># 문서 토큰화</span></span>
<span id="cb17-34"><a href="#cb17-34"></a>        tokenized_docs <span class="op">=</span> []</span>
<span id="cb17-35"><a href="#cb17-35"></a>        <span class="cf">for</span> doc <span class="kw">in</span> documents:</span>
<span id="cb17-36"><a href="#cb17-36"></a>            tokens <span class="op">=</span> doc[<span class="st">'text'</span>].lower().split()</span>
<span id="cb17-37"><a href="#cb17-37"></a>            tokenized_docs.append(tokens)</span>
<span id="cb17-38"><a href="#cb17-38"></a>        </span>
<span id="cb17-39"><a href="#cb17-39"></a>        <span class="co"># BM25 인덱스 생성</span></span>
<span id="cb17-40"><a href="#cb17-40"></a>        <span class="va">self</span>.bm25_index <span class="op">=</span> BM25Okapi(tokenized_docs)</span>
<span id="cb17-41"><a href="#cb17-41"></a>        <span class="va">self</span>.documents <span class="op">=</span> documents</span>
<span id="cb17-42"><a href="#cb17-42"></a>    </span>
<span id="cb17-43"><a href="#cb17-43"></a>    <span class="kw">def</span> hybrid_search(</span>
<span id="cb17-44"><a href="#cb17-44"></a>        <span class="va">self</span>, </span>
<span id="cb17-45"><a href="#cb17-45"></a>        query: <span class="bu">str</span>, </span>
<span id="cb17-46"><a href="#cb17-46"></a>        top_k: <span class="bu">int</span> <span class="op">=</span> <span class="dv">10</span>,</span>
<span id="cb17-47"><a href="#cb17-47"></a>        alpha: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb17-48"><a href="#cb17-48"></a>    ) <span class="op">-&gt;</span> List[Dict]:</span>
<span id="cb17-49"><a href="#cb17-49"></a>        <span class="co">"""</span></span>
<span id="cb17-50"><a href="#cb17-50"></a><span class="co">        하이브리드 검색</span></span>
<span id="cb17-51"><a href="#cb17-51"></a><span class="co">        </span></span>
<span id="cb17-52"><a href="#cb17-52"></a><span class="co">        Args:</span></span>
<span id="cb17-53"><a href="#cb17-53"></a><span class="co">            query: 검색 쿼리</span></span>
<span id="cb17-54"><a href="#cb17-54"></a><span class="co">            top_k: 반환할 문서 수</span></span>
<span id="cb17-55"><a href="#cb17-55"></a><span class="co">            alpha: 벡터 검색 가중치 (0~1)</span></span>
<span id="cb17-56"><a href="#cb17-56"></a><span class="co">                   1.0 = 100% 벡터 검색</span></span>
<span id="cb17-57"><a href="#cb17-57"></a><span class="co">                   0.0 = 100% 키워드 검색</span></span>
<span id="cb17-58"><a href="#cb17-58"></a><span class="co">                   0.5 = 균형</span></span>
<span id="cb17-59"><a href="#cb17-59"></a><span class="co">        """</span></span>
<span id="cb17-60"><a href="#cb17-60"></a>        <span class="co"># 1. 벡터 검색 (의미론적 유사도)</span></span>
<span id="cb17-61"><a href="#cb17-61"></a>        vector_results <span class="op">=</span> <span class="va">self</span>._vector_search(query, top_k<span class="op">=</span>top_k<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb17-62"><a href="#cb17-62"></a>        </span>
<span id="cb17-63"><a href="#cb17-63"></a>        <span class="co"># 2. BM25 검색 (키워드 매칭)</span></span>
<span id="cb17-64"><a href="#cb17-64"></a>        bm25_results <span class="op">=</span> <span class="va">self</span>._bm25_search(query, top_k<span class="op">=</span>top_k<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb17-65"><a href="#cb17-65"></a>        </span>
<span id="cb17-66"><a href="#cb17-66"></a>        <span class="co"># 3. 점수 정규화 및 결합</span></span>
<span id="cb17-67"><a href="#cb17-67"></a>        combined_scores <span class="op">=</span> <span class="va">self</span>._combine_scores(</span>
<span id="cb17-68"><a href="#cb17-68"></a>            vector_results, </span>
<span id="cb17-69"><a href="#cb17-69"></a>            bm25_results, </span>
<span id="cb17-70"><a href="#cb17-70"></a>            alpha</span>
<span id="cb17-71"><a href="#cb17-71"></a>        )</span>
<span id="cb17-72"><a href="#cb17-72"></a>        </span>
<span id="cb17-73"><a href="#cb17-73"></a>        <span class="co"># 4. 상위 k개 반환</span></span>
<span id="cb17-74"><a href="#cb17-74"></a>        sorted_results <span class="op">=</span> <span class="bu">sorted</span>(</span>
<span id="cb17-75"><a href="#cb17-75"></a>            combined_scores.items(), </span>
<span id="cb17-76"><a href="#cb17-76"></a>            key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], </span>
<span id="cb17-77"><a href="#cb17-77"></a>            reverse<span class="op">=</span><span class="va">True</span></span>
<span id="cb17-78"><a href="#cb17-78"></a>        )</span>
<span id="cb17-79"><a href="#cb17-79"></a>        </span>
<span id="cb17-80"><a href="#cb17-80"></a>        top_docs <span class="op">=</span> []</span>
<span id="cb17-81"><a href="#cb17-81"></a>        <span class="cf">for</span> doc_id, score <span class="kw">in</span> sorted_results[:top_k]:</span>
<span id="cb17-82"><a href="#cb17-82"></a>            top_docs.append({</span>
<span id="cb17-83"><a href="#cb17-83"></a>                <span class="st">'document'</span>: <span class="va">self</span>.documents[doc_id],</span>
<span id="cb17-84"><a href="#cb17-84"></a>                <span class="st">'score'</span>: score</span>
<span id="cb17-85"><a href="#cb17-85"></a>            })</span>
<span id="cb17-86"><a href="#cb17-86"></a>        </span>
<span id="cb17-87"><a href="#cb17-87"></a>        <span class="cf">return</span> top_docs</span>
<span id="cb17-88"><a href="#cb17-88"></a>    </span>
<span id="cb17-89"><a href="#cb17-89"></a>    <span class="kw">def</span> _vector_search(<span class="va">self</span>, query: <span class="bu">str</span>, top_k: <span class="bu">int</span>) <span class="op">-&gt;</span> Dict[<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb17-90"><a href="#cb17-90"></a>        <span class="co">"""</span></span>
<span id="cb17-91"><a href="#cb17-91"></a><span class="co">        벡터 검색 수행</span></span>
<span id="cb17-92"><a href="#cb17-92"></a><span class="co">        Returns: {doc_id: similarity_score}</span></span>
<span id="cb17-93"><a href="#cb17-93"></a><span class="co">        """</span></span>
<span id="cb17-94"><a href="#cb17-94"></a>        <span class="co"># 질문 임베딩</span></span>
<span id="cb17-95"><a href="#cb17-95"></a>        query_embedding <span class="op">=</span> <span class="va">self</span>.embed_query(query)</span>
<span id="cb17-96"><a href="#cb17-96"></a>        </span>
<span id="cb17-97"><a href="#cb17-97"></a>        <span class="co"># Vector DB 검색</span></span>
<span id="cb17-98"><a href="#cb17-98"></a>        results <span class="op">=</span> <span class="va">self</span>.vector_store.query(</span>
<span id="cb17-99"><a href="#cb17-99"></a>            query_embedding<span class="op">=</span>query_embedding,</span>
<span id="cb17-100"><a href="#cb17-100"></a>            n_results<span class="op">=</span>top_k</span>
<span id="cb17-101"><a href="#cb17-101"></a>        )</span>
<span id="cb17-102"><a href="#cb17-102"></a>        </span>
<span id="cb17-103"><a href="#cb17-103"></a>        <span class="co"># doc_id: score 매핑</span></span>
<span id="cb17-104"><a href="#cb17-104"></a>        scores <span class="op">=</span> {}</span>
<span id="cb17-105"><a href="#cb17-105"></a>        <span class="cf">for</span> i, doc_id <span class="kw">in</span> <span class="bu">enumerate</span>(results[<span class="st">'ids'</span>][<span class="dv">0</span>]):</span>
<span id="cb17-106"><a href="#cb17-106"></a>            <span class="co"># 거리를 유사도로 변환 (코사인 거리 → 유사도)</span></span>
<span id="cb17-107"><a href="#cb17-107"></a>            distance <span class="op">=</span> results[<span class="st">'distances'</span>][<span class="dv">0</span>][i]</span>
<span id="cb17-108"><a href="#cb17-108"></a>            similarity <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> distance</span>
<span id="cb17-109"><a href="#cb17-109"></a>            scores[doc_id] <span class="op">=</span> similarity</span>
<span id="cb17-110"><a href="#cb17-110"></a>        </span>
<span id="cb17-111"><a href="#cb17-111"></a>        <span class="cf">return</span> scores</span>
<span id="cb17-112"><a href="#cb17-112"></a>    </span>
<span id="cb17-113"><a href="#cb17-113"></a>    <span class="kw">def</span> _bm25_search(<span class="va">self</span>, query: <span class="bu">str</span>, top_k: <span class="bu">int</span>) <span class="op">-&gt;</span> Dict[<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb17-114"><a href="#cb17-114"></a>        <span class="co">"""</span></span>
<span id="cb17-115"><a href="#cb17-115"></a><span class="co">        BM25 검색 수행</span></span>
<span id="cb17-116"><a href="#cb17-116"></a><span class="co">        Returns: {doc_id: bm25_score}</span></span>
<span id="cb17-117"><a href="#cb17-117"></a><span class="co">        """</span></span>
<span id="cb17-118"><a href="#cb17-118"></a>        <span class="co"># 쿼리 토큰화</span></span>
<span id="cb17-119"><a href="#cb17-119"></a>        query_tokens <span class="op">=</span> query.lower().split()</span>
<span id="cb17-120"><a href="#cb17-120"></a>        </span>
<span id="cb17-121"><a href="#cb17-121"></a>        <span class="co"># BM25 점수 계산</span></span>
<span id="cb17-122"><a href="#cb17-122"></a>        bm25_scores <span class="op">=</span> <span class="va">self</span>.bm25_index.get_scores(query_tokens)</span>
<span id="cb17-123"><a href="#cb17-123"></a>        </span>
<span id="cb17-124"><a href="#cb17-124"></a>        <span class="co"># 상위 k개의 문서 ID와 점수</span></span>
<span id="cb17-125"><a href="#cb17-125"></a>        top_indices <span class="op">=</span> np.argsort(bm25_scores)[<span class="op">-</span>top_k:][::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb17-126"><a href="#cb17-126"></a>        </span>
<span id="cb17-127"><a href="#cb17-127"></a>        scores <span class="op">=</span> {}</span>
<span id="cb17-128"><a href="#cb17-128"></a>        <span class="cf">for</span> idx <span class="kw">in</span> top_indices:</span>
<span id="cb17-129"><a href="#cb17-129"></a>            scores[idx] <span class="op">=</span> bm25_scores[idx]</span>
<span id="cb17-130"><a href="#cb17-130"></a>        </span>
<span id="cb17-131"><a href="#cb17-131"></a>        <span class="cf">return</span> scores</span>
<span id="cb17-132"><a href="#cb17-132"></a>    </span>
<span id="cb17-133"><a href="#cb17-133"></a>    <span class="kw">def</span> _combine_scores(</span>
<span id="cb17-134"><a href="#cb17-134"></a>        <span class="va">self</span>, </span>
<span id="cb17-135"><a href="#cb17-135"></a>        vector_scores: Dict[<span class="bu">int</span>, <span class="bu">float</span>],</span>
<span id="cb17-136"><a href="#cb17-136"></a>        bm25_scores: Dict[<span class="bu">int</span>, <span class="bu">float</span>],</span>
<span id="cb17-137"><a href="#cb17-137"></a>        alpha: <span class="bu">float</span></span>
<span id="cb17-138"><a href="#cb17-138"></a>    ) <span class="op">-&gt;</span> Dict[<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb17-139"><a href="#cb17-139"></a>        <span class="co">"""</span></span>
<span id="cb17-140"><a href="#cb17-140"></a><span class="co">        두 검색 결과의 점수를 결합</span></span>
<span id="cb17-141"><a href="#cb17-141"></a><span class="co">        </span></span>
<span id="cb17-142"><a href="#cb17-142"></a><span class="co">        Reciprocal Rank Fusion (RRF) 또는 가중 합계 사용 가능</span></span>
<span id="cb17-143"><a href="#cb17-143"></a><span class="co">        여기서는 정규화 후 가중 합계 사용</span></span>
<span id="cb17-144"><a href="#cb17-144"></a><span class="co">        """</span></span>
<span id="cb17-145"><a href="#cb17-145"></a>        <span class="co"># 점수 정규화 (0~1 범위로)</span></span>
<span id="cb17-146"><a href="#cb17-146"></a>        <span class="kw">def</span> normalize_scores(scores: Dict[<span class="bu">int</span>, <span class="bu">float</span>]) <span class="op">-&gt;</span> Dict[<span class="bu">int</span>, <span class="bu">float</span>]:</span>
<span id="cb17-147"><a href="#cb17-147"></a>            <span class="cf">if</span> <span class="kw">not</span> scores:</span>
<span id="cb17-148"><a href="#cb17-148"></a>                <span class="cf">return</span> {}</span>
<span id="cb17-149"><a href="#cb17-149"></a>            </span>
<span id="cb17-150"><a href="#cb17-150"></a>            min_score <span class="op">=</span> <span class="bu">min</span>(scores.values())</span>
<span id="cb17-151"><a href="#cb17-151"></a>            max_score <span class="op">=</span> <span class="bu">max</span>(scores.values())</span>
<span id="cb17-152"><a href="#cb17-152"></a>            </span>
<span id="cb17-153"><a href="#cb17-153"></a>            <span class="cf">if</span> max_score <span class="op">==</span> min_score:</span>
<span id="cb17-154"><a href="#cb17-154"></a>                <span class="cf">return</span> {k: <span class="fl">1.0</span> <span class="cf">for</span> k <span class="kw">in</span> scores}</span>
<span id="cb17-155"><a href="#cb17-155"></a>            </span>
<span id="cb17-156"><a href="#cb17-156"></a>            <span class="cf">return</span> {</span>
<span id="cb17-157"><a href="#cb17-157"></a>                k: (v <span class="op">-</span> min_score) <span class="op">/</span> (max_score <span class="op">-</span> min_score)</span>
<span id="cb17-158"><a href="#cb17-158"></a>                <span class="cf">for</span> k, v <span class="kw">in</span> scores.items()</span>
<span id="cb17-159"><a href="#cb17-159"></a>            }</span>
<span id="cb17-160"><a href="#cb17-160"></a>        </span>
<span id="cb17-161"><a href="#cb17-161"></a>        norm_vector <span class="op">=</span> normalize_scores(vector_scores)</span>
<span id="cb17-162"><a href="#cb17-162"></a>        norm_bm25 <span class="op">=</span> normalize_scores(bm25_scores)</span>
<span id="cb17-163"><a href="#cb17-163"></a>        </span>
<span id="cb17-164"><a href="#cb17-164"></a>        <span class="co"># 모든 문서 ID 수집</span></span>
<span id="cb17-165"><a href="#cb17-165"></a>        all_doc_ids <span class="op">=</span> <span class="bu">set</span>(norm_vector.keys()) <span class="op">|</span> <span class="bu">set</span>(norm_bm25.keys())</span>
<span id="cb17-166"><a href="#cb17-166"></a>        </span>
<span id="cb17-167"><a href="#cb17-167"></a>        <span class="co"># 가중 합계</span></span>
<span id="cb17-168"><a href="#cb17-168"></a>        combined <span class="op">=</span> {}</span>
<span id="cb17-169"><a href="#cb17-169"></a>        <span class="cf">for</span> doc_id <span class="kw">in</span> all_doc_ids:</span>
<span id="cb17-170"><a href="#cb17-170"></a>            vector_score <span class="op">=</span> norm_vector.get(doc_id, <span class="fl">0.0</span>)</span>
<span id="cb17-171"><a href="#cb17-171"></a>            bm25_score <span class="op">=</span> norm_bm25.get(doc_id, <span class="fl">0.0</span>)</span>
<span id="cb17-172"><a href="#cb17-172"></a>            </span>
<span id="cb17-173"><a href="#cb17-173"></a>            combined[doc_id] <span class="op">=</span> alpha <span class="op">*</span> vector_score <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> alpha) <span class="op">*</span> bm25_score</span>
<span id="cb17-174"><a href="#cb17-174"></a>        </span>
<span id="cb17-175"><a href="#cb17-175"></a>        <span class="cf">return</span> combined</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Hybrid Search 사용 예시</strong>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a><span class="co"># 초기화</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>rag <span class="op">=</span> HybridSearchRAG()</span>
<span id="cb18-3"><a href="#cb18-3"></a></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="co"># 문서 인덱싱</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>documents <span class="op">=</span> load_documents()</span>
<span id="cb18-6"><a href="#cb18-6"></a>rag.index_documents(documents)</span>
<span id="cb18-7"><a href="#cb18-7"></a></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="co"># 검색</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>query <span class="op">=</span> <span class="st">"Anthropic CEO"</span></span>
<span id="cb18-10"><a href="#cb18-10"></a></span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="co"># 의미론적 검색만 (alpha=1.0)</span></span>
<span id="cb18-12"><a href="#cb18-12"></a>semantic_results <span class="op">=</span> rag.hybrid_search(query, top_k<span class="op">=</span><span class="dv">5</span>, alpha<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb18-13"><a href="#cb18-13"></a></span>
<span id="cb18-14"><a href="#cb18-14"></a><span class="co"># 키워드 검색만 (alpha=0.0)</span></span>
<span id="cb18-15"><a href="#cb18-15"></a>keyword_results <span class="op">=</span> rag.hybrid_search(query, top_k<span class="op">=</span><span class="dv">5</span>, alpha<span class="op">=</span><span class="fl">0.0</span>)</span>
<span id="cb18-16"><a href="#cb18-16"></a></span>
<span id="cb18-17"><a href="#cb18-17"></a><span class="co"># 하이브리드 (alpha=0.5)</span></span>
<span id="cb18-18"><a href="#cb18-18"></a>hybrid_results <span class="op">=</span> rag.hybrid_search(query, top_k<span class="op">=</span><span class="dv">5</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>alpha 파라미터 튜닝 가이드</strong>:</p>
<table class="table">
<thead>
<tr class="header">
<th>alpha</th>
<th>특징</th>
<th>추천 사용 사례</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0.0-0.3</td>
<td>키워드 중심</td>
<td>정확한 용어 매칭 필요 (법률, 의료)</td>
</tr>
<tr class="even">
<td>0.4-0.6</td>
<td>균형</td>
<td>일반적 Q&amp;A ⭐</td>
</tr>
<tr class="odd">
<td>0.7-1.0</td>
<td>의미론 중심</td>
<td>개념적 질문, 유연한 표현</td>
</tr>
</tbody>
</table>
</section>
<section id="검색-순위가-최적이-아님" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="검색-순위가-최적이-아님"><span class="header-section-number">5.2</span> 검색 순위가 최적이 아님</h3>
<p><strong>증상</strong>: 관련 문서를 찾았지만, 순서가 잘못됨</p>
<p><strong>해결책</strong>: Re-ranking (재순위화)</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">class</span> RerankerRAG:</span>
<span id="cb19-2"><a href="#cb19-2"></a>    <span class="co">"""</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="co">    검색 후 재순위화를 수행하는 RAG</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="co">    """</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>    </span>
<span id="cb19-6"><a href="#cb19-6"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb19-7"><a href="#cb19-7"></a>        <span class="va">self</span>.base_rag <span class="op">=</span> SimpleRAGSystem()</span>
<span id="cb19-8"><a href="#cb19-8"></a>        <span class="va">self</span>.reranker <span class="op">=</span> <span class="va">self</span>._load_reranker()</span>
<span id="cb19-9"><a href="#cb19-9"></a>    </span>
<span id="cb19-10"><a href="#cb19-10"></a>    <span class="kw">def</span> _load_reranker(<span class="va">self</span>):</span>
<span id="cb19-11"><a href="#cb19-11"></a>        <span class="co">"""</span></span>
<span id="cb19-12"><a href="#cb19-12"></a><span class="co">        재순위화 모델 로드</span></span>
<span id="cb19-13"><a href="#cb19-13"></a><span class="co">        </span></span>
<span id="cb19-14"><a href="#cb19-14"></a><span class="co">        옵션:</span></span>
<span id="cb19-15"><a href="#cb19-15"></a><span class="co">        1. Cross-encoder 모델 (BERT 기반)</span></span>
<span id="cb19-16"><a href="#cb19-16"></a><span class="co">        2. Cohere Rerank API</span></span>
<span id="cb19-17"><a href="#cb19-17"></a><span class="co">        3. 커스텀 모델</span></span>
<span id="cb19-18"><a href="#cb19-18"></a><span class="co">        """</span></span>
<span id="cb19-19"><a href="#cb19-19"></a>        <span class="im">from</span> sentence_transformers <span class="im">import</span> CrossEncoder</span>
<span id="cb19-20"><a href="#cb19-20"></a>        </span>
<span id="cb19-21"><a href="#cb19-21"></a>        <span class="co"># MS MARCO 데이터셋으로 학습된 cross-encoder</span></span>
<span id="cb19-22"><a href="#cb19-22"></a>        model <span class="op">=</span> CrossEncoder(<span class="st">'cross-encoder/ms-marco-MiniLM-L-6-v2'</span>)</span>
<span id="cb19-23"><a href="#cb19-23"></a>        <span class="cf">return</span> model</span>
<span id="cb19-24"><a href="#cb19-24"></a>    </span>
<span id="cb19-25"><a href="#cb19-25"></a>    <span class="kw">def</span> retrieve_and_rerank(</span>
<span id="cb19-26"><a href="#cb19-26"></a>        <span class="va">self</span>, </span>
<span id="cb19-27"><a href="#cb19-27"></a>        query: <span class="bu">str</span>,</span>
<span id="cb19-28"><a href="#cb19-28"></a>        initial_k: <span class="bu">int</span> <span class="op">=</span> <span class="dv">20</span>,</span>
<span id="cb19-29"><a href="#cb19-29"></a>        final_k: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb19-30"><a href="#cb19-30"></a>    ) <span class="op">-&gt;</span> List[Dict]:</span>
<span id="cb19-31"><a href="#cb19-31"></a>        <span class="co">"""</span></span>
<span id="cb19-32"><a href="#cb19-32"></a><span class="co">        검색 후 재순위화</span></span>
<span id="cb19-33"><a href="#cb19-33"></a><span class="co">        </span></span>
<span id="cb19-34"><a href="#cb19-34"></a><span class="co">        Args:</span></span>
<span id="cb19-35"><a href="#cb19-35"></a><span class="co">            initial_k: 초기 검색 문서 수 (많이 가져옴)</span></span>
<span id="cb19-36"><a href="#cb19-36"></a><span class="co">            final_k: 최종 반환 문서 수 (재순위 후 상위)</span></span>
<span id="cb19-37"><a href="#cb19-37"></a><span class="co">        """</span></span>
<span id="cb19-38"><a href="#cb19-38"></a>        <span class="co"># Step 1: 초기 검색 (많은 문서)</span></span>
<span id="cb19-39"><a href="#cb19-39"></a>        candidates <span class="op">=</span> <span class="va">self</span>.base_rag.retrieve(query, top_k<span class="op">=</span>initial_k)</span>
<span id="cb19-40"><a href="#cb19-40"></a>        </span>
<span id="cb19-41"><a href="#cb19-41"></a>        <span class="bu">print</span>(<span class="ss">f"🔍 초기 검색: </span><span class="sc">{</span><span class="bu">len</span>(candidates)<span class="sc">}</span><span class="ss">개 문서"</span>)</span>
<span id="cb19-42"><a href="#cb19-42"></a>        </span>
<span id="cb19-43"><a href="#cb19-43"></a>        <span class="co"># Step 2: 재순위화</span></span>
<span id="cb19-44"><a href="#cb19-44"></a>        pairs <span class="op">=</span> [[query, doc[<span class="st">'text'</span>]] <span class="cf">for</span> doc <span class="kw">in</span> candidates]</span>
<span id="cb19-45"><a href="#cb19-45"></a>        scores <span class="op">=</span> <span class="va">self</span>.reranker.predict(pairs)</span>
<span id="cb19-46"><a href="#cb19-46"></a>        </span>
<span id="cb19-47"><a href="#cb19-47"></a>        <span class="co"># Step 3: 점수 기준으로 재정렬</span></span>
<span id="cb19-48"><a href="#cb19-48"></a>        <span class="cf">for</span> i, doc <span class="kw">in</span> <span class="bu">enumerate</span>(candidates):</span>
<span id="cb19-49"><a href="#cb19-49"></a>            doc[<span class="st">'rerank_score'</span>] <span class="op">=</span> scores[i]</span>
<span id="cb19-50"><a href="#cb19-50"></a>        </span>
<span id="cb19-51"><a href="#cb19-51"></a>        reranked <span class="op">=</span> <span class="bu">sorted</span>(</span>
<span id="cb19-52"><a href="#cb19-52"></a>            candidates, </span>
<span id="cb19-53"><a href="#cb19-53"></a>            key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="st">'rerank_score'</span>], </span>
<span id="cb19-54"><a href="#cb19-54"></a>            reverse<span class="op">=</span><span class="va">True</span></span>
<span id="cb19-55"><a href="#cb19-55"></a>        )</span>
<span id="cb19-56"><a href="#cb19-56"></a>        </span>
<span id="cb19-57"><a href="#cb19-57"></a>        <span class="bu">print</span>(<span class="ss">f"🔄 재순위화 완료"</span>)</span>
<span id="cb19-58"><a href="#cb19-58"></a>        <span class="bu">print</span>(<span class="ss">f"📊 상위 문서 점수 변화:"</span>)</span>
<span id="cb19-59"><a href="#cb19-59"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">3</span>, <span class="bu">len</span>(reranked))):</span>
<span id="cb19-60"><a href="#cb19-60"></a>            doc <span class="op">=</span> reranked[i]</span>
<span id="cb19-61"><a href="#cb19-61"></a>            <span class="bu">print</span>(<span class="ss">f"  [</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">] 원래 순위: </span><span class="sc">{</span>candidates<span class="sc">.</span>index(doc)<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> "</span></span>
<span id="cb19-62"><a href="#cb19-62"></a>                  <span class="ss">f"→ 재순위 점수: </span><span class="sc">{</span>doc[<span class="st">'rerank_score'</span>]<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb19-63"><a href="#cb19-63"></a>        </span>
<span id="cb19-64"><a href="#cb19-64"></a>        <span class="co"># Step 4: 상위 k개만 반환</span></span>
<span id="cb19-65"><a href="#cb19-65"></a>        <span class="cf">return</span> reranked[:final_k]</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>재순위화 모델 선택</strong>:</p>
<table class="table">
<thead>
<tr class="header">
<th>모델</th>
<th>속도</th>
<th>성능</th>
<th>비용</th>
<th>추천</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cross-encoder (local)</td>
<td>느림</td>
<td>높음</td>
<td>무료</td>
<td>정확도 중요 시</td>
</tr>
<tr class="even">
<td>Cohere Rerank API</td>
<td>빠름</td>
<td>매우 높음</td>
<td>유료</td>
<td>프로덕션 ⭐</td>
</tr>
<tr class="odd">
<td>LLM-based (GPT/Claude)</td>
<td>매우 느림</td>
<td>높음</td>
<td>비쌈</td>
<td>특수 도메인</td>
</tr>
</tbody>
</table>
<p><strong>Cohere Rerank 사용 예시</strong>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a><span class="im">import</span> cohere</span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="kw">def</span> rerank_with_cohere(query: <span class="bu">str</span>, documents: List[<span class="bu">str</span>], top_k: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span>):</span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="co">"""</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="co">    Cohere Rerank API 사용</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="co">    """</span></span>
<span id="cb20-7"><a href="#cb20-7"></a>    co <span class="op">=</span> cohere.Client(<span class="st">"your-api-key"</span>)</span>
<span id="cb20-8"><a href="#cb20-8"></a>    </span>
<span id="cb20-9"><a href="#cb20-9"></a>    results <span class="op">=</span> co.rerank(</span>
<span id="cb20-10"><a href="#cb20-10"></a>        query<span class="op">=</span>query,</span>
<span id="cb20-11"><a href="#cb20-11"></a>        documents<span class="op">=</span>documents,</span>
<span id="cb20-12"><a href="#cb20-12"></a>        top_n<span class="op">=</span>top_k,</span>
<span id="cb20-13"><a href="#cb20-13"></a>        model<span class="op">=</span><span class="st">"rerank-english-v2.0"</span></span>
<span id="cb20-14"><a href="#cb20-14"></a>    )</span>
<span id="cb20-15"><a href="#cb20-15"></a>    </span>
<span id="cb20-16"><a href="#cb20-16"></a>    reranked_docs <span class="op">=</span> []</span>
<span id="cb20-17"><a href="#cb20-17"></a>    <span class="cf">for</span> result <span class="kw">in</span> results:</span>
<span id="cb20-18"><a href="#cb20-18"></a>        reranked_docs.append({</span>
<span id="cb20-19"><a href="#cb20-19"></a>            <span class="st">'text'</span>: documents[result.index],</span>
<span id="cb20-20"><a href="#cb20-20"></a>            <span class="st">'score'</span>: result.relevance_score</span>
<span id="cb20-21"><a href="#cb20-21"></a>        })</span>
<span id="cb20-22"><a href="#cb20-22"></a>    </span>
<span id="cb20-23"><a href="#cb20-23"></a>    <span class="cf">return</span> reranked_docs</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="쿼리가-모호하거나-부적절함" class="level3" data-number="5.3">
<h3 data-number="5.3" class="anchored" data-anchor-id="쿼리가-모호하거나-부적절함"><span class="header-section-number">5.3</span> 쿼리가 모호하거나 부적절함</h3>
<p><strong>증상</strong>: 사용자 질문이 너무 짧거나, 애매하거나, 검색에 적합하지 않음</p>
<p><strong>해결책</strong>: Query Transformation (쿼리 변환)</p>
<section id="기법-1-query-expansion-쿼리-확장" class="level4" data-number="5.3.1">
<h4 data-number="5.3.1" class="anchored" data-anchor-id="기법-1-query-expansion-쿼리-확장"><span class="header-section-number">5.3.1</span> 기법 1: Query Expansion (쿼리 확장)</h4>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">def</span> expand_query(query: <span class="bu">str</span>) <span class="op">-&gt;</span> List[<span class="bu">str</span>]:</span>
<span id="cb21-2"><a href="#cb21-2"></a>    <span class="co">"""</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="co">    하나의 쿼리를 여러 변형으로 확장</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="co">    """</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>    prompt <span class="op">=</span> <span class="ss">f"""다음 질문을 다양한 방식으로 3가지 변형하여 표현하세요.</span></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="ss">원래 의미는 유지하되, 다른 단어나 표현을 사용하세요.</span></span>
<span id="cb21-7"><a href="#cb21-7"></a></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="ss">원래 질문: </span><span class="sc">{</span>query<span class="sc">}</span></span>
<span id="cb21-9"><a href="#cb21-9"></a></span>
<span id="cb21-10"><a href="#cb21-10"></a><span class="ss">변형 1:</span></span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="ss">변형 2:</span></span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="ss">변형 3:"""</span></span>
<span id="cb21-13"><a href="#cb21-13"></a></span>
<span id="cb21-14"><a href="#cb21-14"></a>    client <span class="op">=</span> anthropic.Anthropic(api_key<span class="op">=</span><span class="st">"your-api-key"</span>)</span>
<span id="cb21-15"><a href="#cb21-15"></a>    </span>
<span id="cb21-16"><a href="#cb21-16"></a>    message <span class="op">=</span> client.messages.create(</span>
<span id="cb21-17"><a href="#cb21-17"></a>        model<span class="op">=</span><span class="st">"claude-sonnet-4-20250514"</span>,</span>
<span id="cb21-18"><a href="#cb21-18"></a>        max_tokens<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb21-19"><a href="#cb21-19"></a>        temperature<span class="op">=</span><span class="fl">0.7</span>,</span>
<span id="cb21-20"><a href="#cb21-20"></a>        messages<span class="op">=</span>[{<span class="st">"role"</span>: <span class="st">"user"</span>, <span class="st">"content"</span>: prompt}]</span>
<span id="cb21-21"><a href="#cb21-21"></a>    )</span>
<span id="cb21-22"><a href="#cb21-22"></a>    </span>
<span id="cb21-23"><a href="#cb21-23"></a>    response <span class="op">=</span> message.content[<span class="dv">0</span>].text</span>
<span id="cb21-24"><a href="#cb21-24"></a>    </span>
<span id="cb21-25"><a href="#cb21-25"></a>    <span class="co"># 변형 파싱</span></span>
<span id="cb21-26"><a href="#cb21-26"></a>    variations <span class="op">=</span> [query]  <span class="co"># 원래 쿼리 포함</span></span>
<span id="cb21-27"><a href="#cb21-27"></a>    <span class="cf">for</span> line <span class="kw">in</span> response.split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb21-28"><a href="#cb21-28"></a>        line <span class="op">=</span> line.strip()</span>
<span id="cb21-29"><a href="#cb21-29"></a>        <span class="cf">if</span> line <span class="kw">and</span> <span class="kw">not</span> line.startswith(<span class="st">'변형'</span>):</span>
<span id="cb21-30"><a href="#cb21-30"></a>            variations.append(line)</span>
<span id="cb21-31"><a href="#cb21-31"></a>    </span>
<span id="cb21-32"><a href="#cb21-32"></a>    <span class="cf">return</span> variations[:<span class="dv">4</span>]  <span class="co"># 원본 + 3개 변형</span></span>
<span id="cb21-33"><a href="#cb21-33"></a></span>
<span id="cb21-34"><a href="#cb21-34"></a><span class="kw">def</span> search_with_expanded_query(</span>
<span id="cb21-35"><a href="#cb21-35"></a>    query: <span class="bu">str</span>, </span>
<span id="cb21-36"><a href="#cb21-36"></a>    rag: SimpleRAGSystem,</span>
<span id="cb21-37"><a href="#cb21-37"></a>    top_k_per_query: <span class="bu">int</span> <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb21-38"><a href="#cb21-38"></a>) <span class="op">-&gt;</span> List[Dict]:</span>
<span id="cb21-39"><a href="#cb21-39"></a>    <span class="co">"""</span></span>
<span id="cb21-40"><a href="#cb21-40"></a><span class="co">    확장된 쿼리들로 검색하고 결과 통합</span></span>
<span id="cb21-41"><a href="#cb21-41"></a><span class="co">    """</span></span>
<span id="cb21-42"><a href="#cb21-42"></a>    <span class="co"># 쿼리 확장</span></span>
<span id="cb21-43"><a href="#cb21-43"></a>    expanded_queries <span class="op">=</span> expand_query(query)</span>
<span id="cb21-44"><a href="#cb21-44"></a>    </span>
<span id="cb21-45"><a href="#cb21-45"></a>    <span class="bu">print</span>(<span class="ss">f"🔄 쿼리 확장:"</span>)</span>
<span id="cb21-46"><a href="#cb21-46"></a>    <span class="cf">for</span> i, q <span class="kw">in</span> <span class="bu">enumerate</span>(expanded_queries):</span>
<span id="cb21-47"><a href="#cb21-47"></a>        <span class="bu">print</span>(<span class="ss">f"  [</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">] </span><span class="sc">{</span>q<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-48"><a href="#cb21-48"></a>    </span>
<span id="cb21-49"><a href="#cb21-49"></a>    <span class="co"># 각 쿼리로 검색</span></span>
<span id="cb21-50"><a href="#cb21-50"></a>    all_results <span class="op">=</span> []</span>
<span id="cb21-51"><a href="#cb21-51"></a>    seen_ids <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb21-52"><a href="#cb21-52"></a>    </span>
<span id="cb21-53"><a href="#cb21-53"></a>    <span class="cf">for</span> q <span class="kw">in</span> expanded_queries:</span>
<span id="cb21-54"><a href="#cb21-54"></a>        results <span class="op">=</span> rag.retrieve(q, top_k<span class="op">=</span>top_k_per_query)</span>
<span id="cb21-55"><a href="#cb21-55"></a>        </span>
<span id="cb21-56"><a href="#cb21-56"></a>        <span class="cf">for</span> doc <span class="kw">in</span> results:</span>
<span id="cb21-57"><a href="#cb21-57"></a>            doc_id <span class="op">=</span> doc[<span class="st">'metadata'</span>].get(<span class="st">'chunk_id'</span>, doc[<span class="st">'text'</span>][:<span class="dv">50</span>])</span>
<span id="cb21-58"><a href="#cb21-58"></a>            </span>
<span id="cb21-59"><a href="#cb21-59"></a>            <span class="co"># 중복 제거</span></span>
<span id="cb21-60"><a href="#cb21-60"></a>            <span class="cf">if</span> doc_id <span class="kw">not</span> <span class="kw">in</span> seen_ids:</span>
<span id="cb21-61"><a href="#cb21-61"></a>                all_results.append(doc)</span>
<span id="cb21-62"><a href="#cb21-62"></a>                seen_ids.add(doc_id)</span>
<span id="cb21-63"><a href="#cb21-63"></a>    </span>
<span id="cb21-64"><a href="#cb21-64"></a>    <span class="co"># 재순위화 (선택적)</span></span>
<span id="cb21-65"><a href="#cb21-65"></a>    <span class="co"># ...</span></span>
<span id="cb21-66"><a href="#cb21-66"></a>    </span>
<span id="cb21-67"><a href="#cb21-67"></a>    <span class="cf">return</span> all_results</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="query-decomposition-쿼리-분해" class="level4" data-number="5.3.2">
<h4 data-number="5.3.2" class="anchored" data-anchor-id="query-decomposition-쿼리-분해"><span class="header-section-number">5.3.2</span> Query Decomposition (쿼리 분해)</h4>
<p>복잡한 질문을 하위 질문으로 나눈다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">def</span> decompose_query(query: <span class="bu">str</span>) <span class="op">-&gt;</span> List[<span class="bu">str</span>]:</span>
<span id="cb22-2"><a href="#cb22-2"></a>    <span class="co">"""</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="co">    복잡한 질문을 하위 질문들로 분해</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="co">    """</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>    prompt <span class="op">=</span> <span class="ss">f"""다음 복잡한 질문을 답하기 위해 필요한 하위 질문들로 분해하세요.</span></span>
<span id="cb22-6"><a href="#cb22-6"></a></span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="ss">질문: </span><span class="sc">{</span>query<span class="sc">}</span></span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="ss">하위 질문들 (각 줄에 하나씩):</span></span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="ss">1."""</span></span>
<span id="cb22-11"><a href="#cb22-11"></a></span>
<span id="cb22-12"><a href="#cb22-12"></a>    client <span class="op">=</span> anthropic.Anthropic(api_key<span class="op">=</span><span class="st">"your-api-key"</span>)</span>
<span id="cb22-13"><a href="#cb22-13"></a>    </span>
<span id="cb22-14"><a href="#cb22-14"></a>    message <span class="op">=</span> client.messages.create(</span>
<span id="cb22-15"><a href="#cb22-15"></a>        model<span class="op">=</span><span class="st">"claude-sonnet-4-20250514"</span>,</span>
<span id="cb22-16"><a href="#cb22-16"></a>        max_tokens<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb22-17"><a href="#cb22-17"></a>        temperature<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb22-18"><a href="#cb22-18"></a>        messages<span class="op">=</span>[{<span class="st">"role"</span>: <span class="st">"user"</span>, <span class="st">"content"</span>: prompt}]</span>
<span id="cb22-19"><a href="#cb22-19"></a>    )</span>
<span id="cb22-20"><a href="#cb22-20"></a>    </span>
<span id="cb22-21"><a href="#cb22-21"></a>    response <span class="op">=</span> message.content[<span class="dv">0</span>].text</span>
<span id="cb22-22"><a href="#cb22-22"></a>    </span>
<span id="cb22-23"><a href="#cb22-23"></a>    <span class="co"># 하위 질문 파싱</span></span>
<span id="cb22-24"><a href="#cb22-24"></a>    sub_queries <span class="op">=</span> []</span>
<span id="cb22-25"><a href="#cb22-25"></a>    <span class="cf">for</span> line <span class="kw">in</span> response.split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb22-26"><a href="#cb22-26"></a>        line <span class="op">=</span> line.strip()</span>
<span id="cb22-27"><a href="#cb22-27"></a>        <span class="co"># "1. " 같은 번호 제거</span></span>
<span id="cb22-28"><a href="#cb22-28"></a>        <span class="im">import</span> re</span>
<span id="cb22-29"><a href="#cb22-29"></a>        line <span class="op">=</span> re.sub(<span class="vs">r'^\d+\.\s*'</span>, <span class="st">''</span>, line)</span>
<span id="cb22-30"><a href="#cb22-30"></a>        </span>
<span id="cb22-31"><a href="#cb22-31"></a>        <span class="cf">if</span> line:</span>
<span id="cb22-32"><a href="#cb22-32"></a>            sub_queries.append(line)</span>
<span id="cb22-33"><a href="#cb22-33"></a>    </span>
<span id="cb22-34"><a href="#cb22-34"></a>    <span class="cf">return</span> sub_queries</span>
<span id="cb22-35"><a href="#cb22-35"></a></span>
<span id="cb22-36"><a href="#cb22-36"></a><span class="kw">def</span> answer_with_decomposition(</span>
<span id="cb22-37"><a href="#cb22-37"></a>    query: <span class="bu">str</span>, </span>
<span id="cb22-38"><a href="#cb22-38"></a>    rag: SimpleRAGSystem</span>
<span id="cb22-39"><a href="#cb22-39"></a>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb22-40"><a href="#cb22-40"></a>    <span class="co">"""</span></span>
<span id="cb22-41"><a href="#cb22-41"></a><span class="co">    쿼리 분해를 사용한 답변 생성</span></span>
<span id="cb22-42"><a href="#cb22-42"></a><span class="co">    """</span></span>
<span id="cb22-43"><a href="#cb22-43"></a>    <span class="bu">print</span>(<span class="ss">f"❓ 원래 질문: </span><span class="sc">{</span>query<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb22-44"><a href="#cb22-44"></a>    </span>
<span id="cb22-45"><a href="#cb22-45"></a>    <span class="co"># Step 1: 질문 분해</span></span>
<span id="cb22-46"><a href="#cb22-46"></a>    sub_queries <span class="op">=</span> decompose_query(query)</span>
<span id="cb22-47"><a href="#cb22-47"></a>    </span>
<span id="cb22-48"><a href="#cb22-48"></a>    <span class="bu">print</span>(<span class="ss">f"🔍 하위 질문들:"</span>)</span>
<span id="cb22-49"><a href="#cb22-49"></a>    <span class="cf">for</span> i, sq <span class="kw">in</span> <span class="bu">enumerate</span>(sub_queries, <span class="dv">1</span>):</span>
<span id="cb22-50"><a href="#cb22-50"></a>        <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">. </span><span class="sc">{</span>sq<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb22-51"><a href="#cb22-51"></a>    <span class="bu">print</span>()</span>
<span id="cb22-52"><a href="#cb22-52"></a>    </span>
<span id="cb22-53"><a href="#cb22-53"></a>    <span class="co"># Step 2: 각 하위 질문에 답변</span></span>
<span id="cb22-54"><a href="#cb22-54"></a>    sub_answers <span class="op">=</span> []</span>
<span id="cb22-55"><a href="#cb22-55"></a>    <span class="cf">for</span> i, sq <span class="kw">in</span> <span class="bu">enumerate</span>(sub_queries, <span class="dv">1</span>):</span>
<span id="cb22-56"><a href="#cb22-56"></a>        <span class="bu">print</span>(<span class="ss">f"📝 하위 질문 </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss"> 답변 중..."</span>)</span>
<span id="cb22-57"><a href="#cb22-57"></a>        result <span class="op">=</span> rag.query(sq, top_k<span class="op">=</span><span class="dv">3</span>, verbose<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb22-58"><a href="#cb22-58"></a>        sub_answers.append({</span>
<span id="cb22-59"><a href="#cb22-59"></a>            <span class="st">'question'</span>: sq,</span>
<span id="cb22-60"><a href="#cb22-60"></a>            <span class="st">'answer'</span>: result[<span class="st">'answer'</span>]</span>
<span id="cb22-61"><a href="#cb22-61"></a>        })</span>
<span id="cb22-62"><a href="#cb22-62"></a>    </span>
<span id="cb22-63"><a href="#cb22-63"></a>    <span class="co"># Step 3: 하위 답변들을 종합</span></span>
<span id="cb22-64"><a href="#cb22-64"></a>    synthesis_prompt <span class="op">=</span> <span class="ss">f"""다음은 복잡한 질문에 대한 하위 질문들과 그 답변들입니다.</span></span>
<span id="cb22-65"><a href="#cb22-65"></a><span class="ss">이를 종합하여 원래 질문에 대한 완전한 답변을 작성하세요.</span></span>
<span id="cb22-66"><a href="#cb22-66"></a></span>
<span id="cb22-67"><a href="#cb22-67"></a><span class="ss">원래 질문: </span><span class="sc">{</span>query<span class="sc">}</span></span>
<span id="cb22-68"><a href="#cb22-68"></a></span>
<span id="cb22-69"><a href="#cb22-69"></a><span class="ss">하위 질문과 답변:</span></span>
<span id="cb22-70"><a href="#cb22-70"></a><span class="ss">"""</span></span>
<span id="cb22-71"><a href="#cb22-71"></a>    </span>
<span id="cb22-72"><a href="#cb22-72"></a>    <span class="cf">for</span> i, sa <span class="kw">in</span> <span class="bu">enumerate</span>(sub_answers, <span class="dv">1</span>):</span>
<span id="cb22-73"><a href="#cb22-73"></a>        synthesis_prompt <span class="op">+=</span> <span class="ss">f"</span><span class="ch">\n</span><span class="ss">질문 </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>sa[<span class="st">'question'</span>]<span class="sc">}</span><span class="ch">\n</span><span class="ss">답변 </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>sa[<span class="st">'answer'</span>]<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb22-74"><a href="#cb22-74"></a>    </span>
<span id="cb22-75"><a href="#cb22-75"></a>    synthesis_prompt <span class="op">+=</span> <span class="st">"</span><span class="ch">\n</span><span class="st">종합 답변:"</span></span>
<span id="cb22-76"><a href="#cb22-76"></a>    </span>
<span id="cb22-77"><a href="#cb22-77"></a>    client <span class="op">=</span> anthropic.Anthropic(api_key<span class="op">=</span><span class="st">"your-api-key"</span>)</span>
<span id="cb22-78"><a href="#cb22-78"></a>    </span>
<span id="cb22-79"><a href="#cb22-79"></a>    message <span class="op">=</span> client.messages.create(</span>
<span id="cb22-80"><a href="#cb22-80"></a>        model<span class="op">=</span><span class="st">"claude-sonnet-4-20250514"</span>,</span>
<span id="cb22-81"><a href="#cb22-81"></a>        max_tokens<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb22-82"><a href="#cb22-82"></a>        temperature<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb22-83"><a href="#cb22-83"></a>        messages<span class="op">=</span>[{<span class="st">"role"</span>: <span class="st">"user"</span>, <span class="st">"content"</span>: synthesis_prompt}]</span>
<span id="cb22-84"><a href="#cb22-84"></a>    )</span>
<span id="cb22-85"><a href="#cb22-85"></a>    </span>
<span id="cb22-86"><a href="#cb22-86"></a>    final_answer <span class="op">=</span> message.content[<span class="dv">0</span>].text</span>
<span id="cb22-87"><a href="#cb22-87"></a>    </span>
<span id="cb22-88"><a href="#cb22-88"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">✅ 최종 답변:"</span>)</span>
<span id="cb22-89"><a href="#cb22-89"></a>    <span class="bu">print</span>(final_answer)</span>
<span id="cb22-90"><a href="#cb22-90"></a>    </span>
<span id="cb22-91"><a href="#cb22-91"></a>    <span class="cf">return</span> final_answer</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>사용 예시</strong>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a><span class="co"># 복잡한 질문</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>query <span class="op">=</span> <span class="st">"Anthropic은 어떤 회사이고, 주요 제품은 무엇이며, 최근 투자 현황은 어떤가?"</span></span>
<span id="cb23-3"><a href="#cb23-3"></a></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="co"># 쿼리 분해 방식으로 답변</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>answer <span class="op">=</span> answer_with_decomposition(query, rag)</span>
<span id="cb23-6"><a href="#cb23-6"></a></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="co"># 출력:</span></span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="co"># 하위 질문들:</span></span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="co">#   1. Anthropic은 어떤 회사인가?</span></span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="co">#   2. Anthropic의 주요 제품은 무엇인가?</span></span>
<span id="cb23-11"><a href="#cb23-11"></a><span class="co">#   3. Anthropic의 최근 투자 현황은?</span></span>
<span id="cb23-12"><a href="#cb23-12"></a><span class="co"># </span></span>
<span id="cb23-13"><a href="#cb23-13"></a><span class="co"># (각 하위 질문 답변 후)</span></span>
<span id="cb23-14"><a href="#cb23-14"></a><span class="co"># </span></span>
<span id="cb23-15"><a href="#cb23-15"></a><span class="co"># 최종 답변:</span></span>
<span id="cb23-16"><a href="#cb23-16"></a><span class="co"># Anthropic은 2021년에 설립된 AI 안전성 연구 회사입니다. </span></span>
<span id="cb23-17"><a href="#cb23-17"></a><span class="co"># 주요 제품은 Claude라는 대형 언어 모델 시리즈이며...</span></span>
<span id="cb23-18"><a href="#cb23-18"></a><span class="co"># 2023년 Amazon으로부터 40억 달러의 투자를 받았습니다.</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="hypothetical-document-embeddings-hyde" class="level4" data-number="5.3.3">
<h4 data-number="5.3.3" class="anchored" data-anchor-id="hypothetical-document-embeddings-hyde"><span class="header-section-number">5.3.3</span> Hypothetical Document Embeddings (HyDE)</h4>
<p>실제 답변을 가상으로 생성한 후, 그 답변과 유사한 문서를 검색한다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">def</span> hyde_search(query: <span class="bu">str</span>, rag: SimpleRAGSystem, top_k: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span>) <span class="op">-&gt;</span> List[Dict]:</span>
<span id="cb24-2"><a href="#cb24-2"></a>    <span class="co">"""</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="co">    HyDE (Hypothetical Document Embeddings) 검색</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="co">    </span></span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="co">    1. 질문에 대한 가상의 답변 생성</span></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="co">    2. 답변을 임베딩하여 검색</span></span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="co">    3. 유사한 실제 문서 반환</span></span>
<span id="cb24-8"><a href="#cb24-8"></a><span class="co">    """</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>    <span class="bu">print</span>(<span class="ss">f"❓ 질문: </span><span class="sc">{</span>query<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb24-10"><a href="#cb24-10"></a>    </span>
<span id="cb24-11"><a href="#cb24-11"></a>    <span class="co"># Step 1: 가상 답변 생성</span></span>
<span id="cb24-12"><a href="#cb24-12"></a>    hyde_prompt <span class="op">=</span> <span class="ss">f"""다음 질문에 대한 답변을 작성하세요.</span></span>
<span id="cb24-13"><a href="#cb24-13"></a><span class="ss">실제 정보를 모르더라도 합리적이고 구체적인 답변을 작성하세요.</span></span>
<span id="cb24-14"><a href="#cb24-14"></a></span>
<span id="cb24-15"><a href="#cb24-15"></a><span class="ss">질문: </span><span class="sc">{</span>query<span class="sc">}</span></span>
<span id="cb24-16"><a href="#cb24-16"></a></span>
<span id="cb24-17"><a href="#cb24-17"></a><span class="ss">답변:"""</span></span>
<span id="cb24-18"><a href="#cb24-18"></a>    </span>
<span id="cb24-19"><a href="#cb24-19"></a>    client <span class="op">=</span> anthropic.Anthropic(api_key<span class="op">=</span><span class="st">"your-api-key"</span>)</span>
<span id="cb24-20"><a href="#cb24-20"></a>    </span>
<span id="cb24-21"><a href="#cb24-21"></a>    message <span class="op">=</span> client.messages.create(</span>
<span id="cb24-22"><a href="#cb24-22"></a>        model<span class="op">=</span><span class="st">"claude-sonnet-4-20250514"</span>,</span>
<span id="cb24-23"><a href="#cb24-23"></a>        max_tokens<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb24-24"><a href="#cb24-24"></a>        temperature<span class="op">=</span><span class="fl">0.7</span>,</span>
<span id="cb24-25"><a href="#cb24-25"></a>        messages<span class="op">=</span>[{<span class="st">"role"</span>: <span class="st">"user"</span>, <span class="st">"content"</span>: hyde_prompt}]</span>
<span id="cb24-26"><a href="#cb24-26"></a>    )</span>
<span id="cb24-27"><a href="#cb24-27"></a>    </span>
<span id="cb24-28"><a href="#cb24-28"></a>    hypothetical_answer <span class="op">=</span> message.content[<span class="dv">0</span>].text</span>
<span id="cb24-29"><a href="#cb24-29"></a>    </span>
<span id="cb24-30"><a href="#cb24-30"></a>    <span class="bu">print</span>(<span class="ss">f"💭 가상 답변:"</span>)</span>
<span id="cb24-31"><a href="#cb24-31"></a>    <span class="bu">print</span>(hypothetical_answer[:<span class="dv">200</span>] <span class="op">+</span> <span class="st">"..."</span>)</span>
<span id="cb24-32"><a href="#cb24-32"></a>    <span class="bu">print</span>()</span>
<span id="cb24-33"><a href="#cb24-33"></a>    </span>
<span id="cb24-34"><a href="#cb24-34"></a>    <span class="co"># Step 2: 가상 답변으로 검색</span></span>
<span id="cb24-35"><a href="#cb24-35"></a>    <span class="co"># 원래 질문 대신 가상 답변을 임베딩하여 검색</span></span>
<span id="cb24-36"><a href="#cb24-36"></a>    <span class="bu">print</span>(<span class="ss">f"🔍 가상 답변 기반 검색 중..."</span>)</span>
<span id="cb24-37"><a href="#cb24-37"></a>    </span>
<span id="cb24-38"><a href="#cb24-38"></a>    <span class="co"># 가상 답변 임베딩</span></span>
<span id="cb24-39"><a href="#cb24-39"></a>    hypothetical_embedding <span class="op">=</span> rag.embed_texts([hypothetical_answer])[<span class="dv">0</span>]</span>
<span id="cb24-40"><a href="#cb24-40"></a>    </span>
<span id="cb24-41"><a href="#cb24-41"></a>    <span class="co"># Vector DB 검색</span></span>
<span id="cb24-42"><a href="#cb24-42"></a>    results <span class="op">=</span> rag.collection.query(</span>
<span id="cb24-43"><a href="#cb24-43"></a>        query_embeddings<span class="op">=</span>[hypothetical_embedding],</span>
<span id="cb24-44"><a href="#cb24-44"></a>        n_results<span class="op">=</span>top_k</span>
<span id="cb24-45"><a href="#cb24-45"></a>    )</span>
<span id="cb24-46"><a href="#cb24-46"></a>    </span>
<span id="cb24-47"><a href="#cb24-47"></a>    <span class="co"># 결과 포맷팅</span></span>
<span id="cb24-48"><a href="#cb24-48"></a>    documents <span class="op">=</span> []</span>
<span id="cb24-49"><a href="#cb24-49"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(results[<span class="st">'documents'</span>][<span class="dv">0</span>])):</span>
<span id="cb24-50"><a href="#cb24-50"></a>        documents.append({</span>
<span id="cb24-51"><a href="#cb24-51"></a>            <span class="st">'text'</span>: results[<span class="st">'documents'</span>][<span class="dv">0</span>][i],</span>
<span id="cb24-52"><a href="#cb24-52"></a>            <span class="st">'metadata'</span>: results[<span class="st">'metadatas'</span>][<span class="dv">0</span>][i],</span>
<span id="cb24-53"><a href="#cb24-53"></a>            <span class="st">'distance'</span>: results[<span class="st">'distances'</span>][<span class="dv">0</span>][i]</span>
<span id="cb24-54"><a href="#cb24-54"></a>        })</span>
<span id="cb24-55"><a href="#cb24-55"></a>    </span>
<span id="cb24-56"><a href="#cb24-56"></a>    <span class="bu">print</span>(<span class="ss">f"✅ </span><span class="sc">{</span><span class="bu">len</span>(documents)<span class="sc">}</span><span class="ss">개 문서 검색 완료</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb24-57"><a href="#cb24-57"></a>    </span>
<span id="cb24-58"><a href="#cb24-58"></a>    <span class="cf">return</span> documents</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>HyDE가 효과적인 경우</strong>: - ✅ 질문이 짧고 모호할 때 - ✅ 답변 형식이 예측 가능할 때 - ✅ 도메인 전문 용어가 많을 때</p>
<p><strong>주의사항</strong>: - ❌ 추가 LLM 호출로 인한 비용/지연 - ❌ 가상 답변이 잘못되면 검색도 실패</p>
</section>
</section>
</section>
<section id="긴-문서-처리-전략" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="긴-문서-처리-전략"><span class="header-section-number">6</span> 긴 문서 처리 전략</h2>
<section id="문제-단일-문서가-컨텍스트-길이를-초과" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="문제-단일-문서가-컨텍스트-길이를-초과"><span class="header-section-number">6.1</span> 문제: 단일 문서가 컨텍스트 길이를 초과</h3>
<p><strong>시나리오</strong>: 500페이지 PDF 보고서를 RAG에 추가</p>
<section id="parent-document-retriever" class="level4" data-number="6.1.1">
<h4 data-number="6.1.1" class="anchored" data-anchor-id="parent-document-retriever"><span class="header-section-number">6.1.1</span> Parent Document Retriever</h4>
<p>작은 청크로 검색하되, 전체 문서를 반환한다.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">class</span> ParentDocumentRetriever:</span>
<span id="cb25-2"><a href="#cb25-2"></a>    <span class="co">"""</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="co">    작은 청크로 검색, 부모 문서 전체 반환</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="co">    """</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>    </span>
<span id="cb25-6"><a href="#cb25-6"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb25-7"><a href="#cb25-7"></a>        <span class="va">self</span>.chunk_store <span class="op">=</span> {}  <span class="co"># chunk_id → chunk_text</span></span>
<span id="cb25-8"><a href="#cb25-8"></a>        <span class="va">self</span>.parent_store <span class="op">=</span> {}  <span class="co"># parent_id → full_document</span></span>
<span id="cb25-9"><a href="#cb25-9"></a>        <span class="va">self</span>.chunk_to_parent <span class="op">=</span> {}  <span class="co"># chunk_id → parent_id</span></span>
<span id="cb25-10"><a href="#cb25-10"></a>        <span class="va">self</span>.vector_store <span class="op">=</span> <span class="va">None</span></span>
<span id="cb25-11"><a href="#cb25-11"></a>    </span>
<span id="cb25-12"><a href="#cb25-12"></a>    <span class="kw">def</span> add_document(</span>
<span id="cb25-13"><a href="#cb25-13"></a>        <span class="va">self</span>, </span>
<span id="cb25-14"><a href="#cb25-14"></a>        document: <span class="bu">str</span>,</span>
<span id="cb25-15"><a href="#cb25-15"></a>        doc_id: <span class="bu">str</span>,</span>
<span id="cb25-16"><a href="#cb25-16"></a>        chunk_size: <span class="bu">int</span> <span class="op">=</span> <span class="dv">256</span></span>
<span id="cb25-17"><a href="#cb25-17"></a>    ):</span>
<span id="cb25-18"><a href="#cb25-18"></a>        <span class="co">"""</span></span>
<span id="cb25-19"><a href="#cb25-19"></a><span class="co">        문서를 청크로 나누고 인덱싱</span></span>
<span id="cb25-20"><a href="#cb25-20"></a><span class="co">        """</span></span>
<span id="cb25-21"><a href="#cb25-21"></a>        <span class="co"># 부모 문서 저장</span></span>
<span id="cb25-22"><a href="#cb25-22"></a>        <span class="va">self</span>.parent_store[doc_id] <span class="op">=</span> document</span>
<span id="cb25-23"><a href="#cb25-23"></a>        </span>
<span id="cb25-24"><a href="#cb25-24"></a>        <span class="co"># 청크 생성 (작은 크기)</span></span>
<span id="cb25-25"><a href="#cb25-25"></a>        chunks <span class="op">=</span> <span class="va">self</span>.chunk_text(document, chunk_size)</span>
<span id="cb25-26"><a href="#cb25-26"></a>        </span>
<span id="cb25-27"><a href="#cb25-27"></a>        <span class="co"># 각 청크 인덱싱</span></span>
<span id="cb25-28"><a href="#cb25-28"></a>        <span class="cf">for</span> i, chunk <span class="kw">in</span> <span class="bu">enumerate</span>(chunks):</span>
<span id="cb25-29"><a href="#cb25-29"></a>            chunk_id <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>doc_id<span class="sc">}</span><span class="ss">_chunk_</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb25-30"><a href="#cb25-30"></a>            </span>
<span id="cb25-31"><a href="#cb25-31"></a>            <span class="co"># 청크 저장</span></span>
<span id="cb25-32"><a href="#cb25-32"></a>            <span class="va">self</span>.chunk_store[chunk_id] <span class="op">=</span> chunk</span>
<span id="cb25-33"><a href="#cb25-33"></a>            </span>
<span id="cb25-34"><a href="#cb25-34"></a>            <span class="co"># 청크 → 부모 매핑</span></span>
<span id="cb25-35"><a href="#cb25-35"></a>            <span class="va">self</span>.chunk_to_parent[chunk_id] <span class="op">=</span> doc_id</span>
<span id="cb25-36"><a href="#cb25-36"></a>            </span>
<span id="cb25-37"><a href="#cb25-37"></a>            <span class="co"># 벡터 DB에 청크 인덱싱</span></span>
<span id="cb25-38"><a href="#cb25-38"></a>            <span class="va">self</span>._add_to_vector_db(chunk, chunk_id)</span>
<span id="cb25-39"><a href="#cb25-39"></a>    </span>
<span id="cb25-40"><a href="#cb25-40"></a>    <span class="kw">def</span> retrieve(<span class="va">self</span>, query: <span class="bu">str</span>, top_k: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span>) <span class="op">-&gt;</span> List[Dict]:</span>
<span id="cb25-41"><a href="#cb25-41"></a>        <span class="co">"""</span></span>
<span id="cb25-42"><a href="#cb25-42"></a><span class="co">        검색: 청크로 찾지만 부모 문서 반환</span></span>
<span id="cb25-43"><a href="#cb25-43"></a><span class="co">        """</span></span>
<span id="cb25-44"><a href="#cb25-44"></a>        <span class="co"># Step 1: 청크 레벨에서 검색</span></span>
<span id="cb25-45"><a href="#cb25-45"></a>        chunk_results <span class="op">=</span> <span class="va">self</span>._search_chunks(query, top_k<span class="op">=</span>top_k)</span>
<span id="cb25-46"><a href="#cb25-46"></a>        </span>
<span id="cb25-47"><a href="#cb25-47"></a>        <span class="co"># Step 2: 부모 문서 ID 추출</span></span>
<span id="cb25-48"><a href="#cb25-48"></a>        parent_ids <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb25-49"><a href="#cb25-49"></a>        <span class="cf">for</span> chunk_result <span class="kw">in</span> chunk_results:</span>
<span id="cb25-50"><a href="#cb25-50"></a>            chunk_id <span class="op">=</span> chunk_result[<span class="st">'chunk_id'</span>]</span>
<span id="cb25-51"><a href="#cb25-51"></a>            parent_id <span class="op">=</span> <span class="va">self</span>.chunk_to_parent.get(chunk_id)</span>
<span id="cb25-52"><a href="#cb25-52"></a>            <span class="cf">if</span> parent_id:</span>
<span id="cb25-53"><a href="#cb25-53"></a>                parent_ids.add(parent_id)</span>
<span id="cb25-54"><a href="#cb25-54"></a>        </span>
<span id="cb25-55"><a href="#cb25-55"></a>        <span class="co"># Step 3: 부모 문서 반환</span></span>
<span id="cb25-56"><a href="#cb25-56"></a>        parent_docs <span class="op">=</span> []</span>
<span id="cb25-57"><a href="#cb25-57"></a>        <span class="cf">for</span> parent_id <span class="kw">in</span> parent_ids:</span>
<span id="cb25-58"><a href="#cb25-58"></a>            parent_docs.append({</span>
<span id="cb25-59"><a href="#cb25-59"></a>                <span class="st">'id'</span>: parent_id,</span>
<span id="cb25-60"><a href="#cb25-60"></a>                <span class="st">'text'</span>: <span class="va">self</span>.parent_store[parent_id]</span>
<span id="cb25-61"><a href="#cb25-61"></a>            })</span>
<span id="cb25-62"><a href="#cb25-62"></a>        </span>
<span id="cb25-63"><a href="#cb25-63"></a>        <span class="cf">return</span> parent_docs</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>장점</strong>: - ✅ 검색 정확도 높음 (작은 청크) - ✅ 컨텍스트 풍부 (전체 문서)</p>
<p><strong>단점</strong>: - ❌ 전체 문서가 너무 크면 여전히 문제 - ❌ 관련 없는 부분도 포함될 수 있음</p>
</section>
<section id="summary-index" class="level4" data-number="6.1.2">
<h4 data-number="6.1.2" class="anchored" data-anchor-id="summary-index"><span class="header-section-number">6.1.2</span> Summary Index</h4>
<p>문서를 계층적으로 요약하고, 요약본으로 검색한다.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">class</span> SummaryIndexRAG:</span>
<span id="cb26-2"><a href="#cb26-2"></a>    <span class="co">"""</span></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="co">    문서 요약 기반 RAG</span></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="co">    """</span></span>
<span id="cb26-5"><a href="#cb26-5"></a>    </span>
<span id="cb26-6"><a href="#cb26-6"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb26-7"><a href="#cb26-7"></a>        <span class="va">self</span>.summaries <span class="op">=</span> {}  <span class="co"># doc_id → summary</span></span>
<span id="cb26-8"><a href="#cb26-8"></a>        <span class="va">self</span>.documents <span class="op">=</span> {}  <span class="co"># doc_id → full_document</span></span>
<span id="cb26-9"><a href="#cb26-9"></a>        <span class="va">self</span>.vector_store <span class="op">=</span> <span class="va">None</span></span>
<span id="cb26-10"><a href="#cb26-10"></a>    </span>
<span id="cb26-11"><a href="#cb26-11"></a>    <span class="kw">def</span> add_document(<span class="va">self</span>, document: <span class="bu">str</span>, doc_id: <span class="bu">str</span>):</span>
<span id="cb26-12"><a href="#cb26-12"></a>        <span class="co">"""</span></span>
<span id="cb26-13"><a href="#cb26-13"></a><span class="co">        문서와 요약본 모두 인덱싱</span></span>
<span id="cb26-14"><a href="#cb26-14"></a><span class="co">        """</span></span>
<span id="cb26-15"><a href="#cb26-15"></a>        <span class="co"># 원본 저장</span></span>
<span id="cb26-16"><a href="#cb26-16"></a>        <span class="va">self</span>.documents[doc_id] <span class="op">=</span> document</span>
<span id="cb26-17"><a href="#cb26-17"></a>        </span>
<span id="cb26-18"><a href="#cb26-18"></a>        <span class="co"># 요약 생성</span></span>
<span id="cb26-19"><a href="#cb26-19"></a>        summary <span class="op">=</span> <span class="va">self</span>._generate_summary(document)</span>
<span id="cb26-20"><a href="#cb26-20"></a>        <span class="va">self</span>.summaries[doc_id] <span class="op">=</span> summary</span>
<span id="cb26-21"><a href="#cb26-21"></a>        </span>
<span id="cb26-22"><a href="#cb26-22"></a>        <span class="co"># 요약본을 벡터 DB에 인덱싱</span></span>
<span id="cb26-23"><a href="#cb26-23"></a>        <span class="va">self</span>._index_summary(summary, doc_id)</span>
<span id="cb26-24"><a href="#cb26-24"></a>    </span>
<span id="cb26-25"><a href="#cb26-25"></a>    <span class="kw">def</span> _generate_summary(<span class="va">self</span>, document: <span class="bu">str</span>, max_length: <span class="bu">int</span> <span class="op">=</span> <span class="dv">500</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb26-26"><a href="#cb26-26"></a>        <span class="co">"""</span></span>
<span id="cb26-27"><a href="#cb26-27"></a><span class="co">        문서 요약 생성</span></span>
<span id="cb26-28"><a href="#cb26-28"></a><span class="co">        """</span></span>
<span id="cb26-29"><a href="#cb26-29"></a>        <span class="co"># 문서가 너무 길면 청크 단위로 요약 후 재요약</span></span>
<span id="cb26-30"><a href="#cb26-30"></a>        <span class="cf">if</span> <span class="bu">len</span>(document) <span class="op">&gt;</span> <span class="dv">10000</span>:</span>
<span id="cb26-31"><a href="#cb26-31"></a>            <span class="cf">return</span> <span class="va">self</span>._hierarchical_summary(document)</span>
<span id="cb26-32"><a href="#cb26-32"></a>        </span>
<span id="cb26-33"><a href="#cb26-33"></a>        <span class="co"># 단일 요약</span></span>
<span id="cb26-34"><a href="#cb26-34"></a>        prompt <span class="op">=</span> <span class="ss">f"""다음 문서를 </span><span class="sc">{</span>max_length<span class="sc">}</span><span class="ss">자 이내로 요약하세요.</span></span>
<span id="cb26-35"><a href="#cb26-35"></a><span class="ss">핵심 내용과 주요 주제를 포함하세요.</span></span>
<span id="cb26-36"><a href="#cb26-36"></a></span>
<span id="cb26-37"><a href="#cb26-37"></a><span class="ss">문서:</span></span>
<span id="cb26-38"><a href="#cb26-38"></a><span class="sc">{</span>document<span class="sc">}</span></span>
<span id="cb26-39"><a href="#cb26-39"></a></span>
<span id="cb26-40"><a href="#cb26-40"></a><span class="ss">요약:"""</span></span>
<span id="cb26-41"><a href="#cb26-41"></a>        </span>
<span id="cb26-42"><a href="#cb26-42"></a>        client <span class="op">=</span> anthropic.Anthropic(api_key<span class="op">=</span><span class="st">"your-api-key"</span>)</span>
<span id="cb26-43"><a href="#cb26-43"></a>        </span>
<span id="cb26-44"><a href="#cb26-44"></a>        message <span class="op">=</span> client.messages.create(</span>
<span id="cb26-45"><a href="#cb26-45"></a>            model<span class="op">=</span><span class="st">"claude-sonnet-4-20250514"</span>,</span>
<span id="cb26-46"><a href="#cb26-46"></a>            max_tokens<span class="op">=</span>max_length,</span>
<span id="cb26-47"><a href="#cb26-47"></a>            temperature<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb26-48"><a href="#cb26-48"></a>            messages<span class="op">=</span>[{<span class="st">"role"</span>: <span class="st">"user"</span>, <span class="st">"content"</span>: prompt}]</span>
<span id="cb26-49"><a href="#cb26-49"></a>        )</span>
<span id="cb26-50"><a href="#cb26-50"></a>        </span>
<span id="cb26-51"><a href="#cb26-51"></a>        <span class="cf">return</span> message.content[<span class="dv">0</span>].text</span>
<span id="cb26-52"><a href="#cb26-52"></a>    </span>
<span id="cb26-53"><a href="#cb26-53"></a>    <span class="kw">def</span> _hierarchical_summary(<span class="va">self</span>, document: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb26-54"><a href="#cb26-54"></a>        <span class="co">"""</span></span>
<span id="cb26-55"><a href="#cb26-55"></a><span class="co">        계층적 요약 (Map-Reduce 패턴)</span></span>
<span id="cb26-56"><a href="#cb26-56"></a><span class="co">        </span></span>
<span id="cb26-57"><a href="#cb26-57"></a><span class="co">        1. 문서를 청크로 나눔</span></span>
<span id="cb26-58"><a href="#cb26-58"></a><span class="co">        2. 각 청크 요약 (Map)</span></span>
<span id="cb26-59"><a href="#cb26-59"></a><span class="co">        3. 요약들을 결합하여 최종 요약 (Reduce)</span></span>
<span id="cb26-60"><a href="#cb26-60"></a><span class="co">        """</span></span>
<span id="cb26-61"><a href="#cb26-61"></a>        <span class="co"># Step 1: 청크 생성</span></span>
<span id="cb26-62"><a href="#cb26-62"></a>        chunks <span class="op">=</span> <span class="va">self</span>.chunk_text(document, chunk_size<span class="op">=</span><span class="dv">4000</span>)</span>
<span id="cb26-63"><a href="#cb26-63"></a>        </span>
<span id="cb26-64"><a href="#cb26-64"></a>        <span class="co"># Step 2: 각 청크 요약 (Map)</span></span>
<span id="cb26-65"><a href="#cb26-65"></a>        chunk_summaries <span class="op">=</span> []</span>
<span id="cb26-66"><a href="#cb26-66"></a>        <span class="cf">for</span> chunk <span class="kw">in</span> chunks:</span>
<span id="cb26-67"><a href="#cb26-67"></a>            summary <span class="op">=</span> <span class="va">self</span>._generate_summary(chunk, max_length<span class="op">=</span><span class="dv">300</span>)</span>
<span id="cb26-68"><a href="#cb26-68"></a>            chunk_summaries.append(summary)</span>
<span id="cb26-69"><a href="#cb26-69"></a>        </span>
<span id="cb26-70"><a href="#cb26-70"></a>        <span class="co"># Step 3: 요약들 결합 (Reduce)</span></span>
<span id="cb26-71"><a href="#cb26-71"></a>        combined <span class="op">=</span> <span class="st">"</span><span class="ch">\n\n</span><span class="st">"</span>.join(chunk_summaries)</span>
<span id="cb26-72"><a href="#cb26-72"></a>        final_summary <span class="op">=</span> <span class="va">self</span>._generate_summary(combined, max_length<span class="op">=</span><span class="dv">500</span>)</span>
<span id="cb26-73"><a href="#cb26-73"></a>        </span>
<span id="cb26-74"><a href="#cb26-74"></a>        <span class="cf">return</span> final_summary</span>
<span id="cb26-75"><a href="#cb26-75"></a>    </span>
<span id="cb26-76"><a href="#cb26-76"></a>    <span class="kw">def</span> retrieve(<span class="va">self</span>, query: <span class="bu">str</span>, top_k: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span>) <span class="op">-&gt;</span> List[Dict]:</span>
<span id="cb26-77"><a href="#cb26-77"></a>        <span class="co">"""</span></span>
<span id="cb26-78"><a href="#cb26-78"></a><span class="co">        2단계 검색:</span></span>
<span id="cb26-79"><a href="#cb26-79"></a><span class="co">        1. 요약본으로 관련 문서 찾기</span></span>
<span id="cb26-80"><a href="#cb26-80"></a><span class="co">        2. 원본 문서 반환</span></span>
<span id="cb26-81"><a href="#cb26-81"></a><span class="co">        """</span></span>
<span id="cb26-82"><a href="#cb26-82"></a>        <span class="co"># Step 1: 요약본으로 검색</span></span>
<span id="cb26-83"><a href="#cb26-83"></a>        summary_results <span class="op">=</span> <span class="va">self</span>._search_summaries(query, top_k<span class="op">=</span>top_k)</span>
<span id="cb26-84"><a href="#cb26-84"></a>        </span>
<span id="cb26-85"><a href="#cb26-85"></a>        <span class="co"># Step 2: 원본 문서 반환</span></span>
<span id="cb26-86"><a href="#cb26-86"></a>        full_docs <span class="op">=</span> []</span>
<span id="cb26-87"><a href="#cb26-87"></a>        <span class="cf">for</span> result <span class="kw">in</span> summary_results:</span>
<span id="cb26-88"><a href="#cb26-88"></a>            doc_id <span class="op">=</span> result[<span class="st">'doc_id'</span>]</span>
<span id="cb26-89"><a href="#cb26-89"></a>            full_docs.append({</span>
<span id="cb26-90"><a href="#cb26-90"></a>                <span class="st">'id'</span>: doc_id,</span>
<span id="cb26-91"><a href="#cb26-91"></a>                <span class="st">'text'</span>: <span class="va">self</span>.documents[doc_id],</span>
<span id="cb26-92"><a href="#cb26-92"></a>                <span class="st">'summary'</span>: <span class="va">self</span>.summaries[doc_id]</span>
<span id="cb26-93"><a href="#cb26-93"></a>            })</span>
<span id="cb26-94"><a href="#cb26-94"></a>        </span>
<span id="cb26-95"><a href="#cb26-95"></a>        <span class="cf">return</span> full_docs</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
</section>
<section id="실시간-업데이트-처리" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="실시간-업데이트-처리"><span class="header-section-number">7</span> 실시간 업데이트 처리</h2>
<section id="문제-지식베이스가-자주-변경됨" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="문제-지식베이스가-자주-변경됨"><span class="header-section-number">7.1</span> 문제: 지식베이스가 자주 변경됨</h3>
<p><strong>시나리오</strong>: 뉴스 기사, 제품 정보, 가격 등이 실시간으로 업데이트</p>
<section id="해결책-incremental-indexing" class="level4" data-number="7.1.1">
<h4 data-number="7.1.1" class="anchored" data-anchor-id="해결책-incremental-indexing"><span class="header-section-number">7.1.1</span> 해결책: Incremental Indexing</h4>
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">class</span> IncrementalRAG:</span>
<span id="cb27-2"><a href="#cb27-2"></a>    <span class="co">"""</span></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="co">    증분 인덱싱을 지원하는 RAG</span></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="co">    """</span></span>
<span id="cb27-5"><a href="#cb27-5"></a>    </span>
<span id="cb27-6"><a href="#cb27-6"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb27-7"><a href="#cb27-7"></a>        <span class="va">self</span>.vector_store <span class="op">=</span> <span class="va">None</span></span>
<span id="cb27-8"><a href="#cb27-8"></a>        <span class="va">self</span>.document_index <span class="op">=</span> {}  <span class="co"># doc_id → metadata</span></span>
<span id="cb27-9"><a href="#cb27-9"></a>    </span>
<span id="cb27-10"><a href="#cb27-10"></a>    <span class="kw">def</span> add_document(<span class="va">self</span>, document: Dict):</span>
<span id="cb27-11"><a href="#cb27-11"></a>        <span class="co">"""</span></span>
<span id="cb27-12"><a href="#cb27-12"></a><span class="co">        새 문서 추가</span></span>
<span id="cb27-13"><a href="#cb27-13"></a><span class="co">        """</span></span>
<span id="cb27-14"><a href="#cb27-14"></a>        doc_id <span class="op">=</span> document[<span class="st">'id'</span>]</span>
<span id="cb27-15"><a href="#cb27-15"></a>        </span>
<span id="cb27-16"><a href="#cb27-16"></a>        <span class="co"># 중복 체크</span></span>
<span id="cb27-17"><a href="#cb27-17"></a>        <span class="cf">if</span> doc_id <span class="kw">in</span> <span class="va">self</span>.document_index:</span>
<span id="cb27-18"><a href="#cb27-18"></a>            <span class="bu">print</span>(<span class="ss">f"⚠️  문서 </span><span class="sc">{</span>doc_id<span class="sc">}</span><span class="ss"> 이미 존재 - 업데이트 필요"</span>)</span>
<span id="cb27-19"><a href="#cb27-19"></a>            <span class="cf">return</span> <span class="va">self</span>.update_document(document)</span>
<span id="cb27-20"><a href="#cb27-20"></a>        </span>
<span id="cb27-21"><a href="#cb27-21"></a>        <span class="co"># 인덱싱</span></span>
<span id="cb27-22"><a href="#cb27-22"></a>        <span class="va">self</span>._index_document(document)</span>
<span id="cb27-23"><a href="#cb27-23"></a>        <span class="va">self</span>.document_index[doc_id] <span class="op">=</span> {</span>
<span id="cb27-24"><a href="#cb27-24"></a>            <span class="st">'timestamp'</span>: datetime.now(),</span>
<span id="cb27-25"><a href="#cb27-25"></a>            <span class="st">'version'</span>: <span class="dv">1</span></span>
<span id="cb27-26"><a href="#cb27-26"></a>        }</span>
<span id="cb27-27"><a href="#cb27-27"></a>        </span>
<span id="cb27-28"><a href="#cb27-28"></a>        <span class="bu">print</span>(<span class="ss">f"✅ 문서 </span><span class="sc">{</span>doc_id<span class="sc">}</span><span class="ss"> 추가 완료"</span>)</span>
<span id="cb27-29"><a href="#cb27-29"></a>    </span>
<span id="cb27-30"><a href="#cb27-30"></a>    <span class="kw">def</span> update_document(<span class="va">self</span>, document: Dict):</span>
<span id="cb27-31"><a href="#cb27-31"></a>        <span class="co">"""</span></span>
<span id="cb27-32"><a href="#cb27-32"></a><span class="co">        기존 문서 업데이트</span></span>
<span id="cb27-33"><a href="#cb27-33"></a><span class="co">        """</span></span>
<span id="cb27-34"><a href="#cb27-34"></a>        doc_id <span class="op">=</span> document[<span class="st">'id'</span>]</span>
<span id="cb27-35"><a href="#cb27-35"></a>        </span>
<span id="cb27-36"><a href="#cb27-36"></a>        <span class="co"># Step 1: 기존 문서 삭제</span></span>
<span id="cb27-37"><a href="#cb27-37"></a>        <span class="va">self</span>.delete_document(doc_id)</span>
<span id="cb27-38"><a href="#cb27-38"></a>        </span>
<span id="cb27-39"><a href="#cb27-39"></a>        <span class="co"># Step 2: 새 버전 추가</span></span>
<span id="cb27-40"><a href="#cb27-40"></a>        <span class="va">self</span>._index_document(document)</span>
<span id="cb27-41"><a href="#cb27-41"></a>        <span class="va">self</span>.document_index[doc_id] <span class="op">=</span> {</span>
<span id="cb27-42"><a href="#cb27-42"></a>            <span class="st">'timestamp'</span>: datetime.now(),</span>
<span id="cb27-43"><a href="#cb27-43"></a>            <span class="st">'version'</span>: <span class="va">self</span>.document_index[doc_id].get(<span class="st">'version'</span>, <span class="dv">0</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb27-44"><a href="#cb27-44"></a>        }</span>
<span id="cb27-45"><a href="#cb27-45"></a>        </span>
<span id="cb27-46"><a href="#cb27-46"></a>        <span class="bu">print</span>(<span class="ss">f"🔄 문서 </span><span class="sc">{</span>doc_id<span class="sc">}</span><span class="ss"> 업데이트 완료 (v</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>document_index[doc_id][<span class="st">'version'</span>]<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb27-47"><a href="#cb27-47"></a>    </span>
<span id="cb27-48"><a href="#cb27-48"></a>    <span class="kw">def</span> delete_document(<span class="va">self</span>, doc_id: <span class="bu">str</span>):</span>
<span id="cb27-49"><a href="#cb27-49"></a>        <span class="co">"""</span></span>
<span id="cb27-50"><a href="#cb27-50"></a><span class="co">        문서 삭제</span></span>
<span id="cb27-51"><a href="#cb27-51"></a><span class="co">        """</span></span>
<span id="cb27-52"><a href="#cb27-52"></a>        <span class="co"># Vector DB에서 제거</span></span>
<span id="cb27-53"><a href="#cb27-53"></a>        <span class="va">self</span>.vector_store.delete(ids<span class="op">=</span>[doc_id])</span>
<span id="cb27-54"><a href="#cb27-54"></a>        </span>
<span id="cb27-55"><a href="#cb27-55"></a>        <span class="co"># 인덱스에서 제거</span></span>
<span id="cb27-56"><a href="#cb27-56"></a>        <span class="cf">if</span> doc_id <span class="kw">in</span> <span class="va">self</span>.document_index:</span>
<span id="cb27-57"><a href="#cb27-57"></a>            <span class="kw">del</span> <span class="va">self</span>.document_index[doc_id]</span>
<span id="cb27-58"><a href="#cb27-58"></a>        </span>
<span id="cb27-59"><a href="#cb27-59"></a>        <span class="bu">print</span>(<span class="ss">f"🗑️  문서 </span><span class="sc">{</span>doc_id<span class="sc">}</span><span class="ss"> 삭제 완료"</span>)</span>
<span id="cb27-60"><a href="#cb27-60"></a>    </span>
<span id="cb27-61"><a href="#cb27-61"></a>    <span class="kw">def</span> get_document_info(<span class="va">self</span>, doc_id: <span class="bu">str</span>) <span class="op">-&gt;</span> Dict:</span>
<span id="cb27-62"><a href="#cb27-62"></a>        <span class="co">"""</span></span>
<span id="cb27-63"><a href="#cb27-63"></a><span class="co">        문서 메타데이터 조회</span></span>
<span id="cb27-64"><a href="#cb27-64"></a><span class="co">        """</span></span>
<span id="cb27-65"><a href="#cb27-65"></a>        <span class="cf">return</span> <span class="va">self</span>.document_index.get(doc_id)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>사용 예시</strong>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a>rag <span class="op">=</span> IncrementalRAG()</span>
<span id="cb28-2"><a href="#cb28-2"></a></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="co"># 초기 문서 추가</span></span>
<span id="cb28-4"><a href="#cb28-4"></a>rag.add_document({</span>
<span id="cb28-5"><a href="#cb28-5"></a>    <span class="st">'id'</span>: <span class="st">'product_123'</span>,</span>
<span id="cb28-6"><a href="#cb28-6"></a>    <span class="st">'text'</span>: <span class="st">'제품 가격: $99'</span>,</span>
<span id="cb28-7"><a href="#cb28-7"></a>    <span class="st">'metadata'</span>: {<span class="st">'category'</span>: <span class="st">'electronics'</span>}</span>
<span id="cb28-8"><a href="#cb28-8"></a>})</span>
<span id="cb28-9"><a href="#cb28-9"></a></span>
<span id="cb28-10"><a href="#cb28-10"></a><span class="co"># 나중에 가격 변경</span></span>
<span id="cb28-11"><a href="#cb28-11"></a>rag.update_document({</span>
<span id="cb28-12"><a href="#cb28-12"></a>    <span class="st">'id'</span>: <span class="st">'product_123'</span>,</span>
<span id="cb28-13"><a href="#cb28-13"></a>    <span class="st">'text'</span>: <span class="st">'제품 가격: $79 (할인)'</span>,</span>
<span id="cb28-14"><a href="#cb28-14"></a>    <span class="st">'metadata'</span>: {<span class="st">'category'</span>: <span class="st">'electronics'</span>}</span>
<span id="cb28-15"><a href="#cb28-15"></a>})</span>
<span id="cb28-16"><a href="#cb28-16"></a></span>
<span id="cb28-17"><a href="#cb28-17"></a><span class="co"># 문서 정보 확인</span></span>
<span id="cb28-18"><a href="#cb28-18"></a>info <span class="op">=</span> rag.get_document_info(<span class="st">'product_123'</span>)</span>
<span id="cb28-19"><a href="#cb28-19"></a><span class="bu">print</span>(<span class="ss">f"버전: </span><span class="sc">{</span>info[<span class="st">'version'</span>]<span class="sc">}</span><span class="ss">, 업데이트: </span><span class="sc">{</span>info[<span class="st">'timestamp'</span>]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>
</section>
</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>