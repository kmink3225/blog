<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="Tree of Thoughts (ToT)의 정의부터 실전 구현까지 체계적으로 설명한다. Yao et al.&nbsp;(2024) “Tree of Thoughts: Deliberate Problem Solving with Large Language Models” 연구를 바탕으로 트리 구조 탐색의 원리, 생각 분해(Thought Decomposition)와 생성(Thought Generation) 메커니즘, 평가 기반 경로 선택과 백트래킹(Backtracking) 전략, BFS/DFS 탐색 알고리즘을 분석한다. Game of 24, Creative Writing, Crosswords 등 벤치마크에서 CoT 대비 최대 18배 성능 향상(74% vs 4%) 결과를 제시하고, 수학 퍼즐, 창작 글쓰기, 코드 리팩토링 등 실무 예시와 Python 구현 코드(Anthropic Claude API 활용)를 통해 실전 활용 방법을 상세히 다룬다. 비용-성능 트레이드오프 분석(100배+ API 비용), 적용 시나리오별 권장사항, Simple ToT 패턴과 최신 모델에서의 실용성 평가를 제시한다.">

<title>Kwangmin Kim - Tree of Thoughts: 전략적 탐색과 백트래킹으로 복잡한 문제 해결하기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - Tree of Thoughts: 전략적 탐색과 백트래킹으로 복잡한 문제 해결하기">
<meta property="og:description" content="Tree of Thoughts (ToT)의 정의부터 실전 구현까지 체계적으로 설명한다. Yao et al.&nbsp;(2024) “Tree of Thoughts: Deliberate Problem Solving with Large Language Models” 연구를 바탕으로 트리 구조 탐색의 원리, 생각 분해(Thought Decomposition)와 생성(Thought Generation) 메커니즘, 평가 기반 경로 선택과 백트래킹(Backtracking) 전략, BFS/DFS 탐색 알고리즘을 분석한다. Game of 24, Creative Writing, Crosswords 등 벤치마크에서 CoT 대비 최대 18배 성능 향상(74% vs 4%) 결과를 제시하고, 수학 퍼즐, 창작 글쓰기, 코드 리팩토링 등 실무 예시와 Python 구현 코드(Anthropic Claude API 활용)를 통해 실전 활용 방법을 상세히 다룬다. 비용-성능 트레이드오프 분석(100배+ API 비용), 적용 시나리오별 권장사항, Simple ToT 패턴과 최신 모델에서의 실용성 평가를 제시한다.">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Kwangmin Kim - Tree of Thoughts: 전략적 탐색과 백트래킹으로 복잡한 문제 해결하기">
<meta name="twitter:description" content="Tree of Thoughts (ToT)의 정의부터 실전 구현까지 체계적으로 설명한다. Yao et al.&nbsp;(2024) “Tree of Thoughts: Deliberate Problem Solving with Large Language Models” 연구를 바탕으로 트리 구조 탐색의 원리, 생각 분해(Thought Decomposition)와 생성(Thought Generation) 메커니즘, 평가 기반 경로 선택과 백트래킹(Backtracking) 전략, BFS/DFS 탐색 알고리즘을 분석한다. Game of 24, Creative Writing, Crosswords 등 벤치마크에서 CoT 대비 최대 18배 성능 향상(74% vs 4%) 결과를 제시하고, 수학 퍼즐, 창작 글쓰기, 코드 리팩토링 등 실무 예시와 Python 구현 코드(Anthropic Claude API 활용)를 통해 실전 활용 방법을 상세히 다룬다. 비용-성능 트레이드오프 분석(100배+ API 비용), 적용 시나리오별 권장사항, Simple ToT 패턴과 최신 모델에서의 실용성 평가를 제시한다.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">Tree of Thoughts: 전략적 탐색과 백트래킹으로 복잡한 문제 해결하기</h1>
            <p class="subtitle lead">트리 구조 탐색과 평가 기반 경로 선택으로 복잡한 추론 문제를 해결하는 고급 프롬프팅 기법</p>
                  <div>
        <div class="description">
          <p>Tree of Thoughts (ToT)의 정의부터 실전 구현까지 체계적으로 설명한다. Yao et al.&nbsp;(2024) “Tree of Thoughts: Deliberate Problem Solving with Large Language Models” 연구를 바탕으로 트리 구조 탐색의 원리, 생각 분해(Thought Decomposition)와 생성(Thought Generation) 메커니즘, 평가 기반 경로 선택과 백트래킹(Backtracking) 전략, BFS/DFS 탐색 알고리즘을 분석한다. Game of 24, Creative Writing, Crosswords 등 벤치마크에서 CoT 대비 최대 18배 성능 향상(74% vs 4%) 결과를 제시하고, 수학 퍼즐, 창작 글쓰기, 코드 리팩토링 등 실무 예시와 Python 구현 코드(Anthropic Claude API 활용)를 통해 실전 활용 방법을 상세히 다룬다. 비용-성능 트레이드오프 분석(100배+ API 비용), 적용 시나리오별 권장사항, Simple ToT 패턴과 최신 모델에서의 실용성 평가를 제시한다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Prompt Engineering</div>
                <div class="quarto-category">LLM</div>
                <div class="quarto-category">AI</div>
                <div class="quarto-category">Agent</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2025년 02월 03일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#들어가며" id="toc-들어가며" class="nav-link active" data-scroll-target="#들어가며"><span class="header-section-number">1</span> 들어가며</a></li>
  <li><a href="#tree-of-thoughts란" id="toc-tree-of-thoughts란" class="nav-link" data-scroll-target="#tree-of-thoughts란"><span class="header-section-number">2</span> Tree of Thoughts란?</a>
  <ul class="collapse">
  <li><a href="#핵심-개념" id="toc-핵심-개념" class="nav-link" data-scroll-target="#핵심-개념"><span class="header-section-number">2.1</span> 핵심 개념</a></li>
  <li><a href="#chain-of-thought-vs-tree-of-thoughts" id="toc-chain-of-thought-vs-tree-of-thoughts" class="nav-link" data-scroll-target="#chain-of-thought-vs-tree-of-thoughts"><span class="header-section-number">2.2</span> Chain-of-Thought vs Tree of Thoughts</a></li>
  <li><a href="#기본-프로세스" id="toc-기본-프로세스" class="nav-link" data-scroll-target="#기본-프로세스"><span class="header-section-number">2.3</span> 기본 프로세스</a></li>
  </ul></li>
  <li><a href="#tot의-4단계-프로세스" id="toc-tot의-4단계-프로세스" class="nav-link" data-scroll-target="#tot의-4단계-프로세스"><span class="header-section-number">3</span> ToT의 4단계 프로세스</a>
  <ul class="collapse">
  <li><a href="#생각-분해-thought-decomposition" id="toc-생각-분해-thought-decomposition" class="nav-link" data-scroll-target="#생각-분해-thought-decomposition"><span class="header-section-number">3.1</span> 생각 분해 (Thought Decomposition)</a></li>
  <li><a href="#생각-생성-thought-generation" id="toc-생각-생성-thought-generation" class="nav-link" data-scroll-target="#생각-생성-thought-generation"><span class="header-section-number">3.2</span> 생각 생성 (Thought Generation)</a></li>
  <li><a href="#생각-평가-state-evaluation" id="toc-생각-평가-state-evaluation" class="nav-link" data-scroll-target="#생각-평가-state-evaluation"><span class="header-section-number">3.3</span> 생각 평가 (State Evaluation)</a></li>
  <li><a href="#탐색-알고리즘-search-algorithm" id="toc-탐색-알고리즘-search-algorithm" class="nav-link" data-scroll-target="#탐색-알고리즘-search-algorithm"><span class="header-section-number">3.4</span> 탐색 알고리즘 (Search Algorithm)</a></li>
  </ul></li>
  <li><a href="#실전-예제-game-of-24" id="toc-실전-예제-game-of-24" class="nav-link" data-scroll-target="#실전-예제-game-of-24"><span class="header-section-number">4</span> 실전 예제: Game of 24</a>
  <ul class="collapse">
  <li><a href="#문제-정의" id="toc-문제-정의" class="nav-link" data-scroll-target="#문제-정의"><span class="header-section-number">4.1</span> 문제 정의</a></li>
  <li><a href="#왜-어려운가" id="toc-왜-어려운가" class="nav-link" data-scroll-target="#왜-어려운가"><span class="header-section-number">4.2</span> 왜 어려운가?</a></li>
  <li><a href="#tot-구현" id="toc-tot-구현" class="nav-link" data-scroll-target="#tot-구현"><span class="header-section-number">4.3</span> ToT 구현</a></li>
  <li><a href="#실행-결과-예시" id="toc-실행-결과-예시" class="nav-link" data-scroll-target="#실행-결과-예시"><span class="header-section-number">4.4</span> 실행 결과 예시</a></li>
  </ul></li>
  <li><a href="#실험-결과-분석" id="toc-실험-결과-분석" class="nav-link" data-scroll-target="#실험-결과-분석"><span class="header-section-number">5</span> 실험 결과 분석</a>
  <ul class="collapse">
  <li><a href="#벤치마크-성능-비교" id="toc-벤치마크-성능-비교" class="nav-link" data-scroll-target="#벤치마크-성능-비교"><span class="header-section-number">5.1</span> 벤치마크 성능 비교</a></li>
  <li><a href="#game-of-24-결과" id="toc-game-of-24-결과" class="nav-link" data-scroll-target="#game-of-24-결과"><span class="header-section-number">5.2</span> Game of 24 결과</a></li>
  <li><a href="#오답-패턴-분석" id="toc-오답-패턴-분석" class="nav-link" data-scroll-target="#오답-패턴-분석"><span class="header-section-number">5.3</span> 오답 패턴 분석</a></li>
  <li><a href="#노드-방문-횟수-vs-성능" id="toc-노드-방문-횟수-vs-성능" class="nav-link" data-scroll-target="#노드-방문-횟수-vs-성능"><span class="header-section-number">5.4</span> 노드 방문 횟수 vs 성능</a></li>
  </ul></li>
  <li><a href="#creative-writing-실험" id="toc-creative-writing-실험" class="nav-link" data-scroll-target="#creative-writing-실험"><span class="header-section-number">6</span> Creative Writing 실험</a>
  <ul class="collapse">
  <li><a href="#태스크-정의" id="toc-태스크-정의" class="nav-link" data-scroll-target="#태스크-정의"><span class="header-section-number">6.1</span> 태스크 정의</a></li>
  <li><a href="#tot-적용" id="toc-tot-적용" class="nav-link" data-scroll-target="#tot-적용"><span class="header-section-number">6.2</span> ToT 적용</a></li>
  <li><a href="#결과-예시" id="toc-결과-예시" class="nav-link" data-scroll-target="#결과-예시"><span class="header-section-number">6.3</span> 결과 예시</a></li>
  <li><a href="#creative-writing-성능" id="toc-creative-writing-성능" class="nav-link" data-scroll-target="#creative-writing-성능"><span class="header-section-number">6.4</span> Creative Writing 성능</a></li>
  </ul></li>
  <li><a href="#한계점-및-비용-분석" id="toc-한계점-및-비용-분석" class="nav-link" data-scroll-target="#한계점-및-비용-분석"><span class="header-section-number">7</span> 한계점 및 비용 분석</a>
  <ul class="collapse">
  <li><a href="#연산-비용" id="toc-연산-비용" class="nav-link" data-scroll-target="#연산-비용"><span class="header-section-number">7.1</span> 연산 비용</a></li>
  <li><a href="#시간-지연" id="toc-시간-지연" class="nav-link" data-scroll-target="#시간-지연"><span class="header-section-number">7.2</span> 시간 지연</a></li>
  <li><a href="#적용-범위의-제한" id="toc-적용-범위의-제한" class="nav-link" data-scroll-target="#적용-범위의-제한"><span class="header-section-number">7.3</span> 적용 범위의 제한</a></li>
  <li><a href="#gpt-4o의-성능-향상" id="toc-gpt-4o의-성능-향상" class="nav-link" data-scroll-target="#gpt-4o의-성능-향상"><span class="header-section-number">7.4</span> GPT-4/o의 성능 향상</a></li>
  </ul></li>
  <li><a href="#tree-of-thought-prompting-단순화-버전" id="toc-tree-of-thought-prompting-단순화-버전" class="nav-link" data-scroll-target="#tree-of-thought-prompting-단순화-버전"><span class="header-section-number">8</span> Tree-of-Thought-Prompting (단순화 버전)</a>
  <ul class="collapse">
  <li><a href="#기본-패턴" id="toc-기본-패턴" class="nav-link" data-scroll-target="#기본-패턴"><span class="header-section-number">8.1</span> 기본 패턴</a></li>
  <li><a href="#고급-패턴-1-협업-전문가" id="toc-고급-패턴-1-협업-전문가" class="nav-link" data-scroll-target="#고급-패턴-1-협업-전문가"><span class="header-section-number">8.2</span> 고급 패턴 1: 협업 전문가</a></li>
  <li><a href="#고급-패턴-2-동료-평가" id="toc-고급-패턴-2-동료-평가" class="nav-link" data-scroll-target="#고급-패턴-2-동료-평가"><span class="header-section-number">8.3</span> 고급 패턴 2: 동료 평가</a></li>
  </ul></li>
  <li><a href="#다른-기법과의-비교" id="toc-다른-기법과의-비교" class="nav-link" data-scroll-target="#다른-기법과의-비교"><span class="header-section-number">9</span> 다른 기법과의 비교</a>
  <ul class="collapse">
  <li><a href="#tot-vs-cot" id="toc-tot-vs-cot" class="nav-link" data-scroll-target="#tot-vs-cot"><span class="header-section-number">9.1</span> ToT vs CoT</a></li>
  <li><a href="#tot-vs-self-consistency" id="toc-tot-vs-self-consistency" class="nav-link" data-scroll-target="#tot-vs-self-consistency"><span class="header-section-number">9.2</span> ToT vs Self-Consistency</a></li>
  <li><a href="#tot-vs-rag" id="toc-tot-vs-rag" class="nav-link" data-scroll-target="#tot-vs-rag"><span class="header-section-number">9.3</span> ToT vs RAG</a></li>
  </ul></li>
  <li><a href="#실무-적용-시나리오-현실적-평가" id="toc-실무-적용-시나리오-현실적-평가" class="nav-link" data-scroll-target="#실무-적용-시나리오-현실적-평가"><span class="header-section-number">10</span> 실무 적용 시나리오 (현실적 평가)</a>
  <ul class="collapse">
  <li><a href="#코드-리팩토링" id="toc-코드-리팩토링" class="nav-link" data-scroll-target="#코드-리팩토링"><span class="header-section-number">10.1</span> 코드 리팩토링</a></li>
  <li><a href="#창작-지원-도구" id="toc-창작-지원-도구" class="nav-link" data-scroll-target="#창작-지원-도구"><span class="header-section-number">10.2</span> 창작 지원 도구</a></li>
  </ul></li>
  <li><a href="#정리-및-결론" id="toc-정리-및-결론" class="nav-link" data-scroll-target="#정리-및-결론"><span class="header-section-number">11</span> 정리 및 결론</a>
  <ul class="collapse">
  <li><a href="#핵심-요약" id="toc-핵심-요약" class="nav-link" data-scroll-target="#핵심-요약"><span class="header-section-number">11.1</span> 핵심 요약</a></li>
  <li><a href="#언제-tot를-사용할-것인가" id="toc-언제-tot를-사용할-것인가" class="nav-link" data-scroll-target="#언제-tot를-사용할-것인가"><span class="header-section-number">11.2</span> 언제 ToT를 사용할 것인가?</a></li>
  <li><a href="#미래-전망" id="toc-미래-전망" class="nav-link" data-scroll-target="#미래-전망"><span class="header-section-number">11.3</span> 미래 전망</a></li>
  </ul></li>
  <li><a href="#참고문헌" id="toc-참고문헌" class="nav-link" data-scroll-target="#참고문헌"><span class="header-section-number">12</span> 참고문헌</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="들어가며" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="들어가며"><span class="header-section-number">1</span> 들어가며</h2>
<p>Chain-of-Thought (CoT) 프롬프팅은 모델이 단계별로 추론하도록 유도하여 복잡한 문제 해결 능력을 크게 향상시켰다. 하지만 CoT에는 근본적인 한계가 있다: <strong>한번 선택한 추론 경로를 되돌릴 수 없다는 것이다.</strong></p>
<p>예를 들어, 수학 문제를 풀다가 중간에 잘못된 접근을 선택했다면? CoT는 그대로 진행하여 틀린 답에 도달한다. 하지만 사람은 어떻게 하는가? 막다른 골목에 다다르면 뒤로 돌아가서(backtrack) 다른 경로를 시도한다.</p>
<p><strong>Tree of Thoughts (ToT)</strong>는 바로 이러한 인간의 문제 해결 방식을 모델링한 기법이다. 여러 추론 경로를 트리 구조로 탐색하고, 각 경로를 평가하며, 필요시 되돌아가서 더 나은 경로를 찾는다.</p>
<p>이번 포스트에서는 Yao et al.&nbsp;(2024)의 연구를 중심으로 ToT의 원리, 실험 결과, 그리고 실무 적용 가능성을 상세히 분석한다.</p>
</section>
<section id="tree-of-thoughts란" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="tree-of-thoughts란"><span class="header-section-number">2</span> Tree of Thoughts란?</h2>
<section id="핵심-개념" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="핵심-개념"><span class="header-section-number">2.1</span> 핵심 개념</h3>
<p><strong>Tree of Thoughts (ToT)</strong>는 언어 모델이 문제를 해결할 때 여러 가능한 추론 경로를 <strong>트리 구조</strong>로 탐색하는 프레임워크다.</p>
<p><strong>주요 특징</strong>: - <strong>트리 구조</strong>: 각 노드는 “생각(thought)”을 나타냄 - <strong>백트래킹</strong>: 막다른 골목에서 되돌아가기 가능 - <strong>평가 기반</strong>: 각 생각을 평가하여 최선의 경로 선택 - <strong>전략적 탐색</strong>: BFS, DFS 등 탐색 알고리즘 활용</p>
</section>
<section id="chain-of-thought-vs-tree-of-thoughts" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="chain-of-thought-vs-tree-of-thoughts"><span class="header-section-number">2.2</span> Chain-of-Thought vs Tree of Thoughts</h3>
<p>시각적으로 비교하면 차이가 명확하다:</p>
<p><strong>Chain-of-Thought (선형 탐색)</strong>:</p>
<pre><code>Input → Thought 1 → Thought 2 → Thought 3 → Output
           ↓           ↓           ↓
        (고정됨)     (고정됨)     (고정됨)</code></pre>
<p><strong>Tree of Thoughts (트리 탐색)</strong>:</p>
<pre><code>                      Input
                        ↓
              ┌────────────────────┼───────┐
           Thought 1a              1b      1c
              ↓                    ↓       ↓
         ┌────┼────┐               │   (평가: 낮음, 제거)
       2a    2b   2c               2d
        ↓     ↓    ↓               ↓
     (평가) (평가) (선택)(백트래킹)</code></pre>
</section>
<section id="기본-프로세스" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="기본-프로세스"><span class="header-section-number">2.3</span> 기본 프로세스</h3>
<ol type="1">
<li><strong>생각 분해 (Thought Decomposition)</strong>: 문제를 중간 단계로 나눔</li>
<li><strong>생각 생성 (Thought Generation)</strong>: 각 단계에서 여러 후보 생각 생성</li>
<li><strong>생각 평가 (State Evaluation)</strong>: 각 생각의 품질 평가</li>
<li><strong>탐색 알고리즘 (Search Algorithm)</strong>: 최적 경로 탐색 (BFS, DFS 등)</li>
</ol>
</section>
</section>
<section id="tot의-4단계-프로세스" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="tot의-4단계-프로세스"><span class="header-section-number">3</span> ToT의 4단계 프로세스</h2>
<p>Yao et al.&nbsp;(2024)의 논문에 따르면, ToT는 다음 4단계로 구성된다.</p>
<section id="생각-분해-thought-decomposition" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="생각-분해-thought-decomposition"><span class="header-section-number">3.1</span> 생각 분해 (Thought Decomposition)</h3>
<p><strong>목적</strong>: 문제를 어떤 중간 단계로 나눌 것인가를 정의한다.</p>
<p><strong>핵심 질문</strong>: - 각 “생각”은 무엇을 나타내는가? - 몇 단계로 나눌 것인가? - 각 단계는 얼마나 구체적이어야 하는가?</p>
<p><strong>예시: Game of 24</strong></p>
<p>문제: 네 개의 숫자 (4, 9, 10, 13)로 24를 만들 수 있는가?</p>
<pre><code>생각 분해:
- 각 "생각" = 하나의 중간 수식
- 단계 수 = 3 (네 개 숫자를 24로 만들려면 세 번의 연산 필요)

예시 생각:
- "13 - 9 = 4"  (남은 숫자: 4, 4, 10)
- "4 * 10 = 40" (남은 숫자: 4, 40)
- "40 - 4 = 36" (최종: 36) ← 24가 아니므로 실패</code></pre>
<p><strong>예시: Creative Writing</strong></p>
<p>문제: 4개의 무작위 문장으로 연결된 에세이 작성</p>
<pre><code>생각 분해:
- 각 "생각" = 한 문단의 작성 계획
- 단계 수 = 1 (전체 에세이 계획을 한 번에)

예시 생각:
- "첫 문장으로 도입 → 두 번째 문장으로 전개 → ..."
- "시간 순서로 배열: 과거 → 현재 → 미래"
- "대조 구조: 문제 제기 → 해결책 제시"</code></pre>
<p><strong>중요한 점</strong>: 생각의 “입도(granularity)”는 문제에 따라 다르다. - 너무 작으면: 탐색 공간이 폭발적으로 증가 - 너무 크면: 유연성 부족, CoT와 차이 없음</p>
</section>
<section id="생각-생성-thought-generation" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="생각-생성-thought-generation"><span class="header-section-number">3.2</span> 생각 생성 (Thought Generation)</h3>
<p><strong>목적</strong>: 각 단계에서 가능한 여러 생각 후보를 생성한다.</p>
<p><strong>두 가지 방법</strong>:</p>
<section id="sample-샘플링" class="level4" data-number="3.2.1">
<h4 data-number="3.2.1" class="anchored" data-anchor-id="sample-샘플링"><span class="header-section-number">3.2.1</span> Sample (샘플링)</h4>
<p>독립적으로 여러 생각을 샘플링한다 (i.i.d.).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>prompt <span class="op">=</span> <span class="ss">f"""</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ss">Possible next steps for the equation:</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="ss">Current state: </span><span class="sc">{</span>current_state<span class="sc">}</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="ss">Generate a next step.</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="ss">"""</span></span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co"># temperature &gt; 0으로 설정하여 다양한 생각 생성</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>thoughts <span class="op">=</span> []</span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(k):  <span class="co"># k개 생성</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>    thought <span class="op">=</span> model.generate(prompt, temperature<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb5-11"><a href="#cb5-11"></a>    thoughts.append(thought)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>장점</strong>: 생각의 다양성 확보 <strong>단점</strong>: 중복 가능성</p>
</section>
<section id="propose-제안" class="level4" data-number="3.2.2">
<h4 data-number="3.2.2" class="anchored" data-anchor-id="propose-제안"><span class="header-section-number">3.2.2</span> Propose (제안)</h4>
<p>한 번에 여러 생각을 제안하도록 요청한다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>prompt <span class="op">=</span> <span class="ss">f"""</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ss">Current state: </span><span class="sc">{</span>current_state<span class="sc">}</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="ss">Propose 3 possible next steps:</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ss">1.</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="ss">2.</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="ss">3.</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="ss">"""</span></span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a>response <span class="op">=</span> model.generate(prompt, temperature<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-10"><a href="#cb6-10"></a>thoughts <span class="op">=</span> parse_numbered_list(response)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>장점</strong>: 중복 방지, 다양성과 관련성의 균형 <strong>단점</strong>: 프롬프트 복잡도 증가</p>
</section>
</section>
<section id="생각-평가-state-evaluation" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="생각-평가-state-evaluation"><span class="header-section-number">3.3</span> 생각 평가 (State Evaluation)</h3>
<p><strong>목적</strong>: 각 생각이 문제 해결에 얼마나 유망한지 평가한다.</p>
<p><strong>두 가지 방법</strong>:</p>
<section id="value-가치-평가" class="level4" data-number="3.3.1">
<h4 data-number="3.3.1" class="anchored" data-anchor-id="value-가치-평가"><span class="header-section-number">3.3.1</span> Value (가치 평가)</h4>
<p>각 생각에 점수를 부여한다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>prompt <span class="op">=</span> <span class="ss">f"""</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="ss">Evaluate if the following equation is likely to reach 24:</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="ss">Equation: </span><span class="sc">{</span>equation<span class="sc">}</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="ss">Remaining numbers: </span><span class="sc">{</span>remaining<span class="sc">}</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="ss">Rate on a scale:</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="ss">- sure/likely: This will definitely/probably reach 24</span></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="ss">- maybe: Uncertain</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="ss">- impossible: This cannot reach 24</span></span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="ss">Your evaluation:</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="ss">"""</span></span>
<span id="cb7-13"><a href="#cb7-13"></a></span>
<span id="cb7-14"><a href="#cb7-14"></a>evaluation <span class="op">=</span> model.generate(prompt)</span>
<span id="cb7-15"><a href="#cb7-15"></a>score <span class="op">=</span> parse_evaluation(evaluation)  <span class="co"># sure=1.0, likely=0.75, maybe=0.5, impossible=0.0</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>장점</strong>: 세밀한 비교 가능 <strong>단점</strong>: 평가 자체가 어려울 수 있음</p>
</section>
<section id="vote-투표" class="level4" data-number="3.3.2">
<h4 data-number="3.3.2" class="anchored" data-anchor-id="vote-투표"><span class="header-section-number">3.3.2</span> Vote (투표)</h4>
<p>여러 평가를 생성하고 다수결로 결정한다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>votes <span class="op">=</span> []</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_votes):</span>
<span id="cb8-3"><a href="#cb8-3"></a>    evaluation <span class="op">=</span> model.generate(evaluation_prompt)</span>
<span id="cb8-4"><a href="#cb8-4"></a>    votes.append(evaluation)</span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="co"># 다수결</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="im">from</span> collections <span class="im">import</span> Counter</span>
<span id="cb8-8"><a href="#cb8-8"></a>final_evaluation <span class="op">=</span> Counter(votes).most_common(<span class="dv">1</span>)[<span class="dv">0</span>][<span class="dv">0</span>]</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>장점</strong>: 더 안정적인 평가 <strong>단점</strong>: 비용 증가 (여러 번 평가)</p>
</section>
</section>
<section id="탐색-알고리즘-search-algorithm" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="탐색-알고리즘-search-algorithm"><span class="header-section-number">3.4</span> 탐색 알고리즘 (Search Algorithm)</h3>
<p><strong>목적</strong>: 어떤 순서로 트리를 탐색할 것인가를 결정한다.</p>
<section id="bfs-breadth-first-search-너비-우선-탐색" class="level4" data-number="3.4.1">
<h4 data-number="3.4.1" class="anchored" data-anchor-id="bfs-breadth-first-search-너비-우선-탐색"><span class="header-section-number">3.4.1</span> BFS (Breadth-First Search, 너비 우선 탐색)</h4>
<p><strong>전략</strong>: 각 단계에서 가장 유망한 b개의 생각을 유지한다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">def</span> bfs_search(initial_state, b<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb9-2"><a href="#cb9-2"></a>    <span class="co">"""</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="co">    b: beam width (각 단계에서 유지할 생각의 개수)</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co">    """</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>    states <span class="op">=</span> [initial_state]</span>
<span id="cb9-6"><a href="#cb9-6"></a>    </span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="cf">for</span> step <span class="kw">in</span> <span class="bu">range</span>(max_steps):</span>
<span id="cb9-8"><a href="#cb9-8"></a>        all_new_states <span class="op">=</span> []</span>
<span id="cb9-9"><a href="#cb9-9"></a>        </span>
<span id="cb9-10"><a href="#cb9-10"></a>        <span class="co"># 각 현재 상태에서 새로운 생각 생성</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>        <span class="cf">for</span> state <span class="kw">in</span> states:</span>
<span id="cb9-12"><a href="#cb9-12"></a>            new_thoughts <span class="op">=</span> generate_thoughts(state, k<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb9-13"><a href="#cb9-13"></a>            <span class="cf">for</span> thought <span class="kw">in</span> new_thoughts:</span>
<span id="cb9-14"><a href="#cb9-14"></a>                new_state <span class="op">=</span> apply_thought(state, thought)</span>
<span id="cb9-15"><a href="#cb9-15"></a>                score <span class="op">=</span> evaluate_state(new_state)</span>
<span id="cb9-16"><a href="#cb9-16"></a>                all_new_states.append((new_state, score))</span>
<span id="cb9-17"><a href="#cb9-17"></a>        </span>
<span id="cb9-18"><a href="#cb9-18"></a>        <span class="co"># 상위 b개만 유지</span></span>
<span id="cb9-19"><a href="#cb9-19"></a>        all_new_states.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-20"><a href="#cb9-20"></a>        states <span class="op">=</span> [s <span class="cf">for</span> s, _ <span class="kw">in</span> all_new_states[:b]]</span>
<span id="cb9-21"><a href="#cb9-21"></a>        </span>
<span id="cb9-22"><a href="#cb9-22"></a>        <span class="co"># 종료 조건 확인</span></span>
<span id="cb9-23"><a href="#cb9-23"></a>        <span class="cf">for</span> state <span class="kw">in</span> states:</span>
<span id="cb9-24"><a href="#cb9-24"></a>            <span class="cf">if</span> is_goal(state):</span>
<span id="cb9-25"><a href="#cb9-25"></a>                <span class="cf">return</span> state</span>
<span id="cb9-26"><a href="#cb9-26"></a>    </span>
<span id="cb9-27"><a href="#cb9-27"></a>    <span class="cf">return</span> <span class="va">None</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>특징</strong>: - 최적해를 놓칠 확률 낮음 - 메모리 사용량 많음 - “체계적 탐색”에 적합</p>
</section>
<section id="dfs-depth-first-search-깊이-우선-탐색" class="level4" data-number="3.4.2">
<h4 data-number="3.4.2" class="anchored" data-anchor-id="dfs-depth-first-search-깊이-우선-탐색"><span class="header-section-number">3.4.2</span> DFS (Depth-First Search, 깊이 우선 탐색)</h4>
<p><strong>전략</strong>: 하나의 경로를 끝까지 탐색한 후 백트래킹한다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">def</span> dfs_search(initial_state, max_depth<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="co">"""</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="co">    깊이 우선 탐색 + 백트래킹</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co">    """</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="kw">def</span> dfs(state, depth):</span>
<span id="cb10-6"><a href="#cb10-6"></a>        <span class="co"># 종료 조건</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>        <span class="cf">if</span> is_goal(state):</span>
<span id="cb10-8"><a href="#cb10-8"></a>            <span class="cf">return</span> state</span>
<span id="cb10-9"><a href="#cb10-9"></a>        </span>
<span id="cb10-10"><a href="#cb10-10"></a>        <span class="cf">if</span> depth <span class="op">&gt;=</span> max_depth:</span>
<span id="cb10-11"><a href="#cb10-11"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb10-12"><a href="#cb10-12"></a>        </span>
<span id="cb10-13"><a href="#cb10-13"></a>        <span class="co"># 새로운 생각 생성 및 평가</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>        thoughts <span class="op">=</span> generate_thoughts(state, k<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb10-15"><a href="#cb10-15"></a>        evaluated <span class="op">=</span> [(t, evaluate_thought(state, t)) <span class="cf">for</span> t <span class="kw">in</span> thoughts]</span>
<span id="cb10-16"><a href="#cb10-16"></a>        </span>
<span id="cb10-17"><a href="#cb10-17"></a>        <span class="co"># 가장 유망한 것부터 시도 (휴리스틱)</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>        evaluated.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-19"><a href="#cb10-19"></a>        </span>
<span id="cb10-20"><a href="#cb10-20"></a>        <span class="cf">for</span> thought, score <span class="kw">in</span> evaluated:</span>
<span id="cb10-21"><a href="#cb10-21"></a>            <span class="co"># 명백히 불가능한 경로는 가지치기</span></span>
<span id="cb10-22"><a href="#cb10-22"></a>            <span class="cf">if</span> score <span class="op">==</span> <span class="fl">0.0</span>:  <span class="co"># "impossible"</span></span>
<span id="cb10-23"><a href="#cb10-23"></a>                <span class="cf">continue</span></span>
<span id="cb10-24"><a href="#cb10-24"></a>            </span>
<span id="cb10-25"><a href="#cb10-25"></a>            new_state <span class="op">=</span> apply_thought(state, thought)</span>
<span id="cb10-26"><a href="#cb10-26"></a>            result <span class="op">=</span> dfs(new_state, depth <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb10-27"><a href="#cb10-27"></a>            </span>
<span id="cb10-28"><a href="#cb10-28"></a>            <span class="cf">if</span> result <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb10-29"><a href="#cb10-29"></a>                <span class="cf">return</span> result  <span class="co"># 성공</span></span>
<span id="cb10-30"><a href="#cb10-30"></a>        </span>
<span id="cb10-31"><a href="#cb10-31"></a>        <span class="co"># 모든 경로 실패 → 백트래킹</span></span>
<span id="cb10-32"><a href="#cb10-32"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb10-33"><a href="#cb10-33"></a>    </span>
<span id="cb10-34"><a href="#cb10-34"></a>    <span class="cf">return</span> dfs(initial_state, <span class="dv">0</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>특징</strong>: - 메모리 효율적 - 백트래킹 자연스럽게 구현 - 최적해를 놓칠 수 있음 - “시행착오”에 적합</p>
</section>
</section>
</section>
<section id="실전-예제-game-of-24" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="실전-예제-game-of-24"><span class="header-section-number">4</span> 실전 예제: Game of 24</h2>
<p>Yao et al.의 논문에서 가장 인상적인 실험은 “Game of 24”다. 이 게임은 네 개의 숫자를 사칙연산으로 조합하여 24를 만드는 퍼즐이다.</p>
<section id="문제-정의" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="문제-정의"><span class="header-section-number">4.1</span> 문제 정의</h3>
<p><strong>입력</strong>: 네 개의 숫자 (예: 4, 9, 10, 13) <strong>목표</strong>: 사칙연산으로 24 만들기 <strong>정답 예시</strong>: <code>(13 - 9) * (10 - 4) = 4 * 6 = 24</code></p>
</section>
<section id="왜-어려운가" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="왜-어려운가"><span class="header-section-number">4.2</span> 왜 어려운가?</h3>
<ul>
<li><strong>탐색 공간 크기</strong>: 네 개 숫자의 모든 순열과 연산 조합 = 수천 가지</li>
<li><strong>막다른 골목</strong>: 잘못된 중간 단계는 절대 24에 도달 불가</li>
<li><strong>전략 필요</strong>: 무작위 시도로는 해결 어려움</li>
</ul>
</section>
<section id="tot-구현" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="tot-구현"><span class="header-section-number">4.3</span> ToT 구현</h3>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="im">import</span> anthropic</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="im">from</span> typing <span class="im">import</span> List, Tuple, Optional</span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="im">from</span> dataclasses <span class="im">import</span> dataclass</span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="at">@dataclass</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="kw">class</span> GameState:</span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="co">"""Game of 24 상태"""</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>    numbers: List[<span class="bu">int</span>]  <span class="co"># 남은 숫자들</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>    operations: List[<span class="bu">str</span>]  <span class="co"># 지금까지의 연산들</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>    current_value: Optional[<span class="bu">int</span>]  <span class="co"># 현재 값 (마지막 단계에서)</span></span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="kw">class</span> ToT_Game24:</span>
<span id="cb11-13"><a href="#cb11-13"></a>    <span class="co">"""</span></span>
<span id="cb11-14"><a href="#cb11-14"></a><span class="co">    Tree of Thoughts for Game of 24</span></span>
<span id="cb11-15"><a href="#cb11-15"></a><span class="co">    """</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>    </span>
<span id="cb11-17"><a href="#cb11-17"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, api_key: <span class="bu">str</span>):</span>
<span id="cb11-18"><a href="#cb11-18"></a>        <span class="va">self</span>.client <span class="op">=</span> anthropic.Anthropic(api_key<span class="op">=</span>api_key)</span>
<span id="cb11-19"><a href="#cb11-19"></a>        <span class="va">self</span>.model <span class="op">=</span> <span class="st">"claude-sonnet-4-20250514"</span></span>
<span id="cb11-20"><a href="#cb11-20"></a>    </span>
<span id="cb11-21"><a href="#cb11-21"></a>    <span class="kw">def</span> generate_next_steps(<span class="va">self</span>, state: GameState, k: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span>) <span class="op">-&gt;</span> List[<span class="bu">str</span>]:</span>
<span id="cb11-22"><a href="#cb11-22"></a>        <span class="co">"""</span></span>
<span id="cb11-23"><a href="#cb11-23"></a><span class="co">        Step 1: 다음 가능한 단계들 생성 (Thought Generation)</span></span>
<span id="cb11-24"><a href="#cb11-24"></a><span class="co">        """</span></span>
<span id="cb11-25"><a href="#cb11-25"></a>        numbers_str <span class="op">=</span> <span class="st">", "</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, state.numbers))</span>
<span id="cb11-26"><a href="#cb11-26"></a>        operations_str <span class="op">=</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>.join(state.operations) <span class="cf">if</span> state.operations <span class="cf">else</span> <span class="st">"None"</span></span>
<span id="cb11-27"><a href="#cb11-27"></a>        </span>
<span id="cb11-28"><a href="#cb11-28"></a>        prompt <span class="op">=</span> <span class="ss">f"""</span></span>
<span id="cb11-29"><a href="#cb11-29"></a><span class="ss">You are solving the Game of 24.</span></span>
<span id="cb11-30"><a href="#cb11-30"></a></span>
<span id="cb11-31"><a href="#cb11-31"></a><span class="ss">Current state:</span></span>
<span id="cb11-32"><a href="#cb11-32"></a><span class="ss">- Remaining numbers: </span><span class="sc">{</span>numbers_str<span class="sc">}</span></span>
<span id="cb11-33"><a href="#cb11-33"></a><span class="ss">- Operations so far:</span></span>
<span id="cb11-34"><a href="#cb11-34"></a><span class="sc">{</span>operations_str<span class="sc">}</span></span>
<span id="cb11-35"><a href="#cb11-35"></a></span>
<span id="cb11-36"><a href="#cb11-36"></a><span class="ss">Generate </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> possible next steps. Each step should:</span></span>
<span id="cb11-37"><a href="#cb11-37"></a><span class="ss">1. Pick two numbers from the remaining numbers</span></span>
<span id="cb11-38"><a href="#cb11-38"></a><span class="ss">2. Apply one operation (+, -, *, /)</span></span>
<span id="cb11-39"><a href="#cb11-39"></a><span class="ss">3. Show the result</span></span>
<span id="cb11-40"><a href="#cb11-40"></a></span>
<span id="cb11-41"><a href="#cb11-41"></a><span class="ss">Format: "a OP b = c" (e.g., "10 - 4 = 6")</span></span>
<span id="cb11-42"><a href="#cb11-42"></a></span>
<span id="cb11-43"><a href="#cb11-43"></a><span class="ss">List </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> different next steps:</span></span>
<span id="cb11-44"><a href="#cb11-44"></a><span class="ss">"""</span></span>
<span id="cb11-45"><a href="#cb11-45"></a>        </span>
<span id="cb11-46"><a href="#cb11-46"></a>        message <span class="op">=</span> <span class="va">self</span>.client.messages.create(</span>
<span id="cb11-47"><a href="#cb11-47"></a>            model<span class="op">=</span><span class="va">self</span>.model,</span>
<span id="cb11-48"><a href="#cb11-48"></a>            max_tokens<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb11-49"><a href="#cb11-49"></a>            temperature<span class="op">=</span><span class="fl">0.7</span>,  <span class="co"># 다양성을 위해 temperature &gt; 0</span></span>
<span id="cb11-50"><a href="#cb11-50"></a>            messages<span class="op">=</span>[{<span class="st">"role"</span>: <span class="st">"user"</span>, <span class="st">"content"</span>: prompt}]</span>
<span id="cb11-51"><a href="#cb11-51"></a>        )</span>
<span id="cb11-52"><a href="#cb11-52"></a>        </span>
<span id="cb11-53"><a href="#cb11-53"></a>        response <span class="op">=</span> message.content[<span class="dv">0</span>].text.strip()</span>
<span id="cb11-54"><a href="#cb11-54"></a>        </span>
<span id="cb11-55"><a href="#cb11-55"></a>        <span class="co"># 줄 단위로 파싱</span></span>
<span id="cb11-56"><a href="#cb11-56"></a>        steps <span class="op">=</span> []</span>
<span id="cb11-57"><a href="#cb11-57"></a>        <span class="cf">for</span> line <span class="kw">in</span> response.split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb11-58"><a href="#cb11-58"></a>            line <span class="op">=</span> line.strip()</span>
<span id="cb11-59"><a href="#cb11-59"></a>            <span class="cf">if</span> <span class="st">'='</span> <span class="kw">in</span> line:</span>
<span id="cb11-60"><a href="#cb11-60"></a>                <span class="co"># "10 - 4 = 6" 형태 추출</span></span>
<span id="cb11-61"><a href="#cb11-61"></a>                steps.append(line)</span>
<span id="cb11-62"><a href="#cb11-62"></a>        </span>
<span id="cb11-63"><a href="#cb11-63"></a>        <span class="cf">return</span> steps[:k]</span>
<span id="cb11-64"><a href="#cb11-64"></a>    </span>
<span id="cb11-65"><a href="#cb11-65"></a>    <span class="kw">def</span> evaluate_step(<span class="va">self</span>, state: GameState, step: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb11-66"><a href="#cb11-66"></a>        <span class="co">"""</span></span>
<span id="cb11-67"><a href="#cb11-67"></a><span class="co">        Step 2: 각 단계 평가 (State Evaluation)</span></span>
<span id="cb11-68"><a href="#cb11-68"></a><span class="co">        </span></span>
<span id="cb11-69"><a href="#cb11-69"></a><span class="co">        Returns:</span></span>
<span id="cb11-70"><a href="#cb11-70"></a><span class="co">            0.0: impossible</span></span>
<span id="cb11-71"><a href="#cb11-71"></a><span class="co">            0.5: maybe</span></span>
<span id="cb11-72"><a href="#cb11-72"></a><span class="co">            0.75: likely</span></span>
<span id="cb11-73"><a href="#cb11-73"></a><span class="co">            1.0: sure</span></span>
<span id="cb11-74"><a href="#cb11-74"></a><span class="co">        """</span></span>
<span id="cb11-75"><a href="#cb11-75"></a>        numbers_str <span class="op">=</span> <span class="st">", "</span>.join(<span class="bu">map</span>(<span class="bu">str</span>, state.numbers))</span>
<span id="cb11-76"><a href="#cb11-76"></a>        </span>
<span id="cb11-77"><a href="#cb11-77"></a>        prompt <span class="op">=</span> <span class="ss">f"""</span></span>
<span id="cb11-78"><a href="#cb11-78"></a><span class="ss">Evaluate if this step is promising for reaching 24:</span></span>
<span id="cb11-79"><a href="#cb11-79"></a></span>
<span id="cb11-80"><a href="#cb11-80"></a><span class="ss">Current numbers: </span><span class="sc">{</span>numbers_str<span class="sc">}</span></span>
<span id="cb11-81"><a href="#cb11-81"></a><span class="ss">Proposed step: </span><span class="sc">{</span>step<span class="sc">}</span></span>
<span id="cb11-82"><a href="#cb11-82"></a></span>
<span id="cb11-83"><a href="#cb11-83"></a><span class="ss">Consider:</span></span>
<span id="cb11-84"><a href="#cb11-84"></a><span class="ss">1. Does this step lead toward 24?</span></span>
<span id="cb11-85"><a href="#cb11-85"></a><span class="ss">2. Are the remaining numbers manageable?</span></span>
<span id="cb11-86"><a href="#cb11-86"></a><span class="ss">3. Is there a clear path to 24?</span></span>
<span id="cb11-87"><a href="#cb11-87"></a></span>
<span id="cb11-88"><a href="#cb11-88"></a><span class="ss">Evaluate as one of:</span></span>
<span id="cb11-89"><a href="#cb11-89"></a><span class="ss">- "sure": This will definitely reach 24</span></span>
<span id="cb11-90"><a href="#cb11-90"></a><span class="ss">- "likely": This probably will reach 24  </span></span>
<span id="cb11-91"><a href="#cb11-91"></a><span class="ss">- "maybe": Uncertain</span></span>
<span id="cb11-92"><a href="#cb11-92"></a><span class="ss">- "impossible": This cannot reach 24</span></span>
<span id="cb11-93"><a href="#cb11-93"></a></span>
<span id="cb11-94"><a href="#cb11-94"></a><span class="ss">Your evaluation (one word only):</span></span>
<span id="cb11-95"><a href="#cb11-95"></a><span class="ss">"""</span></span>
<span id="cb11-96"><a href="#cb11-96"></a>        </span>
<span id="cb11-97"><a href="#cb11-97"></a>        message <span class="op">=</span> <span class="va">self</span>.client.messages.create(</span>
<span id="cb11-98"><a href="#cb11-98"></a>            model<span class="op">=</span><span class="va">self</span>.model,</span>
<span id="cb11-99"><a href="#cb11-99"></a>            max_tokens<span class="op">=</span><span class="dv">20</span>,</span>
<span id="cb11-100"><a href="#cb11-100"></a>            temperature<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb11-101"><a href="#cb11-101"></a>            messages<span class="op">=</span>[{<span class="st">"role"</span>: <span class="st">"user"</span>, <span class="st">"content"</span>: prompt}]</span>
<span id="cb11-102"><a href="#cb11-102"></a>        )</span>
<span id="cb11-103"><a href="#cb11-103"></a>        </span>
<span id="cb11-104"><a href="#cb11-104"></a>        evaluation <span class="op">=</span> message.content[<span class="dv">0</span>].text.strip().lower()</span>
<span id="cb11-105"><a href="#cb11-105"></a>        </span>
<span id="cb11-106"><a href="#cb11-106"></a>        <span class="co"># 점수 매핑</span></span>
<span id="cb11-107"><a href="#cb11-107"></a>        score_map <span class="op">=</span> {</span>
<span id="cb11-108"><a href="#cb11-108"></a>            <span class="st">"sure"</span>: <span class="fl">1.0</span>,</span>
<span id="cb11-109"><a href="#cb11-109"></a>            <span class="st">"likely"</span>: <span class="fl">0.75</span>,</span>
<span id="cb11-110"><a href="#cb11-110"></a>            <span class="st">"maybe"</span>: <span class="fl">0.5</span>,</span>
<span id="cb11-111"><a href="#cb11-111"></a>            <span class="st">"impossible"</span>: <span class="fl">0.0</span></span>
<span id="cb11-112"><a href="#cb11-112"></a>        }</span>
<span id="cb11-113"><a href="#cb11-113"></a>        </span>
<span id="cb11-114"><a href="#cb11-114"></a>        <span class="co"># 부분 매칭</span></span>
<span id="cb11-115"><a href="#cb11-115"></a>        <span class="cf">for</span> key, value <span class="kw">in</span> score_map.items():</span>
<span id="cb11-116"><a href="#cb11-116"></a>            <span class="cf">if</span> key <span class="kw">in</span> evaluation:</span>
<span id="cb11-117"><a href="#cb11-117"></a>                <span class="cf">return</span> value</span>
<span id="cb11-118"><a href="#cb11-118"></a>        </span>
<span id="cb11-119"><a href="#cb11-119"></a>        <span class="cf">return</span> <span class="fl">0.5</span>  <span class="co"># 기본값</span></span>
<span id="cb11-120"><a href="#cb11-120"></a>    </span>
<span id="cb11-121"><a href="#cb11-121"></a>    <span class="kw">def</span> apply_step(<span class="va">self</span>, state: GameState, step: <span class="bu">str</span>) <span class="op">-&gt;</span> Optional[GameState]:</span>
<span id="cb11-122"><a href="#cb11-122"></a>        <span class="co">"""</span></span>
<span id="cb11-123"><a href="#cb11-123"></a><span class="co">        단계를 적용하여 새로운 상태 생성</span></span>
<span id="cb11-124"><a href="#cb11-124"></a><span class="co">        """</span></span>
<span id="cb11-125"><a href="#cb11-125"></a>        <span class="cf">try</span>:</span>
<span id="cb11-126"><a href="#cb11-126"></a>            <span class="co"># "10 - 4 = 6" 파싱</span></span>
<span id="cb11-127"><a href="#cb11-127"></a>            <span class="im">import</span> re</span>
<span id="cb11-128"><a href="#cb11-128"></a>            match <span class="op">=</span> re.match(<span class="vs">r'(\d+)\s*([\+\-\*/])\s*(\d+)\s*=\s*(\d+)'</span>, step)</span>
<span id="cb11-129"><a href="#cb11-129"></a>            </span>
<span id="cb11-130"><a href="#cb11-130"></a>            <span class="cf">if</span> <span class="kw">not</span> match:</span>
<span id="cb11-131"><a href="#cb11-131"></a>                <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb11-132"><a href="#cb11-132"></a>            </span>
<span id="cb11-133"><a href="#cb11-133"></a>            a, op, b, result <span class="op">=</span> match.groups()</span>
<span id="cb11-134"><a href="#cb11-134"></a>            a, b, result <span class="op">=</span> <span class="bu">int</span>(a), <span class="bu">int</span>(b), <span class="bu">int</span>(result)</span>
<span id="cb11-135"><a href="#cb11-135"></a>            </span>
<span id="cb11-136"><a href="#cb11-136"></a>            <span class="co"># 숫자가 현재 상태에 있는지 확인</span></span>
<span id="cb11-137"><a href="#cb11-137"></a>            numbers <span class="op">=</span> state.numbers.copy()</span>
<span id="cb11-138"><a href="#cb11-138"></a>            <span class="cf">if</span> a <span class="kw">not</span> <span class="kw">in</span> numbers <span class="kw">or</span> b <span class="kw">not</span> <span class="kw">in</span> numbers:</span>
<span id="cb11-139"><a href="#cb11-139"></a>                <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb11-140"><a href="#cb11-140"></a>            </span>
<span id="cb11-141"><a href="#cb11-141"></a>            <span class="co"># 숫자 제거</span></span>
<span id="cb11-142"><a href="#cb11-142"></a>            numbers.remove(a)</span>
<span id="cb11-143"><a href="#cb11-143"></a>            numbers.remove(b)</span>
<span id="cb11-144"><a href="#cb11-144"></a>            </span>
<span id="cb11-145"><a href="#cb11-145"></a>            <span class="co"># 결과 추가</span></span>
<span id="cb11-146"><a href="#cb11-146"></a>            numbers.append(result)</span>
<span id="cb11-147"><a href="#cb11-147"></a>            </span>
<span id="cb11-148"><a href="#cb11-148"></a>            <span class="co"># 새로운 상태 생성</span></span>
<span id="cb11-149"><a href="#cb11-149"></a>            new_state <span class="op">=</span> GameState(</span>
<span id="cb11-150"><a href="#cb11-150"></a>                numbers<span class="op">=</span>numbers,</span>
<span id="cb11-151"><a href="#cb11-151"></a>                operations<span class="op">=</span>state.operations <span class="op">+</span> [step],</span>
<span id="cb11-152"><a href="#cb11-152"></a>                current_value<span class="op">=</span>result <span class="cf">if</span> <span class="bu">len</span>(numbers) <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb11-153"><a href="#cb11-153"></a>            )</span>
<span id="cb11-154"><a href="#cb11-154"></a>            </span>
<span id="cb11-155"><a href="#cb11-155"></a>            <span class="cf">return</span> new_state</span>
<span id="cb11-156"><a href="#cb11-156"></a>        </span>
<span id="cb11-157"><a href="#cb11-157"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb11-158"><a href="#cb11-158"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb11-159"><a href="#cb11-159"></a>    </span>
<span id="cb11-160"><a href="#cb11-160"></a>    <span class="kw">def</span> is_goal(<span class="va">self</span>, state: GameState) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb11-161"><a href="#cb11-161"></a>        <span class="co">"""</span></span>
<span id="cb11-162"><a href="#cb11-162"></a><span class="co">        목표 상태인가? (숫자가 하나 남고 그 값이 24)</span></span>
<span id="cb11-163"><a href="#cb11-163"></a><span class="co">        """</span></span>
<span id="cb11-164"><a href="#cb11-164"></a>        <span class="cf">return</span> <span class="bu">len</span>(state.numbers) <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> state.numbers[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">24</span></span>
<span id="cb11-165"><a href="#cb11-165"></a>    </span>
<span id="cb11-166"><a href="#cb11-166"></a>    <span class="kw">def</span> solve_bfs(<span class="va">self</span>, numbers: List[<span class="bu">int</span>], b: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span>) <span class="op">-&gt;</span> Optional[List[<span class="bu">str</span>]]:</span>
<span id="cb11-167"><a href="#cb11-167"></a>        <span class="co">"""</span></span>
<span id="cb11-168"><a href="#cb11-168"></a><span class="co">        BFS로 Game of 24 풀이</span></span>
<span id="cb11-169"><a href="#cb11-169"></a><span class="co">        </span></span>
<span id="cb11-170"><a href="#cb11-170"></a><span class="co">        Args:</span></span>
<span id="cb11-171"><a href="#cb11-171"></a><span class="co">            numbers: 초기 숫자들</span></span>
<span id="cb11-172"><a href="#cb11-172"></a><span class="co">            b: beam width (각 단계에서 유지할 상태 수)</span></span>
<span id="cb11-173"><a href="#cb11-173"></a><span class="co">        """</span></span>
<span id="cb11-174"><a href="#cb11-174"></a>        <span class="bu">print</span>(<span class="ss">f"🎮 Game of 24: </span><span class="sc">{</span>numbers<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-175"><a href="#cb11-175"></a>        <span class="bu">print</span>(<span class="ss">f"🔍 BFS 탐색 시작 (beam width: </span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">)</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb11-176"><a href="#cb11-176"></a>        </span>
<span id="cb11-177"><a href="#cb11-177"></a>        initial_state <span class="op">=</span> GameState(numbers<span class="op">=</span>numbers, operations<span class="op">=</span>[], current_value<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb11-178"><a href="#cb11-178"></a>        states <span class="op">=</span> [(initial_state, <span class="fl">1.0</span>)]  <span class="co"># (state, score)</span></span>
<span id="cb11-179"><a href="#cb11-179"></a>        </span>
<span id="cb11-180"><a href="#cb11-180"></a>        max_steps <span class="op">=</span> <span class="dv">3</span>  <span class="co"># 4개 숫자 → 3번 연산 필요</span></span>
<span id="cb11-181"><a href="#cb11-181"></a>        </span>
<span id="cb11-182"><a href="#cb11-182"></a>        <span class="cf">for</span> step_num <span class="kw">in</span> <span class="bu">range</span>(max_steps):</span>
<span id="cb11-183"><a href="#cb11-183"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">60</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-184"><a href="#cb11-184"></a>            <span class="bu">print</span>(<span class="ss">f"Step </span><span class="sc">{</span>step_num <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-185"><a href="#cb11-185"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">60</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-186"><a href="#cb11-186"></a>            </span>
<span id="cb11-187"><a href="#cb11-187"></a>            all_candidates <span class="op">=</span> []</span>
<span id="cb11-188"><a href="#cb11-188"></a>            </span>
<span id="cb11-189"><a href="#cb11-189"></a>            <span class="co"># 각 현재 상태에서 확장</span></span>
<span id="cb11-190"><a href="#cb11-190"></a>            <span class="cf">for</span> state, prev_score <span class="kw">in</span> states:</span>
<span id="cb11-191"><a href="#cb11-191"></a>                <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">현재 상태: </span><span class="sc">{</span>state<span class="sc">.</span>numbers<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-192"><a href="#cb11-192"></a>                </span>
<span id="cb11-193"><a href="#cb11-193"></a>                <span class="co"># 새로운 단계들 생성</span></span>
<span id="cb11-194"><a href="#cb11-194"></a>                next_steps <span class="op">=</span> <span class="va">self</span>.generate_next_steps(state, k<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb11-195"><a href="#cb11-195"></a>                <span class="bu">print</span>(<span class="ss">f"생성된 단계들: </span><span class="sc">{</span><span class="bu">len</span>(next_steps)<span class="sc">}</span><span class="ss">개"</span>)</span>
<span id="cb11-196"><a href="#cb11-196"></a>                </span>
<span id="cb11-197"><a href="#cb11-197"></a>                <span class="co"># 각 단계 평가</span></span>
<span id="cb11-198"><a href="#cb11-198"></a>                <span class="cf">for</span> step <span class="kw">in</span> next_steps:</span>
<span id="cb11-199"><a href="#cb11-199"></a>                    new_state <span class="op">=</span> <span class="va">self</span>.apply_step(state, step)</span>
<span id="cb11-200"><a href="#cb11-200"></a>                    </span>
<span id="cb11-201"><a href="#cb11-201"></a>                    <span class="cf">if</span> new_state <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb11-202"><a href="#cb11-202"></a>                        <span class="cf">continue</span></span>
<span id="cb11-203"><a href="#cb11-203"></a>                    </span>
<span id="cb11-204"><a href="#cb11-204"></a>                    score <span class="op">=</span> <span class="va">self</span>.evaluate_step(state, step)</span>
<span id="cb11-205"><a href="#cb11-205"></a>                    </span>
<span id="cb11-206"><a href="#cb11-206"></a>                    <span class="bu">print</span>(<span class="ss">f"  - </span><span class="sc">{</span>step<span class="sc">}</span><span class="ss"> → score: </span><span class="sc">{</span>score<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-207"><a href="#cb11-207"></a>                    </span>
<span id="cb11-208"><a href="#cb11-208"></a>                    <span class="co"># 불가능한 경로는 가지치기</span></span>
<span id="cb11-209"><a href="#cb11-209"></a>                    <span class="cf">if</span> score <span class="op">&gt;</span> <span class="fl">0.0</span>:</span>
<span id="cb11-210"><a href="#cb11-210"></a>                        all_candidates.append((new_state, score))</span>
<span id="cb11-211"><a href="#cb11-211"></a>            </span>
<span id="cb11-212"><a href="#cb11-212"></a>            <span class="co"># 상위 b개만 유지</span></span>
<span id="cb11-213"><a href="#cb11-213"></a>            all_candidates.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-214"><a href="#cb11-214"></a>            states <span class="op">=</span> all_candidates[:b]</span>
<span id="cb11-215"><a href="#cb11-215"></a>            </span>
<span id="cb11-216"><a href="#cb11-216"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">유지된 상태: </span><span class="sc">{</span><span class="bu">len</span>(states)<span class="sc">}</span><span class="ss">개"</span>)</span>
<span id="cb11-217"><a href="#cb11-217"></a>            </span>
<span id="cb11-218"><a href="#cb11-218"></a>            <span class="co"># 목표 상태 확인</span></span>
<span id="cb11-219"><a href="#cb11-219"></a>            <span class="cf">for</span> state, score <span class="kw">in</span> states:</span>
<span id="cb11-220"><a href="#cb11-220"></a>                <span class="cf">if</span> <span class="va">self</span>.is_goal(state):</span>
<span id="cb11-221"><a href="#cb11-221"></a>                    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">60</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-222"><a href="#cb11-222"></a>                    <span class="bu">print</span>(<span class="st">"✅ 해결책 발견!"</span>)</span>
<span id="cb11-223"><a href="#cb11-223"></a>                    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">60</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-224"><a href="#cb11-224"></a>                    <span class="cf">for</span> op <span class="kw">in</span> state.operations:</span>
<span id="cb11-225"><a href="#cb11-225"></a>                        <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>op<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-226"><a href="#cb11-226"></a>                    <span class="bu">print</span>(<span class="ss">f"  최종 값: </span><span class="sc">{</span>state<span class="sc">.</span>numbers[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-227"><a href="#cb11-227"></a>                    <span class="cf">return</span> state.operations</span>
<span id="cb11-228"><a href="#cb11-228"></a>        </span>
<span id="cb11-229"><a href="#cb11-229"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">❌ 해결책을 찾지 못했습니다."</span>)</span>
<span id="cb11-230"><a href="#cb11-230"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb11-231"><a href="#cb11-231"></a></span>
<span id="cb11-232"><a href="#cb11-232"></a></span>
<span id="cb11-233"><a href="#cb11-233"></a><span class="co"># 사용 예시</span></span>
<span id="cb11-234"><a href="#cb11-234"></a><span class="kw">def</span> main():</span>
<span id="cb11-235"><a href="#cb11-235"></a>    solver <span class="op">=</span> ToT_Game24(api_key<span class="op">=</span><span class="st">"your-api-key"</span>)</span>
<span id="cb11-236"><a href="#cb11-236"></a>    </span>
<span id="cb11-237"><a href="#cb11-237"></a>    <span class="co"># 테스트 케이스</span></span>
<span id="cb11-238"><a href="#cb11-238"></a>    test_cases <span class="op">=</span> [</span>
<span id="cb11-239"><a href="#cb11-239"></a>        [<span class="dv">4</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">13</span>],  <span class="co"># 쉬움: (13-9)*(10-4) = 24</span></span>
<span id="cb11-240"><a href="#cb11-240"></a>        [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>],    <span class="co"># 어려움: 5*(5-(1/5)) = 24</span></span>
<span id="cb11-241"><a href="#cb11-241"></a>        [<span class="dv">2</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">14</span>],   <span class="co"># 중간: (8/(2-8/8))*2 = 24</span></span>
<span id="cb11-242"><a href="#cb11-242"></a>    ]</span>
<span id="cb11-243"><a href="#cb11-243"></a>    </span>
<span id="cb11-244"><a href="#cb11-244"></a>    <span class="cf">for</span> numbers <span class="kw">in</span> test_cases:</span>
<span id="cb11-245"><a href="#cb11-245"></a>        <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> <span class="st">"="</span><span class="op">*</span><span class="dv">80</span>)</span>
<span id="cb11-246"><a href="#cb11-246"></a>        solution <span class="op">=</span> solver.solve_bfs(numbers, b<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb11-247"><a href="#cb11-247"></a>        <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">80</span> <span class="op">+</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb11-248"><a href="#cb11-248"></a>        </span>
<span id="cb11-249"><a href="#cb11-249"></a>        <span class="cf">if</span> solution:</span>
<span id="cb11-250"><a href="#cb11-250"></a>            <span class="bu">print</span>(<span class="ss">f"✅ 성공: </span><span class="sc">{</span><span class="st">' → '</span><span class="sc">.</span>join(solution)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-251"><a href="#cb11-251"></a>        <span class="cf">else</span>:</span>
<span id="cb11-252"><a href="#cb11-252"></a>            <span class="bu">print</span>(<span class="ss">f"❌ 실패"</span>)</span>
<span id="cb11-253"><a href="#cb11-253"></a></span>
<span id="cb11-254"><a href="#cb11-254"></a></span>
<span id="cb11-255"><a href="#cb11-255"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb11-256"><a href="#cb11-256"></a>    main()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="실행-결과-예시" class="level3" data-number="4.4">
<h3 data-number="4.4" class="anchored" data-anchor-id="실행-결과-예시"><span class="header-section-number">4.4</span> 실행 결과 예시</h3>
<pre><code>================================================================================
🎮 Game of 24: [4, 9, 10, 13]
🔍 BFS 탐색 시작 (beam width: 3)

============================================================
Step 1
============================================================

현재 상태: [4, 9, 10, 13]
생성된 단계들: 5개
  - 13 - 9 = 4 → score: 0.75 (likely)
  - 10 - 4 = 6 → score: 0.5 (maybe)
  - 10 + 13 = 23 → score: 1.0 (sure)
  - 9 * 4 = 36 → score: 0.0 (impossible)
  - 13 - 4 = 9 → score: 0.5 (maybe)

유지된 상태: 3개

============================================================
Step 2
============================================================

현재 상태: [4, 4, 10]  # from 13-9=4
생성된 단계들: 5개
  - 10 - 4 = 6 → score: 0.75 (likely)
  - 4 * 4 = 16 → score: 0.5 (maybe)
  - 10 + 4 = 14 → score: 0.25 (unlikely)

현재 상태: [4, 9, 23]  # from 10+13=23
생성된 단계들: 5개
  - 23 + 9 = 32 → score: 0.0 (impossible)
  - 23 - 9 = 14 → score: 0.5 (maybe)
  - 23 + 4 = 27 → score: 0.0 (impossible)

현재 상태: [9, 10, 13]  # from 13-4=9
... (생략)

유지된 상태: 3개

============================================================
Step 3
============================================================

현재 상태: [4, 6]  # from 10-4=6
생성된 단계들: 2개
  - 6 * 4 = 24 → score: 1.0 (sure)
  - 6 + 4 = 10 → score: 0.0 (impossible)

============================================================
✅ 해결책 발견!
============================================================
  13 - 9 = 4
  10 - 4 = 6
  6 * 4 = 24
  최종 값: 24

================================================================================</code></pre>
</section>
</section>
<section id="실험-결과-분석" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="실험-결과-분석"><span class="header-section-number">5</span> 실험 결과 분석</h2>
<section id="벤치마크-성능-비교" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="벤치마크-성능-비교"><span class="header-section-number">5.1</span> 벤치마크 성능 비교</h3>
<p>Yao et al.&nbsp;(2024)는 ToT를 세 가지 태스크에서 테스트했다:</p>
<ol type="1">
<li><strong>Game of 24</strong>: 네 숫자로 24 만들기</li>
<li><strong>Creative Writing</strong>: 네 문장으로 일관된 에세이 작성</li>
<li><strong>5×5 Crosswords</strong>: 십자말풀이</li>
</ol>
</section>
<section id="game-of-24-결과" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="game-of-24-결과"><span class="header-section-number">5.2</span> Game of 24 결과</h3>
<table class="table">
<thead>
<tr class="header">
<th>방법</th>
<th>성공률</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>IO prompt</td>
<td>7.3%</td>
</tr>
<tr class="even">
<td>CoT prompt</td>
<td>4.0%</td>
</tr>
<tr class="odd">
<td>CoT-SC (k=100)</td>
<td>9.0%</td>
</tr>
<tr class="even">
<td><strong>ToT (b=1)</strong></td>
<td><strong>45%</strong></td>
</tr>
<tr class="odd">
<td><strong>ToT (b=5)</strong></td>
<td><strong>74%</strong></td>
</tr>
<tr class="even">
<td>IO + Refine (k=10)</td>
<td>27%</td>
</tr>
<tr class="odd">
<td>IO (best of 100)</td>
<td>33%</td>
</tr>
<tr class="even">
<td>CoT (best of 100)</td>
<td>49%</td>
</tr>
</tbody>
</table>
<p><strong>핵심 인사이트</strong>:</p>
<ol type="1">
<li><strong>CoT보다 ToT가 압도적으로 우수</strong>: 74% vs 4%
<ul>
<li>CoT는 한 번 잘못된 경로를 선택하면 되돌릴 수 없음</li>
<li>ToT는 백트래킹으로 다른 경로 탐색 가능</li>
</ul></li>
<li><strong>Beam width의 영향</strong>:
<ul>
<li>b=1 (greedy): 45%</li>
<li>b=5: 74%</li>
<li>더 많은 경로를 탐색할수록 성능 향상</li>
</ul></li>
<li><strong>샘플링만으로는 부족</strong>:
<ul>
<li>CoT (best of 100): 49%</li>
<li>ToT (b=5): 74%</li>
<li>단순히 여러 번 시도하는 것보다 전략적 탐색이 효과적</li>
</ul></li>
</ol>
</section>
<section id="오답-패턴-분석" class="level3" data-number="5.3">
<h3 data-number="5.3" class="anchored" data-anchor-id="오답-패턴-분석"><span class="header-section-number">5.3</span> 오답 패턴 분석</h3>
<p>논문에서는 CoT와 ToT의 오답 패턴을 분석했다:</p>
<p><strong>CoT의 오답 패턴</strong>: - <strong>Step 1에서 실패</strong>: 62% - <strong>Step 2에서 실패</strong>: 31% - <strong>Step 3 이상</strong>: 7%</p>
<p>→ CoT는 첫 단계부터 잘못된 경로를 선택하면 바로 실패</p>
<p><strong>ToT의 오답 패턴</strong>: - <strong>Step 1에서 실패</strong>: 8% - <strong>Step 2에서 실패</strong>: 6% - <strong>Step 3 이상</strong>: 3% - <strong>Correct</strong>: 83%</p>
<p>→ ToT는 초기 실수를 복구 가능</p>
<p><strong>실제 예시</strong>:</p>
<pre><code>문제: 4, 9, 10, 13으로 24 만들기

CoT 실패 케이스:
Step 1: 13 + 10 = 23
Step 2: 23 + 9 = 32
Step 3: 32 - 4 = 28 ❌
→ Step 1의 선택이 잘못됨. 되돌릴 수 없음.

ToT 성공 케이스:
Step 1: 
  Option A: 13 + 10 = 23 (score: 0.5, maybe)
  Option B: 13 - 9 = 4 (score: 0.75, likely) ✓ 선택
  Option C: 10 * 4 = 40 (score: 0.0, impossible)

Step 2 (from Option B):
  Option A: 4 + 4 = 8 (score: 0.5)
  Option B: 10 - 4 = 6 (score: 0.75) ✓ 선택
  Option C: 4 * 10 = 40 (score: 0.0)

Step 3:
  6 * 4 = 24 ✅</code></pre>
</section>
<section id="노드-방문-횟수-vs-성능" class="level3" data-number="5.4">
<h3 data-number="5.4" class="anchored" data-anchor-id="노드-방문-횟수-vs-성능"><span class="header-section-number">5.4</span> 노드 방문 횟수 vs 성능</h3>
<p>연구팀은 방문한 노드 수에 따른 성능을 측정했다:</p>
<p><strong>결과</strong>: - <strong>IO (best of k)</strong>: 노드 100개 방문 → 33% 성공률 - <strong>CoT (best of k)</strong>: 노드 100개 방문 → 49% 성공률 - <strong>ToT (b=1~5)</strong>: 노드 20~50개 방문 → 45%~74% 성공률</p>
<p><strong>결론</strong>: ToT는 더 적은 노드를 방문하면서도 더 높은 성공률을 달성한다. 이는 <strong>전략적 탐색</strong>의 효과를 보여준다.</p>
</section>
</section>
<section id="creative-writing-실험" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="creative-writing-실험"><span class="header-section-number">6</span> Creative Writing 실험</h2>
<section id="태스크-정의" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="태스크-정의"><span class="header-section-number">6.1</span> 태스크 정의</h3>
<p><strong>입력</strong>: 네 개의 무작위 문장</p>
<pre><code>1. "The old lighthouse stood alone on the cliff."
2. "Sarah had always been afraid of the dark."
3. "The package arrived three days late."
4. "In his pocket, he found a key he didn't recognize."</code></pre>
<p><strong>목표</strong>: 이 네 문장을 모두 포함하는 일관된 짧은 에세이 작성</p>
</section>
<section id="tot-적용" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="tot-적용"><span class="header-section-number">6.2</span> ToT 적용</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">class</span> ToT_CreativeWriting:</span>
<span id="cb15-2"><a href="#cb15-2"></a>    <span class="co">"""</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="co">    Tree of Thoughts for Creative Writing</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="co">    """</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>    </span>
<span id="cb15-6"><a href="#cb15-6"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, api_key: <span class="bu">str</span>):</span>
<span id="cb15-7"><a href="#cb15-7"></a>        <span class="va">self</span>.client <span class="op">=</span> anthropic.Anthropic(api_key<span class="op">=</span>api_key)</span>
<span id="cb15-8"><a href="#cb15-8"></a>        <span class="va">self</span>.model <span class="op">=</span> <span class="st">"claude-sonnet-4-20250514"</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>    </span>
<span id="cb15-10"><a href="#cb15-10"></a>    <span class="kw">def</span> generate_plans(<span class="va">self</span>, sentences: List[<span class="bu">str</span>], k: <span class="bu">int</span> <span class="op">=</span> <span class="dv">5</span>) <span class="op">-&gt;</span> List[<span class="bu">str</span>]:</span>
<span id="cb15-11"><a href="#cb15-11"></a>        <span class="co">"""</span></span>
<span id="cb15-12"><a href="#cb15-12"></a><span class="co">        Step 1: 여러 작성 계획 생성</span></span>
<span id="cb15-13"><a href="#cb15-13"></a><span class="co">        """</span></span>
<span id="cb15-14"><a href="#cb15-14"></a>        sentences_str <span class="op">=</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>.join([<span class="ss">f"</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">. </span><span class="sc">{</span>s<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> i, s <span class="kw">in</span> <span class="bu">enumerate</span>(sentences)])</span>
<span id="cb15-15"><a href="#cb15-15"></a>        </span>
<span id="cb15-16"><a href="#cb15-16"></a>        prompt <span class="op">=</span> <span class="ss">f"""</span></span>
<span id="cb15-17"><a href="#cb15-17"></a><span class="ss">        You need to write a coherent passage using these 4 random sentences:</span></span>
<span id="cb15-18"><a href="#cb15-18"></a></span>
<span id="cb15-19"><a href="#cb15-19"></a><span class="ss">        </span><span class="sc">{</span>sentences_str<span class="sc">}</span></span>
<span id="cb15-20"><a href="#cb15-20"></a></span>
<span id="cb15-21"><a href="#cb15-21"></a><span class="ss">        Generate </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> different plans for how to connect these sentences into a story.</span></span>
<span id="cb15-22"><a href="#cb15-22"></a><span class="ss">        Each plan should briefly describe:</span></span>
<span id="cb15-23"><a href="#cb15-23"></a><span class="ss">        - The overall narrative structure</span></span>
<span id="cb15-24"><a href="#cb15-24"></a><span class="ss">        - How each sentence connects to others</span></span>
<span id="cb15-25"><a href="#cb15-25"></a><span class="ss">        - The tone and style</span></span>
<span id="cb15-26"><a href="#cb15-26"></a></span>
<span id="cb15-27"><a href="#cb15-27"></a><span class="ss">        List </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> different plans:</span></span>
<span id="cb15-28"><a href="#cb15-28"></a><span class="ss">        """</span></span>
<span id="cb15-29"><a href="#cb15-29"></a>        </span>
<span id="cb15-30"><a href="#cb15-30"></a>        message <span class="op">=</span> <span class="va">self</span>.client.messages.create(</span>
<span id="cb15-31"><a href="#cb15-31"></a>            model<span class="op">=</span><span class="va">self</span>.model,</span>
<span id="cb15-32"><a href="#cb15-32"></a>            max_tokens<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb15-33"><a href="#cb15-33"></a>            temperature<span class="op">=</span><span class="fl">0.8</span>,  <span class="co"># 창의성을 위해 높은 temperature</span></span>
<span id="cb15-34"><a href="#cb15-34"></a>            messages<span class="op">=</span>[{<span class="st">"role"</span>: <span class="st">"user"</span>, <span class="st">"content"</span>: prompt}]</span>
<span id="cb15-35"><a href="#cb15-35"></a>        )</span>
<span id="cb15-36"><a href="#cb15-36"></a>        </span>
<span id="cb15-37"><a href="#cb15-37"></a>        response <span class="op">=</span> message.content[<span class="dv">0</span>].text.strip()</span>
<span id="cb15-38"><a href="#cb15-38"></a>        </span>
<span id="cb15-39"><a href="#cb15-39"></a>        <span class="co"># 계획들 파싱 (단순화를 위해 전체를 하나로 취급하거나 번호로 분리)</span></span>
<span id="cb15-40"><a href="#cb15-40"></a>        plans <span class="op">=</span> []</span>
<span id="cb15-41"><a href="#cb15-41"></a>        current_plan <span class="op">=</span> []</span>
<span id="cb15-42"><a href="#cb15-42"></a>        <span class="cf">for</span> line <span class="kw">in</span> response.split(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>):</span>
<span id="cb15-43"><a href="#cb15-43"></a>            <span class="cf">if</span> line.strip().startswith((<span class="st">'1.'</span>, <span class="st">'2.'</span>, <span class="st">'3.'</span>, <span class="st">'4.'</span>, <span class="st">'5.'</span>, <span class="st">'Plan'</span>)):</span>
<span id="cb15-44"><a href="#cb15-44"></a>                <span class="cf">if</span> current_plan:</span>
<span id="cb15-45"><a href="#cb15-45"></a>                    plans.append(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>.join(current_plan))</span>
<span id="cb15-46"><a href="#cb15-46"></a>                    current_plan <span class="op">=</span> []</span>
<span id="cb15-47"><a href="#cb15-47"></a>            current_plan.append(line)</span>
<span id="cb15-48"><a href="#cb15-48"></a>        </span>
<span id="cb15-49"><a href="#cb15-49"></a>        <span class="cf">if</span> current_plan:</span>
<span id="cb15-50"><a href="#cb15-50"></a>            plans.append(<span class="st">'</span><span class="ch">\n</span><span class="st">'</span>.join(current_plan))</span>
<span id="cb15-51"><a href="#cb15-51"></a>        </span>
<span id="cb15-52"><a href="#cb15-52"></a>        <span class="cf">return</span> plans[:k]</span>
<span id="cb15-53"><a href="#cb15-53"></a>    </span>
<span id="cb15-54"><a href="#cb15-54"></a>    <span class="kw">def</span> evaluate_plan(<span class="va">self</span>, sentences: List[<span class="bu">str</span>], plan: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb15-55"><a href="#cb15-55"></a>        <span class="co">"""</span></span>
<span id="cb15-56"><a href="#cb15-56"></a><span class="co">        Step 2: 계획 평가</span></span>
<span id="cb15-57"><a href="#cb15-57"></a><span class="co">        """</span></span>
<span id="cb15-58"><a href="#cb15-58"></a>        sentences_str <span class="op">=</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>.join([<span class="ss">f"</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">. </span><span class="sc">{</span>s<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> i, s <span class="kw">in</span> <span class="bu">enumerate</span>(sentences)])</span>
<span id="cb15-59"><a href="#cb15-59"></a>        </span>
<span id="cb15-60"><a href="#cb15-60"></a>        prompt <span class="op">=</span> <span class="ss">f"""</span></span>
<span id="cb15-61"><a href="#cb15-61"></a><span class="ss">        Evaluate the following story plan:</span></span>
<span id="cb15-62"><a href="#cb15-62"></a></span>
<span id="cb15-63"><a href="#cb15-63"></a><span class="ss">        Required sentences:</span></span>
<span id="cb15-64"><a href="#cb15-64"></a><span class="ss">        </span><span class="sc">{</span>sentences_str<span class="sc">}</span></span>
<span id="cb15-65"><a href="#cb15-65"></a></span>
<span id="cb15-66"><a href="#cb15-66"></a><span class="ss">        Plan:</span></span>
<span id="cb15-67"><a href="#cb15-67"></a><span class="ss">        </span><span class="sc">{</span>plan<span class="sc">}</span></span>
<span id="cb15-68"><a href="#cb15-68"></a></span>
<span id="cb15-69"><a href="#cb15-69"></a><span class="ss">        Rate this plan on coherence and creativity (1-10):</span></span>
<span id="cb15-70"><a href="#cb15-70"></a><span class="ss">        - Does it naturally connect all four sentences?</span></span>
<span id="cb15-71"><a href="#cb15-71"></a><span class="ss">        - Is the narrative structure clear?</span></span>
<span id="cb15-72"><a href="#cb15-72"></a><span class="ss">        - Is it creative and engaging?</span></span>
<span id="cb15-73"><a href="#cb15-73"></a></span>
<span id="cb15-74"><a href="#cb15-74"></a><span class="ss">        Provide only a number (1-10):</span></span>
<span id="cb15-75"><a href="#cb15-75"></a><span class="ss">        """</span></span>
<span id="cb15-76"><a href="#cb15-76"></a>        </span>
<span id="cb15-77"><a href="#cb15-77"></a>        message <span class="op">=</span> <span class="va">self</span>.client.messages.create(</span>
<span id="cb15-78"><a href="#cb15-78"></a>            model<span class="op">=</span><span class="va">self</span>.model,</span>
<span id="cb15-79"><a href="#cb15-79"></a>            max_tokens<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb15-80"><a href="#cb15-80"></a>            temperature<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb15-81"><a href="#cb15-81"></a>            messages<span class="op">=</span>[{<span class="st">"role"</span>: <span class="st">"user"</span>, <span class="st">"content"</span>: prompt}]</span>
<span id="cb15-82"><a href="#cb15-82"></a>        )</span>
<span id="cb15-83"><a href="#cb15-83"></a>        </span>
<span id="cb15-84"><a href="#cb15-84"></a>        <span class="cf">try</span>:</span>
<span id="cb15-85"><a href="#cb15-85"></a>            score <span class="op">=</span> <span class="bu">float</span>(message.content[<span class="dv">0</span>].text.strip())</span>
<span id="cb15-86"><a href="#cb15-86"></a>            <span class="cf">return</span> score <span class="op">/</span> <span class="fl">10.0</span>  <span class="co"># 0~1 범위로 정규화</span></span>
<span id="cb15-87"><a href="#cb15-87"></a>        <span class="cf">except</span>:</span>
<span id="cb15-88"><a href="#cb15-88"></a>            <span class="cf">return</span> <span class="fl">0.5</span></span>
<span id="cb15-89"><a href="#cb15-89"></a>    </span>
<span id="cb15-90"><a href="#cb15-90"></a>    <span class="kw">def</span> write_passage(<span class="va">self</span>, sentences: List[<span class="bu">str</span>], plan: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb15-91"><a href="#cb15-91"></a>        <span class="co">"""</span></span>
<span id="cb15-92"><a href="#cb15-92"></a><span class="co">        Step 3: 계획에 따라 실제 글 작성</span></span>
<span id="cb15-93"><a href="#cb15-93"></a><span class="co">        """</span></span>
<span id="cb15-94"><a href="#cb15-94"></a>        sentences_str <span class="op">=</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>.join([<span class="ss">f"</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">. </span><span class="sc">{</span>s<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> i, s <span class="kw">in</span> <span class="bu">enumerate</span>(sentences)])</span>
<span id="cb15-95"><a href="#cb15-95"></a>        </span>
<span id="cb15-96"><a href="#cb15-96"></a>        prompt <span class="op">=</span> <span class="ss">f"""</span></span>
<span id="cb15-97"><a href="#cb15-97"></a><span class="ss">        Write a coherent short passage (4 paragraphs) that incorporates ALL of these sentences:</span></span>
<span id="cb15-98"><a href="#cb15-98"></a></span>
<span id="cb15-99"><a href="#cb15-99"></a><span class="ss">        </span><span class="sc">{</span>sentences_str<span class="sc">}</span></span>
<span id="cb15-100"><a href="#cb15-100"></a></span>
<span id="cb15-101"><a href="#cb15-101"></a><span class="ss">        Use this plan:</span></span>
<span id="cb15-102"><a href="#cb15-102"></a><span class="ss">        </span><span class="sc">{</span>plan<span class="sc">}</span></span>
<span id="cb15-103"><a href="#cb15-103"></a></span>
<span id="cb15-104"><a href="#cb15-104"></a><span class="ss">        Requirements:</span></span>
<span id="cb15-105"><a href="#cb15-105"></a><span class="ss">        - Must include all 4 sentences word-for-word</span></span>
<span id="cb15-106"><a href="#cb15-106"></a><span class="ss">        - Create smooth transitions between sentences</span></span>
<span id="cb15-107"><a href="#cb15-107"></a><span class="ss">        - Maintain a consistent tone and narrative</span></span>
<span id="cb15-108"><a href="#cb15-108"></a></span>
<span id="cb15-109"><a href="#cb15-109"></a><span class="ss">        Write the passage:</span></span>
<span id="cb15-110"><a href="#cb15-110"></a><span class="ss">        """</span></span>
<span id="cb15-111"><a href="#cb15-111"></a>        </span>
<span id="cb15-112"><a href="#cb15-112"></a>        message <span class="op">=</span> <span class="va">self</span>.client.messages.create(</span>
<span id="cb15-113"><a href="#cb15-113"></a>            model<span class="op">=</span><span class="va">self</span>.model,</span>
<span id="cb15-114"><a href="#cb15-114"></a>            max_tokens<span class="op">=</span><span class="dv">600</span>,</span>
<span id="cb15-115"><a href="#cb15-115"></a>            temperature<span class="op">=</span><span class="fl">0.7</span>,</span>
<span id="cb15-116"><a href="#cb15-116"></a>            messages<span class="op">=</span>[{<span class="st">"role"</span>: <span class="st">"user"</span>, <span class="st">"content"</span>: prompt}]</span>
<span id="cb15-117"><a href="#cb15-117"></a>        )</span>
<span id="cb15-118"><a href="#cb15-118"></a>        </span>
<span id="cb15-119"><a href="#cb15-119"></a>        <span class="cf">return</span> message.content[<span class="dv">0</span>].text.strip()</span>
<span id="cb15-120"><a href="#cb15-120"></a>    </span>
<span id="cb15-121"><a href="#cb15-121"></a>    <span class="kw">def</span> solve(<span class="va">self</span>, sentences: List[<span class="bu">str</span>], b: <span class="bu">int</span> <span class="op">=</span> <span class="dv">3</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb15-122"><a href="#cb15-122"></a>        <span class="co">"""</span></span>
<span id="cb15-123"><a href="#cb15-123"></a><span class="co">        ToT로 창작 문제 해결</span></span>
<span id="cb15-124"><a href="#cb15-124"></a><span class="co">        """</span></span>
<span id="cb15-125"><a href="#cb15-125"></a>        <span class="bu">print</span>(<span class="ss">f"📝 Creative Writing with ToT"</span>)</span>
<span id="cb15-126"><a href="#cb15-126"></a>        <span class="bu">print</span>(<span class="ss">f"Sentences: </span><span class="sc">{</span>sentences<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb15-127"><a href="#cb15-127"></a>        </span>
<span id="cb15-128"><a href="#cb15-128"></a>        <span class="co"># Step 1: 여러 계획 생성</span></span>
<span id="cb15-129"><a href="#cb15-129"></a>        <span class="bu">print</span>(<span class="st">"Step 1: 계획 생성 중..."</span>)</span>
<span id="cb15-130"><a href="#cb15-130"></a>        plans <span class="op">=</span> <span class="va">self</span>.generate_plans(sentences, k<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb15-131"><a href="#cb15-131"></a>        <span class="bu">print</span>(<span class="ss">f"생성된 계획: </span><span class="sc">{</span><span class="bu">len</span>(plans)<span class="sc">}</span><span class="ss">개</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb15-132"><a href="#cb15-132"></a>        </span>
<span id="cb15-133"><a href="#cb15-133"></a>        <span class="co"># Step 2: 계획 평가</span></span>
<span id="cb15-134"><a href="#cb15-134"></a>        <span class="bu">print</span>(<span class="st">"Step 2: 계획 평가 중..."</span>)</span>
<span id="cb15-135"><a href="#cb15-135"></a>        evaluated_plans <span class="op">=</span> []</span>
<span id="cb15-136"><a href="#cb15-136"></a>        <span class="cf">for</span> i, plan <span class="kw">in</span> <span class="bu">enumerate</span>(plans):</span>
<span id="cb15-137"><a href="#cb15-137"></a>            score <span class="op">=</span> <span class="va">self</span>.evaluate_plan(sentences, plan)</span>
<span id="cb15-138"><a href="#cb15-138"></a>            evaluated_plans.append((plan, score))</span>
<span id="cb15-139"><a href="#cb15-139"></a>            <span class="bu">print</span>(<span class="ss">f"Plan </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: score = </span><span class="sc">{</span>score<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb15-140"><a href="#cb15-140"></a>        </span>
<span id="cb15-141"><a href="#cb15-141"></a>        <span class="co"># 상위 b개 선택</span></span>
<span id="cb15-142"><a href="#cb15-142"></a>        evaluated_plans.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-143"><a href="#cb15-143"></a>        top_plans <span class="op">=</span> evaluated_plans[:b]</span>
<span id="cb15-144"><a href="#cb15-144"></a>        </span>
<span id="cb15-145"><a href="#cb15-145"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">선택된 계획: </span><span class="sc">{</span><span class="bu">len</span>(top_plans)<span class="sc">}</span><span class="ss">개"</span>)</span>
<span id="cb15-146"><a href="#cb15-146"></a>        </span>
<span id="cb15-147"><a href="#cb15-147"></a>        <span class="co"># Step 3: 선택된 계획들로 글 작성</span></span>
<span id="cb15-148"><a href="#cb15-148"></a>        <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Step 3: 글 작성 중..."</span>)</span>
<span id="cb15-149"><a href="#cb15-149"></a>        passages <span class="op">=</span> []</span>
<span id="cb15-150"><a href="#cb15-150"></a>        <span class="cf">for</span> plan, score <span class="kw">in</span> top_plans:</span>
<span id="cb15-151"><a href="#cb15-151"></a>            passage <span class="op">=</span> <span class="va">self</span>.write_passage(sentences, plan)</span>
<span id="cb15-152"><a href="#cb15-152"></a>            passages.append((passage, score))</span>
<span id="cb15-153"><a href="#cb15-153"></a>        </span>
<span id="cb15-154"><a href="#cb15-154"></a>        <span class="co"># 최고 점수의 글 반환</span></span>
<span id="cb15-155"><a href="#cb15-155"></a>        best_passage, best_score <span class="op">=</span> passages[<span class="dv">0</span>]</span>
<span id="cb15-156"><a href="#cb15-156"></a>        </span>
<span id="cb15-157"><a href="#cb15-157"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">최종 선택: score = </span><span class="sc">{</span>best_score<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb15-158"><a href="#cb15-158"></a>        </span>
<span id="cb15-159"><a href="#cb15-159"></a>        <span class="cf">return</span> best_passage</span>
<span id="cb15-160"><a href="#cb15-160"></a></span>
<span id="cb15-161"><a href="#cb15-161"></a></span>
<span id="cb15-162"><a href="#cb15-162"></a><span class="co"># 사용 예시</span></span>
<span id="cb15-163"><a href="#cb15-163"></a><span class="kw">def</span> test_creative_writing():</span>
<span id="cb15-164"><a href="#cb15-164"></a>    sentences <span class="op">=</span> [</span>
<span id="cb15-165"><a href="#cb15-165"></a>        <span class="st">"The old lighthouse stood alone on the cliff."</span>,</span>
<span id="cb15-166"><a href="#cb15-166"></a>        <span class="st">"Sarah had always been afraid of the dark."</span>,</span>
<span id="cb15-167"><a href="#cb15-167"></a>        <span class="st">"The package arrived three days late."</span>,</span>
<span id="cb15-168"><a href="#cb15-168"></a>        <span class="st">"In his pocket, he found a key he didn't recognize."</span></span>
<span id="cb15-169"><a href="#cb15-169"></a>    ]</span>
<span id="cb15-170"><a href="#cb15-170"></a>    </span>
<span id="cb15-171"><a href="#cb15-171"></a>    writer <span class="op">=</span> ToT_CreativeWriting(api_key<span class="op">=</span><span class="st">"your-api-key"</span>)</span>
<span id="cb15-172"><a href="#cb15-172"></a>    passage <span class="op">=</span> writer.solve(sentences, b<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb15-173"><a href="#cb15-173"></a>    </span>
<span id="cb15-174"><a href="#cb15-174"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> <span class="st">"="</span><span class="op">*</span><span class="dv">80</span>)</span>
<span id="cb15-175"><a href="#cb15-175"></a>    <span class="bu">print</span>(<span class="st">"최종 결과:"</span>)</span>
<span id="cb15-176"><a href="#cb15-176"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">80</span>)</span>
<span id="cb15-177"><a href="#cb15-177"></a>    <span class="bu">print</span>(passage)</span>
<span id="cb15-178"><a href="#cb15-178"></a></span>
<span id="cb15-179"><a href="#cb15-179"></a></span>
<span id="cb15-180"><a href="#cb15-180"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb15-181"><a href="#cb15-181"></a>    test_creative_writing()</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="결과-예시" class="level3" data-number="6.3">
<h3 data-number="6.3" class="anchored" data-anchor-id="결과-예시"><span class="header-section-number">6.3</span> 결과 예시</h3>
<pre><code>📝 Creative Writing with ToT
Sentences: ['The old lighthouse stood alone on the cliff.', ...]

Step 1: 계획 생성 중...
생성된 계획: 5개

Step 2: 계획 평가 중...
Plan 1: score = 0.85 (Mystery/thriller structure)
Plan 2: score = 0.72 (Coming-of-age narrative)
Plan 3: score = 0.68 (Time-travel concept)
Plan 4: score = 0.55 (Random connection)
Plan 5: score = 0.61 (Surreal approach)

선택된 계획: 3개

Step 3: 글 작성 중...

최종 선택: score = 0.85

================================================================================
최종 결과:
================================================================================

The old lighthouse stood alone on the cliff, its beam cutting through 
the darkness that had haunted this coast for generations. Sarah had 
always been afraid of the dark, but tonight she climbed the spiral 
stairs with determination, clutching the mysterious package that had 
finally arrived—three days late, but perhaps right on time.

The package arrived three days late, yet its contents seemed meant for 
this exact moment. Inside, wrapped in aged newspaper, was a brass key 
and a faded photograph of the lighthouse keeper from 1952. In his pocket, 
he found a key he didn't recognize, the note had read, describing her 
grandfather's final days at this very lighthouse.

As she inserted the key into the old keeper's lockbox, Sarah understood. 
Her grandfather had left this for her, knowing that one day she would 
need to face her fear. The lighthouse—isolated, dark, but steady—had 
been waiting to teach her that some lights shine brightest in the deepest 
darkness.

With trembling hands, she lit the old lamp. For the first time since 
childhood, Sarah wasn't afraid of the dark. She had become the light.</code></pre>
</section>
<section id="creative-writing-성능" class="level3" data-number="6.4">
<h3 data-number="6.4" class="anchored" data-anchor-id="creative-writing-성능"><span class="header-section-number">6.4</span> Creative Writing 성능</h3>
<table class="table">
<thead>
<tr class="header">
<th>방법</th>
<th>Coherence Score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>IO prompt</td>
<td>6.2/10</td>
</tr>
<tr class="even">
<td>CoT prompt</td>
<td>6.8/10</td>
</tr>
<tr class="odd">
<td><strong>ToT (b=1)</strong></td>
<td><strong>7.5/10</strong></td>
</tr>
<tr class="even">
<td><strong>ToT (b=5)</strong></td>
<td><strong>7.9/10</strong></td>
</tr>
</tbody>
</table>
<p>ToT는 여러 계획을 평가하고 최선의 구조를 선택함으로써 더 일관성 있는 글을 작성한다.</p>
</section>
</section>
<section id="한계점-및-비용-분석" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="한계점-및-비용-분석"><span class="header-section-number">7</span> 한계점 및 비용 분석</h2>
<section id="연산-비용" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="연산-비용"><span class="header-section-number">7.1</span> 연산 비용</h3>
<p>ToT의 가장 큰 한계는 <strong>높은 연산 비용</strong>이다.</p>
<p><strong>비용 계산 (Game of 24 예시)</strong>:</p>
<pre><code>설정:
- Beam width (b) = 5
- 각 단계에서 생성하는 생각 (k) = 5
- 단계 수 (d) = 3

총 API 호출 횟수:

Step 1: 
  - 생각 생성: b × k = 5 × 5 = 25회
  - 평가: 25회
  - 소계: 50회

Step 2:
  - 생각 생성: 5 × 5 = 25회
  - 평가: 25회
  - 소계: 50회

Step 3:
  - 생각 생성: 5 × 5 = 25회
  - 평가: 25회
  - 소계: 50회

총 API 호출: 150회</code></pre>
<p><strong>비용 비교</strong>:</p>
<table class="table">
<thead>
<tr class="header">
<th>방법</th>
<th>API 호출</th>
<th>상대 비용</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>IO</td>
<td>1회</td>
<td>1×</td>
</tr>
<tr class="even">
<td>CoT</td>
<td>1회</td>
<td>1×</td>
</tr>
<tr class="odd">
<td>CoT-SC (k=5)</td>
<td>5회</td>
<td>5×</td>
</tr>
<tr class="even">
<td><strong>ToT (b=5, k=5, d=3)</strong></td>
<td><strong>150회</strong></td>
<td><strong>150×</strong></td>
</tr>
</tbody>
</table>
<p><strong>현실적 비용</strong>:</p>
<p>Claude Sonnet 4 기준 ($3/MTok input, $15/MTok output):</p>
<pre><code>Game of 24 문제 1개:
- 평균 input: 200 tokens/call
- 평균 output: 50 tokens/call
- 총 150회 호출

비용 = (200 × 150 × $3 + 50 × 150 × $15) / 1,000,000
     = (90,000 + 112,500) / 1,000,000
     = $0.20 per problem

CoT: $0.001 per problem

→ ToT는 CoT보다 200배 비쌈</code></pre>
</section>
<section id="시간-지연" class="level3" data-number="7.2">
<h3 data-number="7.2" class="anchored" data-anchor-id="시간-지연"><span class="header-section-number">7.2</span> 시간 지연</h3>
<p>순차적 API 호출로 인한 레이턴시:</p>
<pre><code>각 API 호출: 평균 2초
총 150회 → 300초 = 5분

병렬 처리로 개선 가능하지만 제한적:
- 생각 생성: 병렬 가능 (동시에 k개)
- 평가: 병렬 가능
- 단계 간: 순차적 (피할 수 없음)

최적화된 시간: 약 20-30초
CoT: 2초

→ ToT는 10-15배 느림</code></pre>
</section>
<section id="적용-범위의-제한" class="level3" data-number="7.3">
<h3 data-number="7.3" class="anchored" data-anchor-id="적용-범위의-제한"><span class="header-section-number">7.3</span> 적용 범위의 제한</h3>
<p>ToT가 효과적인 문제는 매우 제한적이다:</p>
<p><strong>ToT가 적합한 문제</strong>: - ✅ 명확한 중간 단계가 있음 - ✅ 각 단계를 독립적으로 평가 가능 - ✅ 백트래킹이 필요함 - ✅ 최적해를 찾는 것이 중요함</p>
<p><strong>ToT가 부적합한 문제</strong>: - ❌ 단순한 Q&amp;A - ❌ 요약, 번역 등 직접적인 변환 - ❌ 개방형 창작 (평가 기준 모호) - ❌ 실시간 응답이 필요한 경우</p>
<p><strong>실제 적용 가능한 분야</strong>: 1. <strong>전략 게임 / 퍼즐</strong>: 체스, 바둑, 수학 퍼즐 2. <strong>복잡한 문제 해결</strong>: 알고리즘 설계, 증명 3. <strong>창작 작업</strong>: 구조화된 글쓰기 (제약 조건 있음) 4. <strong>코드 생성</strong>: 복잡한 로직 (여러 접근 방식 비교)</p>
</section>
<section id="gpt-4o의-성능-향상" class="level3" data-number="7.4">
<h3 data-number="7.4" class="anchored" data-anchor-id="gpt-4o의-성능-향상"><span class="header-section-number">7.4</span> GPT-4/o의 성능 향상</h3>
<p>논문 발표 이후 GPT-4, GPT-4o, Claude 3/4 등 최신 모델들이 등장했다:</p>
<p><strong>현재 상황</strong>:</p>
<pre><code>Game of 24 (4, 9, 10, 13):

GPT-3.5 (2022):
  - IO: 7.3%
  - CoT: 4.0%
  - ToT: 74%
  → ToT가 압도적으로 필요

GPT-4 (2023):
  - IO: 약 40%
  - CoT: 약 60%
  - ToT: 약 85%
  → 여전히 ToT가 좋지만 격차 감소

Claude Sonnet 4 (2024):
  - IO: 약 50-60%
  - CoT: 약 70-80%
  - ToT: 약 90%
  → 대부분의 경우 CoT로 충분</code></pre>
<p><strong>결론</strong>: 최신 모델은 단순 CoT만으로도 많은 문제를 잘 풀기 때문에, ToT가 실제로 필요한 경우는 더욱 줄어들었다.</p>
</section>
</section>
<section id="tree-of-thought-prompting-단순화-버전" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="tree-of-thought-prompting-단순화-버전"><span class="header-section-number">8</span> Tree-of-Thought-Prompting (단순화 버전)</h2>
<p>ToT의 전체 프레임워크는 복잡하지만, 핵심 아이디어를 단순한 프롬프트로 구현할 수 있다. Hulbert (2023)가 제안한 방법이다.</p>
<section id="기본-패턴" class="level3" data-number="8.1">
<h3 data-number="8.1" class="anchored" data-anchor-id="기본-패턴"><span class="header-section-number">8.1</span> 기본 패턴</h3>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a>SIMPLE_TOT_PROMPT <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="st">Imagine three different experts are answering this question.</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="st">All experts will write down 1 step of their thinking, then share it with the group.</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="st">Then all experts will go on to the next step, etc.</span></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="st">If any expert realizes they're wrong at any point then they leave.</span></span>
<span id="cb21-6"><a href="#cb21-6"></a></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="st">The question is: </span><span class="sc">{question}</span></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="st">"""</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="고급-패턴-1-협업-전문가" class="level3" data-number="8.2">
<h3 data-number="8.2" class="anchored" data-anchor-id="고급-패턴-1-협업-전문가"><span class="header-section-number">8.2</span> 고급 패턴 1: 협업 전문가</h3>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a>COLLABORATIVE_TOT_PROMPT <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="st">Simulate three brilliant, logical experts collaboratively answering a question.</span></span>
<span id="cb22-3"><a href="#cb22-3"></a></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="st">Each one verbosely explains their thought process in real-time, considering the </span></span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="st">prior explanations of others and openly acknowledging mistakes.</span></span>
<span id="cb22-6"><a href="#cb22-6"></a></span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="st">At each step, whenever possible, each expert refines and builds upon the thoughts </span></span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="st">of others, acknowledging their contributions.</span></span>
<span id="cb22-9"><a href="#cb22-9"></a></span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="st">They continue until there is a definitive answer to the question.</span></span>
<span id="cb22-11"><a href="#cb22-11"></a></span>
<span id="cb22-12"><a href="#cb22-12"></a><span class="st">For clarity, your entire response should be in a markdown table.</span></span>
<span id="cb22-13"><a href="#cb22-13"></a></span>
<span id="cb22-14"><a href="#cb22-14"></a><span class="st">The question is: </span><span class="sc">{question}</span></span>
<span id="cb22-15"><a href="#cb22-15"></a><span class="st">"""</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="고급-패턴-2-동료-평가" class="level3" data-number="8.3">
<h3 data-number="8.3" class="anchored" data-anchor-id="고급-패턴-2-동료-평가"><span class="header-section-number">8.3</span> 고급 패턴 2: 동료 평가</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a>PEER_REVIEW_TOT_PROMPT <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="st">Identify and behave as three different experts that are appropriate to answering </span></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="st">this question.</span></span>
<span id="cb23-4"><a href="#cb23-4"></a></span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="st">All experts will write down the step and their thinking about the step, then </span></span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="st">share it with the group.</span></span>
<span id="cb23-7"><a href="#cb23-7"></a></span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="st">Then, all experts will go on to the next step, etc.</span></span>
<span id="cb23-9"><a href="#cb23-9"></a></span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="st">At each step all experts will score their peers' responses between 1 and 5, </span></span>
<span id="cb23-11"><a href="#cb23-11"></a><span class="st">1 meaning it is highly unlikely, and 5 meaning it is highly likely.</span></span>
<span id="cb23-12"><a href="#cb23-12"></a></span>
<span id="cb23-13"><a href="#cb23-13"></a><span class="st">If any expert is judged to be wrong at any point then they leave.</span></span>
<span id="cb23-14"><a href="#cb23-14"></a></span>
<span id="cb23-15"><a href="#cb23-15"></a><span class="st">After all experts have provided their analysis, you then analyze all 3 analyses </span></span>
<span id="cb23-16"><a href="#cb23-16"></a><span class="st">and provide either the consensus solution or your best guess solution.</span></span>
<span id="cb23-17"><a href="#cb23-17"></a></span>
<span id="cb23-18"><a href="#cb23-18"></a><span class="st">The question is: </span><span class="sc">{question}</span></span>
<span id="cb23-19"><a href="#cb23-19"></a><span class="st">"""</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="다른-기법과의-비교" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="다른-기법과의-비교"><span class="header-section-number">9</span> 다른 기법과의 비교</h2>
<section id="tot-vs-cot" class="level3" data-number="9.1">
<h3 data-number="9.1" class="anchored" data-anchor-id="tot-vs-cot"><span class="header-section-number">9.1</span> ToT vs CoT</h3>
<table class="table">
<thead>
<tr class="header">
<th>특성</th>
<th>Chain-of-Thought</th>
<th>Tree of Thoughts</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>구조</strong></td>
<td>선형 (linear)</td>
<td>트리 (tree)</td>
</tr>
<tr class="even">
<td><strong>백트래킹</strong></td>
<td>❌ 불가능</td>
<td>✅ 가능</td>
</tr>
<tr class="odd">
<td><strong>탐색</strong></td>
<td>한 경로만</td>
<td>여러 경로</td>
</tr>
<tr class="even">
<td><strong>비용</strong></td>
<td>낮음 (1× )</td>
<td>매우 높음 (100×+)</td>
</tr>
<tr class="odd">
<td><strong>속도</strong></td>
<td>빠름</td>
<td>느림</td>
</tr>
<tr class="even">
<td><strong>적용 범위</strong></td>
<td>넓음</td>
<td>좁음</td>
</tr>
<tr class="odd">
<td><strong>구현 복잡도</strong></td>
<td>낮음</td>
<td>높음</td>
</tr>
</tbody>
</table>
<p><strong>언제 CoT를 사용하나?</strong> - ✅ 대부분의 추론 문제 - ✅ 실시간 응답 필요 - ✅ 비용 제약</p>
<p><strong>언제 ToT를 사용하나?</strong> - ✅ 전략적 계획이 필수 - ✅ 정확도가 최우선 - ✅ 비용/시간 여유</p>
</section>
<section id="tot-vs-self-consistency" class="level3" data-number="9.2">
<h3 data-number="9.2" class="anchored" data-anchor-id="tot-vs-self-consistency"><span class="header-section-number">9.2</span> ToT vs Self-Consistency</h3>
<p><strong>Self-Consistency</strong>:</p>
<pre><code>같은 질문 → [CoT 1] → 답변 1
            → [CoT 2] → 답변 2
            → [CoT 3] → 답변 3
            ...
            → [CoT N] → 답변 N
            
다수결 → 최종 답변</code></pre>
<p><strong>ToT</strong>:</p>
<pre><code>질문 → [생각 1a, 1b, 1c] → 평가 → 선택
     → [생각 2a, 2b, 2c] → 평가 → 선택
     → [생각 3a, 3b, 3c] → 평가 → 선택
     → 최종 답변</code></pre>
<table class="table">
<thead>
<tr class="header">
<th>특성</th>
<th>Self-Consistency</th>
<th>Tree of Thoughts</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>다양성</strong></td>
<td>높음 (독립 샘플)</td>
<td>중간 (제약된 탐색)</td>
</tr>
<tr class="even">
<td><strong>전략</strong></td>
<td>없음 (무작위)</td>
<td>있음 (평가 기반)</td>
</tr>
<tr class="odd">
<td><strong>효율성</strong></td>
<td>낮음</td>
<td>높음</td>
</tr>
<tr class="even">
<td><strong>적용</strong></td>
<td>답이 이산적인 경우</td>
<td>복잡한 계획 필요</td>
</tr>
</tbody>
</table>
<p><strong>조합 가능?</strong>: 네! ToT의 마지막 단계에서 Self-Consistency 적용 가능.</p>
</section>
<section id="tot-vs-rag" class="level3" data-number="9.3">
<h3 data-number="9.3" class="anchored" data-anchor-id="tot-vs-rag"><span class="header-section-number">9.3</span> ToT vs RAG</h3>
<p><strong>비교 자체가 의미 없음</strong>: 다른 목적의 기법</p>
<ul>
<li><strong>RAG</strong>: 외부 지식 활용</li>
<li><strong>ToT</strong>: 내부 추론 개선</li>
</ul>
<p><strong>조합 전략</strong>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">def</span> rag_with_tot(query: <span class="bu">str</span>):</span>
<span id="cb26-2"><a href="#cb26-2"></a>    <span class="co"># Step 1: RAG로 관련 문서 검색</span></span>
<span id="cb26-3"><a href="#cb26-3"></a>    docs <span class="op">=</span> retrieve_documents(query)</span>
<span id="cb26-4"><a href="#cb26-4"></a>    </span>
<span id="cb26-5"><a href="#cb26-5"></a>    <span class="co"># Step 2: ToT로 문서 기반 추론</span></span>
<span id="cb26-6"><a href="#cb26-6"></a>    answer <span class="op">=</span> tot_reasoning(query, docs)</span>
<span id="cb26-7"><a href="#cb26-7"></a>    </span>
<span id="cb26-8"><a href="#cb26-8"></a>    <span class="cf">return</span> answer</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="실무-적용-시나리오-현실적-평가" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="실무-적용-시나리오-현실적-평가"><span class="header-section-number">10</span> 실무 적용 시나리오 (현실적 평가)</h2>
<section id="코드-리팩토링" class="level3" data-number="10.1">
<h3 data-number="10.1" class="anchored" data-anchor-id="코드-리팩토링"><span class="header-section-number">10.1</span> 코드 리팩토링</h3>
<p><strong>문제</strong>: 레거시 코드 리팩토링 전략 수립</p>
<p><strong>평가</strong>: - <strong>추천 가능</strong>: 여러 리팩토링 전략 비교에 유용 - <strong>효과</strong>: 단순 CoT보다 20-30% 나은 제안 - <strong>활용법</strong>: <code>Step 1: 여러 리팩토링 계획 생성   Step 2: 각 계획의 장단점 평가   Step 3: 최적 계획 선택 및 상세화</code></p>
</section>
<section id="창작-지원-도구" class="level3" data-number="10.2">
<h3 data-number="10.2" class="anchored" data-anchor-id="창작-지원-도구"><span class="header-section-number">10.2</span> 창작 지원 도구</h3>
<p><strong>문제</strong>: 소설/시나리오 구조 설계</p>
<p><strong>평가</strong>: - <strong>추천</strong>: 여러 플롯 구조 비교에 효과적 - <strong>강점</strong>: 창의적 대안 제시 - <strong>주의</strong>: 평가 기준이 주관적이라 조정 필요</p>
</section>
</section>
<section id="정리-및-결론" class="level2" data-number="11">
<h2 data-number="11" class="anchored" data-anchor-id="정리-및-결론"><span class="header-section-number">11</span> 정리 및 결론</h2>
<section id="핵심-요약" class="level3" data-number="11.1">
<h3 data-number="11.1" class="anchored" data-anchor-id="핵심-요약"><span class="header-section-number">11.1</span> 핵심 요약</h3>
<p><strong>Tree of Thoughts의 핵심</strong>: - 여러 추론 경로를 트리로 탐색 - 백트래킹으로 실수 복구 - 평가 기반 전략적 탐색 - CoT를 뛰어넘는 복잡한 문제 해결</p>
<p><strong>현실적 평가</strong>: - <strong>학술적 가치</strong>: 매우 높음 (추론 메커니즘 이해) - <strong>실무 적용</strong>: 매우 제한적 - <strong>비용</strong>: 100배+ 비쌈 - <strong>최신 모델</strong>: 단순 CoT로 충분한 경우 많음</p>
</section>
<section id="언제-tot를-사용할-것인가" class="level3" data-number="11.2">
<h3 data-number="11.2" class="anchored" data-anchor-id="언제-tot를-사용할-것인가"><span class="header-section-number">11.2</span> 언제 ToT를 사용할 것인가?</h3>
<p><strong>사용하라</strong>: - 전략 게임, 복잡한 퍼즐 - 최적해가 절대적으로 필요한 경우 - 비용/시간이 문제되지 않는 연구/데모 - 여러 접근법을 체계적으로 비교해야 할 때</p>
<p><strong>사용하지 마라</strong>: - 일반적인 Q&amp;A - 실시간 서비스 - 비용에 민감한 프로덕션 - 최신 강력한 모델 + CoT로 충분한 경우</p>
</section>
<section id="미래-전망" class="level3" data-number="11.3">
<h3 data-number="11.3" class="anchored" data-anchor-id="미래-전망"><span class="header-section-number">11.3</span> 미래 전망</h3>
<p><strong>개선 방향</strong>: 1. <strong>효율성</strong>: 불필요한 탐색 줄이기 2. <strong>자동화</strong>: 평가 함수 자동 학습 3. <strong>하이브리드</strong>: 다른 기법과 결합 4. <strong>경량화</strong>: Simple ToT 스타일의 실용적 변형</p>
<p><strong>장기 전망</strong>: - 모델 성능 향상으로 필요성 감소 - 특수한 도메인에서만 생존 - 아이디어는 에이전트 시스템에 통합될 가능성</p>
</section>
</section>
<section id="참고문헌" class="level2" data-number="12">
<h2 data-number="12" class="anchored" data-anchor-id="참고문헌"><span class="header-section-number">12</span> 참고문헌</h2>
<ol type="1">
<li><p>Yao, S., Yu, D., Zhao, J., Shafran, I., Griffiths, T., Cao, Y., &amp; Narasimhan, K. (2024). <strong>Tree of thoughts: Deliberate problem solving with large language models.</strong> <em>Advances in Neural Information Processing Systems, 36</em>.</p></li>
<li><p>Wei, J., et al.&nbsp;(2022). <strong>Chain-of-thought prompting elicits reasoning in large language models.</strong> <em>Advances in Neural Information Processing Systems, 35</em>, 24824-24837.</p></li>
<li><p>Hulbert, D. (2023). <strong>Tree-of-thought prompting.</strong> <em>GitHub Repository</em>. https://github.com/dave1010/tree-of-thought-prompting</p></li>
<li><p>Wang, X., et al.&nbsp;(2022). <strong>Self-consistency improves chain of thought reasoning in language models.</strong> <em>arXiv preprint arXiv:2203.11171</em>.</p></li>
</ol>


</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>