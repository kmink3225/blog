<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="5가지 주요 직군(리서치/보고서 작성, Product Manager, 엔지니어, 마케터)의 실무에 즉시 활용 가능한 프롬프트 템플릿과 설계 전략을 체계적으로 제시한다. 비즈니스 보고서 9단계 구조(Title Page ~ Appendices), PM 브레인스토밍 5단계 프로세스, Python 코드 리서치용 XML 태그 구조, 디버깅용 5단계 debug_analysis, 마케터용 메타 프롬프트 생성 기법 등 각 직군의 업무 프로세스와 산출물에 최적화된 템플릿 구조를 상세히 분석한다. 변수 설계({{REPORT_TOPIC}}, {{PYTHON_CODE}}, {{MARKETING_GOAL}}), 페르소나 정의(professional/factual/objective), 출력 형식 제어, 체크리스트 기반 자기 검토 등 프롬프트 엔지니어링의 핵심 설계 원칙과 템플릿 커스터마이징, 조합, 라이브러리 구축 전략을 포함한 완전한 실무 가이드를 제공한다.">

<title>Kwangmin Kim - 직군별 프롬프트 템플릿: 도메인 특화 실무 가이드</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - 직군별 프롬프트 템플릿: 도메인 특화 실무 가이드">
<meta property="og:description" content="5가지 주요 직군(리서치/보고서 작성, Product Manager, 엔지니어, 마케터)의 실무에 즉시 활용 가능한 프롬프트 템플릿과 설계 전략을 체계적으로 제시한다. 비즈니스 보고서 9단계 구조(Title Page ~ Appendices), PM 브레인스토밍 5단계 프로세스, Python 코드 리서치용 XML 태그 구조, 디버깅용 5단계 debug_analysis, 마케터용 메타 프롬프트 생성 기법 등 각 직군의 업무 프로세스와 산출물에 최적화된 템플릿 구조를 상세히 분석한다. 변수 설계({{REPORT_TOPIC}}, {{PYTHON_CODE}}, {{MARKETING_GOAL}}), 페르소나 정의(professional/factual/objective), 출력 형식 제어, 체크리스트 기반 자기 검토 등 프롬프트 엔지니어링의 핵심 설계 원칙과 템플릿 커스터마이징, 조합, 라이브러리 구축 전략을 포함한 완전한 실무 가이드를 제공한다.">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Kwangmin Kim - 직군별 프롬프트 템플릿: 도메인 특화 실무 가이드">
<meta name="twitter:description" content="5가지 주요 직군(리서치/보고서 작성, Product Manager, 엔지니어, 마케터)의 실무에 즉시 활용 가능한 프롬프트 템플릿과 설계 전략을 체계적으로 제시한다. 비즈니스 보고서 9단계 구조(Title Page ~ Appendices), PM 브레인스토밍 5단계 프로세스, Python 코드 리서치용 XML 태그 구조, 디버깅용 5단계 debug_analysis, 마케터용 메타 프롬프트 생성 기법 등 각 직군의 업무 프로세스와 산출물에 최적화된 템플릿 구조를 상세히 분석한다. 변수 설계({{REPORT_TOPIC}}, {{PYTHON_CODE}}, {{MARKETING_GOAL}}), 페르소나 정의(professional/factual/objective), 출력 형식 제어, 체크리스트 기반 자기 검토 등 프롬프트 엔지니어링의 핵심 설계 원칙과 템플릿 커스터마이징, 조합, 라이브러리 구축 전략을 포함한 완전한 실무 가이드를 제공한다.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">직군별 프롬프트 템플릿: 도메인 특화 실무 가이드</h1>
            <p class="subtitle lead">리서치, PM, 엔지니어, 마케터를 위한 검증된 프롬프트 설계</p>
                  <div>
        <div class="description">
          <p>5가지 주요 직군(리서치/보고서 작성, Product Manager, 엔지니어, 마케터)의 실무에 즉시 활용 가능한 프롬프트 템플릿과 설계 전략을 체계적으로 제시한다. 비즈니스 보고서 9단계 구조(Title Page ~ Appendices), PM 브레인스토밍 5단계 프로세스, Python 코드 리서치용 XML 태그 구조, 디버깅용 5단계 debug_analysis, 마케터용 메타 프롬프트 생성 기법 등 각 직군의 업무 프로세스와 산출물에 최적화된 템플릿 구조를 상세히 분석한다. 변수 설계({{REPORT_TOPIC}}, {{PYTHON_CODE}}, {{MARKETING_GOAL}}), 페르소나 정의(professional/factual/objective), 출력 형식 제어, 체크리스트 기반 자기 검토 등 프롬프트 엔지니어링의 핵심 설계 원칙과 템플릿 커스터마이징, 조합, 라이브러리 구축 전략을 포함한 완전한 실무 가이드를 제공한다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Prompt Engineering</div>
                <div class="quarto-category">LLM</div>
                <div class="quarto-category">AI</div>
                <div class="quarto-category">Agent</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2026년 02월 02일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#직군별-프롬프트-템플릿" id="toc-직군별-프롬프트-템플릿" class="nav-link active" data-scroll-target="#직군별-프롬프트-템플릿"><span class="header-section-number">1</span> 직군별 프롬프트 템플릿</a>
  <ul class="collapse">
  <li><a href="#직군별-템플릿의-전략적-가치" id="toc-직군별-템플릿의-전략적-가치" class="nav-link" data-scroll-target="#직군별-템플릿의-전략적-가치"><span class="header-section-number">1.1</span> 직군별 템플릿의 전략적 가치</a></li>
  <li><a href="#리서치보고서-작성-프롬프트-템플릿" id="toc-리서치보고서-작성-프롬프트-템플릿" class="nav-link" data-scroll-target="#리서치보고서-작성-프롬프트-템플릿"><span class="header-section-number">1.2</span> 리서치/보고서 작성 프롬프트 템플릿</a></li>
  <li><a href="#브레인스토밍-템플릿-product-manager용" id="toc-브레인스토밍-템플릿-product-manager용" class="nav-link" data-scroll-target="#브레인스토밍-템플릿-product-manager용"><span class="header-section-number">1.3</span> 브레인스토밍 템플릿 (Product Manager용)</a></li>
  <li><a href="#엔지니어-python-코드-리서치-템플릿" id="toc-엔지니어-python-코드-리서치-템플릿" class="nav-link" data-scroll-target="#엔지니어-python-코드-리서치-템플릿"><span class="header-section-number">1.4</span> 엔지니어 Python 코드 리서치 템플릿</a></li>
  <li><a href="#엔지니어-python-코드-디버깅-템플릿" id="toc-엔지니어-python-코드-디버깅-템플릿" class="nav-link" data-scroll-target="#엔지니어-python-코드-디버깅-템플릿"><span class="header-section-number">1.5</span> 엔지니어 Python 코드 디버깅 템플릿</a></li>
  <li><a href="#마케터-프롬프트-템플릿" id="toc-마케터-프롬프트-템플릿" class="nav-link" data-scroll-target="#마케터-프롬프트-템플릿"><span class="header-section-number">1.6</span> 마케터 프롬프트 템플릿</a></li>
  <li><a href="#직군별-템플릿의-실전-활용-전략" id="toc-직군별-템플릿의-실전-활용-전략" class="nav-link" data-scroll-target="#직군별-템플릿의-실전-활용-전략"><span class="header-section-number">1.7</span> 직군별 템플릿의 실전 활용 전략</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="직군별-프롬프트-템플릿" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 직군별 프롬프트 템플릿</h1>
<section id="직군별-템플릿의-전략적-가치" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="직군별-템플릿의-전략적-가치"><span class="header-section-number">1.1</span> 직군별 템플릿의 전략적 가치</h2>
<p>직군별 프롬프트 템플릿은 일반적인 범용 프롬프트와 근본적으로 다른 접근이다. 각 직군의 고유한 업무 프로세스, 용어, 산출물 형식을 반영하여 설계된다.</p>
<p><strong>템플릿화의 핵심 이점</strong></p>
<p>범용 프롬프트는 “무엇이든 할 수 있지만 아무것도 완벽하지 않다”는 한계가 있다. 반면 직군별 템플릿은 해당 직군의 80% 업무를 커버하도록 최적화되어 있어, 즉시 실무에 투입 가능하다.</p>
<p>예를 들어 마케터가 “블로그 글 써줘”라고 하면 AI는 어떤 톤으로, 어떤 구조로, 어떤 길이로 써야 할지 모른다. 하지만 마케터용 템플릿은 “SEO 최적화, 명확한 CTA, 독자 페르소나 반영”같은 마케팅 전문 요구사항이 이미 내장되어 있다.</p>
<p><strong>템플릿의 재사용성</strong></p>
<p>한 번 검증된 템플릿은 팀 전체가 공유할 수 있다. 신입 직원도 선임의 노하우가 담긴 프롬프트를 즉시 사용할 수 있다. 이는 업무 품질의 하한선을 올리는 효과가 있다.</p>
</section>
<section id="리서치보고서-작성-프롬프트-템플릿" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="리서치보고서-작성-프롬프트-템플릿"><span class="header-section-number">1.2</span> 리서치/보고서 작성 프롬프트 템플릿</h2>
<pre><code>You are responsible for writing a formal business report that is
professional, factual, and objective.

Report Topic:
{{REPORT_TOPIC}}

Company Data:
{{COMPANY_DATA}}

Report Structure:
1. Title Page
2. Table of Contents
3. Executive Summary
4. Introduction
5. Main Body (with subheadings)
6. Conclusion
7. Recommendations
8. References (if needed)
9. Appendices (if needed)

Section Guidelines:
1. Title Page: Include the report title, your name, date, and company name.
2. Table of Contents: List sections with page numbers.
3. Executive Summary: Brief overview (max 1 page) of key points and
   recommendations.
4. Introduction: State the report's purpose, background, and scope.
5. Main Body: Present findings and analysis based on the company data. 
   Use clear headings.
6. Conclusion: Summarize key findings.
7. Recommendations: Provide actionable suggestions for the company.
8. References: List external sources, if used.
9. Appendices: Add any detailed supporting information.

Before Submitting:
• Check for logical flow and coherence.
• Proofread for errors.
• Ensure all data is accurate and sections align with the topic.</code></pre>
<p><strong>템플릿 구조 분석</strong></p>
<p><strong>역할 정의: “formal business report”의 3가지 속성</strong></p>
<p>“professional, factual, and objective”는 단순한 수식어가 아니다. 각각이 구체적 제약을 만든다.</p>
<ul>
<li><strong>Professional</strong>: 비속어 금지, 격식 있는 어투, 시각 자료는 차트/표로 제한<br>
</li>
<li><strong>Factual</strong>: 추측 금지, 모든 주장은 데이터로 뒷받침, 감정적 표현 배제<br>
</li>
<li><strong>Objective</strong>: 회사에 유리한 정보만 선택하지 않음, 장단점 균형 있게 제시</li>
</ul>
<p>이 세 단어가 없으면 AI는 마케팅 자료처럼 과장하거나, 블로그 글처럼 캐주얼하게 쓸 수 있다.</p>
<p><strong>변수 설계: {{REPORT_TOPIC}}과 {{COMPANY_DATA}}</strong></p>
<p>두 개의 변수만 제공하면 보고서 전체가 생성된다. 이는 템플릿의 핵심 가치다.</p>
<p>{{REPORT_TOPIC}} 예시:<br>
- “2024년 4분기 매출 감소 원인 분석”<br>
- “신규 시장 진입 타당성 검토”<br>
- “경쟁사 A의 전략 분석 및 대응 방안”</p>
<p>{{COMPANY_DATA}} 예시:<br>
- 매출 데이터 (CSV, 표 형태)<br>
- 고객 피드백 (텍스트)<br>
- 경쟁사 자료 (수집한 정보)</p>
<p><strong>9단계 구조의 실무적 정당성</strong></p>
<p>이 구조는 비즈니스 보고서의 국제 표준이다. MBA 교육, 컨설팅 펌, 대기업에서 공통적으로 사용한다.</p>
<p><strong>왜 이 순서인가?</strong></p>
<ol type="1">
<li><strong>Title Page</strong>: 첫인상, 누가 썼고 무엇에 관한 것인가<br>
</li>
<li><strong>Table of Contents</strong>: 독자가 원하는 섹션으로 바로 점프<br>
</li>
<li><strong>Executive Summary</strong>: 바쁜 경영진은 이것만 읽는다<br>
</li>
<li><strong>Introduction</strong>: 왜 이 보고서가 필요한가<br>
</li>
<li><strong>Main Body</strong>: 실제 분석과 발견<br>
</li>
<li><strong>Conclusion</strong>: 발견 사항 종합<br>
</li>
<li><strong>Recommendations</strong>: 실행 가능한 제안<br>
</li>
<li><strong>References</strong>: 신뢰성 확보<br>
</li>
<li><strong>Appendices</strong>: 본문을 방해하지 않으면서 상세 자료 제공</li>
</ol>
<p><strong>Section Guidelines의 정교함</strong></p>
<p>각 섹션마다 구체적 지침이 있다. 특히 주목할 점:</p>
<p><strong>“Executive Summary: max 1 page”</strong><br>
페이지 제한은 중요하다. 제한이 없으면 AI는 2~3페이지를 쓸 수 있다. 하지만 Executive Summary의 본질은 “한 페이지에 모든 것”이다. 경영진이 엘리베이터 타는 동안 읽을 수 있어야 한다.</p>
<p><strong>“Main Body: Use clear headings”</strong><br>
보고서의 가독성은 제목 구조에서 결정된다. 명확한 제목이 없으면 독자는 길을 잃는다. “Use clear headings”는 AI에게 2~3 레벨의 계층적 제목 구조를 만들라는 암묵적 지시다.</p>
<p><strong>“Recommendations: Provide actionable suggestions”</strong><br>
“Actionable”이 핵심이다. “더 노력해야 한다”는 권고가 아니라, “분기별 고객 만족도 설문을 도입하고, 결과를 제품 팀과 공유한다”같은 구체적 행동이 필요하다.</p>
<p><strong>Before Submitting 체크리스트의 역할</strong></p>
<p>이 섹션은 AI에게 자기 검토를 요구한다. “보고서를 쓰고 나서 다시 읽어보고 이 세 가지를 확인하라”는 메타 지시다.</p>
<ul>
<li><strong>Logical flow</strong>: 섹션 간 연결이 자연스러운가?<br>
</li>
<li><strong>Proofread</strong>: 오타, 문법 오류는 없는가?<br>
</li>
<li><strong>Data accuracy</strong>: 숫자가 일치하는가? 출처가 명확한가?</li>
</ul>
<p>이런 체크리스트가 없으면 AI는 일관성 없는 보고서를 생성할 수 있다. 예를 들어 Introduction에서 “3가지 핵심 발견”을 언급했는데 Main Body에서 2가지만 다루는 식이다.</p>
</section>
<section id="브레인스토밍-템플릿-product-manager용" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="브레인스토밍-템플릿-product-manager용"><span class="header-section-number">1.3</span> 브레인스토밍 템플릿 (Product Manager용)</h2>
<pre><code>You are a Product Manager tasked with brainstorming creative and 
practical ideas for the following topic:

Topic: {{TOPIC}}
Context: {{CONTEXT}}

Steps for the brainstorming session:
1. Analyze the topic and context. Think about user needs, business goals, 
   and potential solutions.
2. Generate 5 distinct ideas that address the topic from different perspectives.
3. For each idea, include:
   - A title (1-5 words)
   - A short description (2-3 sentences)
   - One potential benefit
   - One possible challenge
4. Identify common themes across your ideas.
5. Combine two or more ideas to create a more comprehensive solution.

Answer in Korean.</code></pre>
<p><strong>Product Manager 페르소나의 함의</strong></p>
<p>Product Manager는 특정한 사고방식을 가진다. 엔지니어처럼 기술적 실현 가능성만 보지 않고, 마케터처럼 홍보만 생각하지도 않는다. 대신 “사용자 니즈 + 비즈니스 목표 + 기술 제약”의 교집합을 찾는다.</p>
<p>“Think about user needs, business goals, and potential solutions”는 이 3가지 차원을 모두 고려하라는 명시적 지시다.</p>
<p><strong>5개 아이디어의 다양성 전략</strong></p>
<p>“5 distinct ideas”에서 “distinct”가 중요하다. 비슷비슷한 아이디어 5개가 아니라, 서로 다른 관점의 아이디어를 요구한다.</p>
<p><strong>어떻게 다양성을 확보하는가?</strong></p>
<p>AI는 보통 첫 번째 아이디어를 생성한 후, 그것의 변형을 만드는 경향이 있다. “distinct”라는 단어는 이를 방지한다. 각 아이디어가 다른 접근법을 사용하도록 강제한다.</p>
<p>예를 들어 “사용자 리텐션 개선” 주제라면:<br>
- 아이디어 1: 푸시 알림 개선 (기술적 접근)<br>
- 아이디어 2: 리워드 프로그램 (비즈니스 접근)<br>
- 아이디어 3: 커뮤니티 기능 추가 (소셜 접근)<br>
- 아이디어 4: 온보딩 프로세스 단순화 (UX 접근)<br>
- 아이디어 5: 프리미엄 기능 무료 체험 (마케팅 접근)</p>
<p><strong>4가지 요소 구조의 PM 방법론</strong></p>
<p>각 아이디어마다 제목, 설명, 이점, 과제를 요구한다. 이는 PM의 표준 평가 프레임워크다.</p>
<p><strong>Title (1-5 words)</strong><br>
짧은 제목은 커뮤니케이션 효율성을 높인다. 회의에서 “아이디어 3”이 아니라 “리워드 프로그램”이라고 부를 수 있다.</p>
<p><strong>Description (2-3 sentences)</strong><br>
간결함을 강제한다. 3문장으로 설명 못하면 아이디어가 아직 명확하지 않다는 신호다.</p>
<p><strong>One potential benefit</strong><br>
“왜 이게 좋은가?”에 대한 답. 이것이 없으면 아이디어는 그냥 제안일 뿐이다.</p>
<p><strong>One possible challenge</strong><br>
이것이 핵심이다. 대부분의 브레인스토밍은 장점만 나열한다. 하지만 실무에서는 “무엇이 문제인가?”를 먼저 파악해야 실행 가능성을 판단할 수 있다.</p>
<p>예시:</p>
<pre><code>아이디어: 사용자 커뮤니티 포럼 추가
이점: 사용자 간 도움으로 고객 지원 비용 감소
과제: 부정적 피드백이 공개적으로 확산될 위험</code></pre>
<p>과제를 명시하면 “이 아이디어를 실행하려면 커뮤니티 모더레이션 전략이 필요하다”는 후속 논의가 자연스럽게 이어진다.</p>
<p><strong>4단계: Common themes 파악</strong></p>
<p>이 단계는 패턴 인식이다. 5개 아이디어를 보면 보통 2~3개의 공통 테마가 발견된다.</p>
<p>예를 들어:<br>
- 아이디어 1, 3: 사용자 참여 증대<br>
- 아이디어 2, 5: 경제적 인센티브<br>
- 아이디어 4: 진입 장벽 제거</p>
<p>테마를 파악하면 “우리가 실제로 해결하려는 근본 문제가 무엇인가?”를 이해할 수 있다.</p>
<p><strong>5단계: 아이디어 결합</strong></p>
<p>최고의 솔루션은 종종 여러 아이디어의 조합이다. 이 단계는 시너지를 찾는다.</p>
<p>예시:</p>
<pre><code>결합: 리워드 프로그램 + 커뮤니티 포럼
→ "커뮤니티 기여 리워드 시스템"

사용자가 포럼에서 다른 사용자를 도우면 포인트를 얻고, 
포인트로 프리미엄 기능을 잠금 해제할 수 있다.

이점: 
- 커뮤니티 활성화 (도움을 주려는 동기 부여)
- 프리미엄 전환 유도 (맛보기 효과)
- 고객 지원 비용 감소

과제:
- 포인트 경제 설계 복잡도
- 악용 방지 (스팸, 저품질 답변)</code></pre>
<p>결합은 단순 합산이 아니라, 두 아이디어가 만나서 새로운 가치를 창출하는 것이다.</p>
</section>
<section id="엔지니어-python-코드-리서치-템플릿" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="엔지니어-python-코드-리서치-템플릿"><span class="header-section-number">1.4</span> 엔지니어 Python 코드 리서치 템플릿</h2>
<pre><code>You are a Python code analyst tasked with researching specific
aspects of Python code. Your goal is to analyze the given code
snippet and answer a research question about it. 
Follow these instructions carefully:

1. You will be presented with a Python code snippet and a
   research question.

2. Here is the Python code to analyze:
&lt;python_code&gt;
{{PYTHON_CODE}}
&lt;/python_code&gt;

3. Here is the research question to answer:
&lt;research_question&gt;
{{RESEARCH_QUESTION}}
&lt;/research_question&gt;

4. Analyze the provided Python code carefully. Consider its
   structure, functionality, and any notable features or patterns.

5. Answer the research question based on your analysis of the code. 
   Your answer should be thorough, accurate, and directly related to 
   the code and the question asked.

6. Provide your response in the following format:
&lt;analysis&gt;
First, provide a brief overview of the code and its main features.
&lt;/analysis&gt;

&lt;answer&gt;
Then, provide a detailed answer to the research question. 
Include specific references to the code where relevant. 
If the question cannot be fully answered based on the
provided code, explain why and what additional information 
might be needed.
&lt;/answer&gt;

Remember to focus solely on the provided code and the specific 
research question. Do not make assumptions about code that isn't 
shown or speculate about the broader context unless it's directly 
relevant to answering the question.</code></pre>
<p><strong>XML 태그 구조의 전략적 사용</strong></p>
<p>이 템플릿은 XML 태그를 적극 활용한다. <code>&lt;python_code&gt;</code>, <code>&lt;research_question&gt;</code>, <code>&lt;analysis&gt;</code>, <code>&lt;answer&gt;</code> 같은 명시적 구조화는 세 가지 이점을 제공한다.</p>
<p><strong>이점 1: 명확한 경계</strong><br>
코드 분석에서 가장 큰 문제는 “어디까지가 분석할 코드이고, 어디부터가 질문인가?”의 혼란이다. XML 태그는 이를 완벽히 분리한다.</p>
<p><strong>이점 2: 프로그래밍 방식 처리</strong><br>
XML 구조는 자동화에 유리하다. 예를 들어 GitHub에서 코드를 자동으로 가져와 <code>&lt;python_code&gt;</code> 태그에 삽입하는 스크립트를 만들 수 있다.</p>
<p><strong>이점 3: 일관된 출력 형식</strong><br>
AI의 출력도 XML 태그로 구조화되므로, 파싱이 쉽다. <code>&lt;analysis&gt;</code> 부분만 추출하거나, <code>&lt;answer&gt;</code>만 표시하는 등 유연한 활용이 가능하다.</p>
<p><strong>“Do not make assumptions” 경고의 중요성</strong></p>
<p>코드 분석에서 AI의 가장 큰 함정은 “보이지 않는 코드를 가정하는 것”이다.</p>
<p>예를 들어:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>result <span class="op">=</span> process_data(<span class="bu">input</span>)</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>AI는 <code>process_data</code> 함수의 구현을 보지 못했는데도, “이 함수는 아마 데이터를 정규화할 것이다”같은 추측을 할 수 있다. 이는 위험하다.</p>
<p>“Do not make assumptions about code that isn’t shown”은 이를 명시적으로 금지한다. 대신 “제공된 코드만으로는 process_data의 동작을 확인할 수 없다”고 정직하게 말하도록 강제한다.</p>
<p><strong>2단계 출력 구조의 가치</strong></p>
<p><strong><analysis>: 전체적 이해</analysis></strong><br>
먼저 코드를 전체적으로 파악한다. “이 코드는 웹 스크래핑을 수행하며, BeautifulSoup를 사용한다”같은 큰 그림을 제시한다.</p>
<p>이는 맥락을 설정한다. 연구 질문이 “왜 try-except를 사용했나?”라면, “이 코드는 외부 API를 호출하므로 네트워크 오류 가능성이 있다”는 맥락이 답변 이해를 돕는다.</p>
<p><strong><answer>: 구체적 답변</answer></strong><br>
그 다음 연구 질문에 집중한다. “Include specific references to the code”는 중요하다. 모호한 답변이 아니라, “line 15의 <code>except requests.exceptions.Timeout</code>을 보면…”같은 구체적 참조를 요구한다.</p>
<p><strong>“If the question cannot be fully answered” 조건</strong></p>
<p>이는 정직성을 강제한다. 코드 일부만 제공되었거나, 질문이 코드 범위를 벗어나면, AI는 이를 인정해야 한다.</p>
<p>예시:</p>
<pre><code>질문: "이 함수의 시간 복잡도는?"
코드: 함수 시그니처만 있고 구현은 없음

나쁜 답변: "O(n)일 것으로 추정됩니다"
좋은 답변: "함수 구현이 제공되지 않아 시간 복잡도를 정확히 분석할 수 없습니다. 
           구현 코드가 필요합니다."</code></pre>
</section>
<section id="엔지니어-python-코드-디버깅-템플릿" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="엔지니어-python-코드-디버깅-템플릿"><span class="header-section-number">1.5</span> 엔지니어 Python 코드 디버깅 템플릿</h2>
<pre><code>You are a Python debugging assistant. Your task is to
analyze Python code that has an error and provide
suggestions to fix it. Follow these steps:

1. Review the provided Python code:
&lt;python_code&gt;
{{PYTHON_CODE}}
&lt;/python_code&gt;

2. Examine the error message:
&lt;error_message&gt;
{{ERROR_MESSAGE}}
&lt;/error_message&gt;

3. Analyze the code and the error message carefully.
Consider the following:
- The type of error (syntax, runtime, logical, etc.)
- The line number where the error occurred (if provided)
- Any specific variables or functions mentioned in the error

4. Provide your debugging suggestions and explanations in the 
   following format:

&lt;debug_analysis&gt;
a) Briefly describe the error and its likely cause
b) Identify the specific line(s) of code that are problematic
c) Explain why the error is occurring
d) Suggest one or more solutions to fix the error
e) If applicable, provide any additional tips or best practices 
   related to the issue
&lt;/debug_analysis&gt;

5. If you believe there might be multiple issues or if the error 
   message is unclear, mention this and provide suggestions for 
   further troubleshooting.

6. If you need any clarification or additional information to 
   better assist with debugging, please state so clearly.

Remember to be clear, concise, and helpful in your explanations. 
Your goal is to not only fix the immediate error but also to help 
the user understand why the error occurred and how to prevent 
similar issues in the future.</code></pre>
<p><strong>디버깅 vs 코드 리서치의 차이</strong></p>
<p>이 템플릿은 리서치 템플릿과 비슷해 보이지만, 근본적으로 다른 목적을 가진다.</p>
<p><strong>리서치</strong>: “이 코드는 어떻게 작동하는가?” (이해)<br>
<strong>디버깅</strong>: “이 코드는 왜 작동하지 않는가?” (문제 해결)</p>
<p>디버깅은 에러 메시지라는 추가 입력이 있고, 출력은 “해결 방법”에 집중한다.</p>
<p><strong>에러 타입 분류의 중요성</strong></p>
<p>“The type of error (syntax, runtime, logical, etc.)”는 진단의 첫 단계다.</p>
<p><strong>Syntax Error</strong><br>
코드가 파이썬 문법을 위반했다. 실행조차 안 된다.<br>
예: <code>if x = 5:</code> (=는 할당, ==가 비교)</p>
<p><strong>Runtime Error</strong><br>
문법은 맞지만 실행 중 문제 발생.<br>
예: <code>1 / 0</code> (ZeroDivisionError)</p>
<p><strong>Logical Error</strong><br>
코드가 실행되지만 예상과 다른 결과.<br>
예: <code>sum = a - b</code> (더하기가 아니라 빼기)</p>
<p>에러 타입에 따라 해결 전략이 완전히 다르다. Syntax는 코드 수정, Runtime은 예외 처리, Logical은 알고리즘 재검토가 필요하다.</p>
<p><strong>5단계 debug_analysis 구조</strong></p>
<p><strong>a) Briefly describe the error and its likely cause</strong><br>
“IndexError: list index out of range”를 “리스트 길이보다 큰 인덱스에 접근하려 했다”로 평문 설명한다. 에러 메시지는 개발자용이라 초보자는 이해 못할 수 있다.</p>
<p><strong>b) Identify the specific line(s)</strong><br>
“line 42: <code>result = data[i]</code>”처럼 정확한 위치를 찾아준다. 에러 메시지에 라인 번호가 있으면 쉽지만, 없으면 코드를 분석해서 찾아야 한다.</p>
<p><strong>c) Explain why</strong><br>
이것이 교육적 가치의 핵심이다. “왜 에러가 나는가?”를 설명한다.</p>
<p>예: “<code>data</code> 리스트 길이는 10인데, 루프는 <code>range(15)</code>로 15번 반복하므로, i=10부터 IndexError 발생”</p>
<p><strong>d) Suggest solutions</strong><br>
여러 해결책을 제시한다. 각각의 트레이드오프도 설명한다.</p>
<p>예:</p>
<pre><code>해결책 1: range(len(data))로 변경 (안전하지만 원래 의도와 다를 수 있음)
해결책 2: data.extend([None] * 5)로 리스트 확장 (의도대로지만 None 처리 필요)
해결책 3: if i &lt; len(data): 조건 추가 (유연하지만 코드 복잡도 증가)</code></pre>
<p><strong>e) Best practices</strong><br>
단순 버그 수정을 넘어서 “이런 종류의 버그를 예방하려면?”을 제안한다.</p>
<p>예: “리스트 인덱싱 전에 항상 길이 체크 / enumerate() 사용 / try-except로 감싸기”</p>
<p><strong>“Multiple issues” 경고의 실전적 가치</strong></p>
<p>실무에서 에러는 종종 여러 문제가 연쇄적으로 발생한 결과다. 하나를 고치면 다음 에러가 나타난다.</p>
<p>템플릿은 AI에게 “다른 잠재적 문제도 찾아라”고 지시한다.</p>
<p>예:</p>
<pre><code>디버깅 분석:
현재 에러: IndexError at line 42

해결 후 예상 문제:
- line 50: data[i]에서 TypeError 가능 (None 값 처리 안 됨)
- line 65: result 반환 전 초기화 안 됨 (UnboundLocalError 위험)

권장: 현재 에러 수정 후, 전체 코드 리뷰하여 위 문제들도 선제적 수정</code></pre>
<p>이는 디버깅 시간을 크게 단축한다. “하나 고치고 실행, 또 에러, 또 고치고…”를 반복하지 않아도 된다.</p>
</section>
<section id="마케터-프롬프트-템플릿" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="마케터-프롬프트-템플릿"><span class="header-section-number">1.6</span> 마케터 프롬프트 템플릿</h2>
<pre><code>You are tasked with creating effective prompts for a growth and 
content marketer. Your goal is to create prompts that are specific, 
actionable, and aligned with the given marketing goal and target audience.

You will be provided with two input variables:

&lt;marketing_goal&gt;
{{MARKETING_GOAL}}
&lt;/marketing_goal&gt;

&lt;target_audience&gt;
{{TARGET_AUDIENCE}}
&lt;/target_audience&gt;

Use these inputs to tailor your prompts to the specific marketing goal 
and target audience.

Guidelines:
1. Make the prompts specific and focused on the marketing goal
2. Ensure the prompts consider the target audience's needs, preferences,
   and pain points
3. Use action-oriented language that encourages creative thinking
4. Include elements that can lead to measurable outcomes
5. Keep the prompts open-ended enough to allow for diverse ideas

Output your prompts in the following format:
&lt;prompt&gt;
Insert your prompt here
&lt;/prompt&gt;

Here are two examples of good prompts:

&lt;prompt&gt;
Develop a content strategy for a blog series that addresses the top 5
pain points of {{target_audience}} related to {{marketing_goal}}, 
including potential topics, content formats, and distribution channels.
&lt;/prompt&gt;

&lt;prompt&gt;
Create a social media campaign concept that showcases how our
product/service helps {{target_audience}} achieve {{marketing_goal}},
including post ideas for three different platforms and a hashtag strategy.
&lt;/prompt&gt;

Generate 5 unique prompts following the guidelines and format provided
above. Ensure that each prompt is distinct and addresses different
aspects of the marketing goal and target audience.</code></pre>
<p><strong>“프롬프트를 만드는 프롬프트”의 메타 구조</strong></p>
<p>이 템플릿은 흥미로운 메타 레벨에서 작동한다. 마케터에게 직접 콘텐츠를 만들어주는 게 아니라, 마케터가 사용할 프롬프트를 생성해준다.</p>
<p><strong>왜 이런 구조인가?</strong></p>
<p>마케팅은 반복적이고 다양하다. 블로그 글 10개, 소셜 포스트 50개, 이메일 캠페인 20개를 만들어야 한다. 매번 프롬프트를 처음부터 쓰기보다, “이 캠페인에 맞는 프롬프트 5개”를 먼저 생성하면 효율적이다.</p>
<p><strong>5가지 Guidelines의 마케팅 전문성</strong></p>
<p><strong>1. Specific and focused on the marketing goal</strong><br>
모호한 프롬프트는 모호한 결과를 낳는다. “소셜 미디어 콘텐츠 만들어줘”보다 “Instagram에서 MZ세대에게 친환경 패션 브랜드 인지도를 높이는 릴스 스크립트 5개”가 훨씬 낫다.</p>
<p><strong>2. Consider target audience’s needs, preferences, and pain points</strong><br>
마케팅의 황금률은 “고객이 원하는 것을 줘라”다. 프롬프트에 타겟 오디언스가 명시되지 않으면, AI는 일반적이고 차별화되지 않은 콘텐츠를 만든다.</p>
<p>예: “바쁜 직장인”과 “은퇴한 시니어”는 완전히 다른 pain point를 가진다.<br>
- 직장인: 시간 부족, 효율성, 빠른 결과<br>
- 시니어: 신뢰성, 단순함, 장기적 가치</p>
<p><strong>3. Action-oriented language</strong><br>
“Create”, “Develop”, “Design”같은 동사는 구체적 산출물을 유도한다. “Think about”이나 “Consider”는 너무 추상적이다.</p>
<p>나쁜 예: “소셜 미디어 전략에 대해 생각해봐”<br>
좋은 예: “주 3회 포스팅 일정표를 만들고, 각 포스트의 목표와 CTA를 명시해”</p>
<p><strong>4. Include elements that can lead to measurable outcomes</strong><br>
마케팅은 결과로 평가된다. “인지도 향상”은 측정 불가능하다. “웹사이트 방문자 30% 증가”는 측정 가능하다.</p>
<p>프롬프트에 “including metrics to track success”같은 문구를 넣으면, AI가 KPI까지 제안한다.</p>
<p><strong>5. Keep the prompts open-ended</strong><br>
역설적이지만, 너무 구체적인 프롬프트는 창의성을 제한한다. “빨간색 배경에 큰 글씨로”보다 “시선을 확 끄는 비주얼”이 더 다양한 아이디어를 낸다.</p>
<p><strong>예시 프롬프트의 구조 분석</strong></p>
<p><strong>예시 1: 블로그 시리즈</strong></p>
<pre><code>Develop a content strategy for a blog series that addresses the top 5
pain points of {{target_audience}} related to {{marketing_goal}}, 
including potential topics, content formats, and distribution channels.</code></pre>
<p>이 프롬프트는 세 가지 산출물을 요구한다:<br>
1. <strong>Top 5 pain points</strong>: 먼저 고객 이해<br>
2. <strong>Topics + formats</strong>: 어떤 내용을 어떤 형식으로<br>
3. <strong>Distribution channels</strong>: 어디서 공유할 것인가</p>
<p>이는 마케팅 전략의 완전한 프레임워크다. 단순히 “블로그 글 써줘”가 아니라 전체 캠페인 설계를 포함한다.</p>
<p><strong>예시 2: 소셜 미디어 캠페인</strong></p>
<pre><code>Create a social media campaign concept that showcases how our
product/service helps {{target_audience}} achieve {{marketing_goal}},
including post ideas for three different platforms and a hashtag strategy.</code></pre>
<p>“Three different platforms”가 중요하다. Instagram, LinkedIn, Twitter는 완전히 다른 콘텐츠 전략이 필요하다.<br>
- Instagram: 시각 중심, 짧은 캡션, 이모지<br>
- LinkedIn: 전문적, 긴 텍스트, 사례 연구<br>
- Twitter: 간결, 실시간, 대화형</p>
<p>“Hashtag strategy”는 발견성(discoverability)을 고려한다. 좋은 해시태그는 너무 일반적이지도(#marketing - 경쟁 과다), 너무 구체적이지도 않다(#b2bsaasmarketingforsmbs - 검색 안 됨).</p>
<p><strong>5개 프롬프트 생성 요구의 의도</strong></p>
<p>왜 5개인가? 다양성과 선택지를 제공하기 위함이다.</p>
<p>마케터는:<br>
- 프롬프트 1: 블로그 콘텐츠용<br>
- 프롬프트 2: 소셜 미디어용<br>
- 프롬프트 3: 이메일 캠페인용<br>
- 프롬프트 4: 랜딩 페이지용<br>
- 프롬프트 5: 비디오 스크립트용</p>
<p>이렇게 채널별로 특화된 프롬프트를 받는다. 각각을 반복 사용하면 일관된 브랜드 메시지를 유지하면서도 채널별 최적화가 가능하다.</p>
</section>
<section id="직군별-템플릿의-실전-활용-전략" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="직군별-템플릿의-실전-활용-전략"><span class="header-section-number">1.7</span> 직군별 템플릿의 실전 활용 전략</h2>
<p><strong>템플릿 커스터마이징</strong></p>
<p>제공된 템플릿은 시작점이다. 실제로는 회사와 팀의 특성에 맞춰 수정해야 한다.</p>
<p>예: 스타트업의 PM 브레인스토밍</p>
<pre><code>원본: Generate 5 distinct ideas
수정: Generate 5 distinct ideas, prioritizing those that can be 
      implemented with a team of 3 engineers in 2 weeks</code></pre>
<p>리소스 제약을 명시하면, 실행 가능한 아이디어에 집중한다.</p>
<p><strong>템플릿 조합</strong></p>
<p>여러 템플릿을 순차적으로 사용하면 강력하다.</p>
<p>워크플로우 예시:<br>
1. PM 브레인스토밍 템플릿 → 5개 아이디어 생성<br>
2. 엔지니어 코드 리서치 템플릿 → 각 아이디어의 기술적 실현 가능성 평가<br>
3. 마케터 프롬프트 템플릿 → 실행 가능한 아이디어의 마케팅 전략 수립</p>
<p><strong>템플릿 라이브러리 구축</strong></p>
<p>기업은 직군별 템플릿을 내부 위키나 Notion에 정리해야 한다.</p>
<p>구조 예시:</p>
<pre><code>템플릿 라이브러리/
├── Product/
│   ├── brainstorming.md
│   ├── user_story.md
│   └── roadmap.md
├── Engineering/
│   ├── code_review.md
│   ├── debugging.md
│   └── architecture_design.md
├── Marketing/
│   ├── campaign_planning.md
│   ├── content_creation.md
│   └── ab_test_design.md
└── Operations/
    ├── process_optimization.md
    ├── incident_report.md
    └── quarterly_planning.md</code></pre>
<p>각 템플릿에는 사용 예시와 성공 사례를 첨부한다. 신입이 와도 즉시 검증된 프롬프트를 사용할 수 있다.</p>


</section>
</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>