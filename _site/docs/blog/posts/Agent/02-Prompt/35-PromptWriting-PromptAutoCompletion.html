<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="실제 서비스 운영 데이터에서 발견된 문제(짧은 이용시간, 낮은 멀티턴 비율)를 해결하기 위한 프롬프트 질문 생성기 구현 방법을 체계적으로 설명한다. Richard Thaler와 Cass Sunstein의 Nudge Theory(2008), Premack &amp; Woodruff의 Theory of Mind(1978) 등 행동경제학과 심리학 이론을 프롬프트 엔지니어링에 적용하는 실전 기법을 다룬다. 사용자의 선택 설계(Choice Architecture)를 조정하는 3단계 질문 구조(High/Moderate/Low certainty), 모바일 환경 최적화(5단어 제한, 반말체), Theory of Mind 명시적 부여(“You have a mind”) 등 실무에서 즉시 활용 가능한 프롬프트 설계 원칙과 GPT-4o, Claude, Gemini 모델별 테스트 결과를 제시한다. 귀납적 접근 방법, 사용자 행동 데이터 기반 설계, UI/UX 제약 반영 등 프로덕션 환경의 프롬프트 엔지니어링 실전 노하우를 상세히 설명한다.">

<title>Kwangmin Kim - 프롬프트 질문 생성기: 행동경제학과 심리학을 활용한 멀티턴 대화 유도</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - 프롬프트 질문 생성기: 행동경제학과 심리학을 활용한 멀티턴 대화 유도">
<meta property="og:description" content="실제 서비스 운영 데이터에서 발견된 문제(짧은 이용시간, 낮은 멀티턴 비율)를 해결하기 위한 프롬프트 질문 생성기 구현 방법을 체계적으로 설명한다. Richard Thaler와 Cass Sunstein의 Nudge Theory(2008), Premack &amp; Woodruff의 Theory of Mind(1978) 등 행동경제학과 심리학 이론을 프롬프트 엔지니어링에 적용하는 실전 기법을 다룬다. 사용자의 선택 설계(Choice Architecture)를 조정하는 3단계 질문 구조(High/Moderate/Low certainty), 모바일 환경 최적화(5단어 제한, 반말체), Theory of Mind 명시적 부여(“You have a mind”) 등 실무에서 즉시 활용 가능한 프롬프트 설계 원칙과 GPT-4o, Claude, Gemini 모델별 테스트 결과를 제시한다. 귀납적 접근 방법, 사용자 행동 데이터 기반 설계, UI/UX 제약 반영 등 프로덕션 환경의 프롬프트 엔지니어링 실전 노하우를 상세히 설명한다.">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Kwangmin Kim - 프롬프트 질문 생성기: 행동경제학과 심리학을 활용한 멀티턴 대화 유도">
<meta name="twitter:description" content="실제 서비스 운영 데이터에서 발견된 문제(짧은 이용시간, 낮은 멀티턴 비율)를 해결하기 위한 프롬프트 질문 생성기 구현 방법을 체계적으로 설명한다. Richard Thaler와 Cass Sunstein의 Nudge Theory(2008), Premack &amp; Woodruff의 Theory of Mind(1978) 등 행동경제학과 심리학 이론을 프롬프트 엔지니어링에 적용하는 실전 기법을 다룬다. 사용자의 선택 설계(Choice Architecture)를 조정하는 3단계 질문 구조(High/Moderate/Low certainty), 모바일 환경 최적화(5단어 제한, 반말체), Theory of Mind 명시적 부여(“You have a mind”) 등 실무에서 즉시 활용 가능한 프롬프트 설계 원칙과 GPT-4o, Claude, Gemini 모델별 테스트 결과를 제시한다. 귀납적 접근 방법, 사용자 행동 데이터 기반 설계, UI/UX 제약 반영 등 프로덕션 환경의 프롬프트 엔지니어링 실전 노하우를 상세히 설명한다.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">프롬프트 질문 생성기: 행동경제학과 심리학을 활용한 멀티턴 대화 유도</h1>
            <p class="subtitle lead">Nudge Theory와 Theory of Mind를 결합한 사용자 참여 증대 프롬프트 설계</p>
                  <div>
        <div class="description">
          <p>실제 서비스 운영 데이터에서 발견된 문제(짧은 이용시간, 낮은 멀티턴 비율)를 해결하기 위한 프롬프트 질문 생성기 구현 방법을 체계적으로 설명한다. Richard Thaler와 Cass Sunstein의 Nudge Theory(2008), Premack &amp; Woodruff의 Theory of Mind(1978) 등 행동경제학과 심리학 이론을 프롬프트 엔지니어링에 적용하는 실전 기법을 다룬다. 사용자의 선택 설계(Choice Architecture)를 조정하는 3단계 질문 구조(High/Moderate/Low certainty), 모바일 환경 최적화(5단어 제한, 반말체), Theory of Mind 명시적 부여(“You have a mind”) 등 실무에서 즉시 활용 가능한 프롬프트 설계 원칙과 GPT-4o, Claude, Gemini 모델별 테스트 결과를 제시한다. 귀납적 접근 방법, 사용자 행동 데이터 기반 설계, UI/UX 제약 반영 등 프로덕션 환경의 프롬프트 엔지니어링 실전 노하우를 상세히 설명한다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Prompt Engineering</div>
                <div class="quarto-category">LLM</div>
                <div class="quarto-category">AI</div>
                <div class="quarto-category">Agent</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2025년 02월 11일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#프롬프트-자동-완성기-prompt-auto-completion" id="toc-프롬프트-자동-완성기-prompt-auto-completion" class="nav-link active" data-scroll-target="#프롬프트-자동-완성기-prompt-auto-completion"><span class="header-section-number">1</span> 프롬프트 자동 완성기 (Prompt Auto-Completion)</a>
  <ul class="collapse">
  <li><a href="#사용자-문제-정의" id="toc-사용자-문제-정의" class="nav-link" data-scroll-target="#사용자-문제-정의"><span class="header-section-number">1.1</span> 사용자 문제 정의</a></li>
  <li><a href="#전제-설정-및-논리적-추론" id="toc-전제-설정-및-논리적-추론" class="nav-link" data-scroll-target="#전제-설정-및-논리적-추론"><span class="header-section-number">1.2</span> 전제 설정 및 논리적 추론</a></li>
  <li><a href="#프롬프트-자동-완성기-설계-과정" id="toc-프롬프트-자동-완성기-설계-과정" class="nav-link" data-scroll-target="#프롬프트-자동-완성기-설계-과정"><span class="header-section-number">1.3</span> 프롬프트 자동 완성기 설계 과정</a></li>
  <li><a href="#프롬프트-자동-완성-툴-제작" id="toc-프롬프트-자동-완성-툴-제작" class="nav-link" data-scroll-target="#프롬프트-자동-완성-툴-제작"><span class="header-section-number">1.4</span> 프롬프트 자동 완성 툴 제작</a>
  <ul class="collapse">
  <li><a href="#role-설정-highly-professional-psychologist" id="toc-role-설정-highly-professional-psychologist" class="nav-link" data-scroll-target="#role-설정-highly-professional-psychologist"><span class="header-section-number">1.4.1</span> Role 설정: “highly professional psychologist”</a></li>
  <li><a href="#task-enhance-my-prompt-anticipating-my-intentions" id="toc-task-enhance-my-prompt-anticipating-my-intentions" class="nav-link" data-scroll-target="#task-enhance-my-prompt-anticipating-my-intentions"><span class="header-section-number">1.4.2</span> Task: “enhance my prompt” + “anticipating my intentions”</a></li>
  <li><a href="#specification-1-edit-my-prompt-in-greater-detail-constructing-complete-sentences" id="toc-specification-1-edit-my-prompt-in-greater-detail-constructing-complete-sentences" class="nav-link" data-scroll-target="#specification-1-edit-my-prompt-in-greater-detail-constructing-complete-sentences"><span class="header-section-number">1.4.3</span> Specification 1: “edit {{$my prompt}} in greater detail, constructing complete sentences”</a></li>
  <li><a href="#specification-2-use-informal-speech-form--해체hae-che-in-korean" id="toc-specification-2-use-informal-speech-form--해체hae-che-in-korean" class="nav-link" data-scroll-target="#specification-2-use-informal-speech-form--해체hae-che-in-korean"><span class="header-section-number">1.4.4</span> Specification 2: “Use informal speech form, -해체(hae che) in Korean”</a></li>
  <li><a href="#specification-3-include-a-role-situation-and-task" id="toc-specification-3-include-a-role-situation-and-task" class="nav-link" data-scroll-target="#specification-3-include-a-role-situation-and-task"><span class="header-section-number">1.4.5</span> Specification 3: “Include a role, situation and task”</a></li>
  <li><a href="#response-제약-1-to-3-sentences" id="toc-response-제약-1-to-3-sentences" class="nav-link" data-scroll-target="#response-제약-1-to-3-sentences"><span class="header-section-number">1.4.6</span> Response 제약: “1 to 3 sentences”</a></li>
  </ul></li>
  <li><a href="#모델별-테스트-결과" id="toc-모델별-테스트-결과" class="nav-link" data-scroll-target="#모델별-테스트-결과"><span class="header-section-number">1.5</span> 모델별 테스트 결과</a>
  <ul class="collapse">
  <li><a href="#gpt-4o-mini-테스트" id="toc-gpt-4o-mini-테스트" class="nav-link" data-scroll-target="#gpt-4o-mini-테스트"><span class="header-section-number">1.5.1</span> GPT-4o mini 테스트</a></li>
  <li><a href="#claude-3.5-sonnet-테스트" id="toc-claude-3.5-sonnet-테스트" class="nav-link" data-scroll-target="#claude-3.5-sonnet-테스트"><span class="header-section-number">1.5.2</span> Claude 3.5 Sonnet 테스트</a></li>
  </ul></li>
  <li><a href="#테스트-시-주의사항" id="toc-테스트-시-주의사항" class="nav-link" data-scroll-target="#테스트-시-주의사항"><span class="header-section-number">1.6</span> 테스트 시 주의사항</a></li>
  <li><a href="#프롬프트-자동-완성기의-한계와-개선-방향" id="toc-프롬프트-자동-완성기의-한계와-개선-방향" class="nav-link" data-scroll-target="#프롬프트-자동-완성기의-한계와-개선-방향"><span class="header-section-number">1.7</span> 프롬프트 자동 완성기의 한계와 개선 방향</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="프롬프트-자동-완성기-prompt-auto-completion" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> 프롬프트 자동 완성기 (Prompt Auto-Completion)</h1>
<section id="사용자-문제-정의" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="사용자-문제-정의"><span class="header-section-number">1.1</span> 사용자 문제 정의</h2>
<p>프롬프트 자동 완성기는 사용자가 AI와 효과적으로 소통하지 못하는 근본적인 문제를 해결한다.</p>
<p><strong>발견된 문제점</strong></p>
<ul>
<li>사용자의 프롬프트가 구체적이지 못하고 불완전하다<br>
</li>
<li>현재 사용자가 프롬프트를 잘 쓸 수 있도록 안내하거나 보조하는 제품 내 장치가 없다</li>
</ul>
<p><strong>문제의 본질</strong></p>
<ul>
<li>대부분의 사용자는 “개발자로 살아남으려면?”처럼 막연한 질문을 던진다.<br>
</li>
<li>이는 세 가지 정보가 부족하다.
<ol type="1">
<li>현재 상황 (예: 비전공자인지, 주니어인지),</li>
<li>원하는 결과 (예: 취업, 이직, 기술 향상),<br>
</li>
<li>제약 조건 (예: 시간, 예산).</li>
</ol></li>
</ul>
<p>AI는 이런 불완전한 입력으로도 답변을 생성하지만, 품질이 낮고 사용자는 만족하지 못한다. 결과적으로 “AI가 별로다”라고 느끼고 떠난다.</p>
<p><strong>귀납적 접근</strong></p>
<p>만약 서비스 로그를 분석하면 사용자의 초기 질문 대부분이 10 단어 이하의 짧고 모호한 형태임을 확인할 수 있다라고 한다면 이는 사용자의 문제가 아니라 인터페이스 설계의 문제다. 사람들은 본능적으로 검색창에 짧은 키워드를 입력하도록 학습되어 있다.</p>
<p>“프롬프트를 잘 쓰는 법”을 교육하는 것보다, 불완전한 입력을 자동으로 완성해주는 도구가 훨씬 실용적이다.</p>
<p><strong>해결 방법</strong></p>
<p>AI와의 대화를 원활하게 진행하고 사용가치와 효율성을 극대화할 수 있는 프롬프트 자동 완성기를 제작한다.</p>
<p><strong>“자동 완성”의 두 가지 의미</strong></p>
<p>여기서 자동 완성은 두 가지를 동시에 의미한다.</p>
<ol type="1">
<li>사용자의 짧은 입력을 구체적인 프롬프트로 확장한다.</li>
</ol>
<ul>
<li>“개발자 공부”를 “비전공자가 6개월 안에 웹 개발자로 취업하기 위한 학습 로드맵을 단계별로 알려줘”로 변환하는 것이다.</li>
</ul>
<ol start="2" type="1">
<li>사용자가 미처 생각하지 못한 맥락 정보를 추론해서 추가한다.<br>
</li>
</ol>
<ul>
<li>이는 Google 검색의 자동완성과는 차원이 다른 고급 기능이다.</li>
</ul>
</section>
<section id="전제-설정-및-논리적-추론" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="전제-설정-및-논리적-추론"><span class="header-section-number">1.2</span> 전제 설정 및 논리적 추론</h2>
<p><strong>가정: 프롬프트 자동 완성기를 구현하면 사용자는 이런 행동을 할 것이다</strong></p>
<ul>
<li>사용자 만족도가 증가한다<br>
</li>
<li>사용자 리텐션이 올라간다<br>
</li>
<li>AI 사용 효용을 느낀 사용자는 더 복잡하고 정교한 질문을 한다<br>
</li>
<li>서비스에 대한 의존도가 높아진다</li>
</ul>
<p><strong>논리적 추론의 구조</strong></p>
<ul>
<li>이 가정은 사용자 행동의 선순환 구조를 전제한다.</li>
<li>자동 완성기가 질 좋은 프롬프트를 생성 → AI가 더 나은 답변 제공 → 사용자가 “이 AI는 똑똑하다”고 인식 → 더 어려운 질문도 시도 → 서비스 가치 체감 증가 → 재방문.<br>
</li>
<li>이는 단순한 희망사항이 아니라, 실제로 검증 가능한 가설이다.</li>
</ul>
<p><strong>비즈니스 메트릭으로 전환</strong></p>
<p>각 가정은 측정 가능한 지표와 연결된다.</p>
<ul>
<li>“사용자 만족도 증가”
<ul>
<li>CSAT(Customer Satisfaction Score): 사용자에게 직접 만족도를 물어보는 방식
<ul>
<li>1점(매우 불만) ~ 5점(매우 만족)</li>
<li>계산식: (만족 응답 수 / 전체 응답 수) × 100</li>
<li>보통 4-5점을 “만족”으로 분류</li>
<li>예: 100명 중 80명이 4-5점 → CSAT 80%</li>
</ul></li>
<li>NPS(Net Promoter Score)
<ul>
<li>“이 서비스를 친구에게 추천하시겠습니까?”<br>
</li>
<li>0점(절대 안 함) ~ 10점(매우 추천)<br>
</li>
</ul></li>
</ul></li>
<li>“리텐션 상승” → DAU/MAU, 7일 재방문율<br>
</li>
<li>“복잡한 질문 증가” → 평균 프롬프트 길이, 멀티턴 대화 비율<br>
</li>
<li>“의존도 증가” → 주간 평균 사용 횟수, 구독 전환율</li>
</ul>
<p>이런 지표를 A/B 테스트로 검증하면 프롬프트 자동 완성기의 실제 효과를 측정할 수 있다.</p>
<p><strong>역설적 발견</strong></p>
<ul>
<li>흥미로운 점은 “복잡한 질문을 한다”는 것이 목표라는 점이다.</li>
<li>일반적으로 서비스는 사용을 “쉽게” 만들려 하지만, 여기서는 오히려 사용자가 더 “정교하게” 사용하도록 유도한다.</li>
<li>왜냐하면 정교한 질문을 할 수 있다는 것은 AI의 능력을 신뢰한다는 의미이고, 이는 장기적 사용자 가치를 높이기 때문이다.<br>
</li>
<li>단순한 질문만 하는 사용자는 언젠가 “AI가 한계가 있다”고 느끼고 떠난다.</li>
</ul>
</section>
<section id="프롬프트-자동-완성기-설계-과정" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="프롬프트-자동-완성기-설계-과정"><span class="header-section-number">1.3</span> 프롬프트 자동 완성기 설계 과정</h2>
<p><strong>Practice 과제</strong></p>
<ul>
<li>사용자 문제 개선을 위한 프롬프트 자동 완성기를 제작하기 위한 아이디에이션 시도</li>
<li>프롬프트 초안을 작성<br>
</li>
<li>LLM과 프롬프트 자동완성기의 작동 구조를 그림으로 그리기</li>
</ul>
<p><strong>왜 “그림으로 그려보라”고 하는가?</strong></p>
<p>프롬프트 엔지니어링은 단순히 텍스트를 쓰는 작업이 아니다. 시스템 설계다. 사용자 입력 → 자동완성기 → LLM → 출력이라는 데이터 흐름을 시각화하지 않으면, 어디서 병목이 생기는지, 어떤 정보가 손실되는지 파악할 수 없다. 그림을 그리는 과정에서 “자동완성기가 원본 프롬프트를 완전히 대체하는가, 아니면 보조 정보로 추가하는가?” 같은 근본적 설계 질문이 명확해진다.</p>
<p><strong>아키텍처 설계의 핵심 선택</strong></p>
<p>두 가지 접근이 가능하다.</p>
<p><strong>방식 1: 대체형</strong><br>
사용자 입력 → 자동완성기가 완전히 새로운 프롬프트 생성 → LLM에 전달<br>
장점: 일관된 품질<br>
단점: 사용자 의도가 왜곡될 위험</p>
<p><strong>방식 2: 보강형</strong><br>
사용자 입력 → 자동완성기가 맥락 정보 추가 → (원본 + 추가정보)를 LLM에 전달<br>
장점: 사용자 의도 보존<br>
단점: 프롬프트가 길어져 비용 증가</p>
<p>실무에서는 보통 방식 2를 선택한다. 사용자가 “내가 쓴 질문이 무시당했다”고 느끼면 신뢰가 깨지기 때문이다.</p>
</section>
<section id="프롬프트-자동-완성-툴-제작" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="프롬프트-자동-완성-툴-제작"><span class="header-section-number">1.4</span> 프롬프트 자동 완성 툴 제작</h2>
<p><strong>System Prompt</strong></p>
<pre><code>As a highly professional psychologist,
your task is to enhance my prompt for more effective responses
by anticipating my intentions.

Role

Kindly edit {{$my prompt}} in greater detail,
constructing complete sentences.
Please respond in Korean.

Specification

Use informal speech form, -해체(hae che) in Korean.
Include a role, situation and task within the prompt
if it is possible to generate.

Response

The prompt you provide should be limited to 1 to 3 sentences.
Provide only your response.</code></pre>
<section id="role-설정-highly-professional-psychologist" class="level3" data-number="1.4.1">
<h3 data-number="1.4.1" class="anchored" data-anchor-id="role-설정-highly-professional-psychologist"><span class="header-section-number">1.4.1</span> Role 설정: “highly professional psychologist”</h3>
<p>왜 심리학자를 선택했는가? 엔지니어나 작가가 아니라 심리학자를 선택한 이유는 “사용자의 의도를 추론”하는 것이 핵심이기 때문이다. 심리학자는 표면적 언어 뒤의 숨겨진 동기, 감정, 맥락을 읽어내는 전문가다. “개발자 공부”라는 짧은 입력 뒤에 “취업 불안”, “커리어 전환 고민”, “시간 부족” 같은 심리적 맥락이 숨어있다는 가정이다.</p>
<p>“highly professional”이라는 수식어는 단순히 품질을 높이는 게 아니다. LLM에게 전문성을 부여하면 더 신중하고 구조화된 출력을 생성하는 경향이 있다. “친근한 심리학자”가 아니라 “전문적인 심리학자”로 설정하면, 캐주얼한 추측이 아니라 체계적인 분석을 수행한다.</p>
</section>
<section id="task-enhance-my-prompt-anticipating-my-intentions" class="level3" data-number="1.4.2">
<h3 data-number="1.4.2" class="anchored" data-anchor-id="task-enhance-my-prompt-anticipating-my-intentions"><span class="header-section-number">1.4.2</span> Task: “enhance my prompt” + “anticipating my intentions”</h3>
<p>“enhance”는 단순한 확장이 아니라 “품질 향상”을 의미한다. 더 길게 만드는 게 아니라 더 효과적으로 만드는 것이다. “anticipating my intentions”는 핵심이다. 사용자가 명시하지 않은 숨은 의도를 추론하라는 지시다. 이는 “You have a mind”와 같은 맥락의 고급 기법이다.</p>
</section>
<section id="specification-1-edit-my-prompt-in-greater-detail-constructing-complete-sentences" class="level3" data-number="1.4.3">
<h3 data-number="1.4.3" class="anchored" data-anchor-id="specification-1-edit-my-prompt-in-greater-detail-constructing-complete-sentences"><span class="header-section-number">1.4.3</span> Specification 1: “edit {{$my prompt}} in greater detail, constructing complete sentences”</h3>
<p>대부분의 사용자 입력은 파편적이다. “개발자 공부”, “다이어트 방법”, “파이썬 에러” 같은 키워드 나열이다. “constructing complete sentences”는 이를 문법적으로 완전한 문장으로 재구성하라는 의미다. 이는 LLM의 성능을 크게 향상시킨다. LLM은 완전한 문장 구조에서 훨씬 정확한 답변을 생성하기 때문이다.</p>
</section>
<section id="specification-2-use-informal-speech-form--해체hae-che-in-korean" class="level3" data-number="1.4.4">
<h3 data-number="1.4.4" class="anchored" data-anchor-id="specification-2-use-informal-speech-form--해체hae-che-in-korean"><span class="header-section-number">1.4.4</span> Specification 2: “Use informal speech form, -해체(hae che) in Korean”</h3>
<p>한국어의 해체는 “~해”, “~야” 같은 형태로, 존댓말도 반말도 아닌 중간 톤이다. 이는 매우 전략적 선택이다. 반말은 너무 캐주얼해서 전문성이 떨어지고, 존댓말은 너무 격식 있어서 거리감이 생긴다. 해체는 “친근하지만 진지한” 톤을 만든다. 사용자가 AI를 “똑똑한 친구”로 인식하게 하는 최적의 톤이다.</p>
</section>
<section id="specification-3-include-a-role-situation-and-task" class="level3" data-number="1.4.5">
<h3 data-number="1.4.5" class="anchored" data-anchor-id="specification-3-include-a-role-situation-and-task"><span class="header-section-number">1.4.5</span> Specification 3: “Include a role, situation and task”</h3>
<p>이것이 프롬프트 자동 완성의 핵심 알고리즘이다. 좋은 프롬프트는 항상 세 가지 요소를 포함한다.</p>
<ul>
<li><strong>Role</strong>: “너는 10년 경력 개발자야”<br>
</li>
<li><strong>Situation</strong>: “비전공자가 개발자 취업을 준비하는 상황에서”<br>
</li>
<li><strong>Task</strong>: “6개월 학습 로드맵을 단계별로 만들어줘”</li>
</ul>
<p>사용자가 “개발자 공부”라고만 입력하면, 자동완성기는 이를 추론해서 위 세 요소를 포함한 완전한 프롬프트로 변환한다. “if it is possible to generate”라는 조건은 중요하다. 때로는 사용자 입력이 너무 모호해서 Role/Situation/Task를 추론할 수 없다. 이 경우 억지로 만들지 말고 기본적인 확장만 하라는 안전장치다.</p>
</section>
<section id="response-제약-1-to-3-sentences" class="level3" data-number="1.4.6">
<h3 data-number="1.4.6" class="anchored" data-anchor-id="response-제약-1-to-3-sentences"><span class="header-section-number">1.4.6</span> Response 제약: “1 to 3 sentences”</h3>
<p>왜 1~3문장으로 제한하는가? 자동완성기가 너무 긴 프롬프트를 생성하면 두 가지 문제가 발생한다. 첫째, 사용자가 “내 질문이 이렇게 바뀌었어?”라고 당황한다. 둘째, LLM API 비용이 증가한다. 1~3문장은 사용자가 한눈에 확인할 수 있는 길이면서도, Role-Situation-Task를 모두 담을 수 있는 최적 범위다.</p>
<p>“Provide only your response”는 메타 설명 제거 지시다. “제가 당신의 프롬프트를 다음과 같이 개선했습니다…”같은 부가 설명 없이, 순수하게 개선된 프롬프트만 출력하라는 의미다.</p>
</section>
</section>
<section id="모델별-테스트-결과" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="모델별-테스트-결과"><span class="header-section-number">1.5</span> 모델별 테스트 결과</h2>
<section id="gpt-4o-mini-테스트" class="level3" data-number="1.5.1">
<h3 data-number="1.5.1" class="anchored" data-anchor-id="gpt-4o-mini-테스트"><span class="header-section-number">1.5.1</span> GPT-4o mini 테스트</h3>
<p><strong>Query 1: “climate change에 대한 에세이 영어로 200자”</strong></p>
<p>이 입력의 문제점은 명확하다. (1) “climate change”가 너무 광범위하다. 원인? 영향? 해결책? (2) “에세이”의 목적이 불명확하다. 학술적? 설득적? 정보 전달? (3) “200자”가 한글 기준인지 영문 기준인지 모호하다.</p>
<p>자동완성기는 아마도 이렇게 변환했을 것이다:<br>
“기후 변화가 현대 사회에 미치는 영향에 대한 설득력 있는 영문 에세이를 200단어로 작성해줘. 구체적인 사례를 포함해.”</p>
<p>Role(설득적 글쓰기), Situation(현대 사회), Task(200단어 에세이)가 모두 명시되었다.</p>
<p><strong>Query 2: “탕후루 만드는 법”</strong></p>
<p>이 입력은 상대적으로 명확하지만, 여전히 맥락이 부족하다. 초보자용? 전문가용? 어떤 과일로?</p>
<p>자동완성기는 이렇게 확장했을 것이다:<br>
“집에서 처음 만들어보는 사람도 쉽게 따라할 수 있는 딸기 탕후루 만드는 법을 단계별로 알려줘.”</p>
<p>Role(초보자 가이드), Situation(집에서 처음 시도), Task(단계별 레시피)가 추가되었다.</p>
<p><strong>Query 3: “이 텍스트는 사회 복지 정책 평가 결과야. 데이터를 분석해줘.”</strong></p>
<p>이 입력은 비교적 완성도가 높다. 맥락(사회 복지 정책)과 자료 유형(평가 결과)이 명시되어 있다. 하지만 여전히 “분석”이 모호하다. 통계 분석? 트렌드 파악? 문제점 도출?</p>
<p>자동완성기는 이렇게 정교화했을 것이다:<br>
“사회 복지 정책 평가 데이터의 주요 트렌드와 개선점을 파악해서, 정책 입안자가 이해하기 쉬운 요약 리포트를 만들어줘.”</p>
<p>Role(정책 분석가), Situation(정책 입안자용 리포트), Task(트렌드 파악 + 개선점 도출)가 구체화되었다.</p>
</section>
<section id="claude-3.5-sonnet-테스트" class="level3" data-number="1.5.2">
<h3 data-number="1.5.2" class="anchored" data-anchor-id="claude-3.5-sonnet-테스트"><span class="header-section-number">1.5.2</span> Claude 3.5 Sonnet 테스트</h3>
<p><strong>Query 1: “끝말 잇기를 하자”</strong></p>
<p>이 입력은 명확한 Task만 있고 Role/Situation이 없다. Claude는 맥락을 어떻게 추론할까?</p>
<p>자동완성 결과:<br>
“한국어 단어로 끝말잇기 게임을 하자. 너가 먼저 단어를 제시하면 내가 이어갈게.”</p>
<p>Role(게임 상대), Situation(한국어 단어), Task(끝말잇기)가 추가되었다. “너가 먼저”라는 순서 설정도 중요하다. 이게 없으면 서로 누가 먼저 시작할지 모호하다.</p>
<p><strong>Query 2: “남자 친구 심리를 잘 모르겠어. 내 이야기좀 들어볼래?”</strong></p>
<p>이 입력은 감정적 맥락이 강하다. 단순한 정보 요청이 아니라 상담이 필요한 상황이다.</p>
<p>자동완성 결과:<br>
“연애 심리 상담가 역할로, 내 남자친구 행동을 분석하고 조언을 줘. 먼저 상황을 설명할게.”</p>
<p>Role(연애 상담가), Situation(남자친구 행동 분석), Task(조언 제공)가 명확해졌다. “먼저 상황을 설명할게”는 대화 흐름을 설정하는 중요한 추가다.</p>
<p><strong>Query 3: “John Robert의 Damn Bean을 한국어로 번역해줘”</strong></p>
<p>이 입력은 Task는 명확하지만 번역의 성격이 불분명하다. 직역? 의역? 문학적 번역?</p>
<p>자동완성 결과:<br>
“John Robert의 ‘Damn Bean’ 원문의 뉘앙스를 살려서 자연스러운 한국어로 번역해줘. 원작의 톤을 유지하면서.”</p>
<p>Role(전문 번역가), Situation(원작 톤 유지), Task(자연스러운 한국어 번역)이 구체화되었다.</p>
</section>
</section>
<section id="테스트-시-주의사항" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="테스트-시-주의사항"><span class="header-section-number">1.6</span> 테스트 시 주의사항</h2>
<p><strong>GPT-4o mini의 과도한 확장 경향</strong></p>
<p>GPT-4o mini는 때때로 사용자 입력을 지나치게 해석해서 원래 의도와 다른 방향으로 확장하는 경향이 있다. 예를 들어 “개발자 공부”를 “프론트엔드 개발자가 되기 위한 React 중심 학습”으로 과도하게 구체화할 수 있다. 사용자는 백엔드에 관심 있을 수도 있는데 말이다.</p>
<p><strong>해결 방법</strong>: “if it is possible to generate” 조건을 더 강화하거나, Temperature를 낮춰서 보수적으로 확장하게 만든다.</p>
<p><strong>Claude의 맥락 과잉 해석</strong></p>
<p>Claude는 감정적 단서를 민감하게 포착한다. “잘 모르겠어”라는 표현에서 불안감을 읽고, 때로는 사용자가 원하지 않는 감정적 조언을 추가할 수 있다. 사용자는 단순히 정보를 원했는데, Claude가 “힘들겠지만 괜찮아질 거야” 같은 위로를 덧붙이는 식이다.</p>
<p><strong>해결 방법</strong>: “focus on task enhancement, not emotional support unless explicitly needed” 같은 제약을 추가한다.</p>
<p><strong>일관성 검증의 중요성</strong></p>
<p>같은 입력을 여러 번 테스트해봐야 한다. Temperature가 0이 아닌 이상, 매번 다른 결과가 나올 수 있다. “개발자 공부”를 10번 입력했을 때, 10번 모두 합리적인 확장이 나오는지 확인해야 한다. 1~2번은 괜찮은데 나머지가 엉뚱하면 프로덕션에 사용할 수 없다.</p>
<p><strong>사용자 확인 단계의 필요성</strong></p>
<p>자동완성된 프롬프트를 바로 LLM에 전달하지 말고, 사용자에게 먼저 보여주고 확인받는 UI가 필요하다. “이렇게 이해했는데 맞아요?” 같은 확인 단계가 있으면 사용자 신뢰도가 올라간다. 물론 이는 추가 클릭이 필요하지만, 잘못된 해석으로 엉뚱한 답변을 받는 것보다 낫다.</p>
</section>
<section id="프롬프트-자동-완성기의-한계와-개선-방향" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="프롬프트-자동-완성기의-한계와-개선-방향"><span class="header-section-number">1.7</span> 프롬프트 자동 완성기의 한계와 개선 방향</h2>
<p><strong>현재 프롬프트의 한계</strong></p>
<ol type="1">
<li><strong>맥락 정보 부족</strong>: 사용자의 배경, 전문성 수준, 과거 대화 이력이 없으면 정확한 추론이 어렵다.<br>
</li>
<li><strong>도메인 특수성</strong>: “의학 용어 번역”같이 전문 도메인은 일반적인 자동완성으로 처리하기 어렵다.<br>
</li>
<li><strong>다국어 처리</strong>: 한국어 특유의 존댓말/반말 구분, 해체 같은 미묘한 톤 조절이 다른 언어로 확장하기 어렵다.</li>
</ol>
<p><strong>개선 방향</strong></p>
<ol type="1">
<li><strong>사용자 프로필 통합</strong>: “비전공자”, “5년 경력 개발자” 같은 프로필 정보를 자동완성에 활용<br>
</li>
<li><strong>도메인별 템플릿</strong>: 코딩, 글쓰기, 번역 등 도메인별로 특화된 확장 규칙 적용<br>
</li>
<li><strong>학습 루프</strong>: 사용자가 자동완성 결과를 수정한 패턴을 학습해서 점진적 개선</li>
</ol>
<p><strong>비즈니스 임팩트 측정</strong></p>
<p>자동완성기 도입 전후로 다음 지표를 비교해야 한다:<br>
- 평균 프롬프트 길이 (짧음 → 중간)<br>
- 첫 응답 만족도 (낮음 → 높음)<br>
- 재질문 비율 (높음 → 낮음)<br>
- 멀티턴 대화 비율 (낮음 → 높음)</p>
<p>이 네 가지가 모두 개선되면 자동완성기가 성공한 것이다.</p>


</section>
</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>