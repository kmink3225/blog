<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kwangmin Kim">
<meta name="description" content="Few-Shot Prompting의 정의부터 실전 활용까지 체계적으로 설명한다. GPT-3 논문(Brown et al.&nbsp;2020)의 핵심 발견을 통해 모델 크기와 예시 개수의 상관관계, In-Context Learning의 메커니즘을 분석한다. “What Makes In-Context Learning Work?”(Min et al.&nbsp;2022) 연구를 바탕으로 예시의 품질(정답 라벨 vs 랜덤 라벨), 입력-라벨 형식의 중요성, 4가지 핵심 요소(Format, Label Space, Input Distribution, Mapping)를 상세히 다룬다. 감정 분류, 새로운 단어 학습, 일기 작성 등 실무 예시와 복잡한 추론 과제에서의 한계를 통해 Few-Shot의 적절한 활용 시나리오를 제시한다.">

<title>Kwangmin Kim - Few-Shot Prompting</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete-preset-algolia.umd.js"></script>
<meta name="quarto:offset" content="../../../../../">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "algolia": {
    "application-id": "DUOR1DRC9D",
    "search-only-api-key": "f264da5dea684ffb9e9b4a574af3ed61",
    "index-name": "prod_QUARTO",
    "analytics-events": true,
    "show-logo": true,
    "libDir": "site_libs"
  },
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": true,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js"></script>


<script type="text/javascript">
var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights/dist/search-insights.iife.min.js";
!function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
(e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
}(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-plugin-algolia-insights">

</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6W0EKFMWBN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6W0EKFMWBN', { 'anonymize_ip': true});
</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: black;
      }

      .quarto-title-block .quarto-title-banner {
        color: black;
background: #EDF3F9;
      }
</style>
<style>
.custom-footer { 
  text-align: center; 
  font-size: 0.8em; 
  color: #666; 
  margin-top: 2rem; 
}
</style>


<link rel="stylesheet" href="../../../../../styles.css">
<meta property="og:title" content="Kwangmin Kim - Few-Shot Prompting">
<meta property="og:description" content="Few-Shot Prompting의 정의부터 실전 활용까지 체계적으로 설명한다. GPT-3 논문(Brown et al.&nbsp;2020)의 핵심 발견을 통해 모델 크기와 예시 개수의 상관관계, In-Context Learning의 메커니즘을 분석한다. “What Makes In-Context Learning Work?”(Min et al.&nbsp;2022) 연구를 바탕으로 예시의 품질(정답 라벨 vs 랜덤 라벨), 입력-라벨 형식의 중요성, 4가지 핵심 요소(Format, Label Space, Input Distribution, Mapping)를 상세히 다룬다. 감정 분류, 새로운 단어 학습, 일기 작성 등 실무 예시와 복잡한 추론 과제에서의 한계를 통해 Few-Shot의 적절한 활용 시나리오를 제시한다.">
<meta property="og:site_name" content="Kwangmin Kim">
<meta name="twitter:title" content="Kwangmin Kim - Few-Shot Prompting">
<meta name="twitter:description" content="Few-Shot Prompting의 정의부터 실전 활용까지 체계적으로 설명한다. GPT-3 논문(Brown et al.&nbsp;2020)의 핵심 발견을 통해 모델 크기와 예시 개수의 상관관계, In-Context Learning의 메커니즘을 분석한다. “What Makes In-Context Learning Work?”(Min et al.&nbsp;2022) 연구를 바탕으로 예시의 품질(정답 라벨 vs 랜덤 라벨), 입력-라벨 형식의 중요성, 4가지 핵심 요소(Format, Label Space, Input Distribution, Mapping)를 상세히 다룬다. 감정 분류, 새로운 단어 학습, 일기 작성 등 실무 예시와 복잡한 추론 과제에서의 한계를 통해 Few-Shot의 적절한 활용 시나리오를 제시한다.">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../.././images/logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Kwangmin Kim</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html"> 
<span class="menu-text">Me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225"> <i class="bi bi-github" role="img" aria-label="Github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/kwangmin-kim-a5241b200/"> <i class="bi bi-linkedin" role="img" aria-label="Linkedin">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="다크 모드 전환"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">Few-Shot Prompting</h1>
            <p class="subtitle lead">적은 예시로 큰 효과를 만드는 In-Context Learning의 원리와 실전</p>
                  <div>
        <div class="description">
          <p>Few-Shot Prompting의 정의부터 실전 활용까지 체계적으로 설명한다. GPT-3 논문(Brown et al.&nbsp;2020)의 핵심 발견을 통해 모델 크기와 예시 개수의 상관관계, In-Context Learning의 메커니즘을 분석한다. “What Makes In-Context Learning Work?”(Min et al.&nbsp;2022) 연구를 바탕으로 예시의 품질(정답 라벨 vs 랜덤 라벨), 입력-라벨 형식의 중요성, 4가지 핵심 요소(Format, Label Space, Input Distribution, Mapping)를 상세히 다룬다. 감정 분류, 새로운 단어 학습, 일기 작성 등 실무 예시와 복잡한 추론 과제에서의 한계를 통해 Few-Shot의 적절한 활용 시나리오를 제시한다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Prompt Engineering</div>
                <div class="quarto-category">LLM</div>
                <div class="quarto-category">AI</div>
                <div class="quarto-category">Agent</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      <div>
      <div class="quarto-title-meta-heading">저자</div>
      <div class="quarto-title-meta-contents">
               <p>Kwangmin Kim </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">공개</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2025년 01월 29일</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#part-5-zero-shot-chain-of-thought-prompting" id="toc-part-5-zero-shot-chain-of-thought-prompting" class="nav-link active" data-scroll-target="#part-5-zero-shot-chain-of-thought-prompting"><span class="header-section-number">1</span> Part 5: Zero-Shot Chain-of-Thought Prompting</a>
  <ul class="collapse">
  <li><a href="#들어가며" id="toc-들어가며" class="nav-link" data-scroll-target="#들어가며"><span class="header-section-number">1.1</span> 들어가며</a></li>
  <li><a href="#few-shot-cot의-문제점-재확인" id="toc-few-shot-cot의-문제점-재확인" class="nav-link" data-scroll-target="#few-shot-cot의-문제점-재확인"><span class="header-section-number">1.2</span> Few-Shot CoT의 문제점 재확인</a>
  <ul class="collapse">
  <li><a href="#전통적인-few-shot-cot" id="toc-전통적인-few-shot-cot" class="nav-link" data-scroll-target="#전통적인-few-shot-cot"><span class="header-section-number">1.2.1</span> 전통적인 Few-Shot CoT</a></li>
  </ul></li>
  <li><a href="#zero-shot-cot의-혁신-단계적으로-생각해봅시다" id="toc-zero-shot-cot의-혁신-단계적으로-생각해봅시다" class="nav-link" data-scroll-target="#zero-shot-cot의-혁신-단계적으로-생각해봅시다"><span class="header-section-number">1.3</span> Zero-Shot CoT의 혁신: “단계적으로 생각해봅시다”</a>
  <ul class="collapse">
  <li><a href="#핵심-아이디어" id="toc-핵심-아이디어" class="nav-link" data-scroll-target="#핵심-아이디어"><span class="header-section-number">1.3.1</span> 핵심 아이디어</a></li>
  <li><a href="#실제-적용-예시" id="toc-실제-적용-예시" class="nav-link" data-scroll-target="#실제-적용-예시"><span class="header-section-number">1.3.2</span> 실제 적용 예시</a></li>
  </ul></li>
  <li><a href="#few-shot-cot-vs-zero-shot-cot-비교" id="toc-few-shot-cot-vs-zero-shot-cot-비교" class="nav-link" data-scroll-target="#few-shot-cot-vs-zero-shot-cot-비교"><span class="header-section-number">1.4</span> Few-Shot CoT vs Zero-Shot CoT 비교</a>
  <ul class="collapse">
  <li><a href="#시각적-비교" id="toc-시각적-비교" class="nav-link" data-scroll-target="#시각적-비교"><span class="header-section-number">1.4.1</span> 시각적 비교</a></li>
  <li><a href="#동일-문제로-비교" id="toc-동일-문제로-비교" class="nav-link" data-scroll-target="#동일-문제로-비교"><span class="header-section-number">1.4.2</span> 동일 문제로 비교</a></li>
  </ul></li>
  <li><a href="#연구-결과-zero-shot-cot의-효과" id="toc-연구-결과-zero-shot-cot의-효과" class="nav-link" data-scroll-target="#연구-결과-zero-shot-cot의-효과"><span class="header-section-number">1.5</span> 연구 결과: Zero-Shot CoT의 효과</a>
  <ul class="collapse">
  <li><a href="#모델-크기별-성능-변화" id="toc-모델-크기별-성능-변화" class="nav-link" data-scroll-target="#모델-크기별-성능-변화"><span class="header-section-number">1.5.1</span> 모델 크기별 성능 변화</a></li>
  <li><a href="#벤치마크-전반적-성능" id="toc-벤치마크-전반적-성능" class="nav-link" data-scroll-target="#벤치마크-전반적-성능"><span class="header-section-number">1.5.2</span> 벤치마크 전반적 성능</a></li>
  <li><a href="#샘플링-수에-따른-정확도-변화" id="toc-샘플링-수에-따른-정확도-변화" class="nav-link" data-scroll-target="#샘플링-수에-따른-정확도-변화"><span class="header-section-number">1.5.3</span> 샘플링 수에 따른 정확도 변화</a></li>
  </ul></li>
  <li><a href="#다양한-trigger-문구-실험" id="toc-다양한-trigger-문구-실험" class="nav-link" data-scroll-target="#다양한-trigger-문구-실험"><span class="header-section-number">1.6</span> 다양한 Trigger 문구 실험</a>
  <ul class="collapse">
  <li><a href="#효과적인-trigger-문구들" id="toc-효과적인-trigger-문구들" class="nav-link" data-scroll-target="#효과적인-trigger-문구들"><span class="header-section-number">1.6.1</span> 효과적인 Trigger 문구들</a></li>
  <li><a href="#효과-없는-trigger-문구들" id="toc-효과-없는-trigger-문구들" class="nav-link" data-scroll-target="#효과-없는-trigger-문구들"><span class="header-section-number">1.6.2</span> 효과 없는 Trigger 문구들</a></li>
  <li><a href="#한국어-적용" id="toc-한국어-적용" class="nav-link" data-scroll-target="#한국어-적용"><span class="header-section-number">1.6.3</span> 한국어 적용</a></li>
  </ul></li>
  <li><a href="#실습-zero-shot-cot-적용하기" id="toc-실습-zero-shot-cot-적용하기" class="nav-link" data-scroll-target="#실습-zero-shot-cot-적용하기"><span class="header-section-number">1.7</span> 실습: Zero-Shot CoT 적용하기</a>
  <ul class="collapse">
  <li><a href="#실습-1-기본-zero-shot-cot" id="toc-실습-1-기본-zero-shot-cot" class="nav-link" data-scroll-target="#실습-1-기본-zero-shot-cot"><span class="header-section-number">1.7.1</span> 실습 1: 기본 Zero-Shot CoT</a></li>
  <li><a href="#실습-2-일기-작성" id="toc-실습-2-일기-작성" class="nav-link" data-scroll-target="#실습-2-일기-작성"><span class="header-section-number">1.7.2</span> 실습 2: 일기 작성</a></li>
  <li><a href="#실습-3-재닛의-오리-문제-복습" id="toc-실습-3-재닛의-오리-문제-복습" class="nav-link" data-scroll-target="#실습-3-재닛의-오리-문제-복습"><span class="header-section-number">1.7.3</span> 실습 3: 재닛의 오리 문제 (복습)</a></li>
  </ul></li>
  <li><a href="#zero-shot-cot의-작동-원리" id="toc-zero-shot-cot의-작동-원리" class="nav-link" data-scroll-target="#zero-shot-cot의-작동-원리"><span class="header-section-number">1.8</span> Zero-Shot CoT의 작동 원리</a>
  <ul class="collapse">
  <li><a href="#왜-이렇게-간단한-문구가-효과가-있을까" id="toc-왜-이렇게-간단한-문구가-효과가-있을까" class="nav-link" data-scroll-target="#왜-이렇게-간단한-문구가-효과가-있을까"><span class="header-section-number">1.8.1</span> 왜 이렇게 간단한 문구가 효과가 있을까?</a></li>
  <li><a href="#few-shot-cot와의-관계" id="toc-few-shot-cot와의-관계" class="nav-link" data-scroll-target="#few-shot-cot와의-관계"><span class="header-section-number">1.8.2</span> Few-Shot CoT와의 관계</a></li>
  </ul></li>
  <li><a href="#zero-shot-cot의-장점과-한계" id="toc-zero-shot-cot의-장점과-한계" class="nav-link" data-scroll-target="#zero-shot-cot의-장점과-한계"><span class="header-section-number">1.9</span> Zero-Shot CoT의 장점과 한계</a>
  <ul class="collapse">
  <li><a href="#장점" id="toc-장점" class="nav-link" data-scroll-target="#장점"><span class="header-section-number">1.9.1</span> 장점</a></li>
  <li><a href="#한계점" id="toc-한계점" class="nav-link" data-scroll-target="#한계점"><span class="header-section-number">1.9.2</span> 한계점</a></li>
  </ul></li>
  <li><a href="#zero-shot-cot-활용-팁" id="toc-zero-shot-cot-활용-팁" class="nav-link" data-scroll-target="#zero-shot-cot-활용-팁"><span class="header-section-number">1.10</span> Zero-Shot CoT 활용 팁</a>
  <ul class="collapse">
  <li><a href="#trigger-문구-선택" id="toc-trigger-문구-선택" class="nav-link" data-scroll-target="#trigger-문구-선택"><span class="header-section-number">1.10.1</span> 1. Trigger 문구 선택</a></li>
  <li><a href="#언어-명시" id="toc-언어-명시" class="nav-link" data-scroll-target="#언어-명시"><span class="header-section-number">1.10.2</span> 2. 언어 명시</a></li>
  <li><a href="#temperature-설정" id="toc-temperature-설정" class="nav-link" data-scroll-target="#temperature-설정"><span class="header-section-number">1.10.3</span> 3. Temperature 설정</a></li>
  <li><a href="#출력-형식-가이드" id="toc-출력-형식-가이드" class="nav-link" data-scroll-target="#출력-형식-가이드"><span class="header-section-number">1.10.4</span> 4. 출력 형식 가이드</a></li>
  <li><a href="#복잡한-문제-처리" id="toc-복잡한-문제-처리" class="nav-link" data-scroll-target="#복잡한-문제-처리"><span class="header-section-number">1.10.5</span> 5. 복잡한 문제 처리</a></li>
  </ul></li>
  <li><a href="#비교-요약-zero-shot-vs-few-shot-vs-zero-shot-cot" id="toc-비교-요약-zero-shot-vs-few-shot-vs-zero-shot-cot" class="nav-link" data-scroll-target="#비교-요약-zero-shot-vs-few-shot-vs-zero-shot-cot"><span class="header-section-number">1.11</span> 비교 요약: Zero-Shot vs Few-Shot vs Zero-Shot CoT</a></li>
  <li><a href="#마무리" id="toc-마무리" class="nav-link" data-scroll-target="#마무리"><span class="header-section-number">1.12</span> 마무리</a></li>
  <li><a href="#참고문헌" id="toc-참고문헌" class="nav-link" data-scroll-target="#참고문헌"><span class="header-section-number">1.13</span> 참고문헌</a></li>
  <li><a href="#self-consistency" id="toc-self-consistency" class="nav-link" data-scroll-target="#self-consistency"><span class="header-section-number">1.14</span> Self-consistency</a></li>
  </ul></li>
  <li><a href="#advanced" id="toc-advanced" class="nav-link" data-scroll-target="#advanced"><span class="header-section-number">2</span> Advanced</a>
  <ul class="collapse">
  <li><a href="#generate-knowledge-prompting" id="toc-generate-knowledge-prompting" class="nav-link" data-scroll-target="#generate-knowledge-prompting"><span class="header-section-number">2.1</span> Generate Knowledge Prompting,</a></li>
  <li><a href="#prompt-chaining-tree-of-thoughts" id="toc-prompt-chaining-tree-of-thoughts" class="nav-link" data-scroll-target="#prompt-chaining-tree-of-thoughts"><span class="header-section-number">2.2</span> Prompt Chaining, Tree of Thoughts</a></li>
  <li><a href="#retrieval-augmented-generation" id="toc-retrieval-augmented-generation" class="nav-link" data-scroll-target="#retrieval-augmented-generation"><span class="header-section-number">2.3</span> • Retrieval Augmented Generation,</a></li>
  <li><a href="#automatic-prompt-engineer" id="toc-automatic-prompt-engineer" class="nav-link" data-scroll-target="#automatic-prompt-engineer"><span class="header-section-number">2.4</span> Automatic Prompt Engineer,</a></li>
  <li><a href="#active-prompt-directional-stimulus" id="toc-active-prompt-directional-stimulus" class="nav-link" data-scroll-target="#active-prompt-directional-stimulus"><span class="header-section-number">2.5</span> Active-Prompt, Directional Stimulus</a></li>
  <li><a href="#prompting-react" id="toc-prompting-react" class="nav-link" data-scroll-target="#prompting-react"><span class="header-section-number">2.6</span> Prompting, React</a></li>
  </ul></li>
  <li><a href="#applications" id="toc-applications" class="nav-link" data-scroll-target="#applications"><span class="header-section-number">3</span> Applications</a>
  <ul class="collapse">
  <li><a href="#데이터-생성과-분류하기" id="toc-데이터-생성과-분류하기" class="nav-link" data-scroll-target="#데이터-생성과-분류하기"><span class="header-section-number">3.1</span> 데이터 생성과 분류하기</a></li>
  <li><a href="#코드-생성하기" id="toc-코드-생성하기" class="nav-link" data-scroll-target="#코드-생성하기"><span class="header-section-number">3.2</span> 코드 생성하기</a></li>
  <li><a href="#펑션콜-함수" id="toc-펑션콜-함수" class="nav-link" data-scroll-target="#펑션콜-함수"><span class="header-section-number">3.3</span> 펑션콜 함수</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="part-5-zero-shot-chain-of-thought-prompting" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Part 5: Zero-Shot Chain-of-Thought Prompting</h1>
<section id="들어가며" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="들어가며"><span class="header-section-number">1.1</span> 들어가며</h2>
<p>이전 글에서 Chain-of-Thought (CoT) Prompting이 복잡한 추론 문제에서 탁월한 성능을 보인다는 것을 확인했습니다. 하지만 CoT에는 치명적인 단점이 있었습니다. <strong>매번 사람이 직접 추론 단계를 작성한 예시를 제공해야 한다는 것</strong>입니다.</p>
<p>이번 글에서는 이러한 수작업 부담을 획기적으로 줄인 <strong>Zero-Shot Chain-of-Thought</strong> 기법을 소개합니다. 놀랍게도, 단 한 문장만 추가하면 됩니다.</p>
</section>
<section id="few-shot-cot의-문제점-재확인" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="few-shot-cot의-문제점-재확인"><span class="header-section-number">1.2</span> Few-Shot CoT의 문제점 재확인</h2>
<p>먼저 기존 CoT 방식의 번거로움을 다시 살펴보겠습니다.</p>
<section id="전통적인-few-shot-cot" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="전통적인-few-shot-cot"><span class="header-section-number">1.2.1</span> 전통적인 Few-Shot CoT</h3>
<pre><code>이 그룹의 홀수의 합이 짝수가 된다: 4, 8, 9, 15, 12, 2, 1.
A: 모든 홀수(9, 15, 1)를 더하면 25입니다.
   정답은 "거짓"입니다.

이 그룹의 홀수의 합이 짝수가 된다: 17, 10, 19, 4, 8, 12, 24.
A: 모든 홀수(17, 19)를 더하면 36입니다.
   정답은 "참"입니다.

이 그룹의 홀수의 합이 짝수가 된다: 16, 11, 14, 4, 8, 13, 24.
A: 모든 홀수(11, 13)를 더하면 24입니다.
   정답은 "참"입니다.

이 그룹의 홀수의 합이 짝수가 된다: 17, 9, 10, 12, 13, 4, 2.
A: 모든 홀수(17, 9, 13)를 더하면 39입니다.
   정답은 "거짓"입니다.

이 그룹의 홀수의 합이 짝수가 된다: 15, 32, 5, 13, 82, 7, 1.
A:</code></pre>
<p><strong>문제점:</strong> - 4개의 예시를 모두 직접 작성해야 함 - 각 예시마다 추론 과정을 상세히 기술해야 함 - 도메인이나 문제 유형이 바뀌면 새로 작성해야 함 - 시간과 노력이 많이 소요됨</p>
</section>
</section>
<section id="zero-shot-cot의-혁신-단계적으로-생각해봅시다" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="zero-shot-cot의-혁신-단계적으로-생각해봅시다"><span class="header-section-number">1.3</span> Zero-Shot CoT의 혁신: “단계적으로 생각해봅시다”</h2>
<section id="핵심-아이디어" class="level3" data-number="1.3.1">
<h3 data-number="1.3.1" class="anchored" data-anchor-id="핵심-아이디어"><span class="header-section-number">1.3.1</span> 핵심 아이디어</h3>
<p>Kojima et al.&nbsp;(2022)의 연구 “Large Language Models are Zero-Shot Reasoners”에서 놀라운 발견을 했습니다.</p>
<p><strong>단 하나의 문장을 추가하는 것만으로 CoT의 효과를 얻을 수 있다:</strong></p>
<pre><code>"Let's think step by step."
(단계적으로 생각해봅시다.)</code></pre>
</section>
<section id="실제-적용-예시" class="level3" data-number="1.3.2">
<h3 data-number="1.3.2" class="anchored" data-anchor-id="실제-적용-예시"><span class="header-section-number">1.3.2</span> 실제 적용 예시</h3>
<pre><code>Q: 저글러가 16개의 공을 저글링할 수 있습니다. 
   공의 절반은 골프공이고, 골프공의 절반은 파란색입니다. 
   파란색 골프공은 몇 개입니까?

Let's think step by step.</code></pre>
<p><strong>모델 출력:</strong></p>
<pre><code>총 16개의 공이 있습니다. 공의 절반은 골프공입니다.
따라서 16 ÷ 2 = 8개의 골프공이 있습니다.
골프공의 절반은 파란색입니다.
따라서 8 ÷ 2 = 4개의 파란색 골프공이 있습니다.
정답은 4입니다.</code></pre>
<p>✅ <strong>정답!</strong> 예시 없이도 올바른 추론 과정을 생성했습니다.</p>
</section>
</section>
<section id="few-shot-cot-vs-zero-shot-cot-비교" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="few-shot-cot-vs-zero-shot-cot-비교"><span class="header-section-number">1.4</span> Few-Shot CoT vs Zero-Shot CoT 비교</h2>
<section id="시각적-비교" class="level3" data-number="1.4.1">
<h3 data-number="1.4.1" class="anchored" data-anchor-id="시각적-비교"><span class="header-section-number">1.4.1</span> 시각적 비교</h3>
<p><strong>Few-Shot CoT:</strong></p>
<pre><code>[예시 1: 문제 + 상세한 추론 과정 + 답]
[예시 2: 문제 + 상세한 추론 과정 + 답]
[예시 3: 문제 + 상세한 추론 과정 + 답]
[실제 문제]</code></pre>
<p><strong>Zero-Shot CoT:</strong></p>
<pre><code>[실제 문제]
Let's think step by step.</code></pre>
<p>훨씬 간단합니다!</p>
</section>
<section id="동일-문제로-비교" class="level3" data-number="1.4.2">
<h3 data-number="1.4.2" class="anchored" data-anchor-id="동일-문제로-비교"><span class="header-section-number">1.4.2</span> 동일 문제로 비교</h3>
<p><strong>문제:</strong> 저글러가 16개의 공을 저글링할 수 있습니다. 공의 절반은 골프공이고, 골프공의 절반은 파란색입니다. 파란색 골프공은 몇 개입니까?</p>
<p><strong>Zero-shot (예시 없음):</strong></p>
<pre><code>Q: [문제]
A: 정답은 (아랍어 숫자로)</code></pre>
<p>출력: 8 ❌</p>
<p><strong>Few-shot CoT:</strong></p>
<pre><code>[3개의 예시 + 추론 과정]
Q: [문제]
A:</code></pre>
<p>출력: (올바른 추론 과정) → 4 ✅</p>
<p><strong>Zero-shot CoT (본 연구):</strong></p>
<pre><code>Q: [문제]
A: Let's think step by step.</code></pre>
<p>출력: (올바른 추론 과정) → 4 ✅</p>
</section>
</section>
<section id="연구-결과-zero-shot-cot의-효과" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="연구-결과-zero-shot-cot의-효과"><span class="header-section-number">1.5</span> 연구 결과: Zero-Shot CoT의 효과</h2>
<section id="모델-크기별-성능-변화" class="level3" data-number="1.5.1">
<h3 data-number="1.5.1" class="anchored" data-anchor-id="모델-크기별-성능-변화"><span class="header-section-number">1.5.1</span> 모델 크기별 성능 변화</h3>
<p>Kojima et al.&nbsp;(2022)은 다양한 크기의 모델에서 Zero-Shot CoT의 효과를 측정했습니다.</p>
<p><strong>GSM8K 데이터셋 (수학 문제):</strong></p>
<pre><code>모델 크기 | Zero-shot | Zero-shot-CoT | 향상률
---------|-----------|---------------|--------
8B       |    0%     |      5%       | +5%p
62B      |   10%     |     15%       | +5%p
540B     |   15%     |     45%       | +30%p</code></pre>
<p><strong>MultiArith 데이터셋:</strong></p>
<pre><code>GPT-3 모델별 성능:
- 0.3B: 0% → 0%
- 1.3B: 0% → 0%
- 6.7B: 5% → 20%
- 175B: 20% → 80%</code></pre>
<p><strong>주요 발견:</strong> - 모델이 클수록 Zero-Shot CoT의 효과가 극대화됨 - 175B 이상에서 Few-Shot CoT에 근접하는 성능 - 작은 모델에서도 일부 향상 효과 존재</p>
</section>
<section id="벤치마크-전반적-성능" class="level3" data-number="1.5.2">
<h3 data-number="1.5.2" class="anchored" data-anchor-id="벤치마크-전반적-성능"><span class="header-section-number">1.5.2</span> 벤치마크 전반적 성능</h3>
<p><strong>산술 추론:</strong> - MultiArith: 17.7% → 78.7% (+61%p) - GSM8K: 10.4% → 40.7% (+30.3%p) - AddSub: 상당한 향상</p>
<p><strong>상식 추론:</strong> - CommonsenseQA: 꾸준한 향상 - StrategyQA: 지속적 개선</p>
<p><strong>기타 추론:</strong> - Date Understanding: 명확한 개선 - Sports Understanding: 유의미한 향상</p>
</section>
<section id="샘플링-수에-따른-정확도-변화" class="level3" data-number="1.5.3">
<h3 data-number="1.5.3" class="anchored" data-anchor-id="샘플링-수에-따른-정확도-변화"><span class="header-section-number">1.5.3</span> 샘플링 수에 따른 정확도 변화</h3>
<p>연구진은 여러 번 추론 경로를 샘플링했을 때의 효과도 분석했습니다.</p>
<pre><code>샘플 수 증가에 따른 정확도:
- MultiArith: 50% → 55% → 65% → 75%
- SVAMP: 35% → 45% → 50% → 55%
- CommonsenseQA: 60% → 65% → 70% → 75%</code></pre>
<p><strong>핵심 인사이트:</strong> 더 많은 추론 경로를 샘플링할수록 정확도가 향상됩니다. 이는 다음 글에서 다룰 Self-Consistency 기법의 기반이 됩니다.</p>
</section>
</section>
<section id="다양한-trigger-문구-실험" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="다양한-trigger-문구-실험"><span class="header-section-number">1.6</span> 다양한 Trigger 문구 실험</h2>
<p>“Let’s think step by step” 외에도 다양한 트리거 문구가 효과가 있는지 실험했습니다.</p>
<section id="효과적인-trigger-문구들" class="level3" data-number="1.6.1">
<h3 data-number="1.6.1" class="anchored" data-anchor-id="효과적인-trigger-문구들"><span class="header-section-number">1.6.1</span> 효과적인 Trigger 문구들</h3>
<p><strong>MultiArith 데이터셋 정확도 (text-davinci-002 모델):</strong></p>
<table class="table">
<colgroup>
<col style="width: 22%">
<col style="width: 48%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>순위</th>
<th>Trigger 문구</th>
<th>정확도</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Let’s think step by step.</td>
<td>78.7%</td>
</tr>
<tr class="even">
<td>2</td>
<td>First, (*1)</td>
<td>77.3%</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Let’s think about this logically.</td>
<td>74.5%</td>
</tr>
<tr class="even">
<td>4</td>
<td>Let’s solve this problem by splitting it into steps. (*2)</td>
<td>72.2%</td>
</tr>
<tr class="odd">
<td>5</td>
<td>Let’s be realistic and think step by step.</td>
<td>70.8%</td>
</tr>
<tr class="even">
<td>6</td>
<td>Let’s think like a detective step by step.</td>
<td>70.3%</td>
</tr>
<tr class="odd">
<td>7</td>
<td>Let’s think</td>
<td>57.5%</td>
</tr>
</tbody>
</table>
<p>(<em>1) Ahn et al.&nbsp;(2022)에서 로봇 제어 명령 생성용으로 사용 (</em>2) Reynolds and McDonell (2021)에서 사용 (정량적 평가는 없었음)</p>
</section>
<section id="효과-없는-trigger-문구들" class="level3" data-number="1.6.2">
<h3 data-number="1.6.2" class="anchored" data-anchor-id="효과-없는-trigger-문구들"><span class="header-section-number">1.6.2</span> 효과 없는 Trigger 문구들</h3>
<table class="table">
<thead>
<tr class="header">
<th>순위</th>
<th>Trigger 문구</th>
<th>정확도</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>Don’t think. Just feel.</td>
<td>18.8%</td>
</tr>
<tr class="even">
<td>11</td>
<td>Let’s think step by step but reach an incorrect answer.</td>
<td>18.7%</td>
</tr>
<tr class="odd">
<td>12</td>
<td>Let’s count the number of “a” in the question.</td>
<td>16.7%</td>
</tr>
<tr class="even">
<td>13</td>
<td>By using the fact that the earth is round,</td>
<td>9.3%</td>
</tr>
</tbody>
</table>
<p><strong>흥미로운 발견:</strong> - 단순히 “Let’s think”만으로도 어느 정도 효과 있음 - “step by step” 같은 단계적 사고 유도가 중요 - 잘못된 방향으로 유도하면 성능이 크게 떨어짐 - 무관한 내용은 거의 효과 없음</p>
</section>
<section id="한국어-적용" class="level3" data-number="1.6.3">
<h3 data-number="1.6.3" class="anchored" data-anchor-id="한국어-적용"><span class="header-section-number">1.6.3</span> 한국어 적용</h3>
<p>영어 trigger를 한국어로 번역해도 효과가 있습니다:</p>
<pre><code>"단계적으로 생각해봅시다."
"먼저,"
"논리적으로 생각해봅시다."
"이 문제를 단계별로 나누어 풀어봅시다."
"현실적으로 단계별로 생각해봅시다."
"탐정처럼 단계별로 생각해봅시다."</code></pre>
</section>
</section>
<section id="실습-zero-shot-cot-적용하기" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="실습-zero-shot-cot-적용하기"><span class="header-section-number">1.7</span> 실습: Zero-Shot CoT 적용하기</h2>
<p>이제 이전에 실패했던 홀수 합 문제를 Zero-Shot CoT로 해결해보겠습니다.</p>
<section id="실습-1-기본-zero-shot-cot" class="level3" data-number="1.7.1">
<h3 data-number="1.7.1" class="anchored" data-anchor-id="실습-1-기본-zero-shot-cot"><span class="header-section-number">1.7.1</span> 실습 1: 기본 Zero-Shot CoT</h3>
<p><strong>문제 설정:</strong></p>
<pre><code>이 그룹의 홀수들을 더하면 짝수가 됩니다: 4, 8, 9, 15, 12, 2, 1.
답: 거짓입니다.

이 그룹의 홀수들을 더하면 짝수가 됩니다: 17, 10, 19, 4, 8, 12, 24.
답: 참입니다.

이 그룹의 홀수들을 더하면 짝수가 됩니다: 16, 11, 14, 4, 8, 13, 24.
답: 참입니다.

이 그룹의 홀수들을 더하면 짝수가 됩니다: 17, 9, 10, 12, 13, 4, 2.
답: 거짓입니다.

이 그룹의 홀수들을 더하면 짝수가 됩니다: 15, 32, 5, 13, 82, 7, 1.
답:

-- Let's think step by step.
-- Answer in Korean</code></pre>
<p><strong>OpenAI Playground 설정:</strong> - Model: gpt-3.5-turbo - Temperature: 0.1-0.3 - Maximum tokens: 400</p>
<p><strong>기대 출력:</strong></p>
<pre><code>이 그룹의 홀수들을 더하면 짝수가 됩니다: 15, 32, 5, 13, 82, 7, 1.

먼저 이 숫자들 중 홀수를 찾아봅시다:
- 15 (홀수)
- 32 (짝수)
- 5 (홀수)
- 13 (홀수)
- 82 (짝수)
- 7 (홀수)
- 1 (홀수)

홀수는: 15, 5, 13, 7, 1

이제 이 홀수들을 더해봅시다:
15 + 5 + 13 + 7 + 1 = 41

41은 홀수입니다.

따라서 "이 그룹의 홀수들을 더하면 짝수가 됩니다"는 거짓입니다.

답: 거짓입니다.</code></pre>
<p>✅ <strong>성공!</strong></p>
</section>
<section id="실습-2-일기-작성" class="level3" data-number="1.7.2">
<h3 data-number="1.7.2" class="anchored" data-anchor-id="실습-2-일기-작성"><span class="header-section-number">1.7.2</span> 실습 2: 일기 작성</h3>
<p>Zero-Shot CoT는 추론 문제뿐만 아니라 창작 활동에도 활용할 수 있습니다.</p>
<p><strong>프롬프트:</strong></p>
<pre><code>"오늘의 일기"를 네 줄 분량으로 작성해보세요.
시작 문장의 포맷대로 출력해야 합니다.

시작 문장: "나는 오늘 날씨가 좋아서 산책을 했다. 그리고 __."

Let's think step by step.</code></pre>
<p><strong>기대 출력:</strong></p>
<pre><code>1단계: 산책 후 무엇을 했는지 생각해봅시다.
2단계: 하루 동안의 감정을 떠올려봅시다.
3단계: 저녁 시간 활동을 생각해봅시다.
4단계: 마무리 생각을 정리합시다.

"나는 오늘 날씨가 좋아서 산책을 했다. 그리고 공원에서 예쁜 꽃들을 보며 
기분이 좋아졌다. 오후에는 친구와 카페에서 이야기를 나누며 즐거운 
시간을 보냈다. 하루를 마무리하며 오늘도 행복했다는 생각이 들었다."</code></pre>
</section>
<section id="실습-3-재닛의-오리-문제-복습" class="level3" data-number="1.7.3">
<h3 data-number="1.7.3" class="anchored" data-anchor-id="실습-3-재닛의-오리-문제-복습"><span class="header-section-number">1.7.3</span> 실습 3: 재닛의 오리 문제 (복습)</h3>
<p>이번에는 예시 없이 Zero-Shot CoT만으로 해결해봅시다.</p>
<p><strong>프롬프트:</strong></p>
<pre><code>재닛의 오리들은 하루에 알을 16개 낳습니다. 
재닛은 매일 아침 3개의 알을 먹고, 
매일 4개의 알을 머핀을 굽는데 사용합니다. 
나머지 알은 하나에 2달러씩 판매합니다. 
재닛은 매일 얼마를 벌까요?

Let's think step by step.</code></pre>
<p><strong>기대 출력:</strong></p>
<pre><code>1단계: 재닛의 오리들이 낳는 알의 개수를 확인합니다.
→ 하루 16개

2단계: 재닛이 사용하는 알의 개수를 계산합니다.
→ 먹는 알: 3개
→ 머핀용 알: 4개
→ 총 사용: 3 + 4 = 7개

3단계: 판매할 수 있는 알의 개수를 계산합니다.
→ 16 - 7 = 9개

4단계: 판매 금액을 계산합니다.
→ 9개 × 2달러 = 18달러

답: 재닛은 매일 18달러를 벌게 됩니다.</code></pre>
</section>
</section>
<section id="zero-shot-cot의-작동-원리" class="level2" data-number="1.8">
<h2 data-number="1.8" class="anchored" data-anchor-id="zero-shot-cot의-작동-원리"><span class="header-section-number">1.8</span> Zero-Shot CoT의 작동 원리</h2>
<section id="왜-이렇게-간단한-문구가-효과가-있을까" class="level3" data-number="1.8.1">
<h3 data-number="1.8.1" class="anchored" data-anchor-id="왜-이렇게-간단한-문구가-효과가-있을까"><span class="header-section-number">1.8.1</span> 왜 이렇게 간단한 문구가 효과가 있을까?</h3>
<p>연구진은 몇 가지 가설을 제시했습니다:</p>
<ol type="1">
<li><strong>사전 학습 데이터의 영향</strong>
<ul>
<li>인터넷 텍스트에는 “Let’s think step by step”과 함께 단계적 설명이 많음</li>
<li>모델이 학습 과정에서 이러한 패턴을 암묵적으로 학습</li>
</ul></li>
<li><strong>추론 모드 활성화</strong>
<ul>
<li>특정 trigger가 모델의 “추론 모드”를 활성화</li>
<li>단순 패턴 매칭이 아닌 논리적 사고 유도</li>
</ul></li>
<li><strong>중간 표현 생성 유도</strong>
<ul>
<li>최종 답을 바로 생성하는 대신 중간 단계를 거치도록 유도</li>
<li>각 단계가 다음 단계의 맥락이 됨</li>
</ul></li>
</ol>
</section>
<section id="few-shot-cot와의-관계" class="level3" data-number="1.8.2">
<h3 data-number="1.8.2" class="anchored" data-anchor-id="few-shot-cot와의-관계"><span class="header-section-number">1.8.2</span> Few-Shot CoT와의 관계</h3>
<p>Zero-Shot CoT는 Few-Shot CoT를 대체하는 것이 아니라 <strong>보완적인 관계</strong>입니다:</p>
<p><strong>Zero-Shot CoT가 유리한 경우:</strong> - 빠른 프로토타이핑이 필요할 때 - 예시 작성이 어려운 새로운 도메인 - 다양한 문제 유형을 다룰 때 - 예시 작성 비용을 줄이고 싶을 때</p>
<p><strong>Few-Shot CoT가 유리한 경우:</strong> - 특정 추론 스타일이나 포맷이 필요할 때 - 도메인 특화된 전문 지식이 필요할 때 - 최고 성능이 중요할 때 - 일관된 출력 형식이 필요할 때</p>
</section>
</section>
<section id="zero-shot-cot의-장점과-한계" class="level2" data-number="1.9">
<h2 data-number="1.9" class="anchored" data-anchor-id="zero-shot-cot의-장점과-한계"><span class="header-section-number">1.9</span> Zero-Shot CoT의 장점과 한계</h2>
<section id="장점" class="level3" data-number="1.9.1">
<h3 data-number="1.9.1" class="anchored" data-anchor-id="장점"><span class="header-section-number">1.9.1</span> 장점</h3>
<ol type="1">
<li><strong>수작업 부담 대폭 감소</strong>
<ul>
<li>예시를 작성할 필요 없음</li>
<li>단 한 문장만 추가하면 됨</li>
</ul></li>
<li><strong>범용성</strong>
<ul>
<li>다양한 도메인에 즉시 적용 가능</li>
<li>새로운 문제 유형에도 바로 사용</li>
</ul></li>
<li><strong>빠른 프로토타이핑</strong>
<ul>
<li>복잡한 예시 작성 없이 바로 테스트</li>
<li>아이디어 검증이 빠름</li>
</ul></li>
<li><strong>토큰 효율성</strong>
<ul>
<li>Few-Shot보다 적은 토큰 사용</li>
<li>비용 절감 효과</li>
</ul></li>
<li><strong>모델 크기에 따른 확장성</strong>
<ul>
<li>모델이 클수록 효과가 증가</li>
<li>미래의 더 큰 모델에서 더 효과적일 가능성</li>
</ul></li>
</ol>
</section>
<section id="한계점" class="level3" data-number="1.9.2">
<h3 data-number="1.9.2" class="anchored" data-anchor-id="한계점"><span class="header-section-number">1.9.2</span> 한계점</h3>
<ol type="1">
<li><strong>성능 상한</strong>
<ul>
<li>잘 설계된 Few-Shot CoT보다는 성능이 낮을 수 있음</li>
<li>특히 복잡하고 전문적인 도메인에서</li>
</ul></li>
<li><strong>모델 크기 의존성</strong>
<ul>
<li>여전히 대형 모델에서만 효과적</li>
<li>소형 모델에서는 제한적</li>
</ul></li>
<li><strong>일관성 문제</strong>
<ul>
<li>출력 형식이 매번 다를 수 있음</li>
<li>구조화된 출력이 필요한 경우 부적합</li>
</ul></li>
<li><strong>추론 스타일 제어 어려움</strong>
<ul>
<li>특정한 추론 방식을 강제하기 어려움</li>
<li>Few-Shot처럼 세밀한 제어 불가</li>
</ul></li>
</ol>
</section>
</section>
<section id="zero-shot-cot-활용-팁" class="level2" data-number="1.10">
<h2 data-number="1.10" class="anchored" data-anchor-id="zero-shot-cot-활용-팁"><span class="header-section-number">1.10</span> Zero-Shot CoT 활용 팁</h2>
<section id="trigger-문구-선택" class="level3" data-number="1.10.1">
<h3 data-number="1.10.1" class="anchored" data-anchor-id="trigger-문구-선택"><span class="header-section-number">1.10.1</span> 1. Trigger 문구 선택</h3>
<p>목적에 따라 적절한 trigger를 선택하세요:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a><span class="co"># 일반적인 추론</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="co">"Let's think step by step."</span></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="co">"단계적으로 생각해봅시다."</span></span>
<span id="cb20-4"><a href="#cb20-4"></a></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="co"># 논리적 추론 강조</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="co">"Let's think about this logically."</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="co">"논리적으로 생각해봅시다."</span></span>
<span id="cb20-8"><a href="#cb20-8"></a></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="co"># 문제 분해 강조</span></span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="co">"Let's solve this problem by splitting it into steps."</span></span>
<span id="cb20-11"><a href="#cb20-11"></a><span class="co">"이 문제를 단계별로 나누어 풀어봅시다."</span></span>
<span id="cb20-12"><a href="#cb20-12"></a></span>
<span id="cb20-13"><a href="#cb20-13"></a><span class="co"># 신중한 접근 강조</span></span>
<span id="cb20-14"><a href="#cb20-14"></a><span class="co">"Let's be realistic and think step by step."</span></span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="co">"현실적으로 단계별로 생각해봅시다."</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="언어-명시" class="level3" data-number="1.10.2">
<h3 data-number="1.10.2" class="anchored" data-anchor-id="언어-명시"><span class="header-section-number">1.10.2</span> 2. 언어 명시</h3>
<p>한국어 출력을 원하는 경우 명시적으로 지정:</p>
<pre><code>Let's think step by step.
Answer in Korean.</code></pre>
<p>또는</p>
<pre><code>단계적으로 생각해봅시다.
한국어로 답변해주세요.</code></pre>
</section>
<section id="temperature-설정" class="level3" data-number="1.10.3">
<h3 data-number="1.10.3" class="anchored" data-anchor-id="temperature-설정"><span class="header-section-number">1.10.3</span> 3. Temperature 설정</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a><span class="co"># 추론 문제 (정확성 중시)</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>temperature <span class="op">=</span> <span class="fl">0.1</span> <span class="op">~</span> <span class="fl">0.3</span></span>
<span id="cb23-3"><a href="#cb23-3"></a></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="co"># 창작 문제 (다양성 중시)</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>temperature <span class="op">=</span> <span class="fl">0.7</span> <span class="op">~</span> <span class="fl">0.9</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="출력-형식-가이드" class="level3" data-number="1.10.4">
<h3 data-number="1.10.4" class="anchored" data-anchor-id="출력-형식-가이드"><span class="header-section-number">1.10.4</span> 4. 출력 형식 가이드</h3>
<p>필요시 출력 형식도 함께 지정:</p>
<pre><code>Let's think step by step.

최종 답변은 다음 형식으로 제시해주세요:
답: [답변 내용]</code></pre>
</section>
<section id="복잡한-문제-처리" class="level3" data-number="1.10.5">
<h3 data-number="1.10.5" class="anchored" data-anchor-id="복잡한-문제-처리"><span class="header-section-number">1.10.5</span> 5. 복잡한 문제 처리</h3>
<p>매우 복잡한 문제는 단계를 더 명확히 요청:</p>
<pre><code>Let's break down this complex problem into smaller steps.
Think through each step carefully.</code></pre>
</section>
</section>
<section id="비교-요약-zero-shot-vs-few-shot-vs-zero-shot-cot" class="level2" data-number="1.11">
<h2 data-number="1.11" class="anchored" data-anchor-id="비교-요약-zero-shot-vs-few-shot-vs-zero-shot-cot"><span class="header-section-number">1.11</span> 비교 요약: Zero-Shot vs Few-Shot vs Zero-Shot CoT</h2>
<table class="table">
<thead>
<tr class="header">
<th>특성</th>
<th>Zero-Shot</th>
<th>Few-Shot</th>
<th>Zero-Shot CoT</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>예시 필요</td>
<td>❌</td>
<td>✅ (2-10개)</td>
<td>❌</td>
</tr>
<tr class="even">
<td>추론 과정 명시</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr class="odd">
<td>수작업 부담</td>
<td>낮음</td>
<td>높음</td>
<td>매우 낮음</td>
</tr>
<tr class="even">
<td>설정 시간</td>
<td>빠름</td>
<td>느림</td>
<td>매우 빠름</td>
</tr>
<tr class="odd">
<td>복잡한 추론</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr class="even">
<td>토큰 사용량</td>
<td>적음</td>
<td>많음</td>
<td>중간</td>
</tr>
<tr class="odd">
<td>비용</td>
<td>낮음</td>
<td>높음</td>
<td>중간</td>
</tr>
<tr class="even">
<td>성능</td>
<td>낮음</td>
<td>높음</td>
<td>중간~높음</td>
</tr>
<tr class="odd">
<td>유연성</td>
<td>중간</td>
<td>낮음</td>
<td>높음</td>
</tr>
<tr class="even">
<td>일관성</td>
<td>중간</td>
<td>높음</td>
<td>중간</td>
</tr>
</tbody>
</table>
</section>
<section id="마무리" class="level2" data-number="1.12">
<h2 data-number="1.12" class="anchored" data-anchor-id="마무리"><span class="header-section-number">1.12</span> 마무리</h2>
<p>Zero-Shot Chain-of-Thought는 프롬프트 엔지니어링의 효율성을 획기적으로 개선한 기법입니다. “단계적으로 생각해봅시다”라는 단순한 문구 하나로 Few-Shot CoT에 근접하는 성능을 얻을 수 있다는 것은 놀라운 발견입니다.</p>
<p><strong>핵심 요약:</strong> - 단 한 문장 추가로 복잡한 추론 능력 획득 - 예시 작성 부담 없이 빠른 적용 가능 - 대형 모델에서 특히 효과적 - Few-Shot CoT와 상호 보완적 관계</p>
<p>하지만 여전히 한 가지 문제가 남아있습니다. Zero-Shot CoT나 Few-Shot CoT 모두 <strong>한 번의 추론 경로</strong>만 생성합니다. 만약 그 추론 과정에 오류가 있다면 어떻게 될까요?</p>
<p>다음 글에서는 <strong>Self-Consistency</strong> 기법을 통해 여러 추론 경로를 생성하고 가장 일관된 답을 선택하는 방법을 알아보겠습니다. 이는 마치 여러 학생에게 같은 문제를 풀게 하고 다수결로 답을 정하는 것과 유사한 접근입니다.</p>
</section>
<section id="참고문헌" class="level2" data-number="1.13">
<h2 data-number="1.13" class="anchored" data-anchor-id="참고문헌"><span class="header-section-number">1.13</span> 참고문헌</h2>
<ul>
<li>Kojima, T., Gu, S. S., Reid, M., Matsuo, Y., &amp; Iwasawa, Y. (2022). Large language models are zero-shot reasoners. <em>Advances in Neural Information Processing Systems, 35</em>, 22199-22213.</li>
<li>Wei, J., Wang, X., Schuurmans, D., Bosma, M., Xia, F., Chi, E., … &amp; Zhou, D. (2022). Chain-of-thought prompting elicits reasoning in large language models. <em>Advances in Neural Information Processing Systems, 35</em>, 24824-24837.</li>
</ul>
</section>
<section id="self-consistency" class="level2" data-number="1.14">
<h2 data-number="1.14" class="anchored" data-anchor-id="self-consistency"><span class="header-section-number">1.14</span> Self-consistency</h2>
</section>
</section>
<section id="advanced" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Advanced</h1>
<section id="generate-knowledge-prompting" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="generate-knowledge-prompting"><span class="header-section-number">2.1</span> Generate Knowledge Prompting,</h2>
</section>
<section id="prompt-chaining-tree-of-thoughts" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="prompt-chaining-tree-of-thoughts"><span class="header-section-number">2.2</span> Prompt Chaining, Tree of Thoughts</h2>
</section>
<section id="retrieval-augmented-generation" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="retrieval-augmented-generation"><span class="header-section-number">2.3</span> • Retrieval Augmented Generation,</h2>
</section>
<section id="automatic-prompt-engineer" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="automatic-prompt-engineer"><span class="header-section-number">2.4</span> Automatic Prompt Engineer,</h2>
</section>
<section id="active-prompt-directional-stimulus" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="active-prompt-directional-stimulus"><span class="header-section-number">2.5</span> Active-Prompt, Directional Stimulus</h2>
</section>
<section id="prompting-react" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="prompting-react"><span class="header-section-number">2.6</span> Prompting, React</h2>
</section>
</section>
<section id="applications" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Applications</h1>
<section id="데이터-생성과-분류하기" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="데이터-생성과-분류하기"><span class="header-section-number">3.1</span> 데이터 생성과 분류하기</h2>
</section>
<section id="코드-생성하기" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="코드-생성하기"><span class="header-section-number">3.2</span> 코드 생성하기</h2>
</section>
<section id="펑션콜-함수" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="펑션콜-함수"><span class="header-section-number">3.3</span> 펑션콜 함수</h2>


</section>
</section>

</main> <!-- /main -->
<script type="text/javascript">

// replace cmd keyboard shortcut w/ control on non-Mac platforms
const kPlatformMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
if (!kPlatformMac) {
   var kbds = document.querySelectorAll("kbd")
   kbds.forEach(function(kbd) {
      kbd.innerHTML = kbd.innerHTML.replace(/⌘/g, '⌃');
   });
}

// tweak headings in pymd
document.querySelectorAll(".pymd span.co").forEach(el => {
   if (!el.innerText.startsWith("#|")) {
      el.style.fontWeight = 1000;
   }
});

</script>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup" style="padding-bottom: 1em; max-width: 400px;" class="ms-auto me-auto">
  <p style="font-weight: 600; margin-bottom: 0;">Subscribe</p>
  <span style="font-size: 0.9em;">Enjoy this blog? Get notified of new posts by email:</span>
<form action="https://quarto.us14.list-manage.com/subscribe/post?u=c79fb56a311ae347fbe916740&amp;id=ec05dfca03" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
    <div id="mc_embed_signup_scroll">
	
        <div class="input-group mt-1 mb-2">
        <input type="email" class="form-control" placeholder="Email Address" aria-label="Email Address" name="EMAIL" style="font-size: 0.8em; padding: .2em;">
        </div>              

	<div id="mce-responses" class="clear foot">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_c79fb56a311ae347fbe916740_ec05dfca03" tabindex="-1" value=""></div>
        <div class="optionalParent">
            <div class="clear foot" style="display: flex; align-items: center; justify-content: center;">
              
              
                <input type="submit" value="Subscribe" name="subscribe" style="min-width: 150px; font-size: 0.8em;" id="mc-embedded-subscribe" class="button btn btn-light btn-sm ms-auto me-auto">
            </div>
        </div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="kmink3225/blog" data-repo-id="R_kgDOLCZyDg" data-category="Blog" data-category-id="" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Kwangmin Kim</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kmink3225/blog">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>