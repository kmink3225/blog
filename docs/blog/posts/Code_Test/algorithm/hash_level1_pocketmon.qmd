---
title: "Programmers Code Problem Study"
author: "Kwangmin Kim"
date: 2025/09/11
categories: [Algorithm Test]
---

# 문제 정보

-   제목: 폰켓몬
-   링크: https://school.programmers.co.kr/learn/courses/30/lessons/1845
-   **난이도**: 1
-   **유형**: Hash
-   풀이 시간: 10분

# 문제 설명

당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다. 홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 \[3번, 1번, 2번, 3번\]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다.

첫 번째(3번), 두 번째(1번) 폰켓몬을 선택 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택 두 번째(1번), 세 번째(2번) 폰켓몬을 선택 두 번째(1번), 네 번째(3번) 폰켓몬을 선택 세 번째(2번), 네 번째(3번) 폰켓몬을 선택

이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다. 당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요.

## 제한사항

nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다. nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다. 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다. 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.

## 입출력 예

| nums            | result |
|-----------------|--------|
| \[3,1,2,3\]     | 2      |
| \[3,3,3,2,2,4\] | 3      |
| \[3,3,3,2,2,2\] | 2      |

## 입출력 예 설명

### 입출력 예 #1

문제의 예시와 같습니다.

### 입출력 예 #2

6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다. 가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다.

### 입출력 예 #3

6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다. 가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 2번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다.

# 문제 해설

## 문제 핵심 이해

이 문제의 핵심은 **가장 다양한 종류의 폰켓몬을 선택하는 것**

-   전체 폰켓몬: N마리
-   선택 가능: N/2마리\
-   목표: 최대한 많은 종류 선택

## 중요한 조건들

1.  **중복 제거**: 같은 종류는 하나만 선택해도 충분
2.  **선택 제한**: N/2마리만 선택할 수 있다.
3.  **최적 전략**: min(고유 종류 수, N/2)가 정답

## 해결 방법별 분석

### 알고리즘 요약

#### 핵심 아이디어

**최대한 다양한 종류를 선택하되, N/2개 선택 제한을 넘지 않는** 그리디 전략을 해시셋으로 구현

#### 알고리즘 동작

1.  **고유 종류 계산**: `set()`을 사용해 중복을 제거하고 고유한 폰켓몬 종류 개수를 구함
2.  **선택 제한 계산**: 전체 개수를 2로 나누어 선택 가능한 최대 개수를 구함
3.  **최적값 선택**: 두 값 중 작은 값이 선택할 수 있는 최대 종류 수

#### 왜 효율적인가?

해시셋의 자동 중복 제거 기능을 활용하여 O(n) 시간에 간단하고 직관적으로 해결할 수 있음

#### 핵심 포인트

다양성을 최대화하려면 **"각 종류마다 최대 1마리씩만 선택"**하는 것이 최적이므로, 고유 종류 수와 선택 가능 수 중 작은 값이 정답

### 해시셋(Set) 방법 (권장)

**시간복잡도**: O(n)\
**공간복잡도**: O(n)

``` python
def solution(nums):
    # 고유한 종류의 개수 구하기
    unique_types = len(set(nums))  # O(n) 시간, O(n) 공간
    max_selection = len(nums) // 2  # N/2 계산
    
    # 최대한 다양하게 선택할 수 있는 종류 수
    return min(unique_types, max_selection)
```

**동작 원리**: - `set()`을 사용해 중복 제거하여 고유 종류 개수 계산 - `N/2`개만 선택 가능하므로 둘 중 작은 값이 정답

### 해시맵(Dictionary) 방법

**시간복잡도**: O(n)\
**공간복잡도**: O(n)

``` python
def solution(nums):
    # 각 종류별 개수 카운트
    pokemon_count = {}
    for pokemon in nums:
        pokemon_count[pokemon] = pokemon_count.get(pokemon, 0) + 1
    
    # 고유 종류 수와 선택 가능 수 비교
    unique_types = len(pokemon_count)
    max_selection = len(nums) // 2
    
    return min(unique_types, max_selection)
```

**동작 원리**: - 각 폰켓몬 종류별로 개수를 딕셔너리에 저장 - 딕셔너리의 키 개수 = 고유 종류 수 - min(고유 종류 수, N/2) 반환

### 정렬 + 중복 제거 방법

**시간복잡도**: O(n log n)\
**공간복잡도**: O(1)

``` python
def solution(nums):
    nums.sort()  # 정렬 O(n log n)
    
    # 인접한 요소 비교로 고유 종류 개수 계산
    unique_count = 1  # 첫 번째 요소는 항상 고유
    for i in range(1, len(nums)):
        if nums[i] != nums[i-1]:  # 이전 요소와 다르면 새로운 종류
            unique_count += 1
    
    return min(unique_count, len(nums) // 2)
```

**특징**: - 메모리 효율적이지만 정렬로 인한 시간 오버헤드 존재 - 메모리 제약이 있는 환경에서 고려

## 정답 코드

### 최적 해답 (해시셋 사용)

``` python
def solution(nums):
    # 가장 간단하고 직관적
    return min(len(set(nums)), len(nums) // 2)
```

### 해시맵 사용 해답

``` python
def solution(nums):
    # 종류별 개수까지 알고 싶을 때
    pokemon_types = {}
    for pokemon in nums:
        pokemon_types[pokemon] = pokemon_types.get(pokemon, 0) + 1
    
    return min(len(pokemon_types), len(nums) // 2)
```

### 한 줄 해답 (고급)

``` python
def solution(nums):
    return min(len(set(nums)), len(nums) // 2)
```

## 복잡도 비교표

| 방법   | 시간복잡도 | 공간복잡도 | 특징                       |
|--------|------------|------------|----------------------------|
| 해시셋 | O(n)       | O(n)       | **최적 성능, 가장 간단**   |
| 해시맵 | O(n)       | O(n)       | 종류별 개수 정보 추가 제공 |
| 정렬   | O(n log n) | O(1)       | 메모리 효율적              |

## 왜 해시셋이 최적인가?

1.  **단순함**: `min(len(set(nums)), len(nums) // 2)` 한 줄로 해결
2.  **시간 효율성**: O(n) - 배열을 한 번만 순회
3.  **직관성**: "고유한 종류 수"라는 개념과 정확히 일치
4.  **자동 중복 제거**: set 자료구조가 자동으로 중복을 제거

## 핵심 포인트

-   **중복 제거**: set을 사용해 고유 종류만 추출
-   **그리디 전략**: 최대한 다양한 종류를 선택하는 것이 최적
-   **제한 조건**: N/2개만 선택할 수 있으므로 min() 함수 사용

이 문제의 핵심은 **"가능한 많은 종류를 선택하되, N/2개 제한을 넘지 않는 것"**입니다.

## 예제별 동작 과정

### 예제 1: `[3,1,2,3]` → 결과: 2

**해시셋 방법**: 1. `set([3,1,2,3])` = `{1, 2, 3}` → 고유 종류: 3개 2. `len([3,1,2,3]) // 2` = `4 // 2` = 2 → 선택 가능: 2개 3. `min(3, 2)` = 2 → **답: 2**

### 예제 2: `[3,3,3,2,2,4]` → 결과: 3

**해시셋 방법**: 1. `set([3,3,3,2,2,4])` = `{2, 3, 4}` → 고유 종류: 3개 2. `len([3,3,3,2,2,4]) // 2` = `6 // 2` = 3 → 선택 가능: 3개 3. `min(3, 3)` = 3 → **답: 3**

### 예제 3: `[3,3,3,2,2,2]` → 결과: 2

**해시셋 방법**: 1. `set([3,3,3,2,2,2])` = `{2, 3}` → 고유 종류: 2개 2. `len([3,3,3,2,2,2]) // 2` = `6 // 2` = 3 → 선택 가능: 3개 3. `min(2, 3)` = 2 → **답: 2** (종류가 부족해서 제한됨)