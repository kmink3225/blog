---
title: "ReAct: ì¶”ë¡ ê³¼ í–‰ë™ì„ ê²°í•©í•œ AI Agent êµ¬ì¶•"
subtitle: Reasoningê³¼ Actingì„ ê²°í•©í•˜ì—¬ ì™¸ë¶€ ë„êµ¬ë¥¼ í™œìš©í•˜ëŠ” ììœ¨ì  AI Agent êµ¬í˜„ ê¸°ë²•
description: |
  ReAct (Reasoning + Acting)ì˜ ì •ì˜ë¶€í„° ì‹¤ì „ êµ¬í˜„ê¹Œì§€ ì²´ê³„ì ìœ¼ë¡œ ì„¤ëª…í•œë‹¤.
  Yao et al. (2022) "ReAct: Synergizing Reasoning and Acting in Language Models" ì—°êµ¬ë¥¼ ë°”íƒ•ìœ¼ë¡œ
  ì¶”ë¡ (Thought)ê³¼ í–‰ë™(Action)ì„ ë²ˆê°ˆì•„ ìˆ˜í–‰í•˜ëŠ” ì›ë¦¬, Thought-Action-Observation ì‚¬ì´í´ ë©”ì»¤ë‹ˆì¦˜,
  ì™¸ë¶€ ë„êµ¬ í†µí•©(ì›¹ ê²€ìƒ‰, ê³„ì‚°ê¸°, ë°ì´í„°ë² ì´ìŠ¤, API í˜¸ì¶œ) ì „ëµì„ ë¶„ì„í•œë‹¤.
  HotpotQA, FEVER, WebShop ë“± ë²¤ì¹˜ë§ˆí¬ì—ì„œ CoT ëŒ€ë¹„ ìµœëŒ€ 20% ì„±ëŠ¥ í–¥ìƒ ê²°ê³¼ë¥¼ ì œì‹œí•˜ê³ ,
  Wikipedia ê¸°ë°˜ QA, ìˆ˜í•™ ê³„ì‚°, ë‚ ì”¨ ì •ë³´ ì¡°íšŒ, ì „ììƒê±°ë˜ ë“± ì‹¤ë¬´ ì˜ˆì‹œì™€
  Python êµ¬í˜„ ì½”ë“œ(Anthropic Claude API, ë„êµ¬ ì—°ë™)ë¥¼ í†µí•´ ì‹¤ì „ Agent êµ¬ì¶• ë°©ë²•ì„ ìƒì„¸íˆ ë‹¤ë£¬ë‹¤.
  ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë³µêµ¬ ì „ëµ, ìµœëŒ€ ë°˜ë³µ íšŸìˆ˜ ì œí•œ, ë„êµ¬ ì„ íƒ ìµœì í™”,
  CoT vs ReAct ë¹„êµ, ììœ¨ Agent íŒ¨í„´ê³¼ ì•ˆì „ì„± ê³ ë ¤ì‚¬í•­ì„ ì œì‹œí•œë‹¤.
categories:
  - Prompt Engineering
  - LLM
  - AI
  - Agent
author: Kwangmin Kim
date: 02/09/2025
format: 
  html:
    page-layout: full
    code-fold: true
    toc: true
    number-sections: true
draft: False
---

## ë“¤ì–´ê°€ë©°

LLMì€ ê°•ë ¥í•˜ì§€ë§Œ, **í–‰ë™í•  ìˆ˜ ì—†ë‹¤**ëŠ” ê·¼ë³¸ì ì¸ í•œê³„ê°€ ìˆë‹¤. ì§ˆë¬¸ì— ë‹µí•  ìˆ˜ëŠ” ìˆì§€ë§Œ, ì›¹ ê²€ìƒ‰ì„ í•˜ê±°ë‚˜, ê³„ì‚°ì„ ìˆ˜í–‰í•˜ê±°ë‚˜, ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì¡°íšŒí•  ìˆ˜ëŠ” ì—†ë‹¤.

**ReAct (Reasoning + Acting)**ëŠ” ì´ í•œê³„ë¥¼ ê·¹ë³µí•œë‹¤. LLMì´ **ì¶”ë¡ (Reasoning)**ê³¼ **í–‰ë™(Acting)**ì„ ë²ˆê°ˆì•„ ìˆ˜í–‰í•˜ë©°, ì™¸ë¶€ ë„êµ¬ë¥¼ í™œìš©í•˜ì—¬ ë³µì¡í•œ ë¬¸ì œë¥¼ ë‹¨ê³„ì ìœ¼ë¡œ í•´ê²°í•œë‹¤.

### ê¸°ì¡´ ì ‘ê·¼ë²•ì˜ í•œê³„

#### ìˆœìˆ˜ ì¶”ë¡ ë§Œ (Chain-of-Thought)

```
ì§ˆë¬¸: "2024ë…„ ë…¸ë²¨ ë¬¼ë¦¬í•™ìƒ ìˆ˜ìƒìëŠ”?"

CoT ì‘ë‹µ:
"ë‹¨ê³„ 1: ë…¸ë²¨ìƒì€ ë§¤ë…„ 10ì›”ì— ë°œí‘œë©ë‹ˆë‹¤.
 ë‹¨ê³„ 2: ë¬¼ë¦¬í•™ìƒì€ ì¤‘ìš”í•œ ë°œê²¬ì— ìˆ˜ì—¬ë©ë‹ˆë‹¤.
 ë‹¨ê³„ 3: 2024ë…„ ìˆ˜ìƒìëŠ”... (í• ë£¨ì‹œë„¤ì´ì…˜ ê°€ëŠ¥)"

ë¬¸ì œì : ì‹¤ì œ ìµœì‹  ì •ë³´ ì—†ì´ ì¶”ì¸¡
```

#### ìˆœìˆ˜ í–‰ë™ë§Œ (Tool Use)

```
ì§ˆë¬¸: "2024ë…„ ë…¸ë²¨ ë¬¼ë¦¬í•™ìƒ ìˆ˜ìƒìì˜ ì£¼ìš” ì—…ì ì„ ì„¤ëª…í•´ì£¼ì„¸ìš”"

Tool Use:
Action: search("2024 Nobel Physics")
Observation: "John Hopfield and Geoffrey Hinton"

ì‘ë‹µ: "John Hopfield and Geoffrey Hinton"

ë¬¸ì œì : ì»¨í…ìŠ¤íŠ¸ ì—†ì´ ë‹¨ìˆœ ì •ë³´ë§Œ ë°˜í™˜
```

#### ReAct (ì¶”ë¡  + í–‰ë™)

```
ì§ˆë¬¸: "2024ë…„ ë…¸ë²¨ ë¬¼ë¦¬í•™ìƒ ìˆ˜ìƒìì˜ ì£¼ìš” ì—…ì ì„ ì„¤ëª…í•´ì£¼ì„¸ìš”"

Thought 1: ë¨¼ì € 2024ë…„ ìˆ˜ìƒìê°€ ëˆ„êµ¬ì¸ì§€ ê²€ìƒ‰í•´ì•¼ í•¨
Action 1: search("2024 Nobel Prize Physics winner")
Observation 1: "John Hopfield and Geoffrey Hinton won for foundational discoveries in artificial neural networks"

Thought 2: ì´ì œ ê° ìˆ˜ìƒìì˜ êµ¬ì²´ì ì¸ ì—…ì ì„ ì°¾ì•„ì•¼ í•¨
Action 2: search("John Hopfield neural networks contribution")
Observation 2: "Hopfield networks (1982), associative memory..."

Thought 3: Geoffrey Hintonì˜ ì—…ì ë„ í™•ì¸ í•„ìš”
Action 3: search("Geoffrey Hinton backpropagation deep learning")
Observation 3: "Backpropagation algorithm, deep learning pioneer..."

Thought 4: ì´ì œ ì¶©ë¶„í•œ ì •ë³´ë¥¼ ëª¨ì•˜ìœ¼ë¯€ë¡œ ì¢…í•© ë‹µë³€ ê°€ëŠ¥
Action 4: finish("2024ë…„ ë…¸ë²¨ ë¬¼ë¦¬í•™ìƒì€ John Hopfieldì™€ Geoffrey Hintonì´ ìˆ˜ìƒí–ˆìŠµë‹ˆë‹¤. HopfieldëŠ” 1982ë…„ Hopfield ë„¤íŠ¸ì›Œí¬ë¥¼ ê°œë°œí•˜ì—¬ ì—°ìƒ ë©”ëª¨ë¦¬ì˜ ê¸°ì´ˆë¥¼ ë§ˆë ¨í–ˆê³ , Hintonì€ ì—­ì „íŒŒ ì•Œê³ ë¦¬ì¦˜ê³¼ ì‹¬ì¸µí•™ìŠµ ë°œì „ì— ê¸°ì—¬í–ˆìŠµë‹ˆë‹¤...")
```

**ì°¨ì´ì **:
- âœ… ë‹¨ê³„ë³„ ì¶”ë¡  (ì™œ ì´ í–‰ë™ì„ í•˜ëŠ”ì§€)
- âœ… ì™¸ë¶€ ë„êµ¬ í™œìš© (ì‹¤ì œ ì •ë³´ íšë“)
- âœ… ê´€ì°° ê²°ê³¼ ë°˜ì˜ (ë™ì  ì¡°ì •)
- âœ… ì¢…í•©ì  ë‹µë³€ (ì»¨í…ìŠ¤íŠ¸ í¬í•¨)

## ReActë€?

Yao et al. (2022)ì´ ì œì•ˆí•œ **ReAct**ëŠ” **Reasoning (ì¶”ë¡ )**ê³¼ **Acting (í–‰ë™)**ì„ ë²ˆê°ˆì•„ ìˆ˜í–‰í•˜ëŠ” í”„ë¡¬í”„íŒ… íŒ¨ëŸ¬ë‹¤ì„ì´ë‹¤.

### í•µì‹¬ êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Thought (ì¶”ë¡ )                 â”‚
â”‚  "ë‹¤ìŒì— ë¬´ì—‡ì„ í•´ì•¼ í•˜ëŠ”ê°€?"               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Action (í–‰ë™)                  â”‚
â”‚  ë„êµ¬ í˜¸ì¶œ: search, calculate, etc.       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Observation (ê´€ì°°)               â”‚
â”‚  í–‰ë™ì˜ ê²°ê³¼                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â†“
        (Thoughtë¡œ ëŒì•„ê°€ê±°ë‚˜ ì™„ë£Œ)
```

### Thought-Action-Observation ì‚¬ì´í´

```python
import anthropic
from typing import List, Dict, Callable
import re

class ReActAgent:
    """
    ReAct Agent êµ¬í˜„
    """
    
    def __init__(self, api_key: str):
        self.client = anthropic.Anthropic(api_key=api_key)
        self.model = "claude-sonnet-4-20250514"
        
        # ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬ë“¤
        self.tools = {}
        self.register_default_tools()
        
        # ì‹¤í–‰ ì´ë ¥
        self.history = []
    
    def register_tool(self, name: str, function: Callable, description: str):
        """
        ë„êµ¬ ë“±ë¡
        
        Args:
            name: ë„êµ¬ ì´ë¦„
            function: ì‹¤í–‰í•  í•¨ìˆ˜
            description: ë„êµ¬ ì„¤ëª…
        """
        self.tools[name] = {
            'function': function,
            'description': description
        }
    
    def register_default_tools(self):
        """
        ê¸°ë³¸ ë„êµ¬ ë“±ë¡
        """
        # ê²€ìƒ‰ ë„êµ¬
        def search(query: str) -> str:
            """ì›¹ ê²€ìƒ‰ (ì‹œë®¬ë ˆì´ì…˜)"""
            # ì‹¤ì œë¡œëŠ” Google Search API ë“± ì‚¬ìš©
            return f"ê²€ìƒ‰ ê²°ê³¼: {query}ì— ëŒ€í•œ ì •ë³´..."
        
        self.register_tool(
            name="search",
            function=search,
            description="ì›¹ì—ì„œ ì •ë³´ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤. ì…ë ¥: ê²€ìƒ‰ ì¿¼ë¦¬"
        )
        
        # ê³„ì‚°ê¸° ë„êµ¬
        def calculate(expression: str) -> str:
            """ìˆ˜í•™ ê³„ì‚°"""
            try:
                result = eval(expression)
                return str(result)
            except Exception as e:
                return f"ê³„ì‚° ì˜¤ë¥˜: {e}"
        
        self.register_tool(
            name="calculate",
            function=calculate,
            description="ìˆ˜í•™ ê³„ì‚°ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. ì…ë ¥: ìˆ˜ì‹ (ì˜ˆ: '2+2', '10*5')"
        )
        
        # ì™„ë£Œ ë„êµ¬
        def finish(answer: str) -> str:
            """ì‘ì—… ì™„ë£Œ"""
            return answer
        
        self.register_tool(
            name="finish",
            function=finish,
            description="ìµœì¢… ë‹µë³€ì„ ì œê³µí•˜ê³  ì¢…ë£Œí•©ë‹ˆë‹¤. ì…ë ¥: ìµœì¢… ë‹µë³€"
        )
    
    def create_prompt(self, question: str) -> str:
        """
        ReAct í”„ë¡¬í”„íŠ¸ ìƒì„±
        """
        # ë„êµ¬ ëª©ë¡
        tools_desc = "\n".join([
            f"- {name}: {info['description']}"
            for name, info in self.tools.items()
        ])
        
        # ê¸°ë³¸ í”„ë¡¬í”„íŠ¸
        prompt = f"""ë‹¤ìŒ ì§ˆë¬¸ì— ë‹µí•˜ê¸° ìœ„í•´ Thought-Action-Observation ì‚¬ì´í´ì„ ì‚¬ìš©í•˜ì„¸ìš”.

        ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬:
        {tools_desc}

        í˜•ì‹:
        Thought: [ë‹¤ìŒ ë‹¨ê³„ì— ëŒ€í•œ ì¶”ë¡ ]
        Action: [ë„êµ¬ëª…][ì…ë ¥]
        Observation: [ë„êµ¬ ì‹¤í–‰ ê²°ê³¼]
        ... (í•„ìš”í•œ ë§Œí¼ ë°˜ë³µ)
        Thought: ì´ì œ ìµœì¢… ë‹µë³€ ê°€ëŠ¥
        Action: finish[ìµœì¢… ë‹µë³€]

        ì§ˆë¬¸: {question}

        Thought 1:"""
        
        # ê¸°ì¡´ ì´ë ¥ ì¶”ê°€
        if self.history:
            prompt += "\n\n" + self._format_history()
        
        return prompt
    
    def _format_history(self) -> str:
        """
        ì‹¤í–‰ ì´ë ¥ í¬ë§·íŒ…
        """
        formatted = []
        for i, step in enumerate(self.history, 1):
            formatted.append(f"Thought {i}: {step['thought']}")
            formatted.append(f"Action {i}: {step['action']}")
            formatted.append(f"Observation {i}: {step['observation']}")
        
        return "\n".join(formatted)
    
    def parse_action(self, text: str) -> tuple:
        """
        Action íŒŒì‹±
        
        í˜•ì‹: "Action: tool_name[input]"
        
        Returns:
            (tool_name, input)
        """
        # "Action: " ì´í›„ í…ìŠ¤íŠ¸ ì¶”ì¶œ
        action_match = re.search(r'Action\s*\d*:\s*(\w+)\[(.*?)\]', text, re.IGNORECASE)
        
        if action_match:
            tool_name = action_match.group(1)
            tool_input = action_match.group(2)
            return tool_name, tool_input
        
        return None, None
    
    def execute_action(self, tool_name: str, tool_input: str) -> str:
        """
        ë„êµ¬ ì‹¤í–‰
        """
        if tool_name not in self.tools:
            return f"ì˜¤ë¥˜: '{tool_name}'ëŠ” ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬ê°€ ì•„ë‹™ë‹ˆë‹¤."
        
        try:
            tool_func = self.tools[tool_name]['function']
            result = tool_func(tool_input)
            return result
        except Exception as e:
            return f"ë„êµ¬ ì‹¤í–‰ ì˜¤ë¥˜: {e}"
    
    def run(self, question: str, max_steps: int = 10, verbose: bool = True) -> str:
        """
        ReAct ì‹¤í–‰
        
        Args:
            question: ì§ˆë¬¸
            max_steps: ìµœëŒ€ ë‹¨ê³„ ìˆ˜
            verbose: ì§„í–‰ ê³¼ì • ì¶œë ¥ ì—¬ë¶€
        
        Returns:
            ìµœì¢… ë‹µë³€
        """
        if verbose:
            print(f"ğŸ¤” ì§ˆë¬¸: {question}\n")
            print("="*80)
        
        self.history = []
        
        for step in range(1, max_steps + 1):
            if verbose:
                print(f"\nğŸ“ Step {step}")
                print("-"*80)
            
            # Prompt ìƒì„±
            prompt = self.create_prompt(question)
            
            # LLM í˜¸ì¶œ
            message = self.client.messages.create(
                model=self.model,
                max_tokens=500,
                temperature=0,
                messages=[{"role": "user", "content": prompt}]
            )
            
            response = message.content[0].text
            
            # Thought ì¶”ì¶œ
            thought_match = re.search(
                r'Thought\s*\d*:\s*(.*?)(?=Action|$)',
                response,
                re.IGNORECASE | re.DOTALL
            )
            thought = thought_match.group(1).strip() if thought_match else ""
            
            if verbose:
                print(f"ğŸ’­ Thought: {thought}")
            
            # Action íŒŒì‹±
            tool_name, tool_input = self.parse_action(response)
            
            if tool_name is None:
                if verbose:
                    print("âš ï¸  Actionì„ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¢…ë£Œí•©ë‹ˆë‹¤.")
                break
            
            if verbose:
                print(f"ğŸ”§ Action: {tool_name}[{tool_input}]")
            
            # Action ì‹¤í–‰
            observation = self.execute_action(tool_name, tool_input)
            
            if verbose:
                print(f"ğŸ‘ï¸  Observation: {observation}")
            
            # ì´ë ¥ ì €ì¥
            self.history.append({
                'thought': thought,
                'action': f"{tool_name}[{tool_input}]",
                'observation': observation
            })
            
            # finish ë„êµ¬ë©´ ì¢…ë£Œ
            if tool_name == 'finish':
                if verbose:
                    print("\n" + "="*80)
                    print("âœ… ì™„ë£Œ!")
                    print("="*80)
                return observation
        
        if verbose:
            print("\nâš ï¸  ìµœëŒ€ ë‹¨ê³„ ìˆ˜ ë„ë‹¬. ì¢…ë£Œí•©ë‹ˆë‹¤.")
        
        return "ìµœëŒ€ ë‹¨ê³„ ìˆ˜ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤."


# ì‚¬ìš© ì˜ˆì‹œ
def main():
    agent = ReActAgent(api_key="your-api-key")
    
    question = "15ì™€ 23ì˜ í•©ì— 3ì„ ê³±í•œ ê°’ì€?"
    
    answer = agent.run(question, max_steps=10, verbose=True)
    
    print(f"\nìµœì¢… ë‹µë³€: {answer}")


if __name__ == "__main__":
    main()
```

## ì‹¤í–‰ ì˜ˆì‹œ

```
ğŸ¤” ì§ˆë¬¸: 15ì™€ 23ì˜ í•©ì— 3ì„ ê³±í•œ ê°’ì€?

================================================================================

ğŸ“ Step 1
--------------------------------------------------------------------------------
ğŸ’­ Thought: ë¨¼ì € 15ì™€ 23ì„ ë”í•´ì•¼ í•©ë‹ˆë‹¤.
ğŸ”§ Action: calculate[15+23]
ğŸ‘ï¸  Observation: 38

ğŸ“ Step 2
--------------------------------------------------------------------------------
ğŸ’­ Thought: ì´ì œ 38ì— 3ì„ ê³±í•´ì•¼ í•©ë‹ˆë‹¤.
ğŸ”§ Action: calculate[38*3]
ğŸ‘ï¸  Observation: 114

ğŸ“ Step 3
--------------------------------------------------------------------------------
ğŸ’­ Thought: ê³„ì‚°ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ìµœì¢… ë‹µë³€ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ğŸ”§ Action: finish[15ì™€ 23ì˜ í•©ì€ 38ì´ê³ , ì´ì— 3ì„ ê³±í•˜ë©´ 114ì…ë‹ˆë‹¤.]
ğŸ‘ï¸  Observation: 15ì™€ 23ì˜ í•©ì€ 38ì´ê³ , ì´ì— 3ì„ ê³±í•˜ë©´ 114ì…ë‹ˆë‹¤.

================================================================================
âœ… ì™„ë£Œ!
================================================================================

ìµœì¢… ë‹µë³€: 15ì™€ 23ì˜ í•©ì€ 38ì´ê³ , ì´ì— 3ì„ ê³±í•˜ë©´ 114ì…ë‹ˆë‹¤.
```

## ì™¸ë¶€ ë„êµ¬ í†µí•©

### ë„êµ¬ 1: ì›¹ ê²€ìƒ‰

```python
def register_real_search_tool(agent: ReActAgent):
    """
    ì‹¤ì œ ì›¹ ê²€ìƒ‰ ë„êµ¬ ë“±ë¡
    """
    def web_search(query: str) -> str:
        """
        Google Search API ì‚¬ìš©
        """
        import requests
        
        # Google Custom Search API
        api_key = "your-google-api-key"
        search_engine_id = "your-search-engine-id"
        
        url = "https://www.googleapis.com/customsearch/v1"
        params = {
            'key': api_key,
            'cx': search_engine_id,
            'q': query,
            'num': 3  # ìƒìœ„ 3ê°œ ê²°ê³¼
        }
        
        try:
            response = requests.get(url, params=params)
            results = response.json()
            
            # ê²°ê³¼ í¬ë§·íŒ…
            if 'items' in results:
                summaries = []
                for item in results['items'][:3]:
                    title = item.get('title', '')
                    snippet = item.get('snippet', '')
                    summaries.append(f"{title}: {snippet}")
                
                return "\n".join(summaries)
            else:
                return "ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
        
        except Exception as e:
            return f"ê²€ìƒ‰ ì˜¤ë¥˜: {e}"
    
    agent.register_tool(
        name="search",
        function=web_search,
        description="ì›¹ì—ì„œ ìµœì‹  ì •ë³´ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤. ì…ë ¥: ê²€ìƒ‰ ì¿¼ë¦¬"
    )
```

### ë„êµ¬ 2: Wikipedia

```python
def register_wikipedia_tool(agent: ReActAgent):
    """
    Wikipedia ë„êµ¬ ë“±ë¡
    """
    def wikipedia_lookup(title: str) -> str:
        """
        Wikipedia í˜ì´ì§€ ìš”ì•½ ê°€ì ¸ì˜¤ê¸°
        """
        import wikipedia
        
        try:
            # í˜ì´ì§€ ê²€ìƒ‰
            page = wikipedia.page(title, auto_suggest=True)
            
            # ìš”ì•½ (ì²˜ìŒ 500ì)
            summary = page.summary[:500]
            
            return f"{page.title}:\n{summary}..."
        
        except wikipedia.exceptions.DisambiguationError as e:
            # ë™ìŒì´ì˜ì–´ í˜ì´ì§€
            options = e.options[:5]
            return f"ì—¬ëŸ¬ ì˜ë¯¸ê°€ ìˆìŠµë‹ˆë‹¤: {', '.join(options)}"
        
        except wikipedia.exceptions.PageError:
            return f"'{title}' í˜ì´ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
        
        except Exception as e:
            return f"Wikipedia ì˜¤ë¥˜: {e}"
    
    agent.register_tool(
        name="wikipedia",
        function=wikipedia_lookup,
        description="Wikipediaì—ì„œ ì •ë³´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤. ì…ë ¥: í˜ì´ì§€ ì œëª©"
    )
```

### ë„êµ¬ 3: ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬

```python
def register_database_tool(agent: ReActAgent):
    """
    ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ë„êµ¬
    """
    def query_database(sql: str) -> str:
        """
        SQL ì¿¼ë¦¬ ì‹¤í–‰ (ì•ˆì „í•˜ê²Œ)
        """
        import sqlite3
        
        # ì•ˆì „ì„± ì²´í¬
        sql_lower = sql.lower().strip()
        
        # SELECTë§Œ í—ˆìš©
        if not sql_lower.startswith('select'):
            return "ì˜¤ë¥˜: SELECT ì¿¼ë¦¬ë§Œ í—ˆìš©ë©ë‹ˆë‹¤."
        
        # ìœ„í—˜í•œ í‚¤ì›Œë“œ ì²´í¬
        dangerous = ['drop', 'delete', 'update', 'insert', 'alter']
        if any(kw in sql_lower for kw in dangerous):
            return "ì˜¤ë¥˜: ë°ì´í„° ìˆ˜ì • ì¿¼ë¦¬ëŠ” í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
        
        try:
            # ì—°ê²° (ì˜ˆì‹œ)
            conn = sqlite3.connect('database.db')
            cursor = conn.cursor()
            
            cursor.execute(sql)
            results = cursor.fetchall()
            
            conn.close()
            
            # ê²°ê³¼ í¬ë§·íŒ…
            if results:
                formatted = "\n".join([str(row) for row in results[:10]])
                return formatted
            else:
                return "ê²°ê³¼ ì—†ìŒ"
        
        except Exception as e:
            return f"ë°ì´í„°ë² ì´ìŠ¤ ì˜¤ë¥˜: {e}"
    
    agent.register_tool(
        name="query_db",
        function=query_database,
        description="ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤ (SELECTë§Œ ê°€ëŠ¥). ì…ë ¥: SQL ì¿¼ë¦¬"
    )
```

### ë„êµ¬ 4: Python ì½”ë“œ ì‹¤í–‰

```python
def register_python_exec_tool(agent: ReActAgent):
    """
    Python ì½”ë“œ ì‹¤í–‰ ë„êµ¬ (ìƒŒë“œë°•ìŠ¤)
    """
    def execute_python(code: str) -> str:
        """
        Python ì½”ë“œ ì‹¤í–‰ (ì•ˆì „í•˜ê²Œ)
        """
        import sys
        from io import StringIO
        import contextlib
        
        # ì¶œë ¥ ìº¡ì²˜
        output = StringIO()
        
        # ì•ˆì „ì„± ì²´í¬
        dangerous_imports = [
            'os', 'sys', 'subprocess', 'eval', 'exec',
            '__import__', 'open', 'file'
        ]
        
        code_lower = code.lower()
        if any(danger in code_lower for danger in dangerous_imports):
            return "ì˜¤ë¥˜: ìœ„í—˜í•œ ì½”ë“œê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤."
        
        try:
            # ì½”ë“œ ì‹¤í–‰ (íƒ€ì„ì•„ì›ƒ í•„ìš”)
            with contextlib.redirect_stdout(output):
                # ì œí•œëœ í™˜ê²½ì—ì„œ ì‹¤í–‰
                allowed_globals = {
                    '__builtins__': {
                        'print': print,
                        'range': range,
                        'len': len,
                        'sum': sum,
                        'max': max,
                        'min': min,
                    }
                }
                
                exec(code, allowed_globals)
            
            result = output.getvalue()
            return result if result else "ì‹¤í–‰ ì™„ë£Œ (ì¶œë ¥ ì—†ìŒ)"
        
        except Exception as e:
            return f"ì‹¤í–‰ ì˜¤ë¥˜: {e}"
    
    agent.register_tool(
        name="python",
        function=execute_python,
        description="Python ì½”ë“œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤ (ì œí•œëœ í™˜ê²½). ì…ë ¥: Python ì½”ë“œ"
    )
```

### ë„êµ¬ 5: API í˜¸ì¶œ

```python
def register_api_tool(agent: ReActAgent):
    """
    ì™¸ë¶€ API í˜¸ì¶œ ë„êµ¬
    """
    def call_api(endpoint: str) -> str:
        """
        REST API í˜¸ì¶œ
        
        í˜•ì‹: "GET https://api.example.com/endpoint"
        """
        import requests
        
        parts = endpoint.split(' ', 1)
        
        if len(parts) != 2:
            return "ì˜¤ë¥˜: í˜•ì‹ì€ 'METHOD URL' ì…ë‹ˆë‹¤."
        
        method, url = parts
        method = method.upper()
        
        if method not in ['GET', 'POST']:
            return "ì˜¤ë¥˜: GET ë˜ëŠ” POSTë§Œ ì§€ì›ë©ë‹ˆë‹¤."
        
        try:
            if method == 'GET':
                response = requests.get(url, timeout=5)
            else:
                response = requests.post(url, timeout=5)
            
            # ì‘ë‹µ (ì²˜ìŒ 500ì)
            content = response.text[:500]
            
            return f"Status: {response.status_code}\n{content}"
        
        except Exception as e:
            return f"API í˜¸ì¶œ ì˜¤ë¥˜: {e}"
    
    agent.register_tool(
        name="api_call",
        function=call_api,
        description="ì™¸ë¶€ APIë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤. ì…ë ¥: 'METHOD URL' (ì˜ˆ: 'GET https://api.example.com/data')"
    )
```

## ë³µì¡í•œ ì˜ˆì‹œ: ë‹¤ë‹¨ê³„ ë¬¸ì œ í•´ê²°

```python
def complex_example():
    """
    ë³µì¡í•œ ë‹¤ë‹¨ê³„ ë¬¸ì œ
    """
    agent = ReActAgent(api_key="your-api-key")
    
    # ì¶”ê°€ ë„êµ¬ ë“±ë¡
    register_wikipedia_tool(agent)
    
    question = """
    2024ë…„ ë…¸ë²¨ ë¬¼ë¦¬í•™ìƒ ìˆ˜ìƒì ì¤‘ í•œ ëª…ì˜ ì¶œìƒ ì—°ë„ë¥¼ ì°¾ê³ ,
    ê·¸ ì‚¬ëŒì´ ëª‡ ì‚´ì— ìˆ˜ìƒí–ˆëŠ”ì§€ ê³„ì‚°í•´ì£¼ì„¸ìš”.
    """
    
    answer = agent.run(question, max_steps=15, verbose=True)
    
    return answer
```

**ì‹¤í–‰ ê³¼ì •**:

```
ğŸ“ Step 1
ğŸ’­ Thought: ë¨¼ì € 2024ë…„ ë…¸ë²¨ ë¬¼ë¦¬í•™ìƒ ìˆ˜ìƒìê°€ ëˆ„êµ¬ì¸ì§€ ê²€ìƒ‰í•´ì•¼ í•©ë‹ˆë‹¤.
ğŸ”§ Action: search[2024 Nobel Prize Physics winner]
ğŸ‘ï¸  Observation: John Hopfield and Geoffrey Hinton won the 2024 Nobel Prize in Physics...

ğŸ“ Step 2
ğŸ’­ Thought: John Hopfieldì˜ ì¶œìƒ ì—°ë„ë¥¼ Wikipediaì—ì„œ ì°¾ê² ìŠµë‹ˆë‹¤.
ğŸ”§ Action: wikipedia[John Hopfield]
ğŸ‘ï¸  Observation: John Hopfield: Born July 15, 1933, American scientist...

ğŸ“ Step 3
ğŸ’­ Thought: 1933ë…„ìƒì´ê³  2024ë…„ì— ìˆ˜ìƒí–ˆìœ¼ë¯€ë¡œ, ë‚˜ì´ë¥¼ ê³„ì‚°í•´ì•¼ í•©ë‹ˆë‹¤.
ğŸ”§ Action: calculate[2024-1933]
ğŸ‘ï¸  Observation: 91

ğŸ“ Step 4
ğŸ’­ Thought: ì´ì œ ì¶©ë¶„í•œ ì •ë³´ë¥¼ ëª¨ì•˜ìŠµë‹ˆë‹¤. ìµœì¢… ë‹µë³€ì„ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ğŸ”§ Action: finish[John HopfieldëŠ” 1933ë…„ 7ì›” 15ì¼ìƒìœ¼ë¡œ, 2024ë…„ ë…¸ë²¨ ë¬¼ë¦¬í•™ìƒì„ 91ì„¸ì— ìˆ˜ìƒí–ˆìŠµë‹ˆë‹¤.]
ğŸ‘ï¸  Observation: John HopfieldëŠ” 1933ë…„ 7ì›” 15ì¼ìƒìœ¼ë¡œ, 2024ë…„ ë…¸ë²¨ ë¬¼ë¦¬í•™ìƒì„ 91ì„¸ì— ìˆ˜ìƒí–ˆìŠµë‹ˆë‹¤.

âœ… ì™„ë£Œ!
```

## ì‹¤í—˜ ê²°ê³¼ ë¶„ì„

Yao et al. (2022)ì˜ ë…¼ë¬¸ ê²°ê³¼ë¥¼ ë¶„ì„í•˜ì.

### ë²¤ì¹˜ë§ˆí¬ ì„±ëŠ¥

#### HotpotQA (Multi-hop Question Answering)

**ì„¤ì •**:
- ë‘ ê°œ ì´ìƒì˜ Wikipedia í˜ì´ì§€ ì •ë³´ í•„ìš”
- ì˜ˆ: "The director of the 2003 film which has a song Frozen, directed 5 films in which year?"

**ê²°ê³¼**:

| ë°©ë²• | ì •í™•ë„ (EM) | F1 Score |
|-----|-----------|----------|
| Standard Prompting | 28.7% | 35.1% |
| CoT (Chain-of-Thought) | 29.4% | 36.6% |
| **ReAct** | **27.4%** | **34.2%** |
| **ReAct + Self-Consistency** | **34.2%** | **42.9%** |

**ê´€ì°°**:
- ReAct ë‹¨ë…: CoTì™€ ìœ ì‚¬
- **ReAct + Self-Consistency**: ìµœê³  ì„±ëŠ¥ (+19% vs Standard)

#### FEVER (Fact Verification)

**ì„¤ì •**:
- ì£¼ì¥ì´ ì‚¬ì‹¤ì¸ì§€ ê²€ì¦
- Wikipedia ê²€ìƒ‰ í•„ìš”

**ê²°ê³¼**:

| ë°©ë²• | ì •í™•ë„ |
|-----|-------|
| Standard Prompting | 56.3% |
| CoT | 58.1% |
| **ReAct** | **64.6%** |

**ê°œì„ í­**: +8.3% (vs Standard)

**ReActê°€ íŠ¹íˆ íš¨ê³¼ì ì¸ ì´ìœ **:
- Wikipedia ê²€ìƒ‰ìœ¼ë¡œ ì‹¤ì œ ì •ë³´ í™•ì¸
- ë‹¨ê³„ë³„ë¡œ ì¦ê±° ìˆ˜ì§‘
- ëª¨ìˆœ ë°œê²¬ ì‹œ ì¶”ê°€ ê²€ìƒ‰

### í–‰ë™ ìœ í˜• ë¶„ì„

**ReActê°€ ì‚¬ìš©í•œ í–‰ë™ë“¤**:

| í–‰ë™ ìœ í˜• | ë¹ˆë„ | ì˜ˆì‹œ |
|---------|------|------|
| **ê²€ìƒ‰ (Search)** | 58% | "search[John Hopfield]" |
| **ì¡°íšŒ (Lookup)** | 23% | "lookup[birth year]" |
| **ê³„ì‚° (Calculate)** | 12% | "calculate[2024-1933]" |
| **ì™„ë£Œ (Finish)** | 7% | "finish[answer]" |

### ì¶”ë¡  ìœ í˜• ë¶„ì„

**Thoughtì˜ ëª©ì **:

| ëª©ì  | ë¹„ìœ¨ | ì˜ˆì‹œ |
|-----|------|------|
| **ê³„íš** | 35% | "ë¨¼ì € Xë¥¼ ì°¾ì•„ì•¼ í•¨" |
| **ê´€ì°° í•´ì„** | 28% | "ì´ ì •ë³´ì— ë”°ë¥´ë©´..." |
| **ì „ëµ ìˆ˜ì •** | 19% | "ì´ ë°©ë²•ì´ ì•ˆ ë˜ë‹ˆ ë‹¤ë¥¸ ì ‘ê·¼" |
| **ê²°ë¡ ** | 18% | "ì¶©ë¶„í•œ ì •ë³´ë¥¼ ëª¨ì•˜ìŒ" |

### ì˜¤ë¥˜ íšŒë³µ ëŠ¥ë ¥

**ì‹œë‚˜ë¦¬ì˜¤**: ê²€ìƒ‰ì´ ì‹¤íŒ¨í•œ ê²½ìš°

**CoT (ì¶”ë¡ ë§Œ)**:
```
ì§ˆë¬¸: "Xì˜ ìƒë…„ì›”ì¼ì€?"

Thought: XëŠ” ìœ ëª…ì¸ì´ë‹¤.
Thought: ìœ ëª…ì¸ì€ ë³´í†µ 1900-2000ë…„ì— íƒœì–´ë‚œë‹¤.
Answer: ì•½ 1950ë…„ (ì¶”ì¸¡)

â†’ ì˜¤ë¥˜ íšŒë³µ ë¶ˆê°€ëŠ¥
```

**ReAct**:
```
ì§ˆë¬¸: "Xì˜ ìƒë…„ì›”ì¼ì€?"

Thought: Xì— ëŒ€í•´ ê²€ìƒ‰í•´ì•¼ í•œë‹¤.
Action: search[X]
Observation: Xì— ëŒ€í•œ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ.

Thought: ê²€ìƒ‰ì–´ê°€ ëª¨í˜¸í•  ìˆ˜ ìˆë‹¤. ì „ì²´ ì´ë¦„ìœ¼ë¡œ ë‹¤ì‹œ ê²€ìƒ‰.
Action: search[X full name]
Observation: X (1965ë…„ 3ì›” 10ì¼ìƒ)ì€...

â†’ ì˜¤ë¥˜ íšŒë³µ ê°€ëŠ¥!
```

**ì˜¤ë¥˜ íšŒë³µ ì„±ê³µë¥ **:
- CoT: 12%
- **ReAct: 67%**

## ê³ ê¸‰ ReAct íŒ¨í„´

### íŒ¨í„´ 1: ê³„ì¸µì  ReAct

ë³µì¡í•œ ì‘ì—…ì„ í•˜ìœ„ ì‘ì—…ìœ¼ë¡œ ë¶„í•´í•˜ì—¬ ì²˜ë¦¬.

```python
class HierarchicalReAct:
    """
    ê³„ì¸µì  ReAct Agent
    
    ê³ ìˆ˜ì¤€ ê³„íš â†’ ì €ìˆ˜ì¤€ ì‹¤í–‰
    """
    
    def __init__(self, api_key: str):
        self.planner = ReActAgent(api_key)  # ê³ ìˆ˜ì¤€ ê³„íšì
        self.executor = ReActAgent(api_key)  # ì €ìˆ˜ì¤€ ì‹¤í–‰ì
        
        # ê³„íšììš© íŠ¹ìˆ˜ ë„êµ¬
        self.register_planner_tools()
    
    def register_planner_tools(self):
        """
        ê³„íšììš© ë„êµ¬: í•˜ìœ„ ì‘ì—… ìƒì„±
        """
        def create_subtask(task_description: str) -> str:
            """í•˜ìœ„ ì‘ì—… ìƒì„±"""
            return f"í•˜ìœ„ ì‘ì—… ìƒì„±: {task_description}"
        
        self.planner.register_tool(
            name="create_subtask",
            function=create_subtask,
            description="ë³µì¡í•œ ì‘ì—…ì„ í•˜ìœ„ ì‘ì—…ìœ¼ë¡œ ë¶„í•´í•©ë‹ˆë‹¤."
        )
    
    def solve(self, complex_question: str) -> str:
        """
        ê³„ì¸µì  ë¬¸ì œ í•´ê²°
        
        1. ê³„íšì: ê³ ìˆ˜ì¤€ ê³„íš ìˆ˜ë¦½
        2. ì‹¤í–‰ì: ê° í•˜ìœ„ ì‘ì—… ì‹¤í–‰
        3. í†µí•©: ê²°ê³¼ ì¢…í•©
        """
        print("ğŸ—ï¸  ê³„ì¸µì  ReAct ì‹œì‘\n")
        
        # Phase 1: ê³ ìˆ˜ì¤€ ê³„íš
        print("=" * 80)
        print("Phase 1: ê³„íš ìˆ˜ë¦½")
        print("=" * 80)
        
        planning_prompt = f"""ë‹¤ìŒ ë³µì¡í•œ ì§ˆë¬¸ì„ í•´ê²°í•˜ê¸° ìœ„í•œ ê³„íšì„ ì„¸ìš°ì„¸ìš”.

        ì§ˆë¬¸: {complex_question}

        ë‹¨ê³„ë³„ í•˜ìœ„ ì‘ì—…ìœ¼ë¡œ ë¶„í•´í•˜ì„¸ìš”:
        1."""
        
        plan = self.planner.run(planning_prompt, max_steps=5, verbose=False)
        
        # í•˜ìœ„ ì‘ì—… ì¶”ì¶œ
        subtasks = self._extract_subtasks(plan)
        
        print(f"\nğŸ“‹ ê³„íšëœ í•˜ìœ„ ì‘ì—…:")
        for i, task in enumerate(subtasks, 1):
            print(f"  {i}. {task}")
        
        # Phase 2: ê° í•˜ìœ„ ì‘ì—… ì‹¤í–‰
        print(f"\n{'=' * 80}")
        print("Phase 2: í•˜ìœ„ ì‘ì—… ì‹¤í–‰")
        print("=" * 80)
        
        subtask_results = []
        
        for i, task in enumerate(subtasks, 1):
            print(f"\nğŸ”¹ í•˜ìœ„ ì‘ì—… {i}: {task}")
            print("-" * 80)
            
            result = self.executor.run(task, max_steps=10, verbose=True)
            subtask_results.append({
                'task': task,
                'result': result
            })
        
        # Phase 3: ê²°ê³¼ í†µí•©
        print(f"\n{'=' * 80}")
        print("Phase 3: ê²°ê³¼ í†µí•©")
        print("=" * 80)
        
        final_answer = self._synthesize_results(
            complex_question,
            subtask_results
        )
        
        return final_answer
    
    def _extract_subtasks(self, plan: str) -> List[str]:
        """ê³„íšì—ì„œ í•˜ìœ„ ì‘ì—… ì¶”ì¶œ"""
        import re
        
        # "1. ...", "2. ..." í˜•ì‹ ì°¾ê¸°
        subtasks = []
        for line in plan.split('\n'):
            match = re.match(r'^\d+\.\s*(.+)$', line.strip())
            if match:
                subtasks.append(match.group(1))
        
        return subtasks
    
    def _synthesize_results(
        self,
        question: str,
        results: List[Dict]
    ) -> str:
        """í•˜ìœ„ ì‘ì—… ê²°ê³¼ í†µí•©"""
        results_str = "\n\n".join([
            f"ì‘ì—…: {r['task']}\nê²°ê³¼: {r['result']}"
            for r in results
        ])
        
        synthesis_prompt = f"""ë‹¤ìŒ í•˜ìœ„ ì‘ì—… ê²°ê³¼ë“¤ì„ ì¢…í•©í•˜ì—¬ ì›ë˜ ì§ˆë¬¸ì— ë‹µí•˜ì„¸ìš”.

        ì›ë˜ ì§ˆë¬¸: {question}

        í•˜ìœ„ ì‘ì—… ê²°ê³¼ë“¤:
        {results_str}

        ì¢…í•© ë‹µë³€:"""
        
        # LLM í˜¸ì¶œ
        import anthropic
        client = anthropic.Anthropic(api_key="your-api-key")
        
        message = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=1500,
            temperature=0,
            messages=[{"role": "user", "content": synthesis_prompt}]
        )
        
        return message.content[0].text
```

**ì‚¬ìš© ì˜ˆì‹œ**:

```python
hierarchical = HierarchicalReAct(api_key="your-api-key")

complex_question = """
2024ë…„ ë…¸ë²¨ ë¬¼ë¦¬í•™ìƒ ìˆ˜ìƒìë“¤ì˜ ì£¼ìš” ì—…ì ì„ ë¹„êµí•˜ê³ ,
í˜„ëŒ€ AI ë°œì „ì— ë¯¸ì¹œ ì˜í–¥ì„ ë¶„ì„í•˜ì„¸ìš”.
"""

answer = hierarchical.solve(complex_question)

# ì¶œë ¥:
# ğŸ“‹ ê³„íšëœ í•˜ìœ„ ì‘ì—…:
#   1. 2024ë…„ ë…¸ë²¨ ë¬¼ë¦¬í•™ìƒ ìˆ˜ìƒì í™•ì¸
#   2. ê° ìˆ˜ìƒìì˜ ì£¼ìš” ì—…ì  ì¡°ì‚¬
#   3. ì—…ì  ê°„ ê³µí†µì ê³¼ ì°¨ì´ì  ë¹„êµ
#   4. AI ë°œì „ì— ë¯¸ì¹œ êµ¬ì²´ì  ì˜í–¥ ë¶„ì„
#   5. ì¢…í•© ê²°ë¡  ë„ì¶œ
```

### íŒ¨í„´ 2: ë°˜ì„±ì  ReAct (Reflexion)

ì‹¤íŒ¨ì—ì„œ í•™ìŠµí•˜ì—¬ ì „ëµì„ ê°œì„ .

```python
class ReflexiveReAct:
    """
    ë°˜ì„±ì  ReAct Agent
    
    ì‹¤íŒ¨ â†’ ë°˜ì„± â†’ ê°œì„  â†’ ì¬ì‹œë„
    """
    
    def __init__(self, api_key: str):
        self.agent = ReActAgent(api_key)
        self.memory = []  # ê³¼ê±° ì‹œë„ ê¸°ë¡
    
    def solve_with_reflection(
        self,
        question: str,
        max_attempts: int = 3
    ) -> str:
        """
        ë°˜ì„±ì  ë¬¸ì œ í•´ê²°
        """
        print(f"ğŸ”„ ë°˜ì„±ì  ReAct ì‹œì‘ (ìµœëŒ€ {max_attempts}íšŒ ì‹œë„)\n")
        
        for attempt in range(1, max_attempts + 1):
            print(f"{'=' * 80}")
            print(f"ì‹œë„ {attempt}/{max_attempts}")
            print(f"{'=' * 80}\n")
            
            # ì´ì „ ì‹¤íŒ¨ ë°˜ì„± ì¶”ê°€
            if self.memory:
                reflection = self._generate_reflection()
                print(f"ğŸ’¡ ë°˜ì„±:")
                print(f"   {reflection}\n")
                
                # ë°˜ì„±ì„ í”„ë¡¬í”„íŠ¸ì— í¬í•¨
                augmented_question = f"""{question}

                ì´ì „ ì‹œë„ì˜ ë°˜ì„±:
                {reflection}

                ì´ë¥¼ ê³ ë ¤í•˜ì—¬ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”."""
            else:
                augmented_question = question
            
            # ì‹¤í–‰
            try:
                answer = self.agent.run(
                    augmented_question,
                    max_steps=15,
                    verbose=True
                )
                
                # ì„±ê³µ ì—¬ë¶€ í‰ê°€
                is_correct = self._evaluate_answer(question, answer)
                
                if is_correct:
                    print(f"\nâœ… ì‹œë„ {attempt}ì—ì„œ ì„±ê³µ!")
                    return answer
                else:
                    print(f"\nâŒ ì‹œë„ {attempt} ì‹¤íŒ¨")
                    
                    # ì‹¤íŒ¨ ê¸°ë¡
                    self.memory.append({
                        'attempt': attempt,
                        'question': question,
                        'answer': answer,
                        'history': self.agent.history.copy()
                    })
            
            except Exception as e:
                print(f"\nâš ï¸  ì˜¤ë¥˜ ë°œìƒ: {e}")
                
                self.memory.append({
                    'attempt': attempt,
                    'question': question,
                    'error': str(e)
                })
        
        print(f"\nâŒ {max_attempts}íšŒ ì‹œë„ í›„ì—ë„ í•´ê²° ì‹¤íŒ¨")
        return "ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
    
    def _generate_reflection(self) -> str:
        """
        ì´ì „ ì‹¤íŒ¨ì—ì„œ ë°˜ì„± ìƒì„±
        """
        last_attempt = self.memory[-1]
        
        reflection_prompt = f"""ì´ì „ ì‹œë„ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë¬´ì—‡ì´ ì˜ëª»ë˜ì—ˆëŠ”ì§€ ë¶„ì„í•˜ì„¸ìš”.

        ì‹¤íŒ¨í•œ ì‹œë„:
        {self._format_attempt(last_attempt)}

        ë°˜ì„± (ë¬´ì—‡ì´ ì˜ëª»ë˜ì—ˆê³ , ì–´ë–»ê²Œ ê°œì„ í•  ìˆ˜ ìˆëŠ”ê°€?):"""
        
        import anthropic
        client = anthropic.Anthropic(api_key="your-api-key")
        
        message = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=300,
            temperature=0,
            messages=[{"role": "user", "content": reflection_prompt}]
        )
        
        return message.content[0].text
    
    def _format_attempt(self, attempt: Dict) -> str:
        """ì‹œë„ ê¸°ë¡ í¬ë§·íŒ…"""
        if 'error' in attempt:
            return f"ì˜¤ë¥˜: {attempt['error']}"
        
        history = attempt.get('history', [])
        formatted = []
        
        for step in history:
            formatted.append(f"Thought: {step['thought']}")
            formatted.append(f"Action: {step['action']}")
            formatted.append(f"Observation: {step['observation']}")
        
        formatted.append(f"\nìµœì¢… ë‹µë³€: {attempt.get('answer', 'N/A')}")
        
        return "\n".join(formatted)
    
    def _evaluate_answer(self, question: str, answer: str) -> bool:
        """
        ë‹µë³€ ì •í™•ì„± í‰ê°€
        
        ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ í‰ê°€ í•„ìš”
        """
        eval_prompt = f"""ë‹¤ìŒ ë‹µë³€ì´ ì§ˆë¬¸ì— ì˜¬ë°”ë¥´ê²Œ ë‹µí–ˆëŠ”ì§€ í‰ê°€í•˜ì„¸ìš”.

ì§ˆë¬¸: {question}
ë‹µë³€: {answer}

ì˜¬ë°”ë¥¸ê°€? (yes/no):"""
        
        import anthropic
        client = anthropic.Anthropic(api_key="your-api-key")
        
        message = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=10,
            temperature=0,
            messages=[{"role": "user", "content": eval_prompt}]
        )
        
        response = message.content[0].text.strip().lower()
        
        return 'yes' in response
```

**ì‹¤í–‰ ì˜ˆì‹œ**:

```
ğŸ”„ ë°˜ì„±ì  ReAct ì‹œì‘ (ìµœëŒ€ 3íšŒ ì‹œë„)

================================================================================
ì‹œë„ 1/3
================================================================================

[... ReAct ì‹¤í–‰ ...]

âŒ ì‹œë„ 1 ì‹¤íŒ¨

================================================================================
ì‹œë„ 2/3
================================================================================

ğŸ’¡ ë°˜ì„±:
   ì´ì „ ì‹œë„ì—ì„œëŠ” ê²€ìƒ‰ ì¿¼ë¦¬ê°€ ë„ˆë¬´ ì¼ë°˜ì ì´ì—ˆìŠµë‹ˆë‹¤.
   ë” êµ¬ì²´ì ì¸ ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•˜ê³ , ì—°ë„ë¥¼ ëª…ì‹œí•´ì•¼ í•©ë‹ˆë‹¤.

[... ê°œì„ ëœ ReAct ì‹¤í–‰ ...]

âœ… ì‹œë„ 2ì—ì„œ ì„±ê³µ!
```

### íŒ¨í„´ 3: ë©€í‹° ì—ì´ì „íŠ¸ í˜‘ë ¥

ì—¬ëŸ¬ Agentê°€ í˜‘ë ¥í•˜ì—¬ ë¬¸ì œ í•´ê²°.

```python
class MultiAgentSystem:
    """
    ë©€í‹° ì—ì´ì „íŠ¸ í˜‘ë ¥ ì‹œìŠ¤í…œ
    """
    
    def __init__(self, api_key: str):
        # ì „ë¬¸í™”ëœ Agentë“¤
        self.researcher = self._create_researcher(api_key)
        self.analyst = self._create_analyst(api_key)
        self.writer = self._create_writer(api_key)
    
    def _create_researcher(self, api_key: str) -> ReActAgent:
        """ì—°êµ¬ì Agent: ì •ë³´ ìˆ˜ì§‘ ì „ë¬¸"""
        agent = ReActAgent(api_key)
        
        # ê²€ìƒ‰ ë„êµ¬ë§Œ ì‚¬ìš©
        register_wikipedia_tool(agent)
        register_real_search_tool(agent)
        
        return agent
    
    def _create_analyst(self, api_key: str) -> ReActAgent:
        """ë¶„ì„ê°€ Agent: ë°ì´í„° ë¶„ì„ ì „ë¬¸"""
        agent = ReActAgent(api_key)
        
        # ê³„ì‚°, Python ì‹¤í–‰ ë„êµ¬
        register_python_exec_tool(agent)
        
        return agent
    
    def _create_writer(self, api_key: str) -> ReActAgent:
        """ì‘ê°€ Agent: ìµœì¢… ì‘ì„± ì „ë¬¸"""
        agent = ReActAgent(api_key)
        
        # ì‘ì„± ë„êµ¬ë§Œ
        # (finish ë„êµ¬ëŠ” ê¸°ë³¸ ë“±ë¡ë¨)
        
        return agent
    
    def collaborate(self, task: str) -> str:
        """
        í˜‘ë ¥ì  ë¬¸ì œ í•´ê²°
        
        1. Researcher: ì •ë³´ ìˆ˜ì§‘
        2. Analyst: ë°ì´í„° ë¶„ì„
        3. Writer: ìµœì¢… ì‘ì„±
        """
        print("ğŸ¤ ë©€í‹° ì—ì´ì „íŠ¸ í˜‘ë ¥ ì‹œì‘\n")
        
        # Phase 1: ì •ë³´ ìˆ˜ì§‘
        print("=" * 80)
        print("Phase 1: Researcher - ì •ë³´ ìˆ˜ì§‘")
        print("=" * 80)
        
        research_task = f"ë‹¤ìŒ ì£¼ì œì— ëŒ€í•œ ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ì„¸ìš”: {task}"
        research_results = self.researcher.run(
            research_task,
            max_steps=10,
            verbose=True
        )
        
        print(f"\nğŸ“š ìˆ˜ì§‘ëœ ì •ë³´:\n{research_results}\n")
        
        # Phase 2: ë°ì´í„° ë¶„ì„
        print("=" * 80)
        print("Phase 2: Analyst - ë°ì´í„° ë¶„ì„")
        print("=" * 80)
        
        analysis_task = f"""ë‹¤ìŒ ì •ë³´ë¥¼ ë¶„ì„í•˜ì„¸ìš”:

ìˆ˜ì§‘ëœ ì •ë³´:
{research_results}

ì›ë˜ ì‘ì—…: {task}"""
        
        analysis_results = self.analyst.run(
            analysis_task,
            max_steps=10,
            verbose=True
        )
        
        print(f"\nğŸ“Š ë¶„ì„ ê²°ê³¼:\n{analysis_results}\n")
        
        # Phase 3: ìµœì¢… ì‘ì„±
        print("=" * 80)
        print("Phase 3: Writer - ìµœì¢… ì‘ì„±")
        print("=" * 80)
        
        writing_task = f"""ë‹¤ìŒ ì •ë³´ì™€ ë¶„ì„ì„ ë°”íƒ•ìœ¼ë¡œ ìµœì¢… ë‹µë³€ì„ ì‘ì„±í•˜ì„¸ìš”:

ì›ë˜ ì‘ì—…: {task}

ìˆ˜ì§‘ëœ ì •ë³´:
{research_results}

ë¶„ì„ ê²°ê³¼:
{analysis_results}"""
        
        final_answer = self.writer.run(
            writing_task,
            max_steps=5,
            verbose=True
        )
        
        return final_answer
```

## Agent ì•„í‚¤í…ì²˜ ì„¤ê³„

### ì•„í‚¤í…ì²˜ 1: ë‹¨ìˆœ ë£¨í”„ (Simple Loop)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User Question          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ReAct Loop             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ Thought          â”‚   â”‚
â”‚   â”‚      â†“           â”‚   â”‚
â”‚   â”‚ Action           â”‚   â”‚
â”‚   â”‚      â†“           â”‚   â”‚
â”‚   â”‚ Observation      â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚          â†“               â”‚
â”‚   (ë°˜ë³µ ë˜ëŠ” ì¢…ë£Œ)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Final Answer           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ì¥ì **: ê°„ë‹¨, ì´í•´í•˜ê¸° ì‰¬ì›€
**ë‹¨ì **: ë³µì¡í•œ ì‘ì—…ì— í•œê³„

### ì•„í‚¤í…ì²˜ 2: ê³„íš-ì‹¤í–‰-ë°˜ì„± (Plan-Execute-Reflect)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User Question          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Planner                â”‚
â”‚   - ê³ ìˆ˜ì¤€ ê³„íš ìˆ˜ë¦½      â”‚
â”‚   - í•˜ìœ„ ì‘ì—… ìƒì„±        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Executor               â”‚
â”‚   - ê° í•˜ìœ„ ì‘ì—… ì‹¤í–‰     â”‚
â”‚   - ReAct Loop           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Reflector              â”‚
â”‚   - ê²°ê³¼ í‰ê°€             â”‚
â”‚   - ì¬ê³„íš í•„ìš” ì‹œ ë°˜ë³µ   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Final Answer           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ì¥ì **: ë³µì¡í•œ ì‘ì—… ì²˜ë¦¬ ê°€ëŠ¥, ì˜¤ë¥˜ íšŒë³µ
**ë‹¨ì **: ë” ë§ì€ LLM í˜¸ì¶œ, ë³µì¡ë„ ì¦ê°€

### ì•„í‚¤í…ì²˜ 3: ë„êµ¬ ì¤‘ì‹¬ (Tool-Centric)

```python
class ToolCentricAgent:
    """
    ë„êµ¬ ì¤‘ì‹¬ Agent
    
    ê° ë„êµ¬ê°€ ì–¸ì œ ì‚¬ìš©ë˜ì–´ì•¼ í•˜ëŠ”ì§€ ëª…ì‹œì ìœ¼ë¡œ ì •ì˜
    """
    
    def __init__(self, api_key: str):
        self.client = anthropic.Anthropic(api_key=api_key)
        self.model = "claude-sonnet-4-20250514"
        
        # ë„êµ¬ì™€ ì‚¬ìš© ì¡°ê±´
        self.tools = {
            'search': {
                'function': self._search,
                'when_to_use': 'ìµœì‹  ì •ë³´ë‚˜ ì‚¬ì‹¤ í™•ì¸ì´ í•„ìš”í•  ë•Œ',
                'examples': ['ëˆ„ê°€ 2024ë…„ì— Xë¥¼ í–ˆë‚˜?', 'Yì˜ ìµœê·¼ ì†Œì‹ì€?']
            },
            'calculate': {
                'function': self._calculate,
                'when_to_use': 'ìˆ˜í•™ ê³„ì‚°ì´ í•„ìš”í•  ë•Œ',
                'examples': ['15 + 23ì€?', 'ë©´ì  ê³„ì‚°']
            },
            'code_exec': {
                'function': self._execute_code,
                'when_to_use': 'ë³µì¡í•œ ë°ì´í„° ì²˜ë¦¬ë‚˜ ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰ì´ í•„ìš”í•  ë•Œ',
                'examples': ['ë¦¬ìŠ¤íŠ¸ ì •ë ¬', 'í†µê³„ ê³„ì‚°']
            }
        }
    
    def select_tool(self, question: str, context: str = "") -> str:
        """
        ì§ˆë¬¸ê³¼ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì ì ˆí•œ ë„êµ¬ ì„ íƒ
        """
        # ë„êµ¬ ì„¤ëª… ìƒì„±
        tools_desc = ""
        for name, info in self.tools.items():
            tools_desc += f"""
ë„êµ¬: {name}
ì‚¬ìš© ì‹œê¸°: {info['when_to_use']}
ì˜ˆì‹œ: {', '.join(info['examples'])}
"""
        
        # ë„êµ¬ ì„ íƒ í”„ë¡¬í”„íŠ¸
        prompt = f"""ë‹¤ìŒ ì§ˆë¬¸ì„ í•´ê²°í•˜ê¸° ìœ„í•´ ì–´ë–¤ ë„êµ¬ë¥¼ ì‚¬ìš©í•´ì•¼ í• ê¹Œìš”?

ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬:
{tools_desc}

ì§ˆë¬¸: {question}

{f'í˜„ì¬ ì»¨í…ìŠ¤íŠ¸: {context}' if context else ''}

ê°€ì¥ ì ì ˆí•œ ë„êµ¬ ì´ë¦„ë§Œ ë‹µí•˜ì„¸ìš” (ë˜ëŠ” 'none' if ë„êµ¬ ë¶ˆí•„ìš”):"""
        
        message = self.client.messages.create(
            model=self.model,
            max_tokens=50,
            temperature=0,
            messages=[{"role": "user", "content": prompt}]
        )
        
        tool_name = message.content[0].text.strip().lower()
        
        return tool_name if tool_name in self.tools else None
    
    def run(self, question: str, max_steps: int = 10) -> str:
        """
        ë„êµ¬ ì¤‘ì‹¬ ì‹¤í–‰
        """
        context = ""
        
        for step in range(1, max_steps + 1):
            print(f"\nğŸ“ Step {step}")
            
            # ë„êµ¬ ì„ íƒ
            tool_name = self.select_tool(question, context)
            
            if tool_name is None or tool_name == 'none':
                # ë„êµ¬ ë¶ˆí•„ìš” - ì§ì ‘ ë‹µë³€
                print("ğŸ’¬ ë„êµ¬ ë¶ˆí•„ìš” - ì§ì ‘ ë‹µë³€")
                return self._generate_final_answer(question, context)
            
            print(f"ğŸ”§ ì„ íƒëœ ë„êµ¬: {tool_name}")
            
            # ë„êµ¬ ì…ë ¥ ìƒì„±
            tool_input = self._generate_tool_input(question, tool_name, context)
            print(f"ğŸ“¥ ì…ë ¥: {tool_input}")
            
            # ë„êµ¬ ì‹¤í–‰
            tool_func = self.tools[tool_name]['function']
            observation = tool_func(tool_input)
            print(f"ğŸ‘ï¸  ê´€ì°°: {observation}")
            
            # ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
            context += f"\n[{tool_name}] {observation}"
            
            # ì™„ë£Œ ì¡°ê±´ ì²´í¬
            if self._is_sufficient(question, context):
                print("\nâœ… ì¶©ë¶„í•œ ì •ë³´ ìˆ˜ì§‘ ì™„ë£Œ")
                return self._generate_final_answer(question, context)
        
        return self._generate_final_answer(question, context)
    
    def _generate_tool_input(
        self,
        question: str,
        tool_name: str,
        context: str
    ) -> str:
        """ë„êµ¬ ì…ë ¥ ìƒì„±"""
        prompt = f"""ì§ˆë¬¸: {question}

ë„êµ¬: {tool_name}

{f'í˜„ì¬ê¹Œì§€ ìˆ˜ì§‘í•œ ì •ë³´: {context}' if context else ''}

ì´ ë„êµ¬ì— ì–´ë–¤ ì…ë ¥ì„ ì œê³µí•´ì•¼ í• ê¹Œìš”? (ì…ë ¥ë§Œ ë‹µí•˜ì„¸ìš”):"""
        
        message = self.client.messages.create(
            model=self.model,
            max_tokens=100,
            temperature=0,
            messages=[{"role": "user", "content": prompt}]
        )
        
        return message.content[0].text.strip()
    
    def _is_sufficient(self, question: str, context: str) -> bool:
        """ì¶©ë¶„í•œ ì •ë³´ë¥¼ ëª¨ì•˜ëŠ”ì§€ í™•ì¸"""
        if not context:
            return False
        
        prompt = f"""ì§ˆë¬¸: {question}

ìˆ˜ì§‘í•œ ì •ë³´:
{context}

ì´ ì •ë³´ë¡œ ì§ˆë¬¸ì— ì¶©ë¶„íˆ ë‹µí•  ìˆ˜ ìˆìŠµë‹ˆê¹Œ? (yes/no):"""
        
        message = self.client.messages.create(
            model=self.model,
            max_tokens=10,
            temperature=0,
            messages=[{"role": "user", "content": prompt}]
        )
        
        response = message.content[0].text.strip().lower()
        
        return 'yes' in response
    
    def _generate_final_answer(self, question: str, context: str) -> str:
        """ìµœì¢… ë‹µë³€ ìƒì„±"""
        prompt = f"""ì§ˆë¬¸: {question}

ìˆ˜ì§‘í•œ ì •ë³´:
{context}

ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì§ˆë¬¸ì— ë‹µí•˜ì„¸ìš”:"""
        
        message = self.client.messages.create(
            model=self.model,
            max_tokens=1000,
            temperature=0,
            messages=[{"role": "user", "content": prompt}]
        )
        
        return message.content[0].text
    
    def _search(self, query: str) -> str:
        """ê²€ìƒ‰ êµ¬í˜„"""
        return f"[ê²€ìƒ‰ ê²°ê³¼: {query}]"
    
    def _calculate(self, expression: str) -> str:
        """ê³„ì‚° êµ¬í˜„"""
        try:
            return str(eval(expression))
        except:
            return "ê³„ì‚° ì˜¤ë¥˜"
    
    def _execute_code(self, code: str) -> str:
        """ì½”ë“œ ì‹¤í–‰ êµ¬í˜„"""
        return f"[ì½”ë“œ ì‹¤í–‰: {code}]"
```

## ë„êµ¬ ì„ íƒ ì „ëµ

### ì „ëµ 1: ê·œì¹™ ê¸°ë°˜ (Rule-Based)

```python
def rule_based_tool_selection(question: str) -> str:
    """
    ê·œì¹™ ê¸°ë°˜ ë„êµ¬ ì„ íƒ
    
    í‚¤ì›Œë“œ ë§¤ì¹­
    """
    question_lower = question.lower()
    
    # ê²€ìƒ‰ í‚¤ì›Œë“œ
    search_keywords = ['ëˆ„êµ¬', 'who', 'ì–¸ì œ', 'when', 'ìµœì‹ ', 'latest', 'ë‰´ìŠ¤']
    if any(kw in question_lower for kw in search_keywords):
        return 'search'
    
    # ê³„ì‚° í‚¤ì›Œë“œ
    calc_keywords = ['ê³„ì‚°', 'calculate', '+', '-', '*', '/', '=']
    if any(kw in question_lower for kw in calc_keywords):
        return 'calculate'
    
    # ì½”ë“œ ì‹¤í–‰ í‚¤ì›Œë“œ
    code_keywords = ['ì •ë ¬', 'sort', 'í•„í„°', 'filter', 'ì•Œê³ ë¦¬ì¦˜']
    if any(kw in question_lower for kw in code_keywords):
        return 'code_exec'
    
    # ê¸°ë³¸ê°’
    return 'none'
```

**ì¥ì **: ë¹ ë¦„, ì˜ˆì¸¡ ê°€ëŠ¥
**ë‹¨ì **: ìœ ì—°ì„± ë¶€ì¡±, ëª¨í˜¸í•œ ê²½ìš° ì²˜ë¦¬ ì–´ë ¤ì›€

### ì „ëµ 2: LLM ê¸°ë°˜ (LLM-Based)

```python
def llm_based_tool_selection(
    question: str,
    tools: Dict,
    context: str = ""
) -> str:
    """
    LLMì„ ì‚¬ìš©í•œ ë„êµ¬ ì„ íƒ
    
    ë” ì§€ëŠ¥ì ì´ì§€ë§Œ ë¹„ìš© ì¦ê°€
    """
    tools_desc = "\n".join([
        f"{name}: {info['description']}"
        for name, info in tools.items()
    ])
    
    prompt = f"""ì§ˆë¬¸ì„ í•´ê²°í•˜ê¸° ìœ„í•´ ì–´ë–¤ ë„êµ¬ê°€ í•„ìš”í•œê°€ìš”?

ë„êµ¬ ëª©ë¡:
{tools_desc}

ì§ˆë¬¸: {question}

{f'ì»¨í…ìŠ¤íŠ¸: {context}' if context else ''}

ê°€ì¥ ì ì ˆí•œ ë„êµ¬ ì´ë¦„ (í•˜ë‚˜ë§Œ):"""
    
    # LLM í˜¸ì¶œ
    # ...
    
    return tool_name
```

**ì¥ì **: ìœ ì—°í•¨, ì»¨í…ìŠ¤íŠ¸ ê³ ë ¤
**ë‹¨ì **: ë¹„ìš©, ì§€ì—° ì‹œê°„

### ì „ëµ 3: í•˜ì´ë¸Œë¦¬ë“œ (Hybrid)

```python
def hybrid_tool_selection(
    question: str,
    tools: Dict,
    context: str = ""
) -> str:
    """
    ê·œì¹™ + LLM í•˜ì´ë¸Œë¦¬ë“œ
    
    1. ê·œì¹™ìœ¼ë¡œ ë¹ ë¥¸ ì„ íƒ ì‹œë„
    2. ë¶ˆí™•ì‹¤í•˜ë©´ LLM ì‚¬ìš©
    """
    # Step 1: ê·œì¹™ ê¸°ë°˜ ì‹œë„
    rule_result = rule_based_tool_selection(question)
    
    # Step 2: í™•ì‹ ë„ í‰ê°€
    confidence = evaluate_rule_confidence(question, rule_result)
    
    if confidence > 0.8:
        # ë†’ì€ í™•ì‹  â†’ ê·œì¹™ ê²°ê³¼ ì‚¬ìš©
        return rule_result
    else:
        # ë‚®ì€ í™•ì‹  â†’ LLM ì‚¬ìš©
        return llm_based_tool_selection(question, tools, context)
```

**ì¥ì **: ë¹„ìš© íš¨ìœ¨ì , ë†’ì€ ì •í™•ë„
**ë‹¨ì **: ë³µì¡ë„ ì¦ê°€

## ì‹¤ë¬´ ì ìš© ì‚¬ë¡€

### ì‚¬ë¡€ 1: ê³ ê° ì§€ì› Agent

```python
class CustomerSupportAgent:
    """
    ê³ ê° ì§€ì› ReAct Agent
    """
    
    def __init__(self, api_key: str):
        self.agent = ReActAgent(api_key)
        
        # ê³ ê° ì§€ì› íŠ¹í™” ë„êµ¬
        self.register_support_tools()
    
    def register_support_tools(self):
        """ê³ ê° ì§€ì› ë„êµ¬ ë“±ë¡"""
        
        # ì£¼ë¬¸ ì¡°íšŒ
        def lookup_order(order_id: str) -> str:
            """ì£¼ë¬¸ ì •ë³´ ì¡°íšŒ"""
            # ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬
            return f"ì£¼ë¬¸ #{order_id}: ë°°ì†¡ ì¤‘ (ì˜ˆìƒ ë„ì°©: 2ì¼ í›„)"
        
        self.agent.register_tool(
            name="lookup_order",
            function=lookup_order,
            description="ì£¼ë¬¸ ë²ˆí˜¸ë¡œ ì£¼ë¬¸ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤."
        )
        
        # í™˜ë¶ˆ ì •ì±… ì¡°íšŒ
        def get_refund_policy(category: str) -> str:
            """í™˜ë¶ˆ ì •ì±… ì¡°íšŒ"""
            policies = {
                'electronics': 'êµ¬ë§¤ í›„ 14ì¼ ì´ë‚´ ë¯¸ê°œë´‰ ìƒíƒœ',
                'clothing': 'êµ¬ë§¤ í›„ 30ì¼ ì´ë‚´, íƒ ë¶€ì°©',
                'food': 'í™˜ë¶ˆ ë¶ˆê°€ (ë‹¨, ë¶ˆëŸ‰ ì‹œ êµí™˜)'
            }
            return policies.get(category, 'ì¼ë°˜ ì •ì±…: 7ì¼ ì´ë‚´')
        
        self.agent.register_tool(
            name="refund_policy",
            function=get_refund_policy,
            description="ìƒí’ˆ ì¹´í…Œê³ ë¦¬ë³„ í™˜ë¶ˆ ì •ì±…ì„ ì¡°íšŒí•©ë‹ˆë‹¤."
        )
        
        # í‹°ì¼“ ìƒì„±
        def create_ticket(issue: str) -> str:
            """ê³ ê° ì§€ì› í‹°ì¼“ ìƒì„±"""
            ticket_id = f"TK-{random.randint(1000, 9999)}"
            return f"í‹°ì¼“ {ticket_id} ìƒì„± ì™„ë£Œ. ë‹´ë‹¹ìê°€ 24ì‹œê°„ ë‚´ ì—°ë½ë“œë¦½ë‹ˆë‹¤."
        
        self.agent.register_tool(
            name="create_ticket",
            function=create_ticket,
            description="ë³µì¡í•œ ë¬¸ì œì— ëŒ€í•´ ì§€ì› í‹°ì¼“ì„ ìƒì„±í•©ë‹ˆë‹¤."
        )
    
    def handle_inquiry(self, customer_message: str) -> str:
        """ê³ ê° ë¬¸ì˜ ì²˜ë¦¬"""
        return self.agent.run(customer_message, max_steps=10, verbose=True)


# ì‚¬ìš©
support = CustomerSupportAgent(api_key="your-api-key")

inquiry = "ì£¼ë¬¸ ë²ˆí˜¸ 12345ì˜ ë°°ì†¡ ìƒíƒœë¥¼ ì•Œë ¤ì£¼ì„¸ìš”. ê·¸ë¦¬ê³  ë§ˆìŒì— ì•ˆ ë“¤ë©´ í™˜ë¶ˆ ê°€ëŠ¥í•œê°€ìš”?"

response = support.handle_inquiry(inquiry)

# ì‹¤í–‰:
# Thought 1: ë¨¼ì € ì£¼ë¬¸ ìƒíƒœë¥¼ í™•ì¸í•´ì•¼ í•©ë‹ˆë‹¤.
# Action 1: lookup_order[12345]
# Observation 1: ì£¼ë¬¸ #12345: ë°°ì†¡ ì¤‘ (ì˜ˆìƒ ë„ì°©: 2ì¼ í›„)
#
# Thought 2: í™˜ë¶ˆ ì •ì±…ì„ í™•ì¸í•´ì•¼ í•©ë‹ˆë‹¤. ìƒí’ˆ ì¹´í…Œê³ ë¦¬ê°€ í•„ìš”í•©ë‹ˆë‹¤.
# Action 2: lookup_order[12345]
# Observation 2: ... (ì¹´í…Œê³ ë¦¬: electronics)
#
# Thought 3: ì „ìì œí’ˆ í™˜ë¶ˆ ì •ì±…ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
# Action 3: refund_policy[electronics]
# Observation 3: êµ¬ë§¤ í›„ 14ì¼ ì´ë‚´ ë¯¸ê°œë´‰ ìƒíƒœ
#
# Thought 4: ì¶©ë¶„í•œ ì •ë³´ë¥¼ ëª¨ì•˜ìŠµë‹ˆë‹¤.
# Action 4: finish[ì£¼ë¬¸ #12345ëŠ” í˜„ì¬ ë°°ì†¡ ì¤‘ì´ë©° 2ì¼ í›„ ë„ì°© ì˜ˆì •ì…ë‹ˆë‹¤. ì „ìì œí’ˆì€ êµ¬ë§¤ í›„ 14ì¼ ì´ë‚´ ë¯¸ê°œë´‰ ìƒíƒœë¡œ í™˜ë¶ˆ ê°€ëŠ¥í•©ë‹ˆë‹¤.]
```

### ì‚¬ë¡€ 2: ë°ì´í„° ë¶„ì„ Agent

```python
class DataAnalysisAgent:
    """
    ë°ì´í„° ë¶„ì„ ReAct Agent
    """
    
    def __init__(self, api_key: str, data_path: str):
        self.agent = ReActAgent(api_key)
        self.data_path = data_path
        
        # ë°ì´í„° ë¶„ì„ ë„êµ¬
        self.register_analysis_tools()
    
    def register_analysis_tools(self):
        """ë°ì´í„° ë¶„ì„ ë„êµ¬ ë“±ë¡"""
        
        # ë°ì´í„° ë¡œë“œ
        def load_data(filename: str) -> str:
            """CSV ë°ì´í„° ë¡œë“œ"""
            import pandas as pd
            
            try:
                df = pd.read_csv(f"{self.data_path}/{filename}")
                
                info = f"""ë°ì´í„° ë¡œë“œ ì™„ë£Œ:
- í–‰ ìˆ˜: {len(df)}
- ì—´ ìˆ˜: {len(df.columns)}
- ì—´ ì´ë¦„: {', '.join(df.columns)}
- ì²˜ìŒ 5í–‰:
{df.head().to_string()}"""
                
                # ì „ì—­ ë³€ìˆ˜ì— ì €ì¥ (ë‹¤ë¥¸ ë„êµ¬ì—ì„œ ì‚¬ìš©)
                globals()['current_df'] = df
                
                return info
            except Exception as e:
                return f"ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨: {e}"
        
        self.agent.register_tool(
            name="load_data",
            function=load_data,
            description="CSV íŒŒì¼ì„ ë¡œë“œí•©ë‹ˆë‹¤. ì…ë ¥: íŒŒì¼ëª…"
        )
        
        # í†µê³„ ê³„ì‚°
        def compute_statistics(column: str) -> str:
            """ì—´ì˜ ê¸°ìˆ  í†µê³„"""
            df = globals().get('current_df')
            
            if df is None:
                return "ë¨¼ì € ë°ì´í„°ë¥¼ ë¡œë“œí•˜ì„¸ìš”."
            
            if column not in df.columns:
                return f"'{column}' ì—´ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
            
            stats = df[column].describe()
            
            return f"{column} í†µê³„:\n{stats.to_string()}"
        
        self.agent.register_tool(
            name="statistics",
            function=compute_statistics,
            description="íŠ¹ì • ì—´ì˜ ê¸°ìˆ  í†µê³„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. ì…ë ¥: ì—´ ì´ë¦„"
        )
        
        # ë°ì´í„° í•„í„°ë§
        def filter_data(condition: str) -> str:
            """ì¡°ê±´ì— ë§ëŠ” ë°ì´í„° í•„í„°ë§"""
            df = globals().get('current_df')
            
            if df is None:
                return "ë¨¼ì € ë°ì´í„°ë¥¼ ë¡œë“œí•˜ì„¸ìš”."
            
            try:
                # ì¡°ê±´ í‰ê°€ (ì£¼ì˜: ì‹¤ì œë¡œëŠ” ë” ì•ˆì „í•œ ë°©ë²• í•„ìš”)
                filtered = df.query(condition)
                
                result = f"""í•„í„°ë§ ê²°ê³¼:
- ë§¤ì¹­ í–‰ ìˆ˜: {len(filtered)}
- ì²˜ìŒ 5í–‰:
{filtered.head().to_string()}"""
                
                return result
            except Exception as e:
                return f"í•„í„°ë§ ì‹¤íŒ¨: {e}"
        
        self.agent.register_tool(
            name="filter",
            function=filter_data,
            description="ì¡°ê±´ì— ë§ëŠ” ë°ì´í„°ë¥¼ í•„í„°ë§í•©ë‹ˆë‹¤. ì…ë ¥: pandas query ì¡°ê±´"
        )
    
    def analyze(self, question: str) -> str:
        """ë°ì´í„° ë¶„ì„ ì‹¤í–‰"""
        return self.agent.run(question, max_steps=15, verbose=True)


# ì‚¬ìš©
analyst = DataAnalysisAgent(
    api_key="your-api-key",
    data_path="./data"
)

question = "sales.csvë¥¼ ë¡œë“œí•˜ê³ , ë§¤ì¶œì´ 1000 ì´ìƒì¸ ì œí’ˆë“¤ì˜ í‰ê·  ê°€ê²©ì„ êµ¬í•´ì£¼ì„¸ìš”."

answer = analyst.analyze(question)

# ì‹¤í–‰:
# Thought 1: ë¨¼ì € sales.csvë¥¼ ë¡œë“œí•´ì•¼ í•©ë‹ˆë‹¤.
# Action 1: load_data[sales.csv]
# Observation 1: ë°ì´í„° ë¡œë“œ ì™„ë£Œ: í–‰ ìˆ˜: 150, ì—´: product, price, sales...
#
# Thought 2: ë§¤ì¶œì´ 1000 ì´ìƒì¸ ë°ì´í„°ë¥¼ í•„í„°ë§í•©ë‹ˆë‹¤.
# Action 2: filter[sales >= 1000]
# Observation 2: í•„í„°ë§ ê²°ê³¼: ë§¤ì¹­ í–‰ ìˆ˜: 45...
#
# Thought 3: ì´ì œ price ì—´ì˜ í†µê³„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
# Action 3: statistics[price]
# Observation 3: price í†µê³„: mean: 1250.5, std: 320.2...
#
# Thought 4: ë‹µë³€ ê°€ëŠ¥í•©ë‹ˆë‹¤.
# Action 4: finish[ë§¤ì¶œì´ 1000 ì´ìƒì¸ ì œí’ˆì€ 45ê°œì´ë©°, í‰ê·  ê°€ê²©ì€ $1,250.5ì…ë‹ˆë‹¤.]
```

### ì‚¬ë¡€ 3: ì—°êµ¬ ë³´ì¡° Agent

```python
class ResearchAssistantAgent:
    """
    ì—°êµ¬ ë³´ì¡° Agent
    
    ë…¼ë¬¸ ê²€ìƒ‰, ìš”ì•½, ë¹„êµ
    """
    
    def __init__(self, api_key: str):
        self.agent = ReActAgent(api_key)
        
        # ì—°êµ¬ ë„êµ¬
        self.register_research_tools()
    
    def register_research_tools(self):
        """ì—°êµ¬ ë„êµ¬ ë“±ë¡"""
        
        # arXiv ê²€ìƒ‰
        def search_arxiv(query: str) -> str:
            """arXiv ë…¼ë¬¸ ê²€ìƒ‰"""
            import arxiv
            
            search = arxiv.Search(
                query=query,
                max_results=5,
                sort_by=arxiv.SortCriterion.Relevance
            )
            
            results = []
            for paper in search.results():
                results.append(f"""ì œëª©: {paper.title}
ì €ì: {', '.join([a.name for a in paper.authors])}
ê²Œì‹œì¼: {paper.published.date()}
ìš”ì•½: {paper.summary[:200]}...
URL: {paper.entry_id}
""")
            
            return "\n\n".join(results)
        
        self.agent.register_tool(
            name="search_papers",
            function=search_arxiv,
            description="arXivì—ì„œ ë…¼ë¬¸ì„ ê²€ìƒ‰í•©ë‹ˆë‹¤. ì…ë ¥: ê²€ìƒ‰ ì¿¼ë¦¬"
        )
        
        # ë…¼ë¬¸ ë‹¤ìš´ë¡œë“œ ë° ìš”ì•½
        def summarize_paper(arxiv_id: str) -> str:
            """ë…¼ë¬¸ ìš”ì•½"""
            import arxiv
            
            paper = next(arxiv.Search(id_list=[arxiv_id]).results())
            
            # ì „ë¬¸ ë‹¤ìš´ë¡œë“œ ë° ìš”ì•½ (ê°„ëµí™”)
            summary = f"""ë…¼ë¬¸: {paper.title}

ì£¼ìš” ë‚´ìš©:
{paper.summary}

ê¸°ì—¬:
(ì—¬ê¸°ì„œëŠ” ì´ˆë¡ ê¸°ë°˜, ì‹¤ì œë¡œëŠ” ì „ë¬¸ ë¶„ì„ í•„ìš”)"""
            
            return summary
        
        self.agent.register_tool(
            name="summarize",
            function=summarize_paper,
            description="arXiv ë…¼ë¬¸ì„ ìš”ì•½í•©ë‹ˆë‹¤. ì…ë ¥: arXiv ID"
        )
    
    def research(self, research_question: str) -> str:
        """ì—°êµ¬ ì§ˆë¬¸ì— ë‹µë³€"""
        return self.agent.run(research_question, max_steps=20, verbose=True)


# ì‚¬ìš©
researcher = ResearchAssistantAgent(api_key="your-api-key")

question = "ReAct í”„ë¡¬í”„íŒ…ì— ëŒ€í•œ ìµœê·¼ ë…¼ë¬¸ì„ ì°¾ê³ , í•µì‹¬ ì•„ì´ë””ì–´ë¥¼ ìš”ì•½í•´ì£¼ì„¸ìš”."

answer = researcher.research(question)
```

## í•œê³„ì  ë° í•´ê²°ì±…

### í•œê³„ 1: ë¬´í•œ ë£¨í”„

**ë¬¸ì œ**: Agentê°€ ê°™ì€ í–‰ë™ì„ ë°˜ë³µ

```python
# ë‚˜ìœ ì˜ˆ
Thought 1: Xë¥¼ ê²€ìƒ‰í•´ì•¼ í•¨
Action 1: search[X]
Observation 1: Xì— ëŒ€í•œ ì •ë³´...

Thought 2: Xë¥¼ ê²€ìƒ‰í•´ì•¼ í•¨  â† ë°˜ë³µ!
Action 2: search[X]
Observation 2: Xì— ëŒ€í•œ ì •ë³´...

(ë¬´í•œ ë°˜ë³µ...)
```

**í•´ê²°ì±…**: ì¤‘ë³µ í–‰ë™ ê°ì§€ ë° ë°©ì§€

```python
class LoopPreventionReAct(ReActAgent):
    """
    ë¬´í•œ ë£¨í”„ ë°©ì§€ ReAct
    """
    
    def __init__(self, api_key: str):
        super().__init__(api_key)
        self.action_history = []  # í–‰ë™ ì´ë ¥
    
    def execute_action(self, tool_name: str, tool_input: str) -> str:
        """
        í–‰ë™ ì‹¤í–‰ (ì¤‘ë³µ ì²´í¬ í¬í•¨)
        """
        action_key = f"{tool_name}[{tool_input}]"
        
        # ì¤‘ë³µ ì²´í¬
        if action_key in self.action_history:
            # ì´ë¯¸ ì‹¤í–‰í•œ í–‰ë™
            count = self.action_history.count(action_key)
            
            if count >= 2:
                # 3ë²ˆ ì´ìƒ ë°˜ë³µ â†’ ê²½ê³ 
                return f"ê²½ê³ : ì´ í–‰ë™ì„ ì´ë¯¸ {count}ë²ˆ ì‹¤í–‰í–ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ì ‘ê·¼ì„ ì‹œë„í•˜ì„¸ìš”."
        
        # í–‰ë™ ê¸°ë¡
        self.action_history.append(action_key)
        
        # ì‹¤í–‰
        return super().execute_action(tool_name, tool_input)
```

### í•œê³„ 2: ë„êµ¬ ì„ íƒ ì˜¤ë¥˜

**ë¬¸ì œ**: ì˜ëª»ëœ ë„êµ¬ ì„ íƒ

```python
# ë‚˜ìœ ì˜ˆ
ì§ˆë¬¸: "15 + 23ì€?"
Action: search[15 + 23]  â† ì˜ëª»ëœ ë„êµ¬!
Observation: ê²€ìƒ‰ ê²°ê³¼... (ê³„ì‚°ì´ ì•„ë‹˜)
```

**í•´ê²°ì±…**: ë„êµ¬ ì„ íƒ ê²€ì¦

```python
def validate_tool_choice(
    question: str,
    selected_tool: str,
    tools: Dict
) -> bool:
    """
    ë„êµ¬ ì„ íƒì´ ì ì ˆí•œì§€ ê²€ì¦
    """
    validation_prompt = f"""ì§ˆë¬¸: {question}

ì„ íƒëœ ë„êµ¬: {selected_tool}
ë„êµ¬ ì„¤ëª…: {tools[selected_tool]['description']}

ì´ ë„êµ¬ ì„ íƒì´ ì ì ˆí•œê°€ìš”? (yes/no):"""
    
    # LLMìœ¼ë¡œ ê²€ì¦
    # ...
    
    return is_appropriate
```

### í•œê³„ 3: ê¸´ ì‹¤í–‰ ì‹œê°„

**ë¬¸ì œ**: ë§ì€ ë‹¨ê³„ë¡œ ì¸í•œ ì§€ì—°

**í•´ê²°ì±…**: ì¡°ê¸° ì¢…ë£Œ ë° ìµœì í™”

```python
class OptimizedReAct(ReActAgent):
    """
    ìµœì í™”ëœ ReAct
    """
    
    def run(
        self,
        question: str,
        max_steps: int = 10,
        timeout: int = 60  # ì´ˆ
    ) -> str:
        """
        íƒ€ì„ì•„ì›ƒ í¬í•¨ ì‹¤í–‰
        """
        import time
        
        start_time = time.time()
        
        for step in range(1, max_steps + 1):
            # íƒ€ì„ì•„ì›ƒ ì²´í¬
            if time.time() - start_time > timeout:
                print(f"â° íƒ€ì„ì•„ì›ƒ ({timeout}ì´ˆ)")
                return self._emergency_answer(question)
            
            # ì •ìƒ ì‹¤í–‰
            # ...
    
    def _emergency_answer(self, question: str) -> str:
        """
        íƒ€ì„ì•„ì›ƒ ì‹œ ê¸´ê¸‰ ë‹µë³€
        
        ì§€ê¸ˆê¹Œì§€ ìˆ˜ì§‘í•œ ì •ë³´ë¡œ ìµœì„ ì˜ ë‹µë³€
        """
        context = self._format_history()
        
        prompt = f"""ì‹œê°„ ì œì•½ìœ¼ë¡œ ì¸í•´ ì¡°ì‚¬ë¥¼ ì™„ë£Œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.
ì§€ê¸ˆê¹Œì§€ ìˆ˜ì§‘í•œ ì •ë³´ë¡œ ìµœì„ ì˜ ë‹µë³€ì„ ì œê³µí•˜ì„¸ìš”.

ì§ˆë¬¸: {question}

ìˆ˜ì§‘í•œ ì •ë³´:
{context}

ë‹µë³€ (ì •ë³´ê°€ ë¶ˆì™„ì „í•¨ì„ ëª…ì‹œ):"""
        
        # LLM í˜¸ì¶œ
        # ...
        
        return answer
```

### í•œê³„ 4: ë¹„ìš©

**ë¬¸ì œ**: ë§ì€ LLM í˜¸ì¶œë¡œ ì¸í•œ ë†’ì€ ë¹„ìš©

**í•´ê²°ì±…**: ë¹„ìš© ìµœì í™” ì „ëµ

```python
class CostOptimizedReAct:
    """
    ë¹„ìš© ìµœì í™” ReAct
    """
    
    def __init__(
        self,
        api_key: str,
        budget_per_query: float = 0.10  # ì¿¼ë¦¬ë‹¹ $0.10
    ):
        self.agent = ReActAgent(api_key)
        self.budget = budget_per_query
        self.cost_per_call = 0.01  # ì˜ˆìƒ ë¹„ìš©
    
    def run_with_budget(self, question: str) -> str:
        """
        ì˜ˆì‚° ì œì•½ í•˜ ì‹¤í–‰
        """
        max_steps = int(self.budget / self.cost_per_call)
        
        print(f"ğŸ’° ì˜ˆì‚°: ${self.budget}")
        print(f"   ìµœëŒ€ ë‹¨ê³„: {max_steps}\n")
        
        # ì‹¤í–‰
        answer = self.agent.run(
            question,
            max_steps=max_steps,
            verbose=True
        )
        
        # ì‹¤ì œ ë¹„ìš© ê³„ì‚°
        actual_cost = len(self.agent.history) * self.cost_per_call
        
        print(f"\nğŸ’µ ì‹¤ì œ ë¹„ìš©: ${actual_cost:.3f}")
        
        return answer
```

## ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

### 1. ëª…í™•í•œ ë„êµ¬ ì„¤ëª…

```python
# âŒ ë‚˜ìœ ì˜ˆ
agent.register_tool(
    name="tool1",
    function=my_func,
    description="ë°ì´í„° ì²˜ë¦¬"  # ë„ˆë¬´ ëª¨í˜¸
)

# âœ… ì¢‹ì€ ì˜ˆ
agent.register_tool(
    name="filter_data",
    function=my_func,
    description="""CSV ë°ì´í„°ë¥¼ ì¡°ê±´ì— ë”°ë¼ í•„í„°ë§í•©ë‹ˆë‹¤.
ì…ë ¥: pandas query í˜•ì‹ì˜ ì¡°ê±´ (ì˜ˆ: 'age > 30 and city == "Seoul"')
ì¶œë ¥: í•„í„°ë§ëœ í–‰ì˜ ìˆ˜ì™€ ì²˜ìŒ 5í–‰ì˜ ë¯¸ë¦¬ë³´ê¸°"""
)
```

### 2. ë„êµ¬ ê²°ê³¼ í¬ë§·íŒ…

```python
def well_formatted_tool(input_data: str) -> str:
    """
    ê²°ê³¼ë¥¼ ëª…í™•í•˜ê²Œ í¬ë§·íŒ…
    """
    result = process_data(input_data)
    
    # âœ… êµ¬ì¡°í™”ëœ ì¶œë ¥
    return f"""ì²˜ë¦¬ ì™„ë£Œ:
- ì…ë ¥ í¬ê¸°: {len(input_data)}
- ì²˜ë¦¬ëœ í•­ëª©: {result['count']}
- ì„±ê³µ: {result['success']}ê°œ
- ì‹¤íŒ¨: {result['failures']}ê°œ

ì²˜ìŒ 3ê°œ ê²°ê³¼:
{format_results(result['items'][:3])}"""
```

### 3. ì˜¤ë¥˜ ì²˜ë¦¬

```python
def robust_tool(input_data: str) -> str:
    """
    ê²¬ê³ í•œ ì˜¤ë¥˜ ì²˜ë¦¬
    """
    try:
        result = risky_operation(input_data)
        return f"ì„±ê³µ: {result}"
    
    except ValueError as e:
        return f"ì…ë ¥ ì˜¤ë¥˜: {e}. ì˜¬ë°”ë¥¸ í˜•ì‹: [ì˜ˆì‹œ]"
    
    except ConnectionError:
        return "ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜. ë‚˜ì¤‘ì— ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ ë‹¤ë¥¸ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."
    
    except Exception as e:
        return f"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {e}"
```

### 4. ì§„í–‰ ìƒí™© ë¡œê¹…

```python
class LoggingReAct(ReActAgent):
    """
    ìƒì„¸í•œ ë¡œê¹…ì´ ìˆëŠ” ReAct
    """
    
    def __init__(self, api_key: str, log_file: str = "react.log"):
        super().__init__(api_key)
        
        import logging
        logging.basicConfig(
            filename=log_file,
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
    
    def execute_action(self, tool_name: str, tool_input: str) -> str:
        """ë¡œê¹… í¬í•¨ í–‰ë™ ì‹¤í–‰"""
        
        self.logger.info(f"ë„êµ¬ í˜¸ì¶œ: {tool_name}[{tool_input}]")
        
        try:
            result = super().execute_action(tool_name, tool_input)
            self.logger.info(f"ë„êµ¬ ê²°ê³¼: {result[:100]}...")
            return result
        
        except Exception as e:
            self.logger.error(f"ë„êµ¬ ì‹¤í–‰ ì˜¤ë¥˜: {e}")
            raise
```

### 5. í…ŒìŠ¤íŠ¸

```python
def test_react_agent():
    """
    ReAct Agent í…ŒìŠ¤íŠ¸
    """
    agent = ReActAgent(api_key="test-key")
    
    # í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤
    test_cases = [
        {
            'question': "2 + 2ëŠ”?",
            'expected_tool': 'calculate',
            'expected_answer': '4'
        },
        {
            'question': "2024ë…„ ë…¸ë²¨ìƒ ìˆ˜ìƒìëŠ”?",
            'expected_tool': 'search',
            'expected_answer_contains': 'ë…¸ë²¨'
        }
    ]
    
    for i, test in enumerate(test_cases, 1):
        print(f"\ní…ŒìŠ¤íŠ¸ {i}: {test['question']}")
        
        answer = agent.run(test['question'], max_steps=5, verbose=False)
        
        # ê²€ì¦
        if 'expected_answer' in test:
            assert answer == test['expected_answer'], f"ê¸°ëŒ€: {test['expected_answer']}, ì‹¤ì œ: {answer}"
        
        if 'expected_answer_contains' in test:
            assert test['expected_answer_contains'] in answer, f"'{test['expected_answer_contains']}'ê°€ ë‹µë³€ì— ì—†ìŒ"
        
        # ë„êµ¬ ì‚¬ìš© í™•ì¸
        used_tools = [step['action'].split('[')[0] for step in agent.history]
        assert test['expected_tool'] in used_tools, f"ê¸°ëŒ€ ë„êµ¬ {test['expected_tool']} ì‚¬ìš© ì•ˆ ë¨"
        
        print("âœ… í†µê³¼")
```

## ë‹¤ë¥¸ Agent í”„ë ˆì„ì›Œí¬ ë¹„êµ

### ReAct vs LangChain Agents

| íŠ¹ì„± | ReAct | LangChain |
|-----|-------|-----------|
| **êµ¬ì¡°** | Thought-Action-Observation | Tool â†’ Output |
| **ì¶”ë¡  ê°€ì‹œì„±** | ë†’ìŒ (ëª…ì‹œì  Thought) | ë‚®ìŒ (ì•”ë¬µì ) |
| **êµ¬í˜„ ë³µì¡ë„** | ì¤‘ê°„ | ë‚®ìŒ (ì¶”ìƒí™”) |
| **ì»¤ìŠ¤í„°ë§ˆì´ì§•** | ì‰¬ì›€ | ì œí•œì  |
| **ë””ë²„ê¹…** | ì‰¬ì›€ | ì–´ë ¤ì›€ |

### ReAct vs AutoGPT

| íŠ¹ì„± | ReAct | AutoGPT |
|-----|-------|---------|
| **ììœ¨ì„±** | ì¤‘ê°„ (ì‚¬ëŒì´ ëª©í‘œ ì„¤ì •) | ë†’ìŒ (ìì²´ ëª©í‘œ) |
| **ì•ˆì •ì„±** | ë†’ìŒ | ë‚®ìŒ |
| **ë¹„ìš©** | ì˜ˆì¸¡ ê°€ëŠ¥ | ë†’ìŒ (ë¬´ì œí•œ ì‹¤í–‰) |
| **ì ìš© ë²”ìœ„** | íŠ¹ì • ì‘ì—… | ë²”ìš© |

## ì •ë¦¬ ë° ì‹œë¦¬ì¦ˆ ì¢…í•©

### ReAct í•µì‹¬ ìš”ì•½

**ReAct (Reasoning + Acting)**:
- Thought-Action-Observation ì‚¬ì´í´
- ì™¸ë¶€ ë„êµ¬ í†µí•©ìœ¼ë¡œ LLM ëŠ¥ë ¥ í™•ì¥
- HotpotQAì—ì„œ CoT ëŒ€ë¹„ +19% ê°œì„  (Self-Consistency ê²°í•© ì‹œ)
- ì˜¤ë¥˜ íšŒë³µ ëŠ¥ë ¥ 67% (CoT: 12%)

**ì£¼ìš” êµ¬ì„± ìš”ì†Œ**:
1. **Thought**: ë‹¤ìŒ ë‹¨ê³„ì— ëŒ€í•œ ì¶”ë¡ 
2. **Action**: ë„êµ¬ í˜¸ì¶œ
3. **Observation**: ê²°ê³¼ ê´€ì°°
4. **Tools**: ê²€ìƒ‰, ê³„ì‚°, API í˜¸ì¶œ ë“±

**ì–¸ì œ ì‚¬ìš©í•  ê²ƒì¸ê°€**:
- âœ… ì™¸ë¶€ ì •ë³´ í•„ìš” (ê²€ìƒ‰, DB)
- âœ… ë³µì¡í•œ ë‹¤ë‹¨ê³„ ë¬¸ì œ
- âœ… ë™ì  í™˜ê²½ (ìƒí™©ì— ë”°ë¼ ì „ëµ ë³€ê²½)
- âœ… ë„êµ¬ í†µí•© í•„ìš”

**ì–¸ì œ ì‚¬ìš©í•˜ì§€ ë§ ê²ƒì¸ê°€**:
- âŒ ë‹¨ìˆœ ì§ˆë¬¸ (CoTë¡œ ì¶©ë¶„)
- âŒ ë¹„ìš© ë§¤ìš° ë¯¼ê°
- âŒ ì‹¤ì‹œê°„ ì‘ë‹µ í•„ìˆ˜ (ì§€ì—° ì‹œê°„)

### ê³ ê¸‰ í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§ ì‹œë¦¬ì¦ˆ ì „ì²´ ì •ë¦¬

**Part 1-10 í•µì‹¬ ê¸°ë²• ìš”ì•½**:

| ê¸°ë²• | í•µì‹¬ ì•„ì´ë””ì–´ | ì£¼ìš” ê°œì„  | ê¶Œì¥ ì‚¬ìš© |
|-----|-------------|---------|----------|
| **Generate Knowledge** | ë°°ê²½ ì§€ì‹ ë¨¼ì € ìƒì„± | +8% | ìƒì‹ ì¶”ë¡  |
| **Prompt Chaining** | ì‘ì—… ë¶„í•´ ë° ì—°ê²° | ë³µì¡ë„ ê´€ë¦¬ | ë‹¤ë‹¨ê³„ ì‘ì—… |
| **Tree of Thoughts** | íŠ¸ë¦¬ íƒìƒ‰ + ë°±íŠ¸ë˜í‚¹ | +70% (Game24) | ìµœì í•´ í•„ìš” |
| **RAG** | ì™¸ë¶€ ì§€ì‹ ê²€ìƒ‰ | í• ë£¨ì‹œë„¤ì´ì…˜ ê°ì†Œ | ì§€ì‹ ê¸°ë°˜ ì‘ì—… |
| **APE** | í”„ë¡¬í”„íŠ¸ ìë™ ìƒì„± | +4.5% | ëŒ€ëŸ‰ ìµœì í™” |
| **OPRO** | LLMì´ LLM ìµœì í™” | +8.4% | í”„ë¡¬í”„íŠ¸ ë°œê²¬ |
| **Active-Prompt** | ë¶ˆí™•ì‹¤í•œ ì˜ˆì‹œ ì„ ë³„ | ë¹„ìš© 50% ì ˆê° | Few-shot íš¨ìœ¨ |
| **Directional Stimulus** | íŒíŠ¸ë¡œ ìœ ë„ | +14% | ë„ë©”ì¸ íŠ¹í™” |
| **ReAct** | ì¶”ë¡  + í–‰ë™ ê²°í•© | +19% | ë„êµ¬ ì‚¬ìš© |

**ê¸°ë²• ì„ íƒ ê°€ì´ë“œ**:

```
ì§ˆë¬¸ ìœ í˜•ì— ë”°ë¥¸ ì„ íƒ:

ë‹¨ìˆœ ì‚¬ì‹¤ ì§ˆë¬¸
â†’ Zero-shot ë˜ëŠ” Few-shot

ë³µì¡í•œ ì¶”ë¡ 
â†’ CoT ë˜ëŠ” Tree of Thoughts

ìµœì‹  ì •ë³´ í•„ìš”
â†’ RAG ë˜ëŠ” ReAct

ë„ë©”ì¸ íŠ¹í™”
â†’ Directional Stimulus ë˜ëŠ” Active-Prompt

í”„ë¡¬í”„íŠ¸ ìµœì í™”
â†’ APE ë˜ëŠ” OPRO

ë‹¤ë‹¨ê³„ ì‘ì—…
â†’ Prompt Chaining ë˜ëŠ” ReAct
```

### ì‹¤ë¬´ ì ìš© ë¡œë“œë§µ

**Week 1-2: ê¸°ì´ˆ**
- CoT, Few-shot ë§ˆìŠ¤í„°
- ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§ ì›ì¹™

**Week 3-4: ì¤‘ê¸‰**
- Prompt Chaining êµ¬í˜„
- RAG ì‹œìŠ¤í…œ êµ¬ì¶•

**Week 5-6: ê³ ê¸‰**
- ReAct Agent ê°œë°œ
- ë„ë©”ì¸ íŠ¹í™” ìµœì í™”

**Week 7-8: í”„ë¡œë•ì…˜**
- ì„±ëŠ¥ ìµœì í™”
- ëª¨ë‹ˆí„°ë§ ë° A/B í…ŒìŠ¤íŠ¸

### ë¯¸ë˜ ë°©í–¥

**í˜„ì¬ íŠ¸ë Œë“œ**:
1. **Agentic AI**: ReAct ê¸°ë°˜ ììœ¨ Agent
2. **Multi-modal**: í…ìŠ¤íŠ¸ + ì´ë¯¸ì§€ + ë¹„ë””ì˜¤
3. **Long-context**: 100K+ í† í° ìœˆë„ìš°
4. **Tool Learning**: ë„êµ¬ ìë™ ë°œê²¬ ë° í•™ìŠµ

**ê¸°ëŒ€ë˜ëŠ” ë°œì „**:
- ë” ìŠ¤ë§ˆíŠ¸í•œ ë„êµ¬ ì„ íƒ
- ìê°€ ê°œì„  Agent
- ë©€í‹° Agent í˜‘ì—… í”„ë ˆì„ì›Œí¬
- ì €ë¹„ìš© ê³ íš¨ìœ¨ ì¶”ë¡ 

---

## ì°¸ê³ ë¬¸í—Œ

1. Yao, S., Zhao, J., Yu, D., Du, N., Shafran, I., Narasimhan, K., & Cao, Y. (2022). **ReAct: Synergizing reasoning and acting in language models.** *arXiv preprint arXiv:2210.03629*.

2. Schick, T., et al. (2023). **Toolformer: Language models can teach themselves to use tools.** *arXiv preprint arXiv:2302.04761*.

3. Shinn, N., et al. (2023). **Reflexion: Language agents with verbal reinforcement learning.** *arXiv preprint arXiv:2303.11366*.

## ì¶”ê°€ì  ê¸°ë²•

* Prompt Compression
    * LLMLingua, AutoCompressor
    * ê¸´ í”„ë¡¬í”„íŠ¸ë¥¼ ì••ì¶•
* In-Context Learning ë³€í˜•
    * Meta-Prompting: í”„ë¡¬í”„íŠ¸ê°€ í”„ë¡¬í”„íŠ¸ë¥¼ ìƒì„±
    * Instruction Induction: ì˜ˆì‹œì—ì„œ instruction ì¶”ë¡ 
    * Rephrase and Respond (RaR): ì§ˆë¬¸ ì¬êµ¬ì„± í›„ ë‹µë³€
* Multimodal Prompting
    * Vision-Language Prompting: ì´ë¯¸ì§€+í…ìŠ¤íŠ¸
    * Audio Prompting: ìŒì„± ì…ë ¥
    * Video Understanding: ë¹„ë””ì˜¤ ë¶„ì„