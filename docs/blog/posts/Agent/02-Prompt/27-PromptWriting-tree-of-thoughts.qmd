---
title: "Tree of Thoughts: ì „ëµì  íƒìƒ‰ê³¼ ë°±íŠ¸ë˜í‚¹ìœ¼ë¡œ ë³µì¡í•œ ë¬¸ì œ í•´ê²°í•˜ê¸°"
subtitle: íŠ¸ë¦¬ êµ¬ì¡° íƒìƒ‰ê³¼ í‰ê°€ ê¸°ë°˜ ê²½ë¡œ ì„ íƒìœ¼ë¡œ ë³µì¡í•œ ì¶”ë¡  ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ê³ ê¸‰ í”„ë¡¬í”„íŒ… ê¸°ë²•
description: |
  Tree of Thoughts (ToT)ì˜ ì •ì˜ë¶€í„° ì‹¤ì „ êµ¬í˜„ê¹Œì§€ ì²´ê³„ì ìœ¼ë¡œ ì„¤ëª…í•œë‹¤.
  Yao et al. (2024) "Tree of Thoughts: Deliberate Problem Solving with Large Language Models" ì—°êµ¬ë¥¼ ë°”íƒ•ìœ¼ë¡œ íŠ¸ë¦¬ êµ¬ì¡° íƒìƒ‰ì˜ ì›ë¦¬, ìƒê° ë¶„í•´(Thought Decomposition)ì™€ ìƒì„±(Thought Generation) ë©”ì»¤ë‹ˆì¦˜,
  í‰ê°€ ê¸°ë°˜ ê²½ë¡œ ì„ íƒê³¼ ë°±íŠ¸ë˜í‚¹(Backtracking) ì „ëµ, BFS/DFS íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì„ ë¶„ì„í•œë‹¤.
  Game of 24, Creative Writing, Crosswords ë“± ë²¤ì¹˜ë§ˆí¬ì—ì„œ CoT ëŒ€ë¹„ ìµœëŒ€ 18ë°° ì„±ëŠ¥ í–¥ìƒ(74% vs 4%) ê²°ê³¼ë¥¼ ì œì‹œí•˜ê³ , ìˆ˜í•™ í¼ì¦, ì°½ì‘ ê¸€ì“°ê¸°, ì½”ë“œ ë¦¬íŒ©í† ë§ ë“± ì‹¤ë¬´ ì˜ˆì‹œì™€
  Python êµ¬í˜„ ì½”ë“œ(Anthropic Claude API í™œìš©)ë¥¼ í†µí•´ ì‹¤ì „ í™œìš© ë°©ë²•ì„ ìƒì„¸íˆ ë‹¤ë£¬ë‹¤.
  ë¹„ìš©-ì„±ëŠ¥ íŠ¸ë ˆì´ë“œì˜¤í”„ ë¶„ì„(100ë°°+ API ë¹„ìš©), ì ìš© ì‹œë‚˜ë¦¬ì˜¤ë³„ ê¶Œì¥ì‚¬í•­,
  Simple ToT íŒ¨í„´ê³¼ ìµœì‹  ëª¨ë¸ì—ì„œì˜ ì‹¤ìš©ì„± í‰ê°€ë¥¼ ì œì‹œí•œë‹¤.
categories:
  - Prompt Engineering
  - LLM
  - AI
  - Agent
author: Kwangmin Kim
date: 02/03/2025
format: 
  html:
    page-layout: full
    code-fold: true
    toc: true
    number-sections: true
draft: False
---

## ë“¤ì–´ê°€ë©°

Chain-of-Thought (CoT) í”„ë¡¬í”„íŒ…ì€ ëª¨ë¸ì´ ë‹¨ê³„ë³„ë¡œ ì¶”ë¡ í•˜ë„ë¡ ìœ ë„í•˜ì—¬ ë³µì¡í•œ ë¬¸ì œ í•´ê²° ëŠ¥ë ¥ì„ í¬ê²Œ í–¥ìƒì‹œì¼°ë‹¤. í•˜ì§€ë§Œ CoTì—ëŠ” ê·¼ë³¸ì ì¸ í•œê³„ê°€ ìˆë‹¤: **í•œë²ˆ ì„ íƒí•œ ì¶”ë¡  ê²½ë¡œë¥¼ ë˜ëŒë¦´ ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒì´ë‹¤.**

ì˜ˆë¥¼ ë“¤ì–´, ìˆ˜í•™ ë¬¸ì œë¥¼ í’€ë‹¤ê°€ ì¤‘ê°„ì— ì˜ëª»ëœ ì ‘ê·¼ì„ ì„ íƒí–ˆë‹¤ë©´? CoTëŠ” ê·¸ëŒ€ë¡œ ì§„í–‰í•˜ì—¬ í‹€ë¦° ë‹µì— ë„ë‹¬í•œë‹¤. í•˜ì§€ë§Œ ì‚¬ëŒì€ ì–´ë–»ê²Œ í•˜ëŠ”ê°€? ë§‰ë‹¤ë¥¸ ê³¨ëª©ì— ë‹¤ë‹¤ë¥´ë©´ ë’¤ë¡œ ëŒì•„ê°€ì„œ(backtrack) ë‹¤ë¥¸ ê²½ë¡œë¥¼ ì‹œë„í•œë‹¤.

**Tree of Thoughts (ToT)**ëŠ” ë°”ë¡œ ì´ëŸ¬í•œ ì¸ê°„ì˜ ë¬¸ì œ í•´ê²° ë°©ì‹ì„ ëª¨ë¸ë§í•œ ê¸°ë²•ì´ë‹¤. ì—¬ëŸ¬ ì¶”ë¡  ê²½ë¡œë¥¼ íŠ¸ë¦¬ êµ¬ì¡°ë¡œ íƒìƒ‰í•˜ê³ , ê° ê²½ë¡œë¥¼ í‰ê°€í•˜ë©°, í•„ìš”ì‹œ ë˜ëŒì•„ê°€ì„œ ë” ë‚˜ì€ ê²½ë¡œë¥¼ ì°¾ëŠ”ë‹¤.

ì´ë²ˆ í¬ìŠ¤íŠ¸ì—ì„œëŠ” Yao et al. (2024)ì˜ ì—°êµ¬ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ToTì˜ ì›ë¦¬, ì‹¤í—˜ ê²°ê³¼, ê·¸ë¦¬ê³  ì‹¤ë¬´ ì ìš© ê°€ëŠ¥ì„±ì„ ìƒì„¸íˆ ë¶„ì„í•œë‹¤.

## Tree of Thoughtsë€?

### í•µì‹¬ ê°œë…

**Tree of Thoughts (ToT)**ëŠ” ì–¸ì–´ ëª¨ë¸ì´ ë¬¸ì œë¥¼ í•´ê²°í•  ë•Œ ì—¬ëŸ¬ ê°€ëŠ¥í•œ ì¶”ë¡  ê²½ë¡œë¥¼ **íŠ¸ë¦¬ êµ¬ì¡°**ë¡œ íƒìƒ‰í•˜ëŠ” í”„ë ˆì„ì›Œí¬ë‹¤.

**ì£¼ìš” íŠ¹ì§•**:
- **íŠ¸ë¦¬ êµ¬ì¡°**: ê° ë…¸ë“œëŠ” "ìƒê°(thought)"ì„ ë‚˜íƒ€ëƒ„
- **ë°±íŠ¸ë˜í‚¹**: ë§‰ë‹¤ë¥¸ ê³¨ëª©ì—ì„œ ë˜ëŒì•„ê°€ê¸° ê°€ëŠ¥
- **í‰ê°€ ê¸°ë°˜**: ê° ìƒê°ì„ í‰ê°€í•˜ì—¬ ìµœì„ ì˜ ê²½ë¡œ ì„ íƒ
- **ì „ëµì  íƒìƒ‰**: BFS, DFS ë“± íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ í™œìš©

### Chain-of-Thought vs Tree of Thoughts

ì‹œê°ì ìœ¼ë¡œ ë¹„êµí•˜ë©´ ì°¨ì´ê°€ ëª…í™•í•˜ë‹¤:

**Chain-of-Thought (ì„ í˜• íƒìƒ‰)**:
```
Input â†’ Thought 1 â†’ Thought 2 â†’ Thought 3 â†’ Output
           â†“           â†“           â†“
        (ê³ ì •ë¨)     (ê³ ì •ë¨)     (ê³ ì •ë¨)
```

**Tree of Thoughts (íŠ¸ë¦¬ íƒìƒ‰)**:
```
                      Input
                        â†“
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”
           Thought 1a              1b      1c
              â†“                    â†“       â†“
         â”Œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”               â”‚   (í‰ê°€: ë‚®ìŒ, ì œê±°)
       2a    2b   2c               2d
        â†“     â†“    â†“               â†“
     (í‰ê°€) (í‰ê°€) (ì„ íƒ)(ë°±íŠ¸ë˜í‚¹)
```

### ê¸°ë³¸ í”„ë¡œì„¸ìŠ¤

1. **ìƒê° ë¶„í•´ (Thought Decomposition)**: ë¬¸ì œë¥¼ ì¤‘ê°„ ë‹¨ê³„ë¡œ ë‚˜ëˆ”
2. **ìƒê° ìƒì„± (Thought Generation)**: ê° ë‹¨ê³„ì—ì„œ ì—¬ëŸ¬ í›„ë³´ ìƒê° ìƒì„±
3. **ìƒê° í‰ê°€ (State Evaluation)**: ê° ìƒê°ì˜ í’ˆì§ˆ í‰ê°€
4. **íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ (Search Algorithm)**: ìµœì  ê²½ë¡œ íƒìƒ‰ (BFS, DFS ë“±)

## ToTì˜ 4ë‹¨ê³„ í”„ë¡œì„¸ìŠ¤

Yao et al. (2024)ì˜ ë…¼ë¬¸ì— ë”°ë¥´ë©´, ToTëŠ” ë‹¤ìŒ 4ë‹¨ê³„ë¡œ êµ¬ì„±ëœë‹¤.

### ìƒê° ë¶„í•´ (Thought Decomposition)

**ëª©ì **: ë¬¸ì œë¥¼ ì–´ë–¤ ì¤‘ê°„ ë‹¨ê³„ë¡œ ë‚˜ëˆŒ ê²ƒì¸ê°€ë¥¼ ì •ì˜í•œë‹¤.

**í•µì‹¬ ì§ˆë¬¸**:
- ê° "ìƒê°"ì€ ë¬´ì—‡ì„ ë‚˜íƒ€ë‚´ëŠ”ê°€?
- ëª‡ ë‹¨ê³„ë¡œ ë‚˜ëˆŒ ê²ƒì¸ê°€?
- ê° ë‹¨ê³„ëŠ” ì–¼ë§ˆë‚˜ êµ¬ì²´ì ì´ì–´ì•¼ í•˜ëŠ”ê°€?

**ì˜ˆì‹œ: Game of 24**

ë¬¸ì œ: ë„¤ ê°œì˜ ìˆ«ì (4, 9, 10, 13)ë¡œ 24ë¥¼ ë§Œë“¤ ìˆ˜ ìˆëŠ”ê°€?

```
ìƒê° ë¶„í•´:
- ê° "ìƒê°" = í•˜ë‚˜ì˜ ì¤‘ê°„ ìˆ˜ì‹
- ë‹¨ê³„ ìˆ˜ = 3 (ë„¤ ê°œ ìˆ«ìë¥¼ 24ë¡œ ë§Œë“¤ë ¤ë©´ ì„¸ ë²ˆì˜ ì—°ì‚° í•„ìš”)

ì˜ˆì‹œ ìƒê°:
- "13 - 9 = 4"  (ë‚¨ì€ ìˆ«ì: 4, 4, 10)
- "4 * 10 = 40" (ë‚¨ì€ ìˆ«ì: 4, 40)
- "40 - 4 = 36" (ìµœì¢…: 36) â† 24ê°€ ì•„ë‹ˆë¯€ë¡œ ì‹¤íŒ¨
```

**ì˜ˆì‹œ: Creative Writing**

ë¬¸ì œ: 4ê°œì˜ ë¬´ì‘ìœ„ ë¬¸ì¥ìœ¼ë¡œ ì—°ê²°ëœ ì—ì„¸ì´ ì‘ì„±

```
ìƒê° ë¶„í•´:
- ê° "ìƒê°" = í•œ ë¬¸ë‹¨ì˜ ì‘ì„± ê³„íš
- ë‹¨ê³„ ìˆ˜ = 1 (ì „ì²´ ì—ì„¸ì´ ê³„íšì„ í•œ ë²ˆì—)

ì˜ˆì‹œ ìƒê°:
- "ì²« ë¬¸ì¥ìœ¼ë¡œ ë„ì… â†’ ë‘ ë²ˆì§¸ ë¬¸ì¥ìœ¼ë¡œ ì „ê°œ â†’ ..."
- "ì‹œê°„ ìˆœì„œë¡œ ë°°ì—´: ê³¼ê±° â†’ í˜„ì¬ â†’ ë¯¸ë˜"
- "ëŒ€ì¡° êµ¬ì¡°: ë¬¸ì œ ì œê¸° â†’ í•´ê²°ì±… ì œì‹œ"
```

**ì¤‘ìš”í•œ ì **: ìƒê°ì˜ "ì…ë„(granularity)"ëŠ” ë¬¸ì œì— ë”°ë¼ ë‹¤ë¥´ë‹¤.
- ë„ˆë¬´ ì‘ìœ¼ë©´: íƒìƒ‰ ê³µê°„ì´ í­ë°œì ìœ¼ë¡œ ì¦ê°€
- ë„ˆë¬´ í¬ë©´: ìœ ì—°ì„± ë¶€ì¡±, CoTì™€ ì°¨ì´ ì—†ìŒ

### ìƒê° ìƒì„± (Thought Generation)

**ëª©ì **: ê° ë‹¨ê³„ì—ì„œ ê°€ëŠ¥í•œ ì—¬ëŸ¬ ìƒê° í›„ë³´ë¥¼ ìƒì„±í•œë‹¤.

**ë‘ ê°€ì§€ ë°©ë²•**:

#### Sample (ìƒ˜í”Œë§)

ë…ë¦½ì ìœ¼ë¡œ ì—¬ëŸ¬ ìƒê°ì„ ìƒ˜í”Œë§í•œë‹¤ (i.i.d.).

```python
prompt = f"""
Possible next steps for the equation:
Current state: {current_state}
Generate a next step.
"""

# temperature > 0ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ ë‹¤ì–‘í•œ ìƒê° ìƒì„±
thoughts = []
for _ in range(k):  # kê°œ ìƒì„±
    thought = model.generate(prompt, temperature=0.7)
    thoughts.append(thought)
```

**ì¥ì **: ìƒê°ì˜ ë‹¤ì–‘ì„± í™•ë³´
**ë‹¨ì **: ì¤‘ë³µ ê°€ëŠ¥ì„±

#### Propose (ì œì•ˆ)

í•œ ë²ˆì— ì—¬ëŸ¬ ìƒê°ì„ ì œì•ˆí•˜ë„ë¡ ìš”ì²­í•œë‹¤.

```python
prompt = f"""
Current state: {current_state}
Propose 3 possible next steps:
1.
2.
3.
"""

response = model.generate(prompt, temperature=0)
thoughts = parse_numbered_list(response)
```

**ì¥ì **: ì¤‘ë³µ ë°©ì§€, ë‹¤ì–‘ì„±ê³¼ ê´€ë ¨ì„±ì˜ ê· í˜•
**ë‹¨ì **: í”„ë¡¬í”„íŠ¸ ë³µì¡ë„ ì¦ê°€

### ìƒê° í‰ê°€ (State Evaluation)

**ëª©ì **: ê° ìƒê°ì´ ë¬¸ì œ í•´ê²°ì— ì–¼ë§ˆë‚˜ ìœ ë§í•œì§€ í‰ê°€í•œë‹¤.

**ë‘ ê°€ì§€ ë°©ë²•**:

#### Value (ê°€ì¹˜ í‰ê°€)

ê° ìƒê°ì— ì ìˆ˜ë¥¼ ë¶€ì—¬í•œë‹¤.

```python
prompt = f"""
Evaluate if the following equation is likely to reach 24:
Equation: {equation}
Remaining numbers: {remaining}

Rate on a scale:
- sure/likely: This will definitely/probably reach 24
- maybe: Uncertain
- impossible: This cannot reach 24

Your evaluation:
"""

evaluation = model.generate(prompt)
score = parse_evaluation(evaluation)  # sure=1.0, likely=0.75, maybe=0.5, impossible=0.0
```

**ì¥ì **: ì„¸ë°€í•œ ë¹„êµ ê°€ëŠ¥
**ë‹¨ì **: í‰ê°€ ìì²´ê°€ ì–´ë ¤ìš¸ ìˆ˜ ìˆìŒ

#### Vote (íˆ¬í‘œ)

ì—¬ëŸ¬ í‰ê°€ë¥¼ ìƒì„±í•˜ê³  ë‹¤ìˆ˜ê²°ë¡œ ê²°ì •í•œë‹¤.

```python
votes = []
for _ in range(num_votes):
    evaluation = model.generate(evaluation_prompt)
    votes.append(evaluation)

# ë‹¤ìˆ˜ê²°
from collections import Counter
final_evaluation = Counter(votes).most_common(1)[0][0]
```

**ì¥ì **: ë” ì•ˆì •ì ì¸ í‰ê°€
**ë‹¨ì **: ë¹„ìš© ì¦ê°€ (ì—¬ëŸ¬ ë²ˆ í‰ê°€)

### íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ (Search Algorithm)

**ëª©ì **: ì–´ë–¤ ìˆœì„œë¡œ íŠ¸ë¦¬ë¥¼ íƒìƒ‰í•  ê²ƒì¸ê°€ë¥¼ ê²°ì •í•œë‹¤.

#### BFS (Breadth-First Search, ë„ˆë¹„ ìš°ì„  íƒìƒ‰)

**ì „ëµ**: ê° ë‹¨ê³„ì—ì„œ ê°€ì¥ ìœ ë§í•œ bê°œì˜ ìƒê°ì„ ìœ ì§€í•œë‹¤.

```python
def bfs_search(initial_state, b=5):
    """
    b: beam width (ê° ë‹¨ê³„ì—ì„œ ìœ ì§€í•  ìƒê°ì˜ ê°œìˆ˜)
    """
    states = [initial_state]
    
    for step in range(max_steps):
        all_new_states = []
        
        # ê° í˜„ì¬ ìƒíƒœì—ì„œ ìƒˆë¡œìš´ ìƒê° ìƒì„±
        for state in states:
            new_thoughts = generate_thoughts(state, k=5)
            for thought in new_thoughts:
                new_state = apply_thought(state, thought)
                score = evaluate_state(new_state)
                all_new_states.append((new_state, score))
        
        # ìƒìœ„ bê°œë§Œ ìœ ì§€
        all_new_states.sort(key=lambda x: x[1], reverse=True)
        states = [s for s, _ in all_new_states[:b]]
        
        # ì¢…ë£Œ ì¡°ê±´ í™•ì¸
        for state in states:
            if is_goal(state):
                return state
    
    return None
```

**íŠ¹ì§•**:
- ìµœì í•´ë¥¼ ë†“ì¹  í™•ë¥  ë‚®ìŒ
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë§ìŒ
- "ì²´ê³„ì  íƒìƒ‰"ì— ì í•©

#### DFS (Depth-First Search, ê¹Šì´ ìš°ì„  íƒìƒ‰)

**ì „ëµ**: í•˜ë‚˜ì˜ ê²½ë¡œë¥¼ ëê¹Œì§€ íƒìƒ‰í•œ í›„ ë°±íŠ¸ë˜í‚¹í•œë‹¤.

```python
def dfs_search(initial_state, max_depth=10):
    """
    ê¹Šì´ ìš°ì„  íƒìƒ‰ + ë°±íŠ¸ë˜í‚¹
    """
    def dfs(state, depth):
        # ì¢…ë£Œ ì¡°ê±´
        if is_goal(state):
            return state
        
        if depth >= max_depth:
            return None
        
        # ìƒˆë¡œìš´ ìƒê° ìƒì„± ë° í‰ê°€
        thoughts = generate_thoughts(state, k=5)
        evaluated = [(t, evaluate_thought(state, t)) for t in thoughts]
        
        # ê°€ì¥ ìœ ë§í•œ ê²ƒë¶€í„° ì‹œë„ (íœ´ë¦¬ìŠ¤í‹±)
        evaluated.sort(key=lambda x: x[1], reverse=True)
        
        for thought, score in evaluated:
            # ëª…ë°±íˆ ë¶ˆê°€ëŠ¥í•œ ê²½ë¡œëŠ” ê°€ì§€ì¹˜ê¸°
            if score == 0.0:  # "impossible"
                continue
            
            new_state = apply_thought(state, thought)
            result = dfs(new_state, depth + 1)
            
            if result is not None:
                return result  # ì„±ê³µ
        
        # ëª¨ë“  ê²½ë¡œ ì‹¤íŒ¨ â†’ ë°±íŠ¸ë˜í‚¹
        return None
    
    return dfs(initial_state, 0)
```

**íŠ¹ì§•**:
- ë©”ëª¨ë¦¬ íš¨ìœ¨ì 
- ë°±íŠ¸ë˜í‚¹ ìì—°ìŠ¤ëŸ½ê²Œ êµ¬í˜„
- ìµœì í•´ë¥¼ ë†“ì¹  ìˆ˜ ìˆìŒ
- "ì‹œí–‰ì°©ì˜¤"ì— ì í•©

## ì‹¤ì „ ì˜ˆì œ: Game of 24

Yao et al.ì˜ ë…¼ë¬¸ì—ì„œ ê°€ì¥ ì¸ìƒì ì¸ ì‹¤í—˜ì€ "Game of 24"ë‹¤. ì´ ê²Œì„ì€ ë„¤ ê°œì˜ ìˆ«ìë¥¼ ì‚¬ì¹™ì—°ì‚°ìœ¼ë¡œ ì¡°í•©í•˜ì—¬ 24ë¥¼ ë§Œë“œëŠ” í¼ì¦ì´ë‹¤.

### ë¬¸ì œ ì •ì˜

**ì…ë ¥**: ë„¤ ê°œì˜ ìˆ«ì (ì˜ˆ: 4, 9, 10, 13)
**ëª©í‘œ**: ì‚¬ì¹™ì—°ì‚°ìœ¼ë¡œ 24 ë§Œë“¤ê¸°
**ì •ë‹µ ì˜ˆì‹œ**: `(13 - 9) * (10 - 4) = 4 * 6 = 24`

### ì™œ ì–´ë ¤ìš´ê°€?

- **íƒìƒ‰ ê³µê°„ í¬ê¸°**: ë„¤ ê°œ ìˆ«ìì˜ ëª¨ë“  ìˆœì—´ê³¼ ì—°ì‚° ì¡°í•© = ìˆ˜ì²œ ê°€ì§€
- **ë§‰ë‹¤ë¥¸ ê³¨ëª©**: ì˜ëª»ëœ ì¤‘ê°„ ë‹¨ê³„ëŠ” ì ˆëŒ€ 24ì— ë„ë‹¬ ë¶ˆê°€
- **ì „ëµ í•„ìš”**: ë¬´ì‘ìœ„ ì‹œë„ë¡œëŠ” í•´ê²° ì–´ë ¤ì›€

### ToT êµ¬í˜„

```python
import anthropic
from typing import List, Tuple, Optional
from dataclasses import dataclass

@dataclass
class GameState:
    """Game of 24 ìƒíƒœ"""
    numbers: List[int]  # ë‚¨ì€ ìˆ«ìë“¤
    operations: List[str]  # ì§€ê¸ˆê¹Œì§€ì˜ ì—°ì‚°ë“¤
    current_value: Optional[int]  # í˜„ì¬ ê°’ (ë§ˆì§€ë§‰ ë‹¨ê³„ì—ì„œ)

class ToT_Game24:
    """
    Tree of Thoughts for Game of 24
    """
    
    def __init__(self, api_key: str):
        self.client = anthropic.Anthropic(api_key=api_key)
        self.model = "claude-sonnet-4-20250514"
    
    def generate_next_steps(self, state: GameState, k: int = 5) -> List[str]:
        """
        Step 1: ë‹¤ìŒ ê°€ëŠ¥í•œ ë‹¨ê³„ë“¤ ìƒì„± (Thought Generation)
        """
        numbers_str = ", ".join(map(str, state.numbers))
        operations_str = "\n".join(state.operations) if state.operations else "None"
        
        prompt = f"""
You are solving the Game of 24.

Current state:
- Remaining numbers: {numbers_str}
- Operations so far:
{operations_str}

Generate {k} possible next steps. Each step should:
1. Pick two numbers from the remaining numbers
2. Apply one operation (+, -, *, /)
3. Show the result

Format: "a OP b = c" (e.g., "10 - 4 = 6")

List {k} different next steps:
"""
        
        message = self.client.messages.create(
            model=self.model,
            max_tokens=300,
            temperature=0.7,  # ë‹¤ì–‘ì„±ì„ ìœ„í•´ temperature > 0
            messages=[{"role": "user", "content": prompt}]
        )
        
        response = message.content[0].text.strip()
        
        # ì¤„ ë‹¨ìœ„ë¡œ íŒŒì‹±
        steps = []
        for line in response.split('\n'):
            line = line.strip()
            if '=' in line:
                # "10 - 4 = 6" í˜•íƒœ ì¶”ì¶œ
                steps.append(line)
        
        return steps[:k]
    
    def evaluate_step(self, state: GameState, step: str) -> float:
        """
        Step 2: ê° ë‹¨ê³„ í‰ê°€ (State Evaluation)
        
        Returns:
            0.0: impossible
            0.5: maybe
            0.75: likely
            1.0: sure
        """
        numbers_str = ", ".join(map(str, state.numbers))
        
        prompt = f"""
Evaluate if this step is promising for reaching 24:

Current numbers: {numbers_str}
Proposed step: {step}

Consider:
1. Does this step lead toward 24?
2. Are the remaining numbers manageable?
3. Is there a clear path to 24?

Evaluate as one of:
- "sure": This will definitely reach 24
- "likely": This probably will reach 24  
- "maybe": Uncertain
- "impossible": This cannot reach 24

Your evaluation (one word only):
"""
        
        message = self.client.messages.create(
            model=self.model,
            max_tokens=20,
            temperature=0,
            messages=[{"role": "user", "content": prompt}]
        )
        
        evaluation = message.content[0].text.strip().lower()
        
        # ì ìˆ˜ ë§¤í•‘
        score_map = {
            "sure": 1.0,
            "likely": 0.75,
            "maybe": 0.5,
            "impossible": 0.0
        }
        
        # ë¶€ë¶„ ë§¤ì¹­
        for key, value in score_map.items():
            if key in evaluation:
                return value
        
        return 0.5  # ê¸°ë³¸ê°’
    
    def apply_step(self, state: GameState, step: str) -> Optional[GameState]:
        """
        ë‹¨ê³„ë¥¼ ì ìš©í•˜ì—¬ ìƒˆë¡œìš´ ìƒíƒœ ìƒì„±
        """
        try:
            # "10 - 4 = 6" íŒŒì‹±
            import re
            match = re.match(r'(\d+)\s*([\+\-\*/])\s*(\d+)\s*=\s*(\d+)', step)
            
            if not match:
                return None
            
            a, op, b, result = match.groups()
            a, b, result = int(a), int(b), int(result)
            
            # ìˆ«ìê°€ í˜„ì¬ ìƒíƒœì— ìˆëŠ”ì§€ í™•ì¸
            numbers = state.numbers.copy()
            if a not in numbers or b not in numbers:
                return None
            
            # ìˆ«ì ì œê±°
            numbers.remove(a)
            numbers.remove(b)
            
            # ê²°ê³¼ ì¶”ê°€
            numbers.append(result)
            
            # ìƒˆë¡œìš´ ìƒíƒœ ìƒì„±
            new_state = GameState(
                numbers=numbers,
                operations=state.operations + [step],
                current_value=result if len(numbers) == 1 else None
            )
            
            return new_state
        
        except Exception as e:
            return None
    
    def is_goal(self, state: GameState) -> bool:
        """
        ëª©í‘œ ìƒíƒœì¸ê°€? (ìˆ«ìê°€ í•˜ë‚˜ ë‚¨ê³  ê·¸ ê°’ì´ 24)
        """
        return len(state.numbers) == 1 and state.numbers[0] == 24
    
    def solve_bfs(self, numbers: List[int], b: int = 5) -> Optional[List[str]]:
        """
        BFSë¡œ Game of 24 í’€ì´
        
        Args:
            numbers: ì´ˆê¸° ìˆ«ìë“¤
            b: beam width (ê° ë‹¨ê³„ì—ì„œ ìœ ì§€í•  ìƒíƒœ ìˆ˜)
        """
        print(f"ğŸ® Game of 24: {numbers}")
        print(f"ğŸ” BFS íƒìƒ‰ ì‹œì‘ (beam width: {b})\n")
        
        initial_state = GameState(numbers=numbers, operations=[], current_value=None)
        states = [(initial_state, 1.0)]  # (state, score)
        
        max_steps = 3  # 4ê°œ ìˆ«ì â†’ 3ë²ˆ ì—°ì‚° í•„ìš”
        
        for step_num in range(max_steps):
            print(f"{'='*60}")
            print(f"Step {step_num + 1}")
            print(f"{'='*60}")
            
            all_candidates = []
            
            # ê° í˜„ì¬ ìƒíƒœì—ì„œ í™•ì¥
            for state, prev_score in states:
                print(f"\ní˜„ì¬ ìƒíƒœ: {state.numbers}")
                
                # ìƒˆë¡œìš´ ë‹¨ê³„ë“¤ ìƒì„±
                next_steps = self.generate_next_steps(state, k=5)
                print(f"ìƒì„±ëœ ë‹¨ê³„ë“¤: {len(next_steps)}ê°œ")
                
                # ê° ë‹¨ê³„ í‰ê°€
                for step in next_steps:
                    new_state = self.apply_step(state, step)
                    
                    if new_state is None:
                        continue
                    
                    score = self.evaluate_step(state, step)
                    
                    print(f"  - {step} â†’ score: {score}")
                    
                    # ë¶ˆê°€ëŠ¥í•œ ê²½ë¡œëŠ” ê°€ì§€ì¹˜ê¸°
                    if score > 0.0:
                        all_candidates.append((new_state, score))
            
            # ìƒìœ„ bê°œë§Œ ìœ ì§€
            all_candidates.sort(key=lambda x: x[1], reverse=True)
            states = all_candidates[:b]
            
            print(f"\nìœ ì§€ëœ ìƒíƒœ: {len(states)}ê°œ")
            
            # ëª©í‘œ ìƒíƒœ í™•ì¸
            for state, score in states:
                if self.is_goal(state):
                    print(f"\n{'='*60}")
                    print("âœ… í•´ê²°ì±… ë°œê²¬!")
                    print(f"{'='*60}")
                    for op in state.operations:
                        print(f"  {op}")
                    print(f"  ìµœì¢… ê°’: {state.numbers[0]}")
                    return state.operations
        
        print(f"\nâŒ í•´ê²°ì±…ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
        return None


# ì‚¬ìš© ì˜ˆì‹œ
def main():
    solver = ToT_Game24(api_key="your-api-key")
    
    # í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤
    test_cases = [
        [4, 9, 10, 13],  # ì‰¬ì›€: (13-9)*(10-4) = 24
        [1, 5, 5, 5],    # ì–´ë ¤ì›€: 5*(5-(1/5)) = 24
        [2, 8, 8, 14],   # ì¤‘ê°„: (8/(2-8/8))*2 = 24
    ]
    
    for numbers in test_cases:
        print("\n" + "="*80)
        solution = solver.solve_bfs(numbers, b=3)
        print("="*80 + "\n")
        
        if solution:
            print(f"âœ… ì„±ê³µ: {' â†’ '.join(solution)}")
        else:
            print(f"âŒ ì‹¤íŒ¨")


if __name__ == "__main__":
    main()
```

### ì‹¤í–‰ ê²°ê³¼ ì˜ˆì‹œ

```
================================================================================
ğŸ® Game of 24: [4, 9, 10, 13]
ğŸ” BFS íƒìƒ‰ ì‹œì‘ (beam width: 3)

============================================================
Step 1
============================================================

í˜„ì¬ ìƒíƒœ: [4, 9, 10, 13]
ìƒì„±ëœ ë‹¨ê³„ë“¤: 5ê°œ
  - 13 - 9 = 4 â†’ score: 0.75 (likely)
  - 10 - 4 = 6 â†’ score: 0.5 (maybe)
  - 10 + 13 = 23 â†’ score: 1.0 (sure)
  - 9 * 4 = 36 â†’ score: 0.0 (impossible)
  - 13 - 4 = 9 â†’ score: 0.5 (maybe)

ìœ ì§€ëœ ìƒíƒœ: 3ê°œ

============================================================
Step 2
============================================================

í˜„ì¬ ìƒíƒœ: [4, 4, 10]  # from 13-9=4
ìƒì„±ëœ ë‹¨ê³„ë“¤: 5ê°œ
  - 10 - 4 = 6 â†’ score: 0.75 (likely)
  - 4 * 4 = 16 â†’ score: 0.5 (maybe)
  - 10 + 4 = 14 â†’ score: 0.25 (unlikely)

í˜„ì¬ ìƒíƒœ: [4, 9, 23]  # from 10+13=23
ìƒì„±ëœ ë‹¨ê³„ë“¤: 5ê°œ
  - 23 + 9 = 32 â†’ score: 0.0 (impossible)
  - 23 - 9 = 14 â†’ score: 0.5 (maybe)
  - 23 + 4 = 27 â†’ score: 0.0 (impossible)

í˜„ì¬ ìƒíƒœ: [9, 10, 13]  # from 13-4=9
... (ìƒëµ)

ìœ ì§€ëœ ìƒíƒœ: 3ê°œ

============================================================
Step 3
============================================================

í˜„ì¬ ìƒíƒœ: [4, 6]  # from 10-4=6
ìƒì„±ëœ ë‹¨ê³„ë“¤: 2ê°œ
  - 6 * 4 = 24 â†’ score: 1.0 (sure)
  - 6 + 4 = 10 â†’ score: 0.0 (impossible)

============================================================
âœ… í•´ê²°ì±… ë°œê²¬!
============================================================
  13 - 9 = 4
  10 - 4 = 6
  6 * 4 = 24
  ìµœì¢… ê°’: 24

================================================================================
```

## ì‹¤í—˜ ê²°ê³¼ ë¶„ì„

### ë²¤ì¹˜ë§ˆí¬ ì„±ëŠ¥ ë¹„êµ

Yao et al. (2024)ëŠ” ToTë¥¼ ì„¸ ê°€ì§€ íƒœìŠ¤í¬ì—ì„œ í…ŒìŠ¤íŠ¸í–ˆë‹¤:

1. **Game of 24**: ë„¤ ìˆ«ìë¡œ 24 ë§Œë“¤ê¸°
2. **Creative Writing**: ë„¤ ë¬¸ì¥ìœ¼ë¡œ ì¼ê´€ëœ ì—ì„¸ì´ ì‘ì„±
3. **5Ã—5 Crosswords**: ì‹­ìë§í’€ì´

### Game of 24 ê²°ê³¼

| ë°©ë²• | ì„±ê³µë¥  |
|-----|-------|
| IO prompt | 7.3% |
| CoT prompt | 4.0% |
| CoT-SC (k=100) | 9.0% |
| **ToT (b=1)** | **45%** |
| **ToT (b=5)** | **74%** |
| IO + Refine (k=10) | 27% |
| IO (best of 100) | 33% |
| CoT (best of 100) | 49% |

**í•µì‹¬ ì¸ì‚¬ì´íŠ¸**:

1. **CoTë³´ë‹¤ ToTê°€ ì••ë„ì ìœ¼ë¡œ ìš°ìˆ˜**: 74% vs 4%
   - CoTëŠ” í•œ ë²ˆ ì˜ëª»ëœ ê²½ë¡œë¥¼ ì„ íƒí•˜ë©´ ë˜ëŒë¦´ ìˆ˜ ì—†ìŒ
   - ToTëŠ” ë°±íŠ¸ë˜í‚¹ìœ¼ë¡œ ë‹¤ë¥¸ ê²½ë¡œ íƒìƒ‰ ê°€ëŠ¥

2. **Beam widthì˜ ì˜í–¥**:
   - b=1 (greedy): 45%
   - b=5: 74%
   - ë” ë§ì€ ê²½ë¡œë¥¼ íƒìƒ‰í• ìˆ˜ë¡ ì„±ëŠ¥ í–¥ìƒ

3. **ìƒ˜í”Œë§ë§Œìœ¼ë¡œëŠ” ë¶€ì¡±**:
   - CoT (best of 100): 49%
   - ToT (b=5): 74%
   - ë‹¨ìˆœíˆ ì—¬ëŸ¬ ë²ˆ ì‹œë„í•˜ëŠ” ê²ƒë³´ë‹¤ ì „ëµì  íƒìƒ‰ì´ íš¨ê³¼ì 

### ì˜¤ë‹µ íŒ¨í„´ ë¶„ì„

ë…¼ë¬¸ì—ì„œëŠ” CoTì™€ ToTì˜ ì˜¤ë‹µ íŒ¨í„´ì„ ë¶„ì„í–ˆë‹¤:

**CoTì˜ ì˜¤ë‹µ íŒ¨í„´**:
- **Step 1ì—ì„œ ì‹¤íŒ¨**: 62%
- **Step 2ì—ì„œ ì‹¤íŒ¨**: 31%
- **Step 3 ì´ìƒ**: 7%

â†’ CoTëŠ” ì²« ë‹¨ê³„ë¶€í„° ì˜ëª»ëœ ê²½ë¡œë¥¼ ì„ íƒí•˜ë©´ ë°”ë¡œ ì‹¤íŒ¨

**ToTì˜ ì˜¤ë‹µ íŒ¨í„´**:
- **Step 1ì—ì„œ ì‹¤íŒ¨**: 8%
- **Step 2ì—ì„œ ì‹¤íŒ¨**: 6%
- **Step 3 ì´ìƒ**: 3%
- **Correct**: 83%

â†’ ToTëŠ” ì´ˆê¸° ì‹¤ìˆ˜ë¥¼ ë³µêµ¬ ê°€ëŠ¥

**ì‹¤ì œ ì˜ˆì‹œ**:

```
ë¬¸ì œ: 4, 9, 10, 13ìœ¼ë¡œ 24 ë§Œë“¤ê¸°

CoT ì‹¤íŒ¨ ì¼€ì´ìŠ¤:
Step 1: 13 + 10 = 23
Step 2: 23 + 9 = 32
Step 3: 32 - 4 = 28 âŒ
â†’ Step 1ì˜ ì„ íƒì´ ì˜ëª»ë¨. ë˜ëŒë¦´ ìˆ˜ ì—†ìŒ.

ToT ì„±ê³µ ì¼€ì´ìŠ¤:
Step 1: 
  Option A: 13 + 10 = 23 (score: 0.5, maybe)
  Option B: 13 - 9 = 4 (score: 0.75, likely) âœ“ ì„ íƒ
  Option C: 10 * 4 = 40 (score: 0.0, impossible)

Step 2 (from Option B):
  Option A: 4 + 4 = 8 (score: 0.5)
  Option B: 10 - 4 = 6 (score: 0.75) âœ“ ì„ íƒ
  Option C: 4 * 10 = 40 (score: 0.0)

Step 3:
  6 * 4 = 24 âœ…
```

### ë…¸ë“œ ë°©ë¬¸ íšŸìˆ˜ vs ì„±ëŠ¥

ì—°êµ¬íŒ€ì€ ë°©ë¬¸í•œ ë…¸ë“œ ìˆ˜ì— ë”°ë¥¸ ì„±ëŠ¥ì„ ì¸¡ì •í–ˆë‹¤:

**ê²°ê³¼**:
- **IO (best of k)**: ë…¸ë“œ 100ê°œ ë°©ë¬¸ â†’ 33% ì„±ê³µë¥ 
- **CoT (best of k)**: ë…¸ë“œ 100ê°œ ë°©ë¬¸ â†’ 49% ì„±ê³µë¥ 
- **ToT (b=1~5)**: ë…¸ë“œ 20~50ê°œ ë°©ë¬¸ â†’ 45%~74% ì„±ê³µë¥ 

**ê²°ë¡ **: ToTëŠ” ë” ì ì€ ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ë©´ì„œë„ ë” ë†’ì€ ì„±ê³µë¥ ì„ ë‹¬ì„±í•œë‹¤. ì´ëŠ” **ì „ëµì  íƒìƒ‰**ì˜ íš¨ê³¼ë¥¼ ë³´ì—¬ì¤€ë‹¤.

## Creative Writing ì‹¤í—˜

### íƒœìŠ¤í¬ ì •ì˜

**ì…ë ¥**: ë„¤ ê°œì˜ ë¬´ì‘ìœ„ ë¬¸ì¥
```
1. "The old lighthouse stood alone on the cliff."
2. "Sarah had always been afraid of the dark."
3. "The package arrived three days late."
4. "In his pocket, he found a key he didn't recognize."
```

**ëª©í‘œ**: ì´ ë„¤ ë¬¸ì¥ì„ ëª¨ë‘ í¬í•¨í•˜ëŠ” ì¼ê´€ëœ ì§§ì€ ì—ì„¸ì´ ì‘ì„±

### ToT ì ìš©

```python
class ToT_CreativeWriting:
    """
    Tree of Thoughts for Creative Writing
    """
    
    def __init__(self, api_key: str):
        self.client = anthropic.Anthropic(api_key=api_key)
        self.model = "claude-sonnet-4-20250514"
    
    def generate_plans(self, sentences: List[str], k: int = 5) -> List[str]:
        """
        Step 1: ì—¬ëŸ¬ ì‘ì„± ê³„íš ìƒì„±
        """
        sentences_str = "\n".join([f"{i+1}. {s}" for i, s in enumerate(sentences)])
        
        prompt = f"""
        You need to write a coherent passage using these 4 random sentences:

        {sentences_str}

        Generate {k} different plans for how to connect these sentences into a story.
        Each plan should briefly describe:
        - The overall narrative structure
        - How each sentence connects to others
        - The tone and style

        List {k} different plans:
        """
        
        message = self.client.messages.create(
            model=self.model,
            max_tokens=1000,
            temperature=0.8,  # ì°½ì˜ì„±ì„ ìœ„í•´ ë†’ì€ temperature
            messages=[{"role": "user", "content": prompt}]
        )
        
        response = message.content[0].text.strip()
        
        # ê³„íšë“¤ íŒŒì‹± (ë‹¨ìˆœí™”ë¥¼ ìœ„í•´ ì „ì²´ë¥¼ í•˜ë‚˜ë¡œ ì·¨ê¸‰í•˜ê±°ë‚˜ ë²ˆí˜¸ë¡œ ë¶„ë¦¬)
        plans = []
        current_plan = []
        for line in response.split('\n'):
            if line.strip().startswith(('1.', '2.', '3.', '4.', '5.', 'Plan')):
                if current_plan:
                    plans.append('\n'.join(current_plan))
                    current_plan = []
            current_plan.append(line)
        
        if current_plan:
            plans.append('\n'.join(current_plan))
        
        return plans[:k]
    
    def evaluate_plan(self, sentences: List[str], plan: str) -> float:
        """
        Step 2: ê³„íš í‰ê°€
        """
        sentences_str = "\n".join([f"{i+1}. {s}" for i, s in enumerate(sentences)])
        
        prompt = f"""
        Evaluate the following story plan:

        Required sentences:
        {sentences_str}

        Plan:
        {plan}

        Rate this plan on coherence and creativity (1-10):
        - Does it naturally connect all four sentences?
        - Is the narrative structure clear?
        - Is it creative and engaging?

        Provide only a number (1-10):
        """
        
        message = self.client.messages.create(
            model=self.model,
            max_tokens=10,
            temperature=0,
            messages=[{"role": "user", "content": prompt}]
        )
        
        try:
            score = float(message.content[0].text.strip())
            return score / 10.0  # 0~1 ë²”ìœ„ë¡œ ì •ê·œí™”
        except:
            return 0.5
    
    def write_passage(self, sentences: List[str], plan: str) -> str:
        """
        Step 3: ê³„íšì— ë”°ë¼ ì‹¤ì œ ê¸€ ì‘ì„±
        """
        sentences_str = "\n".join([f"{i+1}. {s}" for i, s in enumerate(sentences)])
        
        prompt = f"""
        Write a coherent short passage (4 paragraphs) that incorporates ALL of these sentences:

        {sentences_str}

        Use this plan:
        {plan}

        Requirements:
        - Must include all 4 sentences word-for-word
        - Create smooth transitions between sentences
        - Maintain a consistent tone and narrative

        Write the passage:
        """
        
        message = self.client.messages.create(
            model=self.model,
            max_tokens=600,
            temperature=0.7,
            messages=[{"role": "user", "content": prompt}]
        )
        
        return message.content[0].text.strip()
    
    def solve(self, sentences: List[str], b: int = 3) -> str:
        """
        ToTë¡œ ì°½ì‘ ë¬¸ì œ í•´ê²°
        """
        print(f"ğŸ“ Creative Writing with ToT")
        print(f"Sentences: {sentences}\n")
        
        # Step 1: ì—¬ëŸ¬ ê³„íš ìƒì„±
        print("Step 1: ê³„íš ìƒì„± ì¤‘...")
        plans = self.generate_plans(sentences, k=5)
        print(f"ìƒì„±ëœ ê³„íš: {len(plans)}ê°œ\n")
        
        # Step 2: ê³„íš í‰ê°€
        print("Step 2: ê³„íš í‰ê°€ ì¤‘...")
        evaluated_plans = []
        for i, plan in enumerate(plans):
            score = self.evaluate_plan(sentences, plan)
            evaluated_plans.append((plan, score))
            print(f"Plan {i+1}: score = {score:.2f}")
        
        # ìƒìœ„ bê°œ ì„ íƒ
        evaluated_plans.sort(key=lambda x: x[1], reverse=True)
        top_plans = evaluated_plans[:b]
        
        print(f"\nì„ íƒëœ ê³„íš: {len(top_plans)}ê°œ")
        
        # Step 3: ì„ íƒëœ ê³„íšë“¤ë¡œ ê¸€ ì‘ì„±
        print("\nStep 3: ê¸€ ì‘ì„± ì¤‘...")
        passages = []
        for plan, score in top_plans:
            passage = self.write_passage(sentences, plan)
            passages.append((passage, score))
        
        # ìµœê³  ì ìˆ˜ì˜ ê¸€ ë°˜í™˜
        best_passage, best_score = passages[0]
        
        print(f"\nìµœì¢… ì„ íƒ: score = {best_score:.2f}")
        
        return best_passage


# ì‚¬ìš© ì˜ˆì‹œ
def test_creative_writing():
    sentences = [
        "The old lighthouse stood alone on the cliff.",
        "Sarah had always been afraid of the dark.",
        "The package arrived three days late.",
        "In his pocket, he found a key he didn't recognize."
    ]
    
    writer = ToT_CreativeWriting(api_key="your-api-key")
    passage = writer.solve(sentences, b=3)
    
    print("\n" + "="*80)
    print("ìµœì¢… ê²°ê³¼:")
    print("="*80)
    print(passage)


if __name__ == "__main__":
    test_creative_writing()
```

### ê²°ê³¼ ì˜ˆì‹œ

```
ğŸ“ Creative Writing with ToT
Sentences: ['The old lighthouse stood alone on the cliff.', ...]

Step 1: ê³„íš ìƒì„± ì¤‘...
ìƒì„±ëœ ê³„íš: 5ê°œ

Step 2: ê³„íš í‰ê°€ ì¤‘...
Plan 1: score = 0.85 (Mystery/thriller structure)
Plan 2: score = 0.72 (Coming-of-age narrative)
Plan 3: score = 0.68 (Time-travel concept)
Plan 4: score = 0.55 (Random connection)
Plan 5: score = 0.61 (Surreal approach)

ì„ íƒëœ ê³„íš: 3ê°œ

Step 3: ê¸€ ì‘ì„± ì¤‘...

ìµœì¢… ì„ íƒ: score = 0.85

================================================================================
ìµœì¢… ê²°ê³¼:
================================================================================

The old lighthouse stood alone on the cliff, its beam cutting through 
the darkness that had haunted this coast for generations. Sarah had 
always been afraid of the dark, but tonight she climbed the spiral 
stairs with determination, clutching the mysterious package that had 
finally arrivedâ€”three days late, but perhaps right on time.

The package arrived three days late, yet its contents seemed meant for 
this exact moment. Inside, wrapped in aged newspaper, was a brass key 
and a faded photograph of the lighthouse keeper from 1952. In his pocket, 
he found a key he didn't recognize, the note had read, describing her 
grandfather's final days at this very lighthouse.

As she inserted the key into the old keeper's lockbox, Sarah understood. 
Her grandfather had left this for her, knowing that one day she would 
need to face her fear. The lighthouseâ€”isolated, dark, but steadyâ€”had 
been waiting to teach her that some lights shine brightest in the deepest 
darkness.

With trembling hands, she lit the old lamp. For the first time since 
childhood, Sarah wasn't afraid of the dark. She had become the light.
```

### Creative Writing ì„±ëŠ¥

| ë°©ë²• | Coherence Score |
|-----|----------------|
| IO prompt | 6.2/10 |
| CoT prompt | 6.8/10 |
| **ToT (b=1)** | **7.5/10** |
| **ToT (b=5)** | **7.9/10** |

ToTëŠ” ì—¬ëŸ¬ ê³„íšì„ í‰ê°€í•˜ê³  ìµœì„ ì˜ êµ¬ì¡°ë¥¼ ì„ íƒí•¨ìœ¼ë¡œì¨ ë” ì¼ê´€ì„± ìˆëŠ” ê¸€ì„ ì‘ì„±í•œë‹¤.

## í•œê³„ì  ë° ë¹„ìš© ë¶„ì„

### ì—°ì‚° ë¹„ìš©

ToTì˜ ê°€ì¥ í° í•œê³„ëŠ” **ë†’ì€ ì—°ì‚° ë¹„ìš©**ì´ë‹¤.

**ë¹„ìš© ê³„ì‚° (Game of 24 ì˜ˆì‹œ)**:

```
ì„¤ì •:
- Beam width (b) = 5
- ê° ë‹¨ê³„ì—ì„œ ìƒì„±í•˜ëŠ” ìƒê° (k) = 5
- ë‹¨ê³„ ìˆ˜ (d) = 3

ì´ API í˜¸ì¶œ íšŸìˆ˜:

Step 1: 
  - ìƒê° ìƒì„±: b Ã— k = 5 Ã— 5 = 25íšŒ
  - í‰ê°€: 25íšŒ
  - ì†Œê³„: 50íšŒ

Step 2:
  - ìƒê° ìƒì„±: 5 Ã— 5 = 25íšŒ
  - í‰ê°€: 25íšŒ
  - ì†Œê³„: 50íšŒ

Step 3:
  - ìƒê° ìƒì„±: 5 Ã— 5 = 25íšŒ
  - í‰ê°€: 25íšŒ
  - ì†Œê³„: 50íšŒ

ì´ API í˜¸ì¶œ: 150íšŒ
```

**ë¹„ìš© ë¹„êµ**:

| ë°©ë²• | API í˜¸ì¶œ | ìƒëŒ€ ë¹„ìš© |
|-----|---------|----------|
| IO | 1íšŒ | 1Ã— |
| CoT | 1íšŒ | 1Ã— |
| CoT-SC (k=5) | 5íšŒ | 5Ã— |
| **ToT (b=5, k=5, d=3)** | **150íšŒ** | **150Ã—** |

**í˜„ì‹¤ì  ë¹„ìš©**:

Claude Sonnet 4 ê¸°ì¤€ ($3/MTok input, $15/MTok output):

```
Game of 24 ë¬¸ì œ 1ê°œ:
- í‰ê·  input: 200 tokens/call
- í‰ê·  output: 50 tokens/call
- ì´ 150íšŒ í˜¸ì¶œ

ë¹„ìš© = (200 Ã— 150 Ã— $3 + 50 Ã— 150 Ã— $15) / 1,000,000
     = (90,000 + 112,500) / 1,000,000
     = $0.20 per problem

CoT: $0.001 per problem

â†’ ToTëŠ” CoTë³´ë‹¤ 200ë°° ë¹„ìŒˆ
```

### ì‹œê°„ ì§€ì—°

ìˆœì°¨ì  API í˜¸ì¶œë¡œ ì¸í•œ ë ˆì´í„´ì‹œ:

```
ê° API í˜¸ì¶œ: í‰ê·  2ì´ˆ
ì´ 150íšŒ â†’ 300ì´ˆ = 5ë¶„

ë³‘ë ¬ ì²˜ë¦¬ë¡œ ê°œì„  ê°€ëŠ¥í•˜ì§€ë§Œ ì œí•œì :
- ìƒê° ìƒì„±: ë³‘ë ¬ ê°€ëŠ¥ (ë™ì‹œì— kê°œ)
- í‰ê°€: ë³‘ë ¬ ê°€ëŠ¥
- ë‹¨ê³„ ê°„: ìˆœì°¨ì  (í”¼í•  ìˆ˜ ì—†ìŒ)

ìµœì í™”ëœ ì‹œê°„: ì•½ 20-30ì´ˆ
CoT: 2ì´ˆ

â†’ ToTëŠ” 10-15ë°° ëŠë¦¼
```

### ì ìš© ë²”ìœ„ì˜ ì œí•œ

ToTê°€ íš¨ê³¼ì ì¸ ë¬¸ì œëŠ” ë§¤ìš° ì œí•œì ì´ë‹¤:

**ToTê°€ ì í•©í•œ ë¬¸ì œ**:
- âœ… ëª…í™•í•œ ì¤‘ê°„ ë‹¨ê³„ê°€ ìˆìŒ
- âœ… ê° ë‹¨ê³„ë¥¼ ë…ë¦½ì ìœ¼ë¡œ í‰ê°€ ê°€ëŠ¥
- âœ… ë°±íŠ¸ë˜í‚¹ì´ í•„ìš”í•¨
- âœ… ìµœì í•´ë¥¼ ì°¾ëŠ” ê²ƒì´ ì¤‘ìš”í•¨

**ToTê°€ ë¶€ì í•©í•œ ë¬¸ì œ**:
- âŒ ë‹¨ìˆœí•œ Q&A
- âŒ ìš”ì•½, ë²ˆì—­ ë“± ì§ì ‘ì ì¸ ë³€í™˜
- âŒ ê°œë°©í˜• ì°½ì‘ (í‰ê°€ ê¸°ì¤€ ëª¨í˜¸)
- âŒ ì‹¤ì‹œê°„ ì‘ë‹µì´ í•„ìš”í•œ ê²½ìš°

**ì‹¤ì œ ì ìš© ê°€ëŠ¥í•œ ë¶„ì•¼**:
1. **ì „ëµ ê²Œì„ / í¼ì¦**: ì²´ìŠ¤, ë°”ë‘‘, ìˆ˜í•™ í¼ì¦
2. **ë³µì¡í•œ ë¬¸ì œ í•´ê²°**: ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„, ì¦ëª…
3. **ì°½ì‘ ì‘ì—…**: êµ¬ì¡°í™”ëœ ê¸€ì“°ê¸° (ì œì•½ ì¡°ê±´ ìˆìŒ)
4. **ì½”ë“œ ìƒì„±**: ë³µì¡í•œ ë¡œì§ (ì—¬ëŸ¬ ì ‘ê·¼ ë°©ì‹ ë¹„êµ)

### GPT-4/oì˜ ì„±ëŠ¥ í–¥ìƒ

ë…¼ë¬¸ ë°œí‘œ ì´í›„ GPT-4, GPT-4o, Claude 3/4 ë“± ìµœì‹  ëª¨ë¸ë“¤ì´ ë“±ì¥í–ˆë‹¤:

**í˜„ì¬ ìƒí™©**:
```
Game of 24 (4, 9, 10, 13):

GPT-3.5 (2022):
  - IO: 7.3%
  - CoT: 4.0%
  - ToT: 74%
  â†’ ToTê°€ ì••ë„ì ìœ¼ë¡œ í•„ìš”

GPT-4 (2023):
  - IO: ì•½ 40%
  - CoT: ì•½ 60%
  - ToT: ì•½ 85%
  â†’ ì—¬ì „íˆ ToTê°€ ì¢‹ì§€ë§Œ ê²©ì°¨ ê°ì†Œ

Claude Sonnet 4 (2024):
  - IO: ì•½ 50-60%
  - CoT: ì•½ 70-80%
  - ToT: ì•½ 90%
  â†’ ëŒ€ë¶€ë¶„ì˜ ê²½ìš° CoTë¡œ ì¶©ë¶„
```

**ê²°ë¡ **: ìµœì‹  ëª¨ë¸ì€ ë‹¨ìˆœ CoTë§Œìœ¼ë¡œë„ ë§ì€ ë¬¸ì œë¥¼ ì˜ í’€ê¸° ë•Œë¬¸ì—, ToTê°€ ì‹¤ì œë¡œ í•„ìš”í•œ ê²½ìš°ëŠ” ë”ìš± ì¤„ì–´ë“¤ì—ˆë‹¤.

## Tree-of-Thought-Prompting (ë‹¨ìˆœí™” ë²„ì „)

ToTì˜ ì „ì²´ í”„ë ˆì„ì›Œí¬ëŠ” ë³µì¡í•˜ì§€ë§Œ, í•µì‹¬ ì•„ì´ë””ì–´ë¥¼ ë‹¨ìˆœí•œ í”„ë¡¬í”„íŠ¸ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤. Hulbert (2023)ê°€ ì œì•ˆí•œ ë°©ë²•ì´ë‹¤.

### ê¸°ë³¸ íŒ¨í„´

```python
SIMPLE_TOT_PROMPT = """
Imagine three different experts are answering this question.
All experts will write down 1 step of their thinking, then share it with the group.
Then all experts will go on to the next step, etc.
If any expert realizes they're wrong at any point then they leave.

The question is: {question}
"""
```

### ê³ ê¸‰ íŒ¨í„´ 1: í˜‘ì—… ì „ë¬¸ê°€

```python
COLLABORATIVE_TOT_PROMPT = """
Simulate three brilliant, logical experts collaboratively answering a question.

Each one verbosely explains their thought process in real-time, considering the 
prior explanations of others and openly acknowledging mistakes.

At each step, whenever possible, each expert refines and builds upon the thoughts 
of others, acknowledging their contributions.

They continue until there is a definitive answer to the question.

For clarity, your entire response should be in a markdown table.

The question is: {question}
"""
```

### ê³ ê¸‰ íŒ¨í„´ 2: ë™ë£Œ í‰ê°€

```python
PEER_REVIEW_TOT_PROMPT = """
Identify and behave as three different experts that are appropriate to answering 
this question.

All experts will write down the step and their thinking about the step, then 
share it with the group.

Then, all experts will go on to the next step, etc.

At each step all experts will score their peers' responses between 1 and 5, 
1 meaning it is highly unlikely, and 5 meaning it is highly likely.

If any expert is judged to be wrong at any point then they leave.

After all experts have provided their analysis, you then analyze all 3 analyses 
and provide either the consensus solution or your best guess solution.

The question is: {question}
"""
```

## ë‹¤ë¥¸ ê¸°ë²•ê³¼ì˜ ë¹„êµ

### ToT vs CoT

| íŠ¹ì„± | Chain-of-Thought | Tree of Thoughts |
|-----|------------------|------------------|
| **êµ¬ì¡°** | ì„ í˜• (linear) | íŠ¸ë¦¬ (tree) |
| **ë°±íŠ¸ë˜í‚¹** | âŒ ë¶ˆê°€ëŠ¥ | âœ… ê°€ëŠ¥ |
| **íƒìƒ‰** | í•œ ê²½ë¡œë§Œ | ì—¬ëŸ¬ ê²½ë¡œ |
| **ë¹„ìš©** | ë‚®ìŒ (1Ã— ) | ë§¤ìš° ë†’ìŒ (100Ã—+) |
| **ì†ë„** | ë¹ ë¦„ | ëŠë¦¼ |
| **ì ìš© ë²”ìœ„** | ë„“ìŒ | ì¢ìŒ |
| **êµ¬í˜„ ë³µì¡ë„** | ë‚®ìŒ | ë†’ìŒ |

**ì–¸ì œ CoTë¥¼ ì‚¬ìš©í•˜ë‚˜?**
- âœ… ëŒ€ë¶€ë¶„ì˜ ì¶”ë¡  ë¬¸ì œ
- âœ… ì‹¤ì‹œê°„ ì‘ë‹µ í•„ìš”
- âœ… ë¹„ìš© ì œì•½

**ì–¸ì œ ToTë¥¼ ì‚¬ìš©í•˜ë‚˜?**
- âœ… ì „ëµì  ê³„íšì´ í•„ìˆ˜
- âœ… ì •í™•ë„ê°€ ìµœìš°ì„ 
- âœ… ë¹„ìš©/ì‹œê°„ ì—¬ìœ 

### ToT vs Self-Consistency

**Self-Consistency**:
```
ê°™ì€ ì§ˆë¬¸ â†’ [CoT 1] â†’ ë‹µë³€ 1
            â†’ [CoT 2] â†’ ë‹µë³€ 2
            â†’ [CoT 3] â†’ ë‹µë³€ 3
            ...
            â†’ [CoT N] â†’ ë‹µë³€ N
            
ë‹¤ìˆ˜ê²° â†’ ìµœì¢… ë‹µë³€
```

**ToT**:
```
ì§ˆë¬¸ â†’ [ìƒê° 1a, 1b, 1c] â†’ í‰ê°€ â†’ ì„ íƒ
     â†’ [ìƒê° 2a, 2b, 2c] â†’ í‰ê°€ â†’ ì„ íƒ
     â†’ [ìƒê° 3a, 3b, 3c] â†’ í‰ê°€ â†’ ì„ íƒ
     â†’ ìµœì¢… ë‹µë³€
```

| íŠ¹ì„± | Self-Consistency | Tree of Thoughts |
|-----|------------------|------------------|
| **ë‹¤ì–‘ì„±** | ë†’ìŒ (ë…ë¦½ ìƒ˜í”Œ) | ì¤‘ê°„ (ì œì•½ëœ íƒìƒ‰) |
| **ì „ëµ** | ì—†ìŒ (ë¬´ì‘ìœ„) | ìˆìŒ (í‰ê°€ ê¸°ë°˜) |
| **íš¨ìœ¨ì„±** | ë‚®ìŒ | ë†’ìŒ |
| **ì ìš©** | ë‹µì´ ì´ì‚°ì ì¸ ê²½ìš° | ë³µì¡í•œ ê³„íš í•„ìš” |

**ì¡°í•© ê°€ëŠ¥?**: ë„¤! ToTì˜ ë§ˆì§€ë§‰ ë‹¨ê³„ì—ì„œ Self-Consistency ì ìš© ê°€ëŠ¥.

### ToT vs RAG

**ë¹„êµ ìì²´ê°€ ì˜ë¯¸ ì—†ìŒ**: ë‹¤ë¥¸ ëª©ì ì˜ ê¸°ë²•

- **RAG**: ì™¸ë¶€ ì§€ì‹ í™œìš©
- **ToT**: ë‚´ë¶€ ì¶”ë¡  ê°œì„ 

**ì¡°í•© ì „ëµ**:
```python
def rag_with_tot(query: str):
    # Step 1: RAGë¡œ ê´€ë ¨ ë¬¸ì„œ ê²€ìƒ‰
    docs = retrieve_documents(query)
    
    # Step 2: ToTë¡œ ë¬¸ì„œ ê¸°ë°˜ ì¶”ë¡ 
    answer = tot_reasoning(query, docs)
    
    return answer
```

## ì‹¤ë¬´ ì ìš© ì‹œë‚˜ë¦¬ì˜¤ (í˜„ì‹¤ì  í‰ê°€)

### ì½”ë“œ ë¦¬íŒ©í† ë§

**ë¬¸ì œ**: ë ˆê±°ì‹œ ì½”ë“œ ë¦¬íŒ©í† ë§ ì „ëµ ìˆ˜ë¦½

**í‰ê°€**:
- **ì¶”ì²œ ê°€ëŠ¥**: ì—¬ëŸ¬ ë¦¬íŒ©í† ë§ ì „ëµ ë¹„êµì— ìœ ìš©
- **íš¨ê³¼**: ë‹¨ìˆœ CoTë³´ë‹¤ 20-30% ë‚˜ì€ ì œì•ˆ
- **í™œìš©ë²•**: 
  ```
  Step 1: ì—¬ëŸ¬ ë¦¬íŒ©í† ë§ ê³„íš ìƒì„±
  Step 2: ê° ê³„íšì˜ ì¥ë‹¨ì  í‰ê°€
  Step 3: ìµœì  ê³„íš ì„ íƒ ë° ìƒì„¸í™”
  ```

### ì°½ì‘ ì§€ì› ë„êµ¬

**ë¬¸ì œ**: ì†Œì„¤/ì‹œë‚˜ë¦¬ì˜¤ êµ¬ì¡° ì„¤ê³„

**í‰ê°€**:
- **ì¶”ì²œ**: ì—¬ëŸ¬ í”Œë¡¯ êµ¬ì¡° ë¹„êµì— íš¨ê³¼ì 
- **ê°•ì **: ì°½ì˜ì  ëŒ€ì•ˆ ì œì‹œ
- **ì£¼ì˜**: í‰ê°€ ê¸°ì¤€ì´ ì£¼ê´€ì ì´ë¼ ì¡°ì • í•„ìš”

## ì •ë¦¬ ë° ê²°ë¡ 

### í•µì‹¬ ìš”ì•½

**Tree of Thoughtsì˜ í•µì‹¬**:
- ì—¬ëŸ¬ ì¶”ë¡  ê²½ë¡œë¥¼ íŠ¸ë¦¬ë¡œ íƒìƒ‰
- ë°±íŠ¸ë˜í‚¹ìœ¼ë¡œ ì‹¤ìˆ˜ ë³µêµ¬
- í‰ê°€ ê¸°ë°˜ ì „ëµì  íƒìƒ‰
- CoTë¥¼ ë›°ì–´ë„˜ëŠ” ë³µì¡í•œ ë¬¸ì œ í•´ê²°

**í˜„ì‹¤ì  í‰ê°€**:
- **í•™ìˆ ì  ê°€ì¹˜**: ë§¤ìš° ë†’ìŒ (ì¶”ë¡  ë©”ì»¤ë‹ˆì¦˜ ì´í•´)
- **ì‹¤ë¬´ ì ìš©**: ë§¤ìš° ì œí•œì 
- **ë¹„ìš©**: 100ë°°+ ë¹„ìŒˆ
- **ìµœì‹  ëª¨ë¸**: ë‹¨ìˆœ CoTë¡œ ì¶©ë¶„í•œ ê²½ìš° ë§ìŒ

### ì–¸ì œ ToTë¥¼ ì‚¬ìš©í•  ê²ƒì¸ê°€?

**ì‚¬ìš©í•˜ë¼**:
- ì „ëµ ê²Œì„, ë³µì¡í•œ í¼ì¦
- ìµœì í•´ê°€ ì ˆëŒ€ì ìœ¼ë¡œ í•„ìš”í•œ ê²½ìš°
- ë¹„ìš©/ì‹œê°„ì´ ë¬¸ì œë˜ì§€ ì•ŠëŠ” ì—°êµ¬/ë°ëª¨
- ì—¬ëŸ¬ ì ‘ê·¼ë²•ì„ ì²´ê³„ì ìœ¼ë¡œ ë¹„êµí•´ì•¼ í•  ë•Œ

**ì‚¬ìš©í•˜ì§€ ë§ˆë¼**:
- ì¼ë°˜ì ì¸ Q&A
- ì‹¤ì‹œê°„ ì„œë¹„ìŠ¤
- ë¹„ìš©ì— ë¯¼ê°í•œ í”„ë¡œë•ì…˜
- ìµœì‹  ê°•ë ¥í•œ ëª¨ë¸ + CoTë¡œ ì¶©ë¶„í•œ ê²½ìš°

### ë¯¸ë˜ ì „ë§

**ê°œì„  ë°©í–¥**:
1. **íš¨ìœ¨ì„±**: ë¶ˆí•„ìš”í•œ íƒìƒ‰ ì¤„ì´ê¸°
2. **ìë™í™”**: í‰ê°€ í•¨ìˆ˜ ìë™ í•™ìŠµ
3. **í•˜ì´ë¸Œë¦¬ë“œ**: ë‹¤ë¥¸ ê¸°ë²•ê³¼ ê²°í•©
4. **ê²½ëŸ‰í™”**: Simple ToT ìŠ¤íƒ€ì¼ì˜ ì‹¤ìš©ì  ë³€í˜•

**ì¥ê¸° ì „ë§**:
- ëª¨ë¸ ì„±ëŠ¥ í–¥ìƒìœ¼ë¡œ í•„ìš”ì„± ê°ì†Œ
- íŠ¹ìˆ˜í•œ ë„ë©”ì¸ì—ì„œë§Œ ìƒì¡´
- ì•„ì´ë””ì–´ëŠ” ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œì— í†µí•©ë  ê°€ëŠ¥ì„±

## ì°¸ê³ ë¬¸í—Œ

1. Yao, S., Yu, D., Zhao, J., Shafran, I., Griffiths, T., Cao, Y., & Narasimhan, K. (2024). **Tree of thoughts: Deliberate problem solving with large language models.** *Advances in Neural Information Processing Systems, 36*.

2. Wei, J., et al. (2022). **Chain-of-thought prompting elicits reasoning in large language models.** *Advances in Neural Information Processing Systems, 35*, 24824-24837.

3. Hulbert, D. (2023). **Tree-of-thought prompting.** *GitHub Repository*. https://github.com/dave1010/tree-of-thought-prompting

4. Wang, X., et al. (2022). **Self-consistency improves chain of thought reasoning in language models.** *arXiv preprint arXiv:2203.11171*.
