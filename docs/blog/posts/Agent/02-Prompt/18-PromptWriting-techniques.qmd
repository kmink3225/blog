---
title: "Prompt Analytics - 연역적/귀납적 방법론을 활용한 프롬프트 기획"
subtitle: 체계적 문제 정의와 아이디에이션을 통한 실무 프롬프트 설계 전략
description: |
  연역적·귀납적 방법론을 활용하여 프롬프트 기획 문제를 체계적으로 정의하고 해결하는 방법을 소개한다.
  사용자 데이터 분석, 이론적 모델 수립, 행동경제학(넛지 이론), 마음이론(Theory of Mind) 등
  다학제적 접근법을 통해 실무에 적용 가능한 프롬프트 전략을 도출한다.
  프롬프트 질문 생성기, 자동 완성기, 시스템 프롬프트 개선 등 3가지 실제 사례를 통해
  문제 정의부터 구현 아이디어, 구체적 해결 방안까지 단계별 기획 프로세스를 제시한다.
categories:
  - Strategy Frameworks
  - Prompt Engineering
  - AI
  - Agent
author: Kwangmin Kim
date: 01/25/2025
format: 
  html:
    page-layout: full
    code-fold: true
    toc: true
    number-sections: true
draft: False
---

# 프롬프트 엔지니어링 기초 - 개요와 분류 체계

## 들어가며

최근 ChatGPT, Claude, Gemini와 같은 대형 언어 모델(Large Language Models, LLMs)이 우리 일상에 깊숙이 들어왔습니다. 이러한 모델들은 질문에 답하고, 코드를 작성하고, 창작물을 만들어내는 등 놀라운 능력을 보여줍니다. 하지만 같은 모델을 사용하더라도 **어떻게 질문하느냐**에 따라 결과가 천차만별입니다.

"프롬프트 엔지니어링(Prompt Engineering)"은 바로 이 **"어떻게 질문할 것인가"**에 대한 학문입니다. 단순히 질문을 잘하는 것을 넘어, 체계적이고 과학적인 방법론으로 발전하고 있습니다.

이 시리즈에서는 프롬프트 엔지니어링의 기초 기법들을 다룹니다. 특히 **검증된 연구 논문**을 바탕으로 각 기법의 원리와 효과, 그리고 한계를 이해하고, 실습을 통해 직접 적용해볼 것입니다.

## 강의 소개

### 강사

**강수진** - 국내 공채 1호 프롬프트 엔지니어

### 학습 목표

이 시리즈를 통해 다음을 달성할 수 있습니다:

**01** 프롬프트 엔지니어링 기초 기법을 이해한다.

**02** 연구 논문을 통해 각 프롬프트 엔지니어링 기법의 핵심과 한계를 이해한다.

**03** 실습을 통해 각 프롬프트 엔지니어링 방법을 학습한다.

### 왜 기초가 중요한가?

프롬프트 엔지니어링은 이제 단순한 "팁과 트릭"의 모음이 아닙니다. 학계와 산업계에서 축적된 연구 결과를 바탕으로 한 **체계적인 방법론**입니다. 기초를 제대로 이해하면:

- 상황에 맞는 적절한 기법을 선택할 수 있습니다
- 각 기법의 한계를 인지하고 대안을 찾을 수 있습니다
- 새로운 문제에도 원리를 응용할 수 있습니다
- 비용과 성능의 균형을 맞출 수 있습니다

## 프롬프트 엔지니어링 기법의 분류 체계

프롬프트 엔지니어링 기법들은 크게 세 가지 수준으로 분류할 수 있습니다.

### Taxonomy of Prompt Engineering Techniques

```
┌─────────────────────────────────────────────────────────────┐
│           Prompt Engineering Techniques                      │
├─────────────────┬─────────────────┬────────────────────────┤
│     Basic       │    Advanced     │    Applications        │
├─────────────────┼─────────────────┼────────────────────────┤
│ • Zero-Shot     │ • Generate      │ • 데이터 생성과 분류   │
│   Prompting     │   Knowledge     │                        │
│                 │   Prompting     │ • 코드 생성하기        │
│ • Few-Shot      │                 │                        │
│   Prompting     │ • Prompt        │ • 펑션콜 함수          │
│                 │   Chaining      │                        │
│ • Chain-of-     │                 │                        │
│   Thought       │ • Tree of       │                        │
│   Prompting     │   Thoughts      │                        │
│                 │                 │                        │
│ • Self-         │ • RAG           │                        │
│   consistency   │                 │                        │
│                 │ • Automatic     │                        │
│                 │   Prompt        │                        │
│                 │   Engineer      │                        │
│                 │                 │                        │
│                 │ • Active-Prompt │                        │
│                 │                 │                        │
│                 │ • Directional   │                        │
│                 │   Stimulus      │                        │
│                 │   Prompting     │                        │
│                 │                 │                        │
│                 │ • ReAct         │                        │
└─────────────────┴─────────────────┴────────────────────────┘
```

이 시리즈에서는 **Basic(기초)** 수준의 네 가지 핵심 기법을 다룹니다.

## Basic: 기초 프롬프트 엔지니어링 기법

기초 기법들은 프롬프트 엔지니어링의 근간이 되는 방법론들입니다. 이들은 서로 독립적이면서도 상호 보완적인 관계를 가지고 있습니다.

### 1. Zero-Shot Prompting (제로샷 프롬프팅)

**핵심 개념:** 예시 없이 작업을 수행하는 방법

```
프롬프트: 다음 텍스트를 긍정, 부정, 중립으로 분류해주세요.

텍스트: 이 영화는 정말 재미있었어요!
```

**특징:**
- 가장 기본적이고 간단한 방법
- 예시를 제공하지 않음
- 모델의 사전 학습된 지식에 의존
- Instruction Tuning과 RLHF로 성능 향상

**언제 사용하나요?**
- 간단하고 명확한 작업
- 예시를 만들기 어려운 경우
- 빠른 프로토타이핑이 필요할 때

### 2. Few-Shot Prompting (퓨샷 프롬프팅)

**핵심 개념:** 소수의 예시를 제공하여 작업을 수행하는 방법

```
프롬프트: 다음은 감정 분류 예시입니다.

텍스트: 너무 행복해요!
분류: 긍정

텍스트: 실망스럽네요.
분류: 부정

텍스트: 괜찮아요.
분류: 중립

텍스트: 최고였어요!
분류:
```

**특징:**
- 2-10개 정도의 예시 제공
- 예시의 품질과 형식이 중요
- Zero-shot보다 복잡한 작업 가능
- 모델 크기가 충분히 클 때 효과적

**언제 사용하나요?**
- Zero-shot으로 충분하지 않을 때
- 특정 형식이나 스타일이 필요할 때
- 도메인 특화 작업

### 3. Chain-of-Thought Prompting (사고 연쇄 프롬프팅)

**핵심 개념:** 중간 추론 과정을 명시적으로 보여주는 방법

```
프롬프트: 
Q: Roger는 테니스공 5개를 가지고 있습니다. 
   테니스공 3개가 들어있는 캔을 2개 더 샀습니다. 
   이제 몇 개의 테니스공을 가지고 있나요?

A: Roger는 처음에 5개의 공을 가지고 있었습니다.
   캔 2개를 샀는데, 각 캔에 3개씩 들어있으므로
   2 × 3 = 6개의 공을 더 얻었습니다.
   따라서 5 + 6 = 11개입니다.
   
Q: 카페에 사과가 23개 있었습니다.
   20개를 사용하고 6개를 더 샀습니다.
   이제 사과는 몇 개인가요?
```

**특징:**
- 단계별 추론 과정 명시
- 복잡한 추론 문제에 효과적
- 산술, 논리, 상식 추론에 적용
- 대형 모델(~100B+)에서 특히 효과적

**언제 사용하나요?**
- 다단계 추론이 필요한 문제
- 수학 문제, 논리 문제
- 모델의 추론 과정을 확인하고 싶을 때

### 4. Self-Consistency (자기 일관성)

**핵심 개념:** 여러 추론 경로를 생성하고 가장 일관된 답을 선택하는 방법

```
같은 문제를 여러 번 풀어서:

경로 1 → 답: A
경로 2 → 답: A  
경로 3 → 답: B
경로 4 → 답: A
경로 5 → 답: A

최종 답: A (다수결)
```

**특징:**
- Chain-of-Thought의 확장
- 다수결(majority voting) 방식
- 더 높은 정확도
- 더 많은 계산 비용

**언제 사용하나요?**
- 높은 정확도가 중요할 때
- 복잡한 추론 문제
- 계산 비용을 감수할 수 있을 때

## 기법들 간의 관계와 발전 과정

프롬프트 엔지니어링 기법들은 순차적으로 발전해왔습니다:

```
Zero-Shot 
   ↓
   예시 추가
   ↓
Few-Shot
   ↓
   추론 과정 명시
   ↓
Chain-of-Thought (CoT)
   ↓
   예시 제거 (트리거만)
   ↓
Zero-Shot CoT
   ↓
   다중 경로 샘플링
   ↓
Self-Consistency
```

### 핵심 연구 논문들

각 기법은 주요 연구 논문을 통해 소개되고 검증되었습니다:

**Zero-Shot & Few-Shot:**
- Brown et al. (2020), "Language Models are Few-Shot Learners" (OpenAI GPT-3)

**Instruction Tuning:**
- Wei et al. (2021), "Finetuned Language Models are Zero-Shot Learners" (Google, FLAN)

**RLHF:**
- Christiano et al. (2017), "Deep Reinforcement Learning from Human Preferences"

**Chain-of-Thought:**
- Wei et al. (2022), "Chain-of-Thought Prompting Elicits Reasoning in Large Language Models" (Google Research)

**Zero-Shot CoT:**
- Kojima et al. (2022), "Large Language Models are Zero-Shot Reasoners"

**Self-Consistency:**
- Wang et al. (2022), "Self-Consistency Improves Chain of Thought Reasoning in Language Models"

## 어떤 기법을 선택해야 할까?

상황에 따라 적절한 기법을 선택하는 것이 중요합니다.

### 의사결정 트리

```
문제가 간단하고 명확한가?
├─ Yes → Zero-Shot Prompting
└─ No → 예시를 만들 수 있는가?
         ├─ Yes → Few-Shot Prompting
         └─ No → 복잡한 추론이 필요한가?
                  ├─ Yes → Chain-of-Thought
                  │         ├─ 예시 작성 가능 → Few-Shot CoT
                  │         └─ 예시 작성 어려움 → Zero-Shot CoT
                  │                               ├─ 정확도가 매우 중요 → Self-Consistency
                  │                               └─ 비용이 중요 → Zero-Shot CoT만 사용
                  └─ No → Few-Shot Prompting
```

### 비교표

| 기법 | 난이도 | 비용 | 정확도 | 유연성 | 적용 범위 |
|------|--------|------|--------|--------|-----------|
| Zero-Shot | ★☆☆☆☆ | ★☆☆☆☆ | ★★☆☆☆ | ★★★★★ | 광범위 |
| Few-Shot | ★★☆☆☆ | ★★★☆☆ | ★★★☆☆ | ★★★☆☆ | 광범위 |
| Chain-of-Thought | ★★★☆☆ | ★★★★☆ | ★★★★☆ | ★★★☆☆ | 추론 중심 |
| Zero-Shot CoT | ★☆☆☆☆ | ★★★☆☆ | ★★★☆☆ | ★★★★☆ | 추론 중심 |
| Self-Consistency | ★★★★☆ | ★★★★★ | ★★★★★ | ★★☆☆☆ | 추론 중심 |

## 실습 환경 준비

이 시리즈의 실습을 따라하기 위해 다음 중 하나를 준비하세요:

### 옵션 1: OpenAI Playground
- URL: https://platform.openai.com/playground
- 모델: gpt-3.5-turbo 또는 gpt-4
- 장점: 웹 브라우저에서 바로 사용 가능
- 단점: API 크레딧 필요

### 옵션 2: Claude.ai
- URL: https://claude.ai
- 모델: Claude Sonnet 3.5 또는 4
- 장점: 무료 tier 제공
- 단점: 일일 사용량 제한

### 옵션 3: Python + API
```python
# OpenAI API 예시
import openai

openai.api_key = "your-api-key"

response = openai.ChatCompletion.create(
    model="gpt-3.5-turbo",
    messages=[
        {"role": "user", "content": "Your prompt here"}
    ],
    temperature=0.1
)

print(response.choices[0].message.content)
```

### 권장 설정

실습할 때는 다음 설정을 권장합니다:

```
Temperature: 0.1 ~ 0.3  (추론 문제)
Temperature: 0.7 ~ 0.9  (창작 문제)
Max Tokens: 400 ~ 1000
Model: GPT-3.5-turbo 이상 또는 Claude Sonnet 이상
```

## 이 시리즈의 구성

총 6개의 글로 구성됩니다:

**Part 1 (현재):** 프롬프트 엔지니어링 개요와 분류 체계

**Part 2:** Zero-Shot Prompting
- 개념 및 정의
- Instruction Tuning
- RLHF (Reinforcement Learning from Human Feedback)
- 실습

**Part 3:** Few-Shot Prompting
- 개념 및 연구 배경
- 모델 스케일링과 성능
- 예시 포맷의 중요성
- 실습 및 한계

**Part 4:** Chain-of-Thought Prompting
- CoT의 원리와 작동 방식
- 연구 결과 분석
- 다양한 추론 과제 적용
- 실습

**Part 5:** Zero-Shot Chain-of-Thought
- "Let's think step by step"의 마법
- Few-Shot CoT와의 비교
- Trigger 문구 실험
- 실습

**Part 6:** Self-Consistency
- 다수결 투표 메커니즘
- 성능 향상 원리
- 비용-성능 트레이드오프
- 종합 실습

## 학습 팁

### 1. 직접 해보세요
각 글의 실습 예제를 반드시 직접 실행해보세요. 이론만으로는 프롬프트 엔지니어링의 미묘한 차이를 이해하기 어렵습니다.

### 2. 변형해보세요
제공된 예제를 자신의 문제에 맞게 변형해보세요. 이 과정에서 각 기법의 강점과 한계를 체감할 수 있습니다.

### 3. 비교해보세요
같은 문제를 여러 기법으로 풀어보고 결과를 비교하세요. 어떤 기법이 언제 더 효과적인지 알 수 있습니다.

### 4. 논문을 읽어보세요
시간이 된다면 각 글에서 인용하는 원본 논문을 읽어보세요. 더 깊은 이해와 추가 인사이트를 얻을 수 있습니다.

### 5. 기록하세요
실습 결과와 발견한 패턴을 기록하세요. 나중에 실무에서 유용한 레퍼런스가 됩니다.

## 마무리

프롬프트 엔지니어링은 빠르게 발전하는 분야입니다. 하지만 이 기초 기법들은 앞으로도 계속 중요한 기반이 될 것입니다. 마치 프로그래밍의 변수, 함수, 반복문처럼 말이죠.

이 시리즈를 통해:
- 체계적인 프롬프트 설계 능력을 갖추고
- 연구 기반의 검증된 방법론을 이해하며
- 실무에 바로 적용할 수 있는 실전 경험을 쌓을 수 있기를

바랍니다.

다음 글에서는 가장 기본이 되는 **Zero-Shot Prompting**부터 시작하겠습니다. Instruction Tuning과 RLHF가 어떻게 현대 언어 모델의 제로샷 능력을 획기적으로 향상시켰는지 알아보겠습니다.
