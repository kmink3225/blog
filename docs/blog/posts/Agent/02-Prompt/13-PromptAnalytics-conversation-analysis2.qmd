---
title: "Prompt Analytics - 대화 분석 네 가지 기준"
subtitle: Turn, Action, Structure, Stance를 통한 AI 상호작용 분석
description: |
  대화 분석(Conversation Analysis)의 네 가지 핵심 기준으로 AI 상호작용을 체계적으로 분석한다.
  Turn(턴 테이킹)을 통한 대화 범위 구분, Action(행위)을 통한 사용자 의도 파악,
  Structure(구조)를 통한 응답 패턴 분석, Stance(입장)를 통한 감정적/인식적 태도 파악 방법을 제시한다.
  싱글턴과 멀티턴 대화 전략, 선호/비선호 구조, 감정적/비감정적 태도 분석 등
  실무에 바로 적용 가능한 30개 이상의 실제 대화 시나리오와 함께
  효과적인 프롬프트 설계 원칙과 AI 응답 최적화 전략을 구체적으로 제시한다.
categories:
  - Prompt Engineering 
  - Conversation Analysis
  - AI
  - RAG
  - Agent
  - NLP
author: Kwangmin Kim
date: 01/22/2025
format: 
  html:
    page-layout: full
    code-fold: true
    toc: true
    number-sections: true
draft: False
---

# 대화 분석 네 가지 기준  

사회학 분야에서 발전한 Conversation Analysis에서는 대화를 네 가지 차원에서 분석한다.  

* Trun: 턴 테이킹(Turn-taking)
  * CA의 창시자인 Harvey Sacks, Emanuel Schegloff, Gail Jefferson 등이 정립한 가장 기본적인 개념
  * 대화 참여자가 발언권을 주고받는 방식을 분석
* Structure: 인접 쌍(Adjacency Pair) 및 선호/비선호 구조
  * **선호 구조(Preferred Structure)**와 **비선호 구조(Dispreferred Structure)**는 CA에서 '질문-답변', '요청-승낙/거절'과 같은 **인접 쌍(Adjacency Pair)**의 응답 패턴을 분석하는 데 사용되는 표준 용어
* Action (행위)
  * 언어 철학자인 J.L. Austin과 John Searle이 발전시킨 **화행론(Speech Act Theory)**에 기반을 두고 있다.
  * 화행론은 "언어는 단순히 정보를 전달하는 것이 아니라, 특정 행위(요청, 약속, 질문 등)를 수행하는 것"이라고 주장
  * NLP 및 대화형 AI 분야에서는 이 화행을 **대화 행위 유형(Dialogue Act Type)**으로 분류하여, 사용자의 의도(Intent)를 파악하는 기초로 활용
* Stance (화자 태도)
  * Stance (입장) 분석은 **담화 분석(Discourse Analysis)**의 한 분야로, 화자가 주제나 청자에 대해 취하는 평가적, 감정적, 또는 인식적(Epistemic) 태도를 분석
  * 제시된 **감정적 태도(Affective Stance)**와 **비감정적 태도(Epistemic Stance)**는 태도 분석에서 사용하는 표준적인 구분법
  * 이는 AI가 **사용자의 감정을 파악(Sentiment Analysis)**하고 답변의 확실성 수준을 조정(예: "아마도" 또는 "확실하게")하는 데 필수적인 요소로 간주

## Turn (턴): 대화 범위  

* 대화가 **단일 교환**인지 **연속적 교환**인지 구분한다.  
* 맥락 관리(Context Management) 전략 수립
  * 싱글턴은 스테이트리스(과거의 상태나 정보를 전혀 기억하지 않는' 통신 방식이나 서버의 작동 방식)
  * 멀티턴은 메모리 관리 필요

### 싱글턴 (Singleton)  

* 한 번의 질문-답변으로 완결되는 대화  
  - 독립적 발화  
  - 맥락 의존도 낮음  
  - 명확한 종료점  
* 싱글턴으로 프롬프트 설계한다면?:  
  - 모든 정보를 첫 질문에 포함  
  - 명확하고 구체적인 요청  
  - 후속 맥락 기대 안 함  
* **싱글턴의 특징:**  
  - **완결성**: 한 번의 질문으로 답 완성  
  - **독립성**: 이전 대화 맥락 불필요  
  - **명확성**: 질문 의도가 분명  
  - **효율성**: 빠른 답변, 즉시 종료  
* **싱글턴에 적합한 요청:**  
  - 사실 확인 ("수도는?", "가격은?")  
  - 간단한 정의 ("~가 뭐야?")  
  - 계산 ("몇 %야?", "며칠 차이야?")  
  - 번역 ("이거 영어로 뭐야?")    

**구체적 예시: 독립적인 단일 요청들**

**Example 1: 사실 확인**
```
사용자: "2024년 노벨 물리학상 수상자는 누구야?"

AI: "2024년 노벨 물리학상은 Geoffrey Hinton과 John Hopfield가 수상했습니다.
두 분은 인공신경망의 기초 연구로 수상했으며,
특히 기계학습의 기반이 되는 Hopfield 네트워크와 
Boltzmann 머신 개발에 기여했습니다."

[대화 종료 - 후속 질문 없음]
```

**Example 2: 정의 요청**
```
사용자: "REST API가 뭐야?"

AI: "REST API는 Representational State Transfer API의 약자로,
웹에서 시스템 간 데이터를 주고받기 위한 아키텍처 스타일입니다.

핵심 특징:
- HTTP 메서드 사용 (GET, POST, PUT, DELETE)
- 무상태성 (Stateless): 각 요청은 독립적
- 자원 중심 설계: URL로 자원 표현

예시:
GET /users/123 → 사용자 정보 조회
POST /users → 새 사용자 생성
DELETE /users/123 → 사용자 삭제"

[대화 종료]
```


### 멀티턴 (Multi-turn)  

* 여러 차례 이어지는 대화  
  - 맥락 의존적  
  - 점진적 구체화  
  - 복잡한 문제 해결에 적합  
* 프롬프트 설계 시사점:    
  - 초기 질문은 넓게, 점진적으로 좁혀가기  
  - 이전 답변 참조 활용  
  - 대화 흐름 유지  
* 구체적 예시: 점진적으로 발전하는 복잡한 대화

**멀티턴의 특징:**  
  - **맥락 누적**: 각 턴마다 이전 정보 활용  
  - **점진적 구체화**: 넓은 → 좁은 질문  
  - **유기적 발전**: 대화 흐름에 따라 자연스럽게 확장  
  - **복잡한 문제 해결**: 단계별 접근  
  
**멀티턴에 적합한 요청:**  
  - 복잡한 구현 (여러 단계 필요)  
  - 학습 목적 (개념 → 적용 → 심화)  
  - 문제 해결 (현상 → 원인 → 해결)  
  - 기획/설계 (요구사항 → 구조 → 세부사항)    

```
[Turn 1: 넓은 질문으로 시작]
사용자: "파이썬으로 웹 크롤링 하는 방법 알려줘"

AI: "파이썬 웹 크롤링은 주로 requests와 BeautifulSoup을 사용합니다.

기본 예제:

import requests
from bs4 import BeautifulSoup
(code 중략)

정적 페이지에 적합한 방법입니다. 동적 페이지가 필요하신가요?"

[Turn 2: 요구사항 추가 - 맥락 활용]
사용자: "거기에 동적 페이지 크롤링도 추가해줘"

AI: "동적 페이지는 Selenium을 사용해야 합니다.
위 코드를 확장하겠습니다:

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from bs4 import BeautifulSoup

(code 중략)

이제 JavaScript로 로드되는 콘텐츠도 크롤링할 수 있습니다!"

[Turn 3: 새로운 요구사항 - 누적 맥락]
사용자: "이걸 AWS Lambda에서 실행하려면?"

AI: "AWS Lambda에서 실행하려면 몇 가지 수정이 필요합니다:

**1. Selenium을 serverless 환경에 맞게 변경**

import json
import boto3
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from bs4 import BeautifulSoup

**2. 필요한 Lambda Layer 추가**
- Selenium Python 패키지
- Headless Chromium 바이너리
- ChromeDriver

**3. Lambda 설정**
- 메모리: 최소 1024MB
- 타임아웃: 30초 이상
- /tmp 디렉토리 사용

(code 중략)

이렇게 하면 서버리스 환경에서 웹 크롤링이 가능합니다!"

[Turn 4: 세부 구현 질문]
사용자: "Lambda Layer는 어떻게 만들어?"

AI: "Lambda Layer 생성 방법을 단계별로 설명드리겠습니다:

**방법 1: 기존 공개 Layer 사용 (권장)**

# ARN 형태로 Lambda에 추가
arn:aws:lambda:us-east-1:764866452798:layer:chrome-aws-lambda:31


**방법 2: 직접 생성**

1. 로컬에서 패키지 준비: (code 생략)

2. AWS CLI로 업로드: (code 생략)

3. Lambda 함수에 연결: (code 생략)

이제 Layer가 준비되었습니다!"
```

## Action (행위): 대화 목적  

* 사용자가 AI에게 요청하는 **행위의 유형**을 구분한다.  
* 사용자 의도 파악(Intent Recognition) 및 적절한 AI 기능(Tool, Retrieval 등) 연결

### 정보 검색 유형 (Information Seeking)  

* 사실, 정의, 설명 등 **정보를 얻는 것**이 목적  
* 하위 유형:  
  - **사실 확인**: "비트코인의 현재 가격은?"  
  - **정의 요청**: "양자 컴퓨팅이 뭐야?"  
  - **설명 요청**: "딥러닝의 작동 원리를 설명해줘"  
  - **비교 요청**: "React와 Vue의 차이점은?"  
* 특징
  - 객관적 답변 기대  
  - 정확성 중시  
  - 검증 가능성  

### 다른 행위 유형 (Other Action Types)  

**1. 생성 요청 (Generation)**

사용자가 새로운 콘텐츠나 코드를 만들어달라고 요청하는 경우

```
[Example 1: 코드 생성]
사용자: "파이썬으로 피보나치 수열 첫 20개 생성하는 코드 작성해줘"

AI: "재귀와 반복문 두 가지 방법을 보여드리겠습니다:

**방법 1: 반복문 (효율적)**

def fibonacci_iterative(n):
    fib_sequence = []
    a, b = 0, 1
    for _ in range(n):
        fib_sequence.append(a)
        a, b = b, a + b
    return fib_sequence

# 첫 20개 생성
result = fibonacci_iterative(20)
print(result)
# [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...]


**방법 2: 재귀 (교육용)**

def fibonacci_recursive(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fibonacci_recursive(n-1, memo) + fibonacci_recursive(n-2, memo)
    return memo[n]

# 첫 20개 생성
result = [fibonacci_recursive(i) for i in range(20)]
print(result)

반복문 방식이 시간복잡도 O(n)으로 더 효율적입니다!"
```

**2. 변환 요청 (Transformation)**

* 기존 데이터를 다른 형식으로 바꿔달라는 요청

```
[Example 2: 데이터 형식 변환]
사용자: "이 JSON 데이터를 CSV로 변환해줘

[
  {"name": "Alice", "age": 30, "city": "Seoul"},
  {"name": "Bob", "age": 25, "city": "Busan"},
  {"name": "Charlie", "age": 35, "city": "Incheon"}
]

AI: "Python pandas를 사용한 변환 방법입니다:

import pandas as pd
import json

(중략)

**결과 (output.csv):**

name,age,city
Alice,30,Seoul
Bob,25,Busan
Charlie,35,Incheon

```

**행위 유형별 특징 요약:**

| 유형 | 목적 | AI 요구역량 | 검증 기준 |
|------|------|-------------|-----------|
| 정보검색 | 지식 전달 | 정확성, 최신성 | 사실 확인 가능 |
| 생성 | 콘텐츠 창조 | 구문 이해, 코드 생성 | 실행 가능성 |
| 변환 | 형식 변경 | 데이터 처리 | 결과 정합성 |
| 분석 | 인사이트 도출 | 패턴 인식, 추론 | 논리적 타당성 |
| 조언 | 의사결정 지원 | 경험 종합, 맥락 이해 | 실용성 |
| 창작 | 예술 표현 | 창의성, 일관성 | 감동, 몰입 |  

## Structure (구조)

- 응답 패턴  
  * AI가 사용자 요청에 응답하는 **구조적 패턴**을 분석한다.    
  * 안전성(Safety) 및 윤리 가이드라인 설계 (비선호 구조를 통한 거절 패턴 구현)  
  * [예시는 이전 블로그 참조](./12-PromptAnalytics-conversation-analysis1.qmd)    

### 선호 구조 (Preferred Structure)  

* 사회적으로 **기대되고 자연스러운** 응답 패턴  
  - 직접적 응답  
  - 지연 없음  
  - 명확한 수용  
* 구조 분석:
  1. 질문 (정보 요청)  
  2. 즉각적 답변 (직접 응답)  
  3. 예시 제공 (보완)  

* **선호 구조의 특징:**  
  - **즉시성**: 질문 직후 바로 핵심 답변  
  - **완결성**: 추가 질문 없이도 이해 가능  
  - **구조화**: 논리적 순서 (정의 → 예시 → 비교)  
  - **친절함**: 초보자도 이해할 수 있는 설명    

### 비선호 구조 (Dispreferred Structure)  

* **회피, 거부, 지연**을 포함하는 응답 패턴  
  - 간접적 표현  
  - 설명 또는 변명 선행  
  - 대안 제시  
* **구조 분석:**  
  1. 요청 (부적절한 정보 요청)  
  2. 거부 표현 ("죄송하지만")  
  3. 이유 설명  
  4. 대안 제시  
* AI에서 비선호 구조가 나타나는 경우:  
  - 윤리적 문제 (편향, 유해 콘텐츠)  
  - 법적 제약 (저작권, 개인정보)  
  - 능력 한계 (실시간 정보, 미래 예측)  
  - 애매한 요청 (명확화 필요)  
* **비선호 구조의 특징:**  
  - **완충 장치**: 직접 거절 전 설명 제공  
  - **정당화**: 거절의 명확한 이유  
  - **건설적 대안**: "No"가 아닌 "Yes, but..."  
  - **교육적**: 왜 안 되는지, 어떻게 해야 하는지 안내    

## Stance (입장)

- 화자 태도: 통합 분석 프레임워크
- Stance는 화자가 주제, 청자, 또는 상호작용 자체에 대해 취하는 평가적·감정적·인식적 태도를 나타내며, 근본적으로는 상호작용 상대방과의 관계 설정 의도를 반영
- 핵심 축: 관계 설정 (Affiliation)
  - Stance를 이해하는 최우선 기준은 **Affiliation의 유무**. 이는 사용자가 AI를 어떤 존재로 인식하는지를 결정:

| Affiliation 있음 | Affiliation 없음 |
|-----------------|-----------------|
| AI를 상호작용 대상으로 인식 | AI를 도구로만 인식 |
| 관계 형성·유지 의도 | 순수 정보 교환 의도 |
| 감정 표현, 친근한 톤, 개인적 경험 공유 | 객관적이고 사실적인 요청 |

### 세부 분석 차원

#### 감정적 태도 (Affective Stance)

- 주제나 상대방에 대해 표현되는 감정, 평가, 주관적 입장
- **표현 방식**:  
  - 평가 언어 ("훌륭한", "최악의", "놀랍게도")  
  - 감정 표현 ("유감스럽게도", "고맙게도")  
  - 강조 표현 ("정말", "매우", "극도로")  
- **AI 응답 설계**:  
  - 사용자의 감정 상태 인식  
  - 공감적 표현으로 응답  
  - 긍정적 재구성 시도  

#### 비감정적 태도 (Epistemic Stance)

- 주장의 확실성, 믿음의 강도, 인식적 태도  
- **표현 방식**:  
  - 확실성 표시 ("분명히", "아마도", "가능성이 있다")  
  - 증거 제시 정도  
  - 주장의 명확함 vs. 조건부성  
-  **AI 응답 설계**:  
  - 사용자의 확신 수준에 맞춘 답변 구성  
  - 확실성 정도를 명시적으로 표현 ("확실하게" vs. "아마도")  
  - 근거의 강도와 불확실성 영역 명확화  

### Affiliation과의 관계

- **감정 표현 = Affiliation이 있다는 신호**  
- 감정적 태도를 보이는 것은 단순히 "감정을 드러내는 것"이 아니라, 사용자가 AI와의 관계를 형성하려는 의도를 나타낸다  
- 반대로 비감정적·객관적 톤은 도구적 관계(Affiliation 없음)를 신호  

#### 사용자 Stance 분석 → AI 응답 조정

**Case 1: Affiliation 있음 + 감정적 태도**
```
사용자: "정말 답답해서요. 이 문제로 며칠을 고민했는데..."
→ AI: 공감 표현 + 관계 형성 톤 + 확실성 조정
```

**Case 2: Affiliation 없음 + 비감정적 태도**
```
사용자: "데이터셋 크기 1000개일 때 샘플링 방법 추천"
→ AI: 객관적 정보 + 근거 중심 + 확실성 명시
```

**Case 3: 혼합 (감정 표현 + 정보 요청)**
```
사용자: "이 방법이 정말 효과적일까요? 확실한 증거가 있나요?"
→ AI: 적절한 공감 + 증거 기반 답변 + 불확실성 명확화
```

### 세 계층 구조

```
Stance (화자 태도)
├─ Affiliation (근본층): 관계 설정 의도
│  ├─ 있음 → 상호작용 대상으로 인식
│  └─ 없음 → 도구로만 인식
│
└─ 표현 방식 (표면층)
   ├─ Affective Stance: 감정·평가 표현
   └─ Epistemic Stance: 확실성·인식적 태도
```

**AI의 역할**: 사용자의 Affiliation을 인식하되, 감정적·비감정적 태도 모두에 적절히 응답하여 관계 형성 의도를 존중하면서도 정보의 정확성과 확실성을 유지해야 한다.

