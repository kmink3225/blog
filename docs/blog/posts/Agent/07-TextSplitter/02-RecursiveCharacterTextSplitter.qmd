---
title: "RecursiveCharacterTextSplitter"
subtitle: 텍스트 분할
description: |
  효율적인 문서 청킹을 위한 다양한 텍스트 분할 전략을 다룬다.
categories:
  - AI
  - RAG
  - LangChain
author: Kwangmin Kim
date: 12/31/2024
format: 
  html:
    page-layout: full
    code-fold: true
    toc: true
    number-sections: true
draft: False
execute:
    eval: false
---


이 텍스트 분할기는 일반적인 텍스트에 권장되는 방식입니다.

이 분할기는 문자 목록을 매개변수로 받아 동작합니다.

분할기는 청크가 충분히 작아질 때까지 주어진 문자 목록의 순서대로 텍스트를 분할하려고 시도합니다.

기본 문자 목록은 `["\n\n", "\n", " ", ""]`입니다.

- **단락** -> **문장** -> **단어** 순서로 재귀적으로 분할합니다.

이는 단락(그 다음으로 문장, 단어) 단위가 의미적으로 가장 강하게 연관된 텍스트 조각으로 간주되므로, 가능한 한 함께 유지하려는 효과가 있습니다.

1. 텍스트가 분할되는 방식: 문자 목록(`["\n\n", "\n", " ", ""]`) 에 의해 분할됩니다.

2. 청크 크기가 측정되는 방식: 문자 수에 의해 측정됩니다.


- `appendix-keywords.txt` 파일을 열어 내용을 읽어들입니다.
- 읽어들인 내용을 `file` 변수에 저장합니다.

```{python}
# appendix-keywords.txt 파일을 열어서 f라는 파일 객체를 생성합니다.
with open("./data/appendix-keywords.txt") as f:
    file = f.read()  # 파일의 내용을 읽어서 file 변수에 저장합니다.
```

파일로부터 읽은 파일의 일부 내용을 출력합니다.

```{python}
# 파일으로부터 읽은 내용을 일부 출력합니다.
print(file[:500])
```

```{python}
from langchain_text_splitters import RecursiveCharacterTextSplitter
```

`RecursiveCharacterTextSplitter`를 사용하여 텍스트를 작은 청크로 분할하는 예제입니다.

- `chunk_size`를 250 으로 설정하여 각 청크의 크기를 제한합니다.
- `chunk_overlap`을 50 으로 설정하여 인접한 청크 간에 50 개 문자의 중첩을 허용합니다.
- `length_function`으로 `len` 함수를 사용하여 텍스트의 길이를 계산합니다.
- `is_separator_regex`를 `False`로 설정하여 구분자로 정규식을 사용하지 않습니다.

```{python}
text_splitter = RecursiveCharacterTextSplitter(
    # 청크 크기를 매우 작게 설정합니다. 예시를 위한 설정입니다.
    chunk_size=250,
    # 청크 간의 중복되는 문자 수를 설정합니다.
    chunk_overlap=50,
    # 문자열 길이를 계산하는 함수를 지정합니다.
    length_function=len,
    # 구분자로 정규식을 사용할지 여부를 설정합니다.
    is_separator_regex=False,
)
```

- `text_splitter`를 사용하여 `file` 텍스트를 문서 단위로 분할합니다.
- 분할된 문서는 `texts` 리스트에 저장됩니다.
- `print(texts[0])`과 `print(texts[1])`을 통해 분할된 문서의 첫 번째와 두 번째 문서를 출력합니다.

```{python}
# text_splitter를 사용하여 file 텍스트를 문서로 분할합니다.
texts = text_splitter.create_documents([file])
print(texts[0])  # 분할된 문서의 첫 번째 문서를 출력합니다.
print("===" * 20)
print(texts[1])  # 분할된 문서의 두 번째 문서를 출력합니다.
```

`text_splitter.split_text()` 함수를 사용하여 `file` 텍스트를 분할합니다.

```{python}
# 텍스트를 분할하고 분할된 텍스트의 처음 2개 요소를 반환합니다.
text_splitter.split_text(file)[:2]
```

