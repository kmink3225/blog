---
title: "Conda Introduction"
subtitle: Conda Introduction, Conda Installation
description: |
  template
categories:
  - Engineering
author: Kwangmin Kim
date: 05/01/2023
format: 
  html:
    page-layout: full
    code-fold: true
    toc: true
    number-sections: true
draft: False
---



## 실무 워크플로우  

### 프로젝트 시작  

```bash  
# 1. 새 프로젝트 생성  
poetry new my_project  
cd my_project  

# 2. 필요한 패키지 추가  
poetry add pandas numpy matplotlib  

# 3. 개발용 패키지 추가 (테스트, 린팅 등)  
poetry add --group dev pytest black mypy  

# 4. 팀원과 공유  
git add pyproject.toml poetry.lock  
git commit -m "Add dependencies"  
```  

### 팀원이 프로젝트 받기  

```bash  
# 1. 코드 클론  
git clone <repo>  
cd my_project  

# 2. 정확히 같은 환경 구성  
poetry install  

# 3. 작업 시작  
poetry run python main.py  
```  

### 코드 실행 방법  

**방법 1: `poetry run` (권장)**  
```bash  
poetry run python main.py  
poetry run pytest  
poetry run black .  
```  
- 가상환경을 자동으로 활성화하고 명령 실행  
- 깨끗함 (작업 완료 후 자동으로 비활성화)  

**방법 2: `poetry shell` (대화형 작업)**  
```bash  
poetry shell  
python main.py  
pytest  
black .  
exit  # 가상환경 종료  
```  
- 대화형 작업이나 여러 명령을 연달아 실행할 때 편함  

## pyproject.toml 이해하기  

생성된 파일 구조:  
```  
my_project/  
├── pyproject.toml       # 프로젝트 설정 파일 (핵심)  
├── poetry.lock          # 정확한 버전 기록 (자동 생성)  
├── README.md  
├── my_project/          # 패키지 폴더  
│   └── __init__.py  
└── tests/  
    └── __init__.py  
```  

`pyproject.toml` 상세 설명:  

```toml  
[tool.poetry]  
name = "my-project"                           # 패키지 이름  
version = "0.1.0"                             # 버전  
description = "My awesome project"            # 설명  
authors = ["Your Name <you@example.com>"]     # 작성자  

[tool.poetry.dependencies]  
python = "^3.9"                               # Python 버전 요구사항  
pandas = "^2.0"                               # 필수 의존성  
numpy = "^1.24"  
matplotlib = "^3.7"  

[tool.poetry.group.dev.dependencies]  
pytest = "^7.4"                               # 개발용 의존성  
black = "^23.0"  
mypy = "^1.0"  

[build-system]  
requires = ["poetry-core"]                    # 빌드 시스템  
build-backend = "poetry.core.masonry.api"  
```  

# 다른 버전 관리 방법과 비교  

## Poetry vs pip + requirements.txt  

### 문제 1: 의존성 추적 불가  

**pip 방식:**  
```  
requirements.txt  
pandas==2.0.3  
numpy==1.24.1  
scikit-learn==1.3.0  
scipy==1.10.1  
... (수십 줄, 누가 뭘 설치했는지 불명확)  
```  

**Poetry 방식:**  
```toml  
[tool.poetry.dependencies]  
pandas = "^2.0"  
scikit-learn = "^1.3"  
```  
- 직접 필요한 것만 명시  
- numpy, scipy는 자동으로 관리됨  

### 문제 2: 버전 충돌 해결 어려움  

**pip:**  
```bash  
pip install pandas==2.0.0 numpy==1.23.0  
# 호환성 검증? 수동으로 해야 함  
# 실패하면 직접 버전을 조정해야 함  
```  

**Poetry:**  
```bash  
poetry add pandas numpy  
# 자동으로 호환 가능한 버전 조합 찾음  
# 충돌 시 오류 메시지로 알려줌  
```  

### 문제 3: 재현성 부족  

**pip:**  
```bash  
# 개발자 A: requirements.txt 생성  
pip freeze > requirements.txt  
# 나중에 실행했을 때 버전이 달라질 수 있음  

# 개발자 B: 6개월 뒤 설치  
pip install -r requirements.txt  
# A와 다른 버전이 설치될 수 있음 (버그 발생!)  
```  

**Poetry:**  
```bash  
# poetry.lock이 모든 버전을 정확히 기록  
poetry install  # 항상 동일한 버전 설치 (100% 재현성)  
```  



