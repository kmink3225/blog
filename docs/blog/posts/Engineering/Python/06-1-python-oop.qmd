---
title: "Python 객체지향 프로그래밍 (OOP)"
subtitle: "클래스, 상속, 캡슐화, 다형성의 원리와 실전 적용"
description: | 
  객체지향 프로그래밍(OOP)은 복잡한 현실 세계를 소프트웨어로 모델링하기 위한 사고 체계다. 이 글에서는 OOP가 등장한 배경부터 클래스와 객체의 관계, 멤버 변수와 메소드의 동작 원리, 그리고 상속, 추상화, 캡슐화, 다형성이라는 4대 원칙을 다룬다. 마지막으로 은행 계좌 관리 시스템이라는 실전 프로젝트를 통해 모든 개념을 통합 적용한다.
categories:
  - Engineering
  - Python
author: Kwangmin Kim
date: 07/02/2023
draft: false
format: 
  html:
    toc: true
    number-sections: true
    code-fold: true
    page-layout: full
execute: 
  warning: false
  message: false
  eval: false
  echo: true
---

# 개요

이 글은 Python 객체지향 프로그래밍의 전체 흐름을 다룬다:

1. **OOP의 등장 배경** - 왜 객체지향이 필요한가
2. **객체와 클래스** - 설계도와 실체의 관계
3. **멤버 변수와 메소드** - 생성자와 self의 동작 원리
4. **상속과 추상화** - 코드 재사용과 설계 계약
5. **캡슐화와 다형성** - 데이터 보호와 인터페이스 일관성
6. **실전 프로젝트** - 은행 계좌 관리 시스템 구현

# OOP의 등장 배경

**객체지향 프로그래밍(Object-oriented Programming, OOP)** 은 복잡한 현실 세계를 소프트웨어로 모델링하기 위한 사고 체계다.

## 패러다임이란 무엇인가

**프로그래밍 패러다임(Programming Paradigm)** 은 "어떤 방식으로 문제를 바라보고 해결할 것인가"에 대한 사고 체계다.

::: {.callout-note title="절차지향 vs 객체지향"}
| 구분 | 절차지향 | 객체지향 |
|:---|:---|:---|
| **관점** | 순서대로 실행되는 명령들의 집합 | 데이터와 코드를 객체로 묶음 |
| **데이터/함수** | 변수와 함수가 분리되어 산재 | 객체 안에 함께 캡슐화 |
| **대표 언어** | C | Java, Python, C++ |
| **장점** | 간단한 프로그램에 직관적 | 대규모 시스템에 유지보수 용이 |
| **단점** | 규모 커지면 스파게티 코드 발생 | 초기 설계 비용이 높음 |
:::

Wikipedia는 OOP를 다음과 같이 정의한다.

> Object-oriented programming (OOP) is a programming paradigm based on the concept of objects,  
> which can contain data in the form of fields (often known as attributes or properties),  
> and code in the form of procedures (often known as methods).

핵심은 **데이터(data)와 코드(code)를 하나로 묶는다**는 것이다.    
* 절차지향에서는 데이터와 함수가 분리되어 있다.  
  * 변수는 여기 있고, 그 변수를 처리하는 함수는 저기 있다.  
* OOP는 이 둘을 하나의 단위, 즉 **객체(Object)** 안에 함께 가두어 놓는다.
* 즉, 객체는 자신이 가진 데이터(속성)와 그 데이터를 처리하는 코드(메소드)를 함께 가지고 있다.  
  * 자동차 객체는 색상, 속도, 연료량이라는 **속성**을 가지고 있고, 출발하기, 멈추기, 주유하기라는 **메소드**를 가지고 있다.  
  * 사람 객체는 이름, 나이, 직업이라는 **속성**을 가지고 있고, 말하기, 걷기, 일하기라는 **메소드**를 가지고 있다.
* 코드를 읽는 사람도, 수정하는 사람도 해당 객체만 들여다보면 된다.

## OOP가 선택된 이유

OOP가 널리 채택된 가장 중요한 이유:

- **인간이 세상을 인식하는 방식과 유사하다**
  - 인간은 세상을 "사물"과 "관계"로 인식
  - 사물 = 속성 + 행동

| 사물 | 속성 | 행동 |
|:---|:---|:---|
| 자동차 | 색상, 속도, 연료량 | 출발하기, 멈추기, 주유하기 |
| 사람 | 이름, 나이, 직업 | 말하기, 걷기, 일하기 |

- OOP는 이 사고 방식을 코드에 그대로 이식
- `car.accelerate(50)` → "자동차를 50으로 가속시킨다"는 의도가 주석 없이 전달됨

## OOP의 네 가지 장점과 그 실질적 의미

### 실제 세계의 모델링에 적합하다.

* 비즈니스 도메인을 코드로 옮기는 작업이 자연스러워진다.  
* 은행 시스템을 만든다면 "계좌", "고객", "거래" 라는 개념이 그대로 클래스가 된다.  
* 따라서, 요구사항 문서와 코드 사이의 간극이 줄어든다.

### 개념의 정의와 재사용이 자유롭다.  

* 한 번 정의한 "계좌" 클래스는 예금계좌에도, 입출금계좌에도 재활용할 수 있다.  
* 공통 기능은 부모 클래스에 한 번만 작성하고,  
* 자식 클래스는 차이점만 추가로 정의한다.  
* 이것이 **상속(Inheritance)** 의 실질적 가치다.

### 유지보수가 쉽다.

* "상품" 객체의 가격 계산 방식을 변경해야 한다면,  
* `Product` 클래스의 해당 메소드 하나만 수정하면 된다.  
* 이 클래스로 만들어진 모든 상품 객체에 변경사항이 자동으로 반영된다.  
* 절차지향이었다면 가격 계산 로직이 코드 전체에 흩어져 있을 수 있으므로,  
* 수정 누락으로 인한 버그가 발생할 위험이 크다.

### 캡슐화를 통한 데이터 보호

* 객체 내부의 데이터를 외부에서 직접 건드리지 못하게 막을 수 있다.  
* 자동차의 속도를 외부에서 `car.speed = -100` 처럼 직접 설정하는 것은 현실적으로 말이 안 된다.  
* OOP는 `car.drive(-100)` 처럼 메소드를 통해서만 속성을 변경하도록 강제함으로써 데이터의 무결성을 지킨다.  
* 이것이 **캡슐화(Encapsulation)** 의 핵심이다.

## Python과 OOP

**Python = 멀티 패러다임(Multi-paradigm) 언어**

- 순수 OOP 언어(Java): 모든 코드를 반드시 클래스 안에 작성
- Python: OOP + 함수형 + 절차지향 모두 지원

**데이터 과학자를 위한 실용적 조언:**

| 상황 | 권장 방식 |
|:---|:---|
| 간단한 데이터 처리 스크립트 | 함수 위주, 클래스 불필요 |
| 재사용 가능한 전처리 파이프라인 | OOP 설계 권장 |
| 모델 래퍼(wrapper) | OOP 설계 권장 |
| API 연동 모듈 | OOP 설계 권장 |

::: {.callout-note title="Scikit-learn의 OOP 활용"}
```python
from sklearn.linear_model import LogisticRegression

model = LogisticRegression()   # 객체 생성
model.fit(X_train, y_train)    # 메소드 호출
model.predict(X_test)          # 다형성: 모든 모델이 동일한 인터페이스
```
:::


# 객체와 클래스

## 객체란 무엇인가

> An object has state (data) and behavior (code).  
> Objects can correspond to things found in the real world.

**객체의 핵심 구성:**

* **상태(state)** = 멤버 변수(member variable) / 속성(attribute)
  - Python에서는 보통 **속성(attribute)** 이라고 부르는 게 더 자연스럽다:

| 용어 | 사용 맥락 | 설명 |
|:---|:---|:---|
| **멤버 변수** (member variable) | 일반 OOP / C++/Java 스타일 | "클래스의 구성원(member)인 변수" |
| **속성** (attribute) | Python 특화 용어 | "객체가 가진 특성(attribute)" |
| **필드** (field) | Java/C# 스타일 | 멤버 변수와 동일 |
| **인스턴스 변수** (instance variable) | Python 기술 용어 | 인스턴스마다 독립적인 변수임을 강조 |

```python
class Person:
    def __init__(self, name):
        self.name = name  # Python에선 "속성", 일반 OOP에선 "멤버 변수"라 부른다
```

* **행동(behavior)** = 메소드(method)

| 객체 | 상태(속성) | 행동(메소드) |
|:---|:---|:---|
| 자동차 | 속도, 연료량, 색상 | `start()`, `stop()`, `refuel()` |
| 강아지 | 이름, 나이, 품종 | `bark()`, `run()`, `eat()` |
| 주문 | 주문번호, 금액, 상태 | `confirm()`, `cancel()`, `track()` |

::: {.callout-tip title="객체는 물리적 사물만이 아니다"}
"주문", "거래", "세션", "권한"과 같은 추상적 개념도 객체가 될 수 있다.  
이것이 OOP가 비즈니스 도메인 모델링에 강력한 이유다.
:::

## 쇼핑몰 예시로 보는 객체의 구체적 의미

쇼핑몰 상품 목록 화면을 예로 들자면,  
* 화면에는 가방, 지갑, 캐리어 등 10개의 상품이 나열되어 있다.  
* 각 상품은 상품명, 브랜드, 원래 가격, 할인 가격이라는 정보를 보여준다.  
* 그리고 각 상품 카드에는 좋아요, 장바구니 담기, 구매하기 버튼이 있다.

OOP 관점에서 이 화면을 분석하면 다음과 같다.

- 화면에 있는 **상품 하나하나가 각각 하나의 객체**다.
- 상품명, 브랜드, 원래 가격, 할인 가격은 **속성(attribute)** 이다.
- 좋아요, 장바구니 담기, 구매하기는 **메소드(method)** 다.
- 각 상품은 서로 다른 이름과 가격을 가지지만, **속성의 종류는 모든 상품이 동일하다.**  
  * 가방도 상품명이 있고, 지갑도 상품명이 있다.  
  * 가방에는 상품명이 있는데 캐리어에는 상품명이 없는 경우는 없다.
- 모든 상품은 동일한 기능을 수행할 수 있다.  
  * 가방에는 좋아요를 누를 수 있고, 지갑에도 좋아요를 누를 수 있다.  
  * 반면 상품 객체에 "로그인하기"라는 기능은 정의되어 있지 않으므로,  
  * 상품에 로그인을 시도하는 것은 불가능하다.
- 이 마지막 **로그인** 포인트가 중요하다.  
  * **객체는 자신에게 정의된 기능만 수행할 수 있다.**  
  * 이 제약이 코드를 예측 가능하게 만든다.  
  * 어떤 객체가 무슨 일을 할 수 있는지가 명확하게 정의되어 있기 때문에,  
  * 해당 객체를 사용하는 사람은 그 범위 안에서만 상호작용한다.
- 또한 각 상품은 서로 **독립적**이다.  
  * 1번 상품의 가격을 변경해도 2번 상품의 가격은 그대로다.  
  * 하나의 객체에 가해진 변경이 다른 객체에 영향을 주지 않는다.  
  * 이 독립성이 복잡한 시스템을 관리 가능하게 만드는 핵심 원리다.

## 클래스란 무엇인가

> A class is a program-code-template for creating objects.

### 클래스 = 객체를 찍어내는 틀(template) = 건축 설계도

| 비유 | 설계도(클래스) | 건물(객체) |
|:---|:---|:---|
| 설계도 자체는 건물이 아니다 | `Product` 클래스 | 아직 객체 없음 |
| 설계도로 건물을 짓는다 | `Product("가방", 79000)` | 가방 객체 생성 |
| 하나의 설계도로 여러 건물 | 같은 클래스로 | 여러 인스턴스 |
| 한 건물 리모델링 ≠ 다른 건물 영향 | 객체 변경이 | 다른 객체에 영향 없음 |

- **클래스(Class)**: 객체를 만들기 위한 설계도, 개념의 정의
- **객체/인스턴스(Object/Instance)**: 클래스로부터 실제로 생성된 구체적인 실체
  - "객체" = 독립적인 실체 강조 (개념적/실체적 관점)
  - "인스턴스" = 특정 클래스로부터 생성되었다는 관계 강조 (기술적/관계적 관점)  

## 클래스와 인스턴스의 관계

| 원칙 | 설명 |
|:---|:---|
| **클래스 = 설계도** | 클래스 자체는 데이터가 없고, 속성과 기능의 정의만 존재 |
| **인스턴스별 고유 속성값** | 같은 클래스로 만든 객체들도 각각 다른 데이터를 가질 수 있음 |
| **인스턴스 간 독립성** | 한 인스턴스 변경이 다른 인스턴스에 영향 없음 |
| **클래스 변경 = 전체 반영** | 클래스 메소드 수정 시 모든 인스턴스에 적용 |

```python
class Person: # 매개변수(parameter)
    def __init__(self, name, age):
        self.name = name   # 인스턴스마다 다른 값
        self.age = age
    
    def hello(self):
        print(f"안녕하세요, {self.name}입니다.")

# 인스턴스 생성: 인자(argument)
man = Person("Robert", 30)    # man.name = "Robert"
woman = Person("Julia", 32)   # woman.name = "Julia"

man.age = 31                  # man만 변경, woman.age는 여전히 32
```  

## Python에서 클래스 정의하기

```python
class Person:
    def hello(self):
        print("Hello!")
man = Person()  # Person 클래스의 인스턴스 생성
```

**핵심 문법:**

| 요소 | 설명 |
|:---|:---|
| `class` 키워드 | 클래스 정의 시작 |
| 클래스 이름 | **PascalCase** 사용 (`Person`, `BankAccount`) |
| `self` | 메소드의 첫 번째 매개변수, 호출한 인스턴스 자기 자신 |

**`self`의 동작 원리:**

- `man.hello()` 메서드 호출 시 → Python 내부에서 `Person.hello(man)`으로 처리
- `self`에 `man` 인스턴스 자신이 직접 자동 전달됨
- 개발자가 `self`를 직접 전달할 필요 없음

**인스턴스 생성과 사용:**

```python
man = Person()      # 인스턴스 생성
woman = Person()    # 별도의 독립된 인스턴스

man.hello()         # hello() 메소드 호출, Hello! 출력
```

## 클래스 설계 시 고려할 사항

**단일 책임 원칙(Single Responsibility Principle):**

- 하나의 클래스는 하나의 개념, 하나의 역할만 담당
- ✘ `UserAuthenticationAndEmailSendingAndLogging` (세 가지 역할 혼합)
- ✔ `UserAuth`, `EmailSender`, `Logger` (역할별 분리)

**속성과 메소드 결정 기준:**

- 속성 = "특정 개념이 현실에서 **가지는** 것"
- 메소드 = "특정 개념이 현실에서 **하는** 것"
- 예: 상품 객체에 "로그인하기" 메소드가 없는 이유 → 현실에서 상품은 로그인 안 함

# 멤버 변수와 메소드

## 멤버 변수란 무엇인가

### 멤버 변수 = 객체의 데이터 = 상태(state)

- 동의어: 속성(attribute), 필드(field), 인스턴스 변수(instance variable)
- 인스턴스마다 독립적으로 존재 (`man.name ≠ woman.name`)

### 접근 방법:  

| 위치 | 문법 | 예시 |
|:---|:---|:---|
| 외부에서 | `.` 연산자 | `man.name`, `man.age` |
| 메소드 내부 | `self.변수명` | `self.name`, `self.age` |

```python
man = Person("Robert", 30)
print(man.name)   # 외부 접근: Robert

def hello(self):
    print(self.name)   # 내부 접근
```

## 생성자(__init__): 객체가 태어나는 순간

### 생성자(Constructor)

* 생성자 = 인스턴스 생성 시 자동 호출되는 특수 메소드  
  - Python에서는 `__init__()`이라는 이름으로 예약 (발음: dunder init)
  - `__` (더블 언더스코어) = **던더 메소드(dunder method)** 
  - dunder score = "double underscore"의 줄임말

### 생성자의 역할:

| 역할 | 설명 |
|:---|:---|
| **멤버 변수 초기화** | `self.name = name`으로 속성에 초기값 부여 |
| **설정 작업 수행** | DB 연결, 파일 핸들 초기화, 기본값 설정 등 |

```python
class Person:
    def __init__(self, name, age):   # 생성자
        self.name = name             # 멤버 변수 초기화
        self.age = age
    
    def hello(self):
        print(f"Hello! I'm {self.name}")

man = Person("Robert", 30)   # 생성자 자동 호출
```

**`Person("Robert", 30)` 실행 시 내부 과정:**

1. 새 `Person` 인스턴스를 위한 메모리 공간 할당
2. `__init__(self=<새 인스턴스 메모리 주소>, "Robert", 30)` 자동 호출
3. `self.name = "Robert"`, `self.age = 30` 실행
4.  `man = 새 인스턴스 메모리 주소` (완성된 인스턴스를 `man` 변수에 할당)

개발자는 `Person("Robert", 30)` 한 줄만 작성하지만,  
Python이 이 네 단계를 자동으로 처리한다.  
생성자가 이 과정을 담당하기 때문에  
개발자는 "어떤 데이터로 초기화할 것인가"만 결정하면 된다.

## self의 본질

인스턴스 자기 자신에 대한 참조

### self = 메소드를 호출한 인스턴스 자신에 대한 참조

- 메소드는 모든 인스턴스가 공유하는 코드
- `man.hello()` vs `woman.hello()` 구분이 필요
- `self`가 "이 메소드를 호출한 인스턴스"를 가리킴

### 내부 동작:

| 외부 호출 | 내부 변환 |
|:---|:---|
| `man.hello()` | `Person.hello(man)` |
| `woman.hello()` | `Person.hello(woman)` |

- 첫 번째 인자를 받는 매개변수 이름: 관례적으로 `self`
- `this`, `me`로 작성해도 동작하지만 Python 커뮤니티 규칙상 `self` 필수

```python
man = Person("Robert", 30)
print(man.name)   # Robert
print(man.age)    # 30
print(man.job)    # AttributeError: 정의되지 않은 속성
```

::: {.callout-warning}
정의되지 않은 속성(`job`)에 접근하면 `AttributeError` 발생  
→ 객체가 가질 수 있는 속성 범위는 클래스 정의에 의해 결정됨
:::

## 메소드

* 객체가 할 수 있는 행동의 정의  
* 메소드 = 클래스에 정의된 함수 = 인스턴스가 수행할 수 있는 행동

### 일반 함수와의 차이점:

| 구분 | 일반 함수 | 메소드 |
|:---|:---|:---|
| 정의 위치 | 모듈 수준 | 클래스 블록 안 |
| 첫 번째 매개변수 | 없음 | 반드시 `self` |

### `self`를 통한 접근:

- `self.변수명`: 인스턴스의 속성에 접근/수정
- `self.메소드명()`: 같은 인스턴스의 다른 메소드 호출

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def hello(self):
        print("Hello! I'm " + self.name)

    def update_age(self, new_age):
        if new_age > 0:
            self.age = new_age
            print(f"I'm {self.age} years old now!")
        else:
            raise ValueError("나이는 0살보다 어릴 수 없습니다.")

man = Person("Robert", 30)
man.hello()           # Hello! I'm Robert
man.update_age(31)    # I'm 31 years old now!
man.update_age(-5)    # ValueError 발생
```

::: {.callout-tip}
**메소드를 통한 속성 변경의 핵심 가치:**

- `update_age()`는 단순 값 변경이 아닌 **유효성 검증** 포함
- `man.age = -5` (직접 접근) → 검증 없이 음수 설정됨
- `man.update_age(-5)` (메소드 접근) → "나이는 양수" 규칙 강제
- 이것이 **캡슐화가 데이터 무결성을 보호**한다는 의미
:::

## 객체와 멤버 변수의 생명 주기

**생명 주기(lifecycle)** = 객체와 속성이 메모리에 **언제 생성/소멸하는지**

| 단계 | 시점 | 상태 |
|:---|:---|:---|
| **생성** | `Person("Robert", 30)` 호출 | 인스턴스 + 멤버 변수 메모리에 생성 |
| **상주** | 참조 변수(`man`)가 살아있는 동안 | 메모리에 계속 유지 |
| **소멸** | 스코프 벗어남 / `del man` | 가비지 컬렉터가 메모리 해제 |

**스코프 규칙:** 일반 변수와 동일

```python
def create_person():
    temp = Person("Temp", 25)
    temp.hello()   # Hello! I'm Temp
    # 함수가 끝나면 temp가 스코프를 벗어나 인스턴스 소멸

create_person()
# 이 시점에서 temp 인스턴스는 더 이상 존재하지 않음
```

반면 모듈 수준에서 생성된 인스턴스는 프로그램이 실행되는 동안 유지된다.  
이 차이를 이해하지 못하면  
"분명히 인스턴스를 만들었는데 데이터가 없다"는 버그를 만나게 된다.

## 인스턴스 변수와 클래스 변수의 차이

| 구분 | 인스턴스 변수 | 클래스 변수 |
|:---|:---|:---|
| **소속** | 각 인스턴스 | 클래스 자체 |
| **공유 범위** | 인스턴스마다 독립 | 모든 인스턴스가 공유 |
| **정의 위치** | `__init__` 내부 | 클래스 블록 내 (메소드 외부) |
| **접근** | `self.name` | `ClassName.var` 또는 `self.var` |

```python
class Person:
    species = "Homo sapiens"   # 클래스 변수: 모든 인스턴스가 공유

    def __init__(self, name, age):
        self.name = name       # 인스턴스 변수: 인스턴스마다 독립적
        self.age = age

man = Person("Robert", 30)
woman = Person("Julia", 32)

print(man.species)    # Homo sapiens
print(woman.species)  # Homo sapiens
print(Person.species) # Homo sapiens (클래스에서 직접 접근 가능)

Person.species = "Human"
print(man.species)    # Human (클래스 변수 변경이 모든 인스턴스에 반영)
```

**클래스 변수 사용 예시:**

- 모든 인스턴스에 공통 적용되는 설정값
- 인스턴스 생성 횟수 카운터
- "클래스 전체에서 공유되어야 하는 데이터"

::: {.callout-warning}
**주의:** 인스턴스 변수와 클래스 변수를 혼동하면  
의도치 않게 모든 인스턴스의 값이 동시에 바뀌는 버그 발생 가능
:::

## 데이터 과학 관점에서의 활용

**Scikit-learn 모든 모델이 멤버 변수 + 메소드 구조를 따름:**

```python
from sklearn.linear_model import LinearRegression

model = LinearRegression()   # 인스턴스 생성
model.fit(X_train, y_train)  # 메소드 호출 → self.coef_ 등 설정
predictions = model.predict(X_test)  # 메소드 호출

print(model.coef_)           # 멤버 변수 접근
print(model.intercept_)      # 멤버 변수 접근
```

::: {.callout-note}
**동적 속성 생성:**

- `model.coef_`는 `fit()` 실행 후에만 존재하는 멤버 변수
- `fit()` 이전 접근 시 `AttributeError` 발생
- 가능하면 생성자에서 모든 멤버 변수를 초기화하는 것이 좋은 설계 관례
:::

---

# 상속과 추상화

| 개념 | 정의 |
|:---|:---|
| **상속** | 기존 클래스를 기반으로 새로운 클래스를 만드는 메커니즘 |
| **추상화** | 여러 클래스의 공통점을 추출해 상위 개념으로 정의 |

**관계:** 상속이 추상화를 구현하는 도구

## 상속이란 무엇인가

**상속(Inheritance)** = 기존 클래스(부모)의 속성/메소드를 새로운 클래스(자식)가 물려받는 메커니즘

**핵심 이점:** 코드 중복 제거

**은행 시스템 예시:**

| 구분 | 상속 없이 | 상속 사용 시 |
|:---|:---|:---|
| 공통 로직 (계좌번호, 잔액, 입금, 출금) | 예금계좌/입출금계좌에 각각 작성 | `BankAccount`에 한 번만 작성 |
| 입금 로직 수정 시 | 두 클래스 모두 수정 필요 | `BankAccount.deposit()` 하나만 수정 |
| 수정 누락 | 버그 위험 | 자동 반영 |

## 부모 클래스와 자식 클래스의 관계

| 구분 | 부모 클래스 (Parent) | 자식 클래스 (Child) |
|:---|:---|:---|
| **동의어** | 슈퍼클래스, 베이스클래스 | 서브클래스, 파생클래스 |
| **개념 수준** | 포괄적/일반적 | 구체적/특수 |
| **역할** | 공통 기능 정의 | 부모 기능 + 고유 기능 추가 |

**예시:**

- 사람 > 배우: 배우는 사람이다 (is-a)
- 이동수단 > 자동차 > SUV: 계층이 내려갈수록 구체적

::: {.callout-important}
**is-a vs has-a 판단:**

- **is-a** ("배우는 사람이다") → 상속 적합
- **has-a** ("자동차는 엔진을 가진다") → **합성(Composition)** 사용
- 판단 오류 시 클래스 계층이 비틀림
:::

## Python에서 상속 구현하기

Python에서 상속은 클래스 정의 시  
부모 클래스 이름을 괄호 안에 넣는 방식으로 선언한다.

```python
# 부모 클래스
class Person:
    def __init__(self, name, job):
        self.name = name
        self.job = job

    def introduce(self):
        print(f"제 이름은 {self.name}입니다. 직업은 {self.job}입니다.")

# 자식 클래스
class Actor(Person):
    def __init__(self, name, best_movie):
        super().__init__(name, job="배우")  # 부모 생성자 호출
        self.best_movie = best_movie

    def filmography(self):
        print(f"대표 작품은 {self.best_movie}입니다.")

# 인스턴스 생성 및 사용
actor_song = Actor("송강호", best_movie="기생충")

actor_song.introduce()     # 제 이름은 송강호입니다. 직업은 배우입니다.
actor_song.filmography()   # 대표 작품은 기생충입니다.
```

**주요 포인트:**

| 요소 | 설명 |
|:---|:---|
| `Actor(Person)` | `Actor`가 `Person`을 상속받는다는 선언 |
| `super().__init__()` | 부모 클래스 생성자 호출 (필수) |
| `self.best_movie` | `Actor` 클래스만의 고유 속성 |

::: {.callout-warning}
`super().__init__()` 호출을 빠뜨리면 부모 클래스 속성이 초기화되지 않아  
`actor_song.name` 접근 시 `AttributeError` 발생
:::

## 메소드 오버라이딩: 부모의 기능을 자식이 재정의하기

**메소드 오버라이딩(Method Overriding)** = 상속받은 메소드를 **같은 이름으로 재정의**

**사용 시점:** 부모 클래스의 기본 동작이 자식 클래스에 맞지 않을 때

```python
class Person:
    def introduce(self):
        print(f"제 이름은 {self.name}입니다. 직업은 {self.job}입니다.")

class Actor(Person):
    def introduce(self):  # 오버라이딩: 같은 이름으로 재정의
        print(f"안녕하세요, 배우 {self.name}입니다.")
        print(f"대표작은 {self.best_movie}입니다.")
        super().introduce()  # 필요하면 부모 메소드도 함께 호출 가능
```

**동작 방식:**

- `actor_song.introduce()` 호출 시 → `Actor.introduce()` 실행
- 자식 클래스에 동일 이름 메소드 있으면 **자식 것이 우선**
- 다형성(Polymorphism)의 핵심 구현 수단

## 다중 상속과 다이아몬드 문제

**다중 상속(Multiple Inheritance)** = 하나의 자식 클래스가 두 개 이상의 부모를 동시 상속

```python
# 부모 클래스 1: 새 (날 수 있음)
class Bird:
    def __init__(self):
        self.can_fly = True

    def fly(self):
        print("This bird can fly.")

# 부모 클래스 2: 물고기 (수영할 수 있음)
class Fish:
    def __init__(self):
        self.can_swim = True

    def swim(self):
        print("This fish can swim.")

# 자식 클래스: 날으는 물고기 (다중 상속)
class FlyingFish(Fish, Bird):
    def __init__(self):
        Bird.__init__(self)   # 두 부모의 생성자를 명시적으로 호출
        Fish.__init__(self)

    def ability(self):
        if self.can_fly and self.can_swim:
            print("This creature can both fly and swim.")
```

다중 상속은 강력하지만 **다이아몬드 상속 문제(Diamond Inheritance Problem)** 를  
일으킬 수 있다.

```python
class A:
    def method(self):
        print("Method from class A")

class B(A):
    def method(self):
        print("Method from class B")

class C(A):
    def method(self):
        print("Method from class C")

class D(B, C):   # B와 C를 동시에 상속
    pass

d = D()
d.method()   # 어떤 method가 호출될까?
```

`D`는 `B`와 `C`를 동시에 상속받는데,  
`B`와 `C` 둘 다 `A`를 상속받으며 `method()`를 각자 오버라이딩했다.  
`d.method()`를 호출하면 `B`의 것을 써야 하는가, `C`의 것을 써야 하는가?  
이 모호성이 다이아몬드 문제다.

Python은 이 문제를 **MRO(Method Resolution Order)** 로 해결한다.  
MRO는 메소드를 탐색할 순서를 결정하는 알고리즘으로,  
Python은 **C3 선형화(C3 Linearization)** 알고리즘을 사용한다.

```python
print(D.__mro__)
# (<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>)
```

**MRO(Method Resolution Order) 해결:**

- D > B > C > A > object 순서로 탐색
- `D(B, C)`에서 먼저 나열된 `B`가 우선순위

::: {.callout-caution}
**실무 권장사항:**

- 다중 상속은 동작 예측이 어렵고 가독성 저하
- **다중 상속 최대한 회피**
- 필요 시 **믹스인(Mixin) 패턴** 사용
- Java/C#이 인터페이스(interface)로 대체한 이유
:::

## 추상화란 무엇인가

**추상화(Abstraction)** = 복잡한 현실을 단순화하여 **핵심 특징만 추출**하는 과정

**OOP에서의 두 가지 의미:**

| 의미 | 설명 | 예시 |
|:---|:---|:---|
| **공통점 추출** | 여러 객체의 공통점을 상위 클래스로 정의 | 원/사각형/삼각형 → `Shape.get_area()` |
| **세부 숨김** | 구현 세부사항 숨기고 인터페이스만 노출 | 운전자는 엔진 원리 몰라도 액셀만 알면 됨 |

**효과:** 시스템의 복잡도 감소 + 직관성 향상

## Python의 추상 클래스: abc 모듈

**추상 클래스(Abstract Class)** = 직접 인스턴스화 불가, **반드시 상속받아 사용**해야 하는 설계도

**필요성:**

- `Shape.get_area()`를 정의하고 싶지만, `Shape` 자체는 구체적 도형이 아님
- `get_area()` 정의 없으면 자식 클래스에서 구현 강제 불가
- 개발자 실수로 빠뜨려도 오류 미발생

**해결책:** `@abstractmethod`로 선언 → **자식 클래스에서 반드시 구현**, 미구현 시 `TypeError`

```python
from abc import ABC, abstractmethod

# 추상 클래스: 도형
class Shape(ABC):
    @abstractmethod
    def get_size(self):
        pass   # 구현 없음, 자식 클래스에서 반드시 구현해야 함

# 구체 클래스: 직사각형
class Rectangle(Shape):
    def __init__(self, height, width):
        self.height = height
        self.width = width

    def get_size(self):              # 추상 메소드 구현
        return self.height * self.width

# 구체 클래스: 원
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def get_size(self):              # 추상 메소드 구현
        return 3.14 * self.radius * self.radius

# 추상 클래스는 직접 인스턴스화 불가
# shape = Shape()  # TypeError 발생

rect = Rectangle(5, 3)
circle = Circle(4)

print(rect.get_size())    # 15
print(circle.get_size())  # 50.24
```

`Shape`를 상속받는 클래스가 `get_size()`를 구현하지 않으면  
인스턴스를 생성하는 순간 `TypeError`가 발생한다.  
이 강제성이 추상 클래스의 핵심 가치다.  
대규모 팀에서 여러 개발자가 `Shape`를 상속받아 새로운 도형을 만들 때,  
`get_size()`를 빠뜨리는 실수를 런타임 오류가 아닌  
인스턴스 생성 시점에 즉시 잡아낼 수 있다.

## 추상 클래스와 상속의 관계: 설계 계약

추상 클래스를 상속받는다는 것은  
일종의 **설계 계약(design contract)** 을 맺는 것이다.  
"나는 `Shape`를 상속받는다. 그러므로 `get_size()`를 반드시 구현하겠다"는  
약속을 코드 수준에서 강제하는 것이다.

이 계약 구조는 대규모 시스템에서 매우 중요한 역할을 한다.  
Scikit-learn의 `BaseEstimator`와 `TransformerMixin`이 대표적인 예다.  
`fit()`, `transform()`, `predict()` 같은 메소드를 추상 메소드로 정의함으로써  
어떤 모델이든 동일한 인터페이스를 가지도록 강제한다.  
덕분에 `Pipeline`이나 `GridSearchCV` 같은 도구가  
내부 모델의 구체적인 구현을 알지 못해도  
`fit()`, `transform()`을 일관되게 호출할 수 있다.

```python
from sklearn.base import BaseEstimator, TransformerMixin

class CustomScaler(BaseEstimator, TransformerMixin):
    def fit(self, X, y=None):
        self.mean_ = X.mean(axis=0)
        self.std_ = X.std(axis=0)
        return self

    def transform(self, X):
        return (X - self.mean_) / self.std_
```

`BaseEstimator`와 `TransformerMixin`을 상속받음으로써  
`CustomScaler`는 Scikit-learn의 모든 파이프라인과  
자동으로 호환된다.  
이것이 추상화와 상속이 만들어내는 실질적인 생산성이다.

---

# 캡슐화와 다형성

| 개념 | 정의 |
|:---|:---|
| **캡슐화** | 객체 내부를 외부로부터 보호 |
| **다형성** | 서로 다른 객체가 동일한 인터페이스로 다르게 동작 |

## 캡슐화란 무엇인가

캡슐화(Encapsulation)는 객체의 **데이터(속성)와 그 데이터를 다루는 메소드를  
하나로 묶고, 내부 구현을 외부로부터 숨기는 원칙**이다.  
"캡슐"이라는 단어가 말해주듯, 내부 구조를 외부에서 직접 건드리지 못하도록  
캡슐 안에 가두는 것이다.

왜 이것이 필요한가?  
데이터를 외부에서 직접 변경할 수 있으면  
**데이터의 무결성(data integrity)** 을 보장할 수 없기 때문이다.

자동차 속도를 예로 들어보자.  
현실에서 자동차 속도는 음수가 될 수 없고,  
갑자기 0에서 300으로 순간이동하듯 바뀔 수 없다.  
그런데 캡슐화 없이 `car.speed = -100` 또는 `car.speed = 300`을  
코드 어디서든 실행할 수 있다면,  
비즈니스 규칙이 코드 수준에서 전혀 강제되지 않는다.  
버그는 데이터가 잘못된 상태가 된 순간이 아니라  
그 잘못된 데이터가 사용되는 순간에 발견된다.  
그 사이의 거리가 멀수록 디버깅은 어려워진다.

캡슐화는 이 문제를 해결한다.  
속성을 외부에서 직접 변경하지 못하게 막고,  
메소드를 통해서만 변경할 수 있도록 강제한다.  
메소드 안에서 유효성 검증 로직을 실행하므로  
잘못된 데이터가 객체 안으로 들어오는 것 자체를 차단한다.

## 접근 제어자: public, protected, private

**접근 제어자(access modifier)** = 캡슐화를 구현하는 기술적 도구

| 제어자 | 접근 범위 | 설명 |
|:---|:---|:---|
| **public** | 내부 + 외부 모두 | 제한 없이 읽기/쓰기 가능 |
| **protected** | 내부 + 자식 클래스 | 외부 접근 비권장 |
| **private** | 내부만 | 외부 접근 절대 불가 |

**참고:** Java/C++은 언어 수준에서 강제, `private` 속성 외부 접근 시 컴파일 오류

## Python의 캡슐화: 관례 기반 접근 제어

Python은 **접근 제어를 언어 수준에서 강제하지 않음**

- 철학: "We are all consenting adults here"
- 강제 대신 **명명 규칙(naming convention)** 으로 의도 표현

| 제어자 | 문법 | 동작 | 비고 |
|:---|:---|:---|:---|
| **public** | `self.name` | 제한 없음 | 기본값 |
| **protected** | `self._balance` | 기술적 차단 없음 | "건드리지 말라"는 신호 |
| **private** | `self.__secret` | 이름 맹글링 적용 | `_ClassName__secret`으로 변환 |

```python
self.__secret = "internal_data"   # private: 외부 접근 차단

# 외부에서 접근 시도
obj.__secret        # AttributeError
obj._ClassName__secret  # 이름 맹글링 우회 (가능하지만 절대 하면 안 됨)
```

::: {.callout-note}
이름 맹글링 우회는 기술적으로 가능하지만  
Python 커뮤니티 관례상 **매우 나쁜 코드**로 간주됨
:::

## 잘못된 캡슐화 사례와 올바른 설계

PPT의 `Car` 클래스 예시를 통해  
잘못된 캡슐화가 어떤 문제를 일으키는지 살펴본다.

```python
# 잘못된 설계: 캡슐화가 불완전한 사례
class Car:
    def __init__(self) -> None:
        self.speed = 0   # public 속성: 외부에서 직접 변경 가능

    def drive(self, speed) -> int:
        if speed < 0:
            print(f"잘못된 속도입니다. {self.speed} km/h 를 유지합니다.")
            return self.speed

        self.speed = speed

        if speed == 0:
            print("정지 중입니다.")
        else:
            print(f"지금 속도는 {self.speed} km/h 입니다.")

redcar = Car()
redcar.drive(0)    # 정지 중입니다.
redcar.drive(10)   # 지금 속도는 10 km/h 입니다.
redcar.drive(-10)  # 잘못된 속도입니다. 10 km/h 를 유지합니다.

# 문제: drive() 메소드의 유효성 검증을 완전히 우회
redcar.speed = -10  # 아무런 검증 없이 음수 속도가 설정됨
```

`drive()` 메소드는 음수 속도에 대한 유효성 검증을 포함하고 있다.  
그런데 `self.speed`가 `public`이므로  
`redcar.speed = -10`처럼 외부에서 직접 접근하면  
이 검증이 완전히 무력화된다.  
메소드로 보호하려는 노력이 허사가 되는 것이다.

올바른 설계는 다음과 같다.

```python
# 올바른 설계: private 속성과 메소드를 통한 접근 제어
class Car:
    def __init__(self) -> None:
        self.__speed = 0   # private: 외부 직접 접근 차단

    def drive(self, speed) -> int:
        if speed < 0:
            print(f"잘못된 속도입니다. {self.__speed} km/h 를 유지합니다.")
            return self.__speed

        self.__speed = speed

        if speed == 0:
            print("정지 중입니다.")
        else:
            print(f"지금 속도는 {self.__speed} km/h 입니다.")

    def get_speed(self):        # getter: 읽기 전용 접근 제공
        return self.__speed

redcar = Car()
redcar.drive(10)       # 지금 속도는 10 km/h 입니다.
redcar.drive(-10)      # 잘못된 속도입니다. 10 km/h 를 유지합니다.
redcar.__speed = -10   # AttributeError: 직접 접근 차단
print(redcar.get_speed())  # 10: getter를 통한 읽기만 허용
```

`self.__speed`로 선언함으로써  
외부에서 직접 `speed`를 변경하는 경로가 완전히 차단된다.  
속도를 변경하려면 반드시 `drive()` 메소드를 거쳐야 하고,  
이 메소드 안에서 유효성 검증이 항상 실행된다.  
데이터의 무결성이 코드 구조 자체에 의해 보장된다.

## getter와 setter: 제어된 접근 제공

**getter/setter 패턴** = private 속성을 숨기되 **통제된 읽기/쓰기 경로 제공**

```python
class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def get_age(self):        # getter: 읽기 제공
        return self.__age

    def set_age(self, new_age):   # setter: 유효성 검증 후 쓰기 제공
        if new_age > 0:
            self.__age = new_age
        else:
            raise ValueError("나이는 양수여야 합니다.")
```

Python에서는 `@property` 데코레이터를 사용해  
getter/setter를 더 Pythonic하게 구현할 수 있다.

```python
class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    @property
    def age(self):            # getter: person.age로 접근
        return self.__age

    @age.setter
    def age(self, new_age):   # setter: person.age = 31로 설정
        if new_age > 0:
            self.__age = new_age
        else:
            raise ValueError("나이는 양수여야 합니다.")

person = Person("Robert", 30)
print(person.age)   # 30: getter 호출
person.age = 31     # setter 호출, 유효성 검증 실행
person.age = -1     # ValueError 발생
```

**`@property`의 장점:**

- 외부에서는 `person.age`처럼 일반 속성 접근으로 보임
- 실제로는 메소드가 실행됨
- **인터페이스 단순 + 내부 제어 유지**

## 다형성이란 무엇인가

**다형성(Polymorphism)** = "여러(poly) 가지 형태(morph)"

- **정의:** 동일한 인터페이스(메소드 이름)가 객체 타입에 따라 다르게 동작
- **장점:** 구체적 객체 타입을 몰라도 일관된 방식으로 객체 처리 가능

**다형성 없는 설계 (문제점):**

```python
# 다형성 없는 설계: 타입을 직접 확인해야 함
def print_area(shape):
    if isinstance(shape, Circle):
        print(3.14 * shape.radius * shape.radius)
    elif isinstance(shape, Square):
        print(shape.side * shape.side)
    elif isinstance(shape, Triangle):
        print(0.5 * shape.base * shape.height)
    # 새로운 도형이 추가될 때마다 여기에 elif를 추가해야 함
```

::: {.callout-warning}
**문제점:** 새 도형 추가 시 `print_area()` 함수 수정 필요  
→ **개방-폐쇄 원칙(OCP)** 위반: "확장에는 열려있고, 수정에는 닫혀있어야"
:::

**다형성 적용 설계:**

```python
class Shape:
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):   # 오버라이딩: Circle만의 넓이 계산
        return 3.14 * self.radius * self.radius

class Square(Shape):
    def __init__(self, side):
        self.side = side

    def area(self):   # 오버라이딩: Square만의 넓이 계산
        return self.side * self.side

class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def area(self):   # 오버라이딩: Triangle만의 넓이 계산
        return 0.5 * self.base * self.height

# 다형성 활용: 타입에 관계없이 동일한 인터페이스로 처리
shapes = [Circle(3), Square(4), Triangle(3, 5)]

for shape in shapes:
    print(f"Area of {shape.__class__.__name__} is {shape.area()}")

# Area of Circle is 28.26
# Area of Square is 16
# Area of Triangle is 7.5
```

**핵심 포인트:**

- `shape.area()` 호출 시 `Circle`/`Square`/`Triangle` 구분 필요 없음
- 각 객체가 자신의 타입에 맞는 계산을 알아서 수행
- `Pentagon`(오각형) 추가 시 → `area()` 메소드만 구현하면 됨
- 반복문 코드는 수정 불필요 → **확장성 향상**

## 다형성의 두 가지 구현 방식

| 방식 | 설명 | 특징 |
|:---|:---|:---|
| **메소드 오버라이딩** | 자식 클래스가 부모 메소드를 같은 이름으로 재정의 | 상속 관계 필요 |
| **덕 타이핑** | "오리처럼 걷고 오리처럼 운다면 오리" | 상속 관계 없이도 동작 |

```python
class Dog:
    def sound(self):
        print("Woof!")

class Cat:
    def sound(self):
        print("Meow!")

class Duck:
    def sound(self):
        print("Quack!")

# Dog, Cat, Duck은 서로 상속 관계가 없음
# 하지만 모두 sound()를 가지므로 동일하게 다룰 수 있음
animals = [Dog(), Cat(), Duck()]

for animal in animals:
    animal.sound()

# Woof!
# Meow!
# Quack!
```

::: {.callout-note}
**정적 vs 동적 타입 언어:**

- Java/C++: 다형성에 공통 부모 클래스/인터페이스 필수
- Python: 동적 타입 언어라 덕 타이핑 가능
- 단, 필요한 메소드를 문서/타입 힌트로 명확히 표현해야 의도 전달
:::

## 캡슐화와 다형성의 상호작용

**독립적 개념이지만 함께 사용 시 시너지 발생:**

| 개념 | 역할 |
|:---|:---|
| 캡슐화 | 객체 내부 구현을 숨김 |
| 다형성 | 동일한 인터페이스로 다른 구현 호출 |

**결합 효과:** "인터페이스만 알고 구현은 몰라도 된다"

**Scikit-learn Pipeline 예시:**

```python
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression

pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('model', LogisticRegression())
])

pipeline.fit(X_train, y_train)
pipeline.predict(X_test)
```

`Pipeline`은 `StandardScaler`의 내부 구현을 전혀 모른다.  
`LogisticRegression`이 어떻게 학습하는지도 모른다.  
단지 각 단계가 `fit()`과 `transform()` 또는 `predict()`를  
가지고 있다는 것만 안다.  
내부 구현은 각 클래스 안에 캡슐화되어 있고,  
동일한 인터페이스를 통한 다형성으로 Pipeline이 이들을 일관되게 다룬다.  
`LogisticRegression` 대신 `RandomForestClassifier`로 바꿔도  
`Pipeline` 코드는 한 글자도 수정하지 않아도 된다.

---

# 실전 프로젝트: 은행 계좌 관리 시스템

지금까지 학습한 모든 OOP 원칙을 **은행 계좌 관리 시스템**에 통합

## 요구사항 분석: 무엇을 만들 것인가

**계좌 공통 (BankAccount):**

- 계좌번호: 8자리 숫자 랜덤 생성
- 초기 입금액/소유주명: 계좌 개설 시 전달
- 기능: `withdraw()`, `deposit()`
- 출금: 잔액 초과 불가, 초과 시 `ValueError`
- 출금 성공 시 현재 잔액 반환

**예금계좌 (SavingsAccount):**

- 계좌 개설 시 출금 제한 상태
- 이자율: 계좌 생성 시 결정
- 출금 제한 상태에서 출금 시도 시 `AttributeError`
- `release_block()`: 출금 제한 해제 + `잔액 × 이자율` 이자 자동 입금
- 출력: `[예금/{계좌번호}] 잔액 ${잔액}, 이율 {이자율}%, 출금 제한 여부: {True/False}`

**입출금계좌 (CheckingAccount):**

- 출금한도: 속성으로 보유, 기본값 $500
- 계좌 생성 시 다른 값으로 초기 설정 가능
- 중도 변경 가능 (`set_limit()`)
- 출금한도 초과 시 `ValueError`
- 출력: `[입출금/{계좌번호}] 잔액 ${잔액}, 출금한도 ${출금한도}`

**은행 고객 (BankCustomer):**

- 속성: 고객명, 보유 계좌 리스트, 보유 현금
- 기능: `add_account()`, `list_accounts()`, `add_cash()`, `deduct_cash()`, `show_assets()`

## 클래스 설계 전략: OOP 원칙을 어떻게 적용할 것인가

| 원칙 | 적용 전략 |
|:---|:---|
| **상속** | `BankAccount` ← `SavingsAccount`, `CheckingAccount` (is-a 관계) |
| **캡슐화** | `__balance` (private), `_withdrawal_blocked` (protected) |
| **다형성** | `__str__()`, `withdraw()` 각 자식 클래스에서 오버라이딩 |
| **추상화** | `BankAccount`를 ABC로, `__str__()` 추상 메소드 |

## 전체 클래스 다이어그램

구현 전에 클래스 간 관계를 정리하면 다음과 같다.

```
BankAccount (ABC, 추상 클래스)
├── __account_number: str (private)
├── __balance: float (private)
├── owner: str (public)
├── deposit(amount): float
├── withdraw(amount): float
└── __str__(): str (abstractmethod)

SavingsAccount(BankAccount)
├── __interest_rate: float (private)
├── _withdrawal_blocked: bool (protected)
├── release_block(): None
├── withdraw(amount): float (override)
└── __str__(): str (override)

CheckingAccount(BankAccount)
├── __withdrawal_limit: float (private)
├── set_limit(limit): None
├── withdraw(amount): float (override)
└── __str__(): str (override)

BankCustomer
├── name: str
├── __cash: float (private)
├── __accounts: list (private)
├── add_account(account): None
├── list_accounts(): None
├── add_cash(amount): None
├── deduct_cash(amount): None
└── show_assets(): None
```

## 구현: BankAccount 부모 클래스

```python
import random
from abc import ABC, abstractmethod

class BankAccount(ABC):
    """
    모든 계좌 유형의 공통 속성과 기능을 정의하는 추상 기반 클래스.
    직접 인스턴스화 불가. SavingsAccount, CheckingAccount에서 상속받아 사용.
    """

    def __init__(self, owner: str, initial_amount: float) -> None:
        # 계좌번호: 8자리 랜덤 숫자, 외부 변경 불가 (private)
        self.__account_number = str(random.randint(10000000, 99999999))
        # 잔액: 직접 변경 불가 (private), deposit/withdraw 메소드를 통해서만 변경
        self.__balance = initial_amount
        # 소유주: 변경이 필요한 경우가 있으므로 public
        self.owner = owner

    @property
    def account_number(self) -> str:
        """계좌번호 읽기 전용 접근 제공."""
        return self.__account_number

    @property
    def balance(self) -> float:
        """잔액 읽기 전용 접근 제공. 외부에서 직접 수정 불가."""
        return self.__balance

    def deposit(self, amount: float) -> float:
        """
        입금 처리.
        입금액이 0 이하이면 ValueError 발생.
        성공 시 현재 잔액 반환.
        """
        if amount <= 0:
            raise ValueError("입금액은 0보다 커야 합니다.")
        self.__balance += amount
        return self.__balance

    def withdraw(self, amount: float) -> float:
        """
        출금 처리. 잔액 초과 출금 시 ValueError 발생.
        자식 클래스에서 추가 제약 조건과 함께 오버라이딩됨.
        """
        if amount > self.__balance:
            raise ValueError(
                f"잔액 부족: 현재 잔액은 ${self.__balance}입니다."
            )
        self.__balance -= amount
        return self.__balance

    @abstractmethod
    def __str__(self) -> str:
        """
        계좌 정보 출력 형식.
        자식 클래스마다 출력 형식이 다르므로 추상 메소드로 강제.
        """
        pass
```

`BankAccount`가 `ABC`를 상속받아 추상 클래스가 되는 순간,  
`BankAccount()`로 직접 인스턴스를 생성하려 하면 `TypeError`가 발생한다.  
이 설계 의도는 "계좌는 반드시 예금계좌나 입출금계좌 중 하나여야 한다"는  
비즈니스 규칙을 코드 수준에서 강제하는 것이다.

`__balance`를 `private`으로 설정하고 `@property`로 읽기 전용 접근만 제공하는 것은  
잔액이 `deposit()`과 `withdraw()`를 통해서만 변경되어야 한다는  
불변 규칙을 코드 구조로 표현한 것이다.

## 구현: SavingsAccount 예금계좌

```python
class SavingsAccount(BankAccount):
    """
    예금계좌 클래스.
    개설 시 출금이 제한되며, release_block() 호출 시
    이자가 지급되고 출금 제한이 해제됨.
    """

    def __init__(
        self,
        owner: str,
        initial_amount: float,
        interest_rate: float
    ) -> None:
        # 부모 클래스 생성자 호출: 계좌번호, 잔액, 소유주 초기화
        super().__init__(owner, initial_amount)
        # 이자율: 외부에서 임의 변경 불가 (private)
        self.__interest_rate = interest_rate
        # 출금 제한: 개설 시 True (제한 상태)
        # protected: 자식 클래스에서는 접근 가능하나 외부에서는 비권장
        self._withdrawal_blocked = True

    def release_block(self) -> None:
        """
        출금 제한 해제.
        해제 시 현재 잔액에 이자율을 곱한 이자가 자동 입금됨.
        이미 해제된 상태에서 재호출 시 안내 메시지 출력.
        """
        if not self._withdrawal_blocked:
            print("이미 출금 제한이 해제된 계좌입니다.")
            return

        interest = self.balance * self.__interest_rate
        self.deposit(interest)   # 부모 클래스의 deposit() 사용
        self._withdrawal_blocked = False
        print(
            f"출금 제한 해제 완료. "
            f"이자 ${interest:.2f} 입금. "
            f"현재 잔액: ${self.balance:.2f}"
        )

    def withdraw(self, amount: float) -> float:
        """
        출금 처리. 출금 제한 상태에서는 AttributeError 발생.
        제한 해제 후에는 부모 클래스의 잔액 초과 검증도 실행됨.
        """
        if self._withdrawal_blocked:
            raise AttributeError(
                "출금 제한 계좌입니다. release_block()을 먼저 호출하세요."
            )
        # 부모 클래스의 withdraw() 호출: 잔액 초과 검증 포함
        return super().withdraw(amount)

    def __str__(self) -> str:
        return (
            f"[예금/{self.account_number}] "
            f"잔액 ${self.balance:.2f}, "
            f"이율 {self.__interest_rate * 100:.1f}%, "
            f"출금 제한 여부: {self._withdrawal_blocked}"
        )
```

`SavingsAccount.withdraw()`에서 `super().withdraw(amount)`를 호출하는 부분이  
상속과 오버라이딩의 협력 방식을 잘 보여준다.  
`SavingsAccount`는 출금 제한이라는 자신만의 검증을 먼저 수행하고,  
통과하면 부모 클래스의 잔액 초과 검증에 위임한다.  
검증 로직이 중복 없이 각 클래스의 책임에 따라 분리되어 있다.

## 구현: CheckingAccount 입출금계좌

```python
class CheckingAccount(BankAccount):
    """
    입출금계좌 클래스.
    출금한도를 가지며 기본값은 $500.
    한도 초과 출금 시 ValueError 발생.
    """

    def __init__(
        self,
        owner: str,
        initial_amount: float,
        withdrawal_limit: float = 500
    ) -> None:
        super().__init__(owner, initial_amount)
        # 출금한도: set_limit()을 통해서만 변경 가능 (private)
        self.__withdrawal_limit = withdrawal_limit

    def set_limit(self, new_limit: float) -> None:
        """출금한도 변경. 0 이하의 한도는 허용하지 않음."""
        if new_limit <= 0:
            raise ValueError("출금한도는 0보다 커야 합니다.")
        self.__withdrawal_limit = new_limit
        print(f"출금한도가 ${self.__withdrawal_limit:.2f}로 변경되었습니다.")

    def withdraw(self, amount: float) -> float:
        """
        출금 처리. 출금한도 초과 시 ValueError 발생.
        한도 검증 통과 후 부모 클래스의 잔액 초과 검증 실행.
        """
        if amount > self.__withdrawal_limit:
            raise ValueError(
                f"출금한도 초과: 현재 한도는 ${self.__withdrawal_limit:.2f}입니다."
            )
        return super().withdraw(amount)

    def __str__(self) -> str:
        return (
            f"[입출금/{self.account_number}] "
            f"잔액 ${self.balance:.2f}, "
            f"출금한도 ${self.__withdrawal_limit:.2f}"
        )
```

`CheckingAccount`의 생성자에서 `withdrawal_limit: float = 500`처럼  
기본값을 설정한 것은 요구사항의 "기본값 $500, 필요 시 별도 설정 가능"을  
Python의 기본 매개변수(default parameter)로 자연스럽게 표현한 것이다.

## 구현: BankCustomer 은행 고객

```python
class BankCustomer:
    """
    은행 고객 클래스.
    현금과 계좌 목록을 관리하며 자산 현황을 조회할 수 있음.
    """

    def __init__(self, name: str, initial_cash: float = 0) -> None:
        self.name = name
        self.__cash = initial_cash          # private: deduct/add 메소드로만 변경
        self.__accounts = []                # private: add_account()로만 추가

    @property
    def cash(self) -> float:
        return self.__cash

    def add_account(self, account: BankAccount) -> None:
        """보유 계좌 목록에 새로운 계좌 추가."""
        self.__accounts.append(account)
        print(f"계좌 추가 완료: {account}")

    def list_accounts(self) -> None:
        """보유 계좌 목록 출력."""
        if not self.__accounts:
            print("보유 계좌 없음.")
            return
        print(f"\n{self.name}의 계좌 목록:")
        for account in self.__accounts:
            print(f"  {account}")

    def add_cash(self, amount: float) -> None:
        """현금 추가."""
        if amount <= 0:
            raise ValueError("추가할 현금은 0보다 커야 합니다.")
        self.__cash += amount

    def deduct_cash(self, amount: float) -> None:
        """현금 차감. 보유 현금 초과 차감 불가."""
        if amount > self.__cash:
            raise ValueError(
                f"현금 부족: 현재 보유 현금은 ${self.__cash:.2f}입니다."
            )
        self.__cash -= amount

    def show_assets(self) -> None:
        """보유 현금과 모든 계좌 정보 출력."""
        print(f"\n{'='*50}")
        print(f"{self.name}의 자산 현황")
        print(f"{'='*50}")
        print(f"보유 현금: ${self.__cash:.2f}")
        self.list_accounts()
        total = self.__cash + sum(
            account.balance for account in self.__accounts
        )
        print(f"\n총 자산: ${total:.2f}")
        print(f"{'='*50}\n")
```

`show_assets()`에서 `sum(account.balance for account in self.__accounts)`는  
다형성이 조용히 작동하는 지점이다.  
`__accounts` 리스트에는 `SavingsAccount`와 `CheckingAccount`가  
섞여서 들어있을 수 있다.  
하지만 둘 다 `BankAccount`를 상속받으므로 `balance` 속성을 가진다.  
타입을 확인하는 코드 없이 일관되게 처리된다.

## 시나리오 1: 예금 만기 후 자금 이동

```python
print("\n" + "="*60)
print("시나리오 1: 고객 A의 예금 만기 및 자금 이동")
print("="*60)

# 고객 A 생성: 초기 현금 $1000
customer_a = BankCustomer("고객 A", initial_cash=1000)

# 입출금계좌 개설: $200 저축
checking = CheckingAccount("고객 A", initial_amount=200)
customer_a.deduct_cash(200)    # 현금 $200 차감
customer_a.add_account(checking)

# 예금계좌 개설: $800 저축, 이자율 5%
savings = SavingsAccount("고객 A", initial_amount=800, interest_rate=0.05)
customer_a.deduct_cash(800)    # 현금 $800 차감
customer_a.add_account(savings)

print(f"\n계좌 개설 직후 현금: ${customer_a.cash:.2f}")
# 현금: $0 (1000 - 200 - 800)

# 예금 만기 처리: 출금 제한 해제 + 이자 지급
print("\n--- 예금 만기 처리 ---")
savings.release_block()
# 이자: $800 * 0.05 = $40 → 잔액 $840

# 예금계좌에서 $400 출금 후 입출금계좌로 입금
print("\n--- 자금 이동 ---")
withdrawn = savings.withdraw(400)
print(f"예금계좌 출금 $400 완료. 예금 잔액: ${withdrawn:.2f}")

checking.deposit(400)
print(f"입출금계좌 입금 $400 완료. 입출금 잔액: ${checking.balance:.2f}")

# 최종 자산 현황 출력
customer_a.show_assets()

# 예상 출력:
# 예금계좌: $840 - $400 = $440
# 입출금계좌: $200 + $400 = $600
# 현금: $0
# 총 자산: $1040 ($40 이자 수익)
```

시나리오 1에서 주목할 설계 포인트는  
`release_block()` 내부에서 이자 계산과 입금이 자동으로 처리된다는 것이다.  
외부 코드는 `savings.release_block()` 한 줄만 호출하면 되고,  
이자 계산 공식(`balance * interest_rate`)이 어떻게 되는지 알 필요가 없다.  
이것이 캡슐화가 "구현을 숨기고 인터페이스만 노출한다"는 말의 실제 의미다.

## 시나리오 2: 출금한도 초과 및 한도 변경

```python
print("\n" + "="*60)
print("시나리오 2: 고객 B의 출금한도 초과 및 한도 변경")
print("="*60)

# 고객 B 생성: 초기 현금 $900
customer_b = BankCustomer("고객 B", initial_cash=900)

# 입출금계좌 개설: $800 저축, 기본 출금한도 $500 적용
checking_b = CheckingAccount("고객 B", initial_amount=800)
customer_b.deduct_cash(800)
customer_b.add_account(checking_b)

# 예금계좌 개설: $100 저축, 이자율 6%
savings_b = SavingsAccount("고객 B", initial_amount=100, interest_rate=0.06)
customer_b.deduct_cash(100)
customer_b.add_account(savings_b)

print(f"\n계좌 개설 직후 현금: ${customer_b.cash:.2f}")
# 현금: $0 (900 - 800 - 100)

# 출금한도 초과 시도: $800 출금 (한도 $500 초과)
print("\n--- 출금한도 초과 시도 ---")
try:
    checking_b.withdraw(800)
except ValueError as e:
    print(f"출금 실패: {e}")
# 출금 실패: 출금한도 초과: 현재 한도는 $500.00입니다.

# 출금한도 $800으로 변경 후 재시도
print("\n--- 출금한도 변경 후 재시도 ---")
checking_b.set_limit(800)
withdrawn_b = checking_b.withdraw(800)
customer_b.add_cash(withdrawn_b + 800)
# 출금액을 현금으로 수령
# (withdrawn_b는 출금 후 잔액 $0, 실제 수령액은 $800)
customer_b.add_cash(800)   # 출금한 $800을 현금으로 추가

print(f"출금 성공. 입출금계좌 잔액: ${checking_b.balance:.2f}")

# 최종 자산 현황 출력
customer_b.show_assets()

# 예상 출력:
# 입출금계좌: $0
# 예금계좌: $100 (출금 제한 상태)
# 현금: $800
# 총 자산: $900
```

시나리오 2에서 `try-except` 블록으로 `ValueError`를 잡는 패턴은  
실무 코드에서 매우 중요한 방식이다.  
예외를 발생시키는 것과 처리하는 것을 분리하는 것이 핵심이다.  
`CheckingAccount.withdraw()`는 한도 초과 시 예외를 발생시키는 책임만 가진다.  
예외를 어떻게 처리할지는 이 메소드를 호출하는 쪽의 책임이다.  
이 분리가 코드의 재사용성을 높인다.

## OOP 원칙 적용 결과 분석

| 원칙 | 활용 방식 | 효과 |
|:---|:---|:---|
| **상속** | `super().withdraw()` 재사용 | 잔액 초과 검증 중복 제거, 수정 시 한 곳만 변경 |
| **추상화** | `BankAccount`를 ABC, `__str__()` 추상 메소드 | 직접 인스턴스화 차단, 출력 형식 구현 강제 |
| **캡슐화** | `__balance`, `__interest_rate` 등 private | 외부 직접 변경 차단, 데이터 무결성 보장 |
| **다형성** | `show_assets()`에서 동일 인터페이스 처리 | 새 계좌 유형 추가 시 코드 수정 불필요 |

## 실무 관점에서의 설계 시사점

| 판단 지점 | 선택 기준 |
|:---|:---|
| **상속 vs 합성** | is-a → 상속, has-a → 합성 (`BankCustomer`가 `__accounts` 포함) |
| **예외 타입 선택** | 값 오류 → `ValueError`, 속성 접근 불가 → `AttributeError` |
| **타입 힌트** | 실무 필수, IDE 자동완성 + 정적 분석(mypy) + 메소드 계약 명시 |

## 마무리

::: {.callout-tip}
**OOP 4대 원칙의 협력:**

- **상속**: 공통 로직 재사용
- **추상화**: 계약 강제
- **캡슐화**: 데이터 보호
- **다형성**: 확장성 확보

이 네 가지가 함께 작동할 때 "변경하기 쉽고, 확장하기 쉽고, 이해하기 쉬운" 코드가 만들어진다.
:::  
이 네 가지가 함께 작동할 때 비로소  
"변경하기 쉽고, 확장하기 쉽고, 이해하기 쉬운" 코드가 만들어진다.  
OOP는 문법이 아니라 복잡한 현실을 코드로 모델링하는  
사고 방식이라는 점을 이 프로젝트가 구체적으로 보여준다.

---

# 정리

이 글에서 다룬 OOP의 핵심 개념을 연결해서 보면 하나의 흐름으로 이어진다:

| 개념 | 역할 |
|:---|:---|
| **클래스** | 객체를 생성하기 위한 설계도, 속성과 메소드의 정의 |
| **객체** | 클래스로부터 생성된 독립적인 실체 |
| **생성자** | 인스턴스 생성 시 자동 호출되어 멤버 변수를 초기화 |
| **상속** | 기존 클래스를 기반으로 새로운 클래스를 정의, 코드 재사용 |
| **추상화** | 공통점을 추출해 상위 개념으로 정의, 설계 계약 강제 |
| **캡슐화** | 데이터를 보호하고 메소드를 통해서만 접근 허용 |
| **다형성** | 동일한 인터페이스가 객체 타입에 따라 다르게 동작 |

이 개념들이 함께 작동할 때 **예측 가능하고, 변경하기 쉽고, 확장하기 쉬운** 코드가 만들어진다.