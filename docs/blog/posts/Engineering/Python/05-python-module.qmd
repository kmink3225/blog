---
title: "함수와 모듈: 코드 재사용과 구조화의 핵심"
subtitle: "Functions and Modules in Python"
description: |
  파이썬에서 함수와 모듈은 코드 재사용성과 유지보수성을 높이는 핵심 도구이다. 이 글에서는 함수의 정의와 호출, 다양한 매개변수 유형, 변수의 스코프, 모듈과 패키지 시스템, 그리고 라이브러리 생태계와 가상환경까지 체계적으로 다룬다. 함수 설계부터 프로젝트 구조화까지 파이썬 개발의 기반을 다지는 내용이다.
categories:
  - Engineering
  - Python
author: Kwangmin Kim
date: 07/02/2023
draft: false
format: 
  html:
    toc: true
    number-sections: true
    code-fold: true
    page-layout: full
execute: 
  warning: false
  message: false
  eval: false
  echo: true
---

# 개요

이 글은 파이썬의 **함수(Function)**와 **모듈(Module)** 시스템을 체계적으로 다룬다. 다음과 같은 흐름으로 구성되어 있다:

1. **함수의 개념**: 함수란 무엇이며, 왜 필요한가
2. **함수의 구성요소**: 함수명, 매개변수, 본문, 반환값
3. **다양한 매개변수 유형**: 기본 매개변수, 키워드 인자, `*args`, `**kwargs`
4. **변수의 스코프**: 지역변수, 전역변수, LEGB 규칙
5. **모듈과 패키지**: 코드를 파일과 디렉토리로 조직화하는 방법
6. **라이브러리 생태계**: 표준 라이브러리, pip, 가상환경

# 함수란 무엇인가

## 함수의 정의

Wikipedia는 함수(function)를 다음과 같이 정의한다:

> "특정 작업을 수행하는 프로그램 명령 시퀀스를 하나의 단위로 패키지한 것"

이 정의에서 핵심은 두 가지다. 첫째, **특정 작업을 수행한다**는 것이고, 둘째, **하나의 단위로 패키지된다**는 것이다.

"하나의 단위로 패키지된다"는 표현을 실무적으로 풀어보면 이렇다. 어떤 작업을 수행하는 10줄짜리 코드가 있다고 가정하자. 이 코드가 프로그램 여러 곳에서 필요하다면, 함수 없이는 그 10줄을 필요한 곳마다 복사해서 붙여넣어야 한다. 이렇게 되면 나중에 그 로직을 수정할 때 복사한 곳을 모두 찾아서 바꿔야 하는데, 하나라도 놓치면 버그가 발생한다.

함수는 이 10줄을 하나의 이름이 붙은 단위로 묶어두고, 필요한 곳에서 그 이름을 호출하는 방식으로 문제를 해결한다. 수정이 필요하면 함수 내부 한 곳만 바꾸면 된다.

## 함수가 필요한 이유

함수의 장점을 실제 코드 수준에서 풀어보면 다음과 같다.

### 코드 재사용성

같은 로직을 반복해서 작성하지 않아도 된다. 데이터 과학 작업에서 전처리 로직을 함수로 만들어두면 훈련 데이터, 검증 데이터, 테스트 데이터에 동일한 함수를 적용할 수 있다. 코드 중복이 없으므로 한 곳을 수정하면 모든 적용 지점에 반영된다.

### 가독성 향상

함수명이 의도를 드러내기 때문에 코드 자체가 문서가 된다. `clean_missing_values(df)`라는 호출 한 줄은 그 내부의 10줄짜리 처리 코드보다 훨씬 빠르게 의도를 전달한다.

### 유지보수성 향상

로직이 한 곳에 집중되어 있으므로 수정 범위가 명확하다. 결측값 처리 전략을 바꿔야 한다면 `clean_missing_values` 함수 내부만 수정하면 된다.

# 함수의 구성요소

Python에서 함수는 4가지 요소로 구성된다.

```python
def sum(num1, num2):
    print(f"첫 번째 숫자: {num1}")
    print(f"두 번째 숫자: {num2}")
    return num1 + num2
```

## 함수명 (Function Name)

함수 바깥에서 이 함수를 호출하기 위한 식별자이다. 위 예시에서는 `sum`이 함수명이다. 좋은 함수명은 함수가 무엇을 하는지 이름만 봐도 알 수 있어야 한다. `sum`, `calculate_tax`, `load_dataset`처럼 동사 또는 동사+명사 조합이 일반적이다.

## 매개변수 (Parameters)

함수가 실행되는 데 필요한 입력값의 자리표시자이다. 위 예시에서는 `num1`, `num2`가 매개변수이다. 매개변수는 함수 정의 시점에는 실제 값이 없고, 함수가 호출될 때 전달된 인자(argument)와 연결되어 값을 갖게 된다.

## 본문 (Function Body)

함수가 호출되었을 때 실제로 실행되는 명령문의 집합이다. 들여쓰기(indent)로 함수 바깥 코드와 구분된다. Python에서 들여쓰기는 단순한 스타일 규칙이 아니라 코드 블록의 소속을 결정하는 문법적 요소이다.

## 반환값 (Return Value)

함수 실행이 완료된 후 호출한 곳으로 돌려주는 결과값이다. `return` 키워드 뒤에 반환할 표현식을 작성한다. 반환값이 없는 함수는 `return`을 생략할 수 있으며, 이 경우 Python은 자동으로 `None`을 반환한다.

# 함수 정의와 호출

## 함수 정의 문법

Python에서 함수를 정의하는 기본 문법은 다음과 같다:

```python
def 함수명(매개변수1, 매개변수2, ...):
    # 본문
    return 반환값
```

### 핵심 규칙 3가지

**규칙 1: 정의만으로는 코드가 실행되지 않는다**

`def` 블록을 작성하는 것은 함수의 존재를 등록하는 것이지 실행하는 것이 아니다. 함수 내부의 코드는 호출이 발생하는 순간에만 실행된다.

**규칙 2: 같은 이름으로 다시 정의하면 이전 함수가 사라진다**

Python은 함수 이름을 일반 변수와 동일하게 취급한다. 따라서 같은 이름으로 함수를 두 번 정의하면 두 번째 정의가 첫 번째를 완전히 덮어쓴다.

**규칙 3: return을 만나는 순간 함수는 종료된다**

`return` 이후의 코드는 실행되지 않는다. 이것은 조기 반환(early return) 패턴으로 활용할 수 있다:

```python
def divide(a, b):
    if b == 0:
        return None   # 조기 반환: 이 이후 코드는 실행되지 않는다
    return a / b      # b가 0이 아닌 경우에만 도달
```

## 함수 호출

```python
def sum(num1, num2):
    print(f"첫 번째 숫자: {num1}")
    print(f"두 번째 숫자: {num2}")
    return num1 + num2

result = sum(1, 5)   # 이 시점에 비로소 함수 내부가 실행된다
print(result)        # 6
```

## Parameter vs Argument

이 두 용어는 일상적으로 혼용되지만, 엄밀히는 다른 것을 가리킨다.

| 용어 | 시점 | 의미 |
|:---|:---|:---|
| **매개변수(Parameter)** | 함수 **정의** 시 | 자리표시자(placeholder) |
| **인자(Argument)** | 함수 **호출** 시 | 실제로 전달하는 값 |

```python
def sum(num1, num2):   # num1, num2가 매개변수(Parameter)
    return num1 + num2

result = sum(1, 5)     # 1, 5가 인자(Argument)
```

---

# 다양한 매개변수 유형

Python은 매개변수 설계를 위한 여러 가지 도구를 제공한다. 기본 매개변수, 키워드 인자, `*args`, `**kwargs`가 그것이다.

## 기본 매개변수 (Default Parameter)

함수를 호출할 때 해당 인자를 전달하지 않으면 자동으로 사용되는 값을 미리 지정하는 기능이다.

```python
def study(name, language="python"):
    print(f"{name} 님은 {language} 수업 중입니다.")

study("철수")              # 철수 님은 python 수업 중입니다.
study("영희", "java")      # 영희 님은 java 수업 중입니다.
```

**주의: 기본 매개변수는 일반 매개변수 뒤에 위치해야 한다.**

### 가변 객체를 기본값으로 사용할 때의 함정

리스트나 딕셔너리 같은 가변 객체(mutable object)를 기본값으로 지정하면 예상치 못한 동작이 발생한다:

```python
# 위험한 패턴
def append_item(item, container=[]):
    container.append(item)
    return container

print(append_item(1))   # [1]
print(append_item(2))   # [1, 2] <- 의도와 다른 결과!
```

해결책은 기본값을 `None`으로 지정하고 함수 내부에서 새로운 객체를 생성하는 것이다:

```python
# 올바른 패턴
def append_item(item, container=None):
    if container is None:
        container = []
    container.append(item)
    return container
```

## 키워드 인자 (Keyword Argument)

호출 시 매개변수 이름을 명시해서 값을 전달하는 방식이다. 인자의 순서에 관계없이 원하는 매개변수에 값을 전달할 수 있다.

```python
def greet(name, greeting):
    print(greeting, name)

greet(name="Alice", greeting="Hello")   # 순서 무관
greet(greeting="Hi", name="Bob")        # 순서를 바꿔도 동일하게 동작
```

키워드 인자의 장점:

- **명시성**: `train_model(learning_rate=0.001, epochs=100, batch_size=32)`가 `train_model(0.001, 100, 32)`보다 훨씬 명확하다.
- **안전성**: 함수 시그니처가 변경되어 매개변수 순서가 바뀌더라도 키워드 인자로 호출하는 코드는 영향을 받지 않는다.

## 가변 인자 리스트 (`*args`)

몇 개의 인자가 전달될지 미리 알 수 없는 경우, `*args`를 사용한다. 매개변수 이름 앞에 `*`를 붙이면 전달된 위치 인자를 모두 **튜플**로 묶어서 받는다.

```python
def add_numbers(*args):
    result = 0
    for num in args:
        result += num
    return result

add_numbers(1)                    # args = (1,)
add_numbers(1, 10, -10, 5)        # args = (1, 10, -10, 5)
add_numbers(1, 2, 3, 10, 100, 50) # args = (1, 2, 3, 10, 100, 50)
```

## 키워드 가변 인자 리스트 (`**kwargs`)

`*args`가 위치 인자를 가변적으로 받는다면, `**kwargs`는 키워드 인자를 가변적으로 받는다. 매개변수 이름 앞에 `**`를 붙이면 전달된 키워드 인자를 모두 **딕셔너리**로 묶어서 받는다.

```python
def print_kv(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_kv(name="alpha", age=10)
# name: alpha
# age: 10
```

## 매개변수 순서 규칙

일반 매개변수, `*args`, `**kwargs`를 함께 사용할 때는 반드시 다음 순서를 지켜야 한다:

```
일반 매개변수 → 기본 매개변수 → *args → **kwargs
```

```python
def display_info(name, *args, **kwargs):
    print("Name:", name)
    print("Known Languages:", ', '.join(args))
    for key, value in kwargs.items():
        print(f"{key}: {value}")

display_info("Alice", "python", "java", age=30, country="KR")
```

| 유형 | 문법 | 내부 자료형 | 위치 |
|:---|:---|:---|:---|
| 일반 매개변수 | `param` | 단일 값 | 가장 앞 |
| 기본 매개변수 | `param=value` | 단일 값 | 일반 뒤 |
| 가변 인자 | `*args` | tuple | 기본 뒤 |
| 키워드 가변 인자 | `**kwargs` | dict | 가장 뒤 |

---

# 변수의 스코프

## 스코프(Scope)란?

스코프는 변수가 유효하게 접근될 수 있는 코드의 범위를 의미한다. Python은 변수를 참조할 때 **LEGB 규칙**을 따른다:

- **L**ocal(지역) → **E**nclosing(둘러싸는) → **G**lobal(전역) → **B**uilt-in(내장)

핵심은 **안에서 바깥은 보이지만, 바깥에서 안은 보이지 않는다**는 것이다.

```python
# 함수 안에서 만든 변수를 바깥에서 접근하려는 시도
def func():
    var = "variable"
    print(var)   # 함수 내부에서는 정상 동작

print(var)   # NameError: name 'var' is not defined
```

```python
# 함수 바깥에서 만든 변수를 함수 안에서 접근하려는 시도
var = "variable"
def func():
    print(var)   # 정상 동작 (전역변수 읽기 가능)
```

## 지역변수 vs 전역변수

| 구분 | 지역변수 (Local) | 전역변수 (Global) |
|:---|:---|:---|
| **정의 위치** | 함수 내부 | 함수 바깥(모듈 최상위) |
| **생명주기** | 함수 호출 시 생성, 종료 시 소멸 | 프로그램 실행 내내 존재 |
| **접근 범위** | 해당 함수 내부에서만 | 어디서든 읽기 가능 |

## global 키워드

함수 내부에서 전역변수를 **수정**해야 하는 경우, `global` 키워드를 사용한다:

```python
count = 0

def increment():
    global count   # 이 변수는 전역변수임을 명시
    count += 1

increment()
increment()
print(count)   # 2
```

그러나 `global` 키워드는 신중하게 사용해야 한다. 전역변수를 여러 함수에서 수정하기 시작하면 어느 함수가 언제 값을 바꿨는지 추적하기 어려워진다. 실무에서는 함수가 새로운 값을 **반환**하고 호출자가 그 값을 관리하는 방식을 선호한다:

```python
# 반환값 사용 - 더 나은 방식
def increment(count):
    return count + 1

count = 0
count = increment(count)
count = increment(count)
```

---

# 모듈과 패키지

## 모듈이란?

모듈은 Python 정의와 문장을 담고 있는 `.py` 파일이다. 함수, 변수, 클래스 등 Python으로 작성할 수 있는 모든 것을 포함할 수 있다.

```python
# calc.py - 이 파일 자체가 calc라는 모듈이 된다
def add(a, b):
    return a + b

def sub(a, b):
    return a - b
```

모듈이 제공하는 핵심 가치는 **재사용성**과 **네임스페이스 분리**이다.

## 모듈 가져오기: import의 세 가지 방식

### 방식 1: `import 모듈명`

```python
import calc

print(calc.add(3, 4))   # 7
```

어떤 함수가 어느 모듈에서 왔는지 코드를 읽는 사람이 즉시 알 수 있다. 대규모 프로젝트에서 가장 안전한 방식이다.

### 방식 2: `from 모듈명 import 개체명`

```python
from calc import add, sub

print(add(3, 4))   # 모듈명 없이 바로 사용
```

코드가 간결해지지만, 여러 모듈에서 같은 이름의 함수를 가져오면 충돌이 발생할 수 있다.

### 방식 3: `from 모듈명 import *` (권장하지 않음)

```python
from calc import *   # calc의 모든 것을 가져옴
```

어떤 이름들이 어디서 들어왔는지 추적하기 어렵고, 예상치 못한 이름 충돌이 발생할 수 있다.

## `__name__ == "__main__"` 패턴

모듈을 직접 실행할 때와 import할 때의 동작을 분리하는 패턴이다:

```python
# calc.py
def add(a, b):
    return a + b

if __name__ == "__main__":
    # 이 블록은 이 파일을 직접 실행할 때만 동작한다
    print(add(3, 4))   # 테스트 코드
```

`__name__`은 Python이 모든 모듈에 자동으로 부여하는 특수 변수이다. 파일을 직접 실행하면 `"__main__"`이 되고, import되면 모듈 이름(예: `"calc"`)이 된다.

## 패키지란?

패키지는 모듈들을 디렉토리 계층구조로 조직화하는 방법이다:

```
my_package/
    __init__.py
    module1.py
    module2.py
    subpackage/
        __init__.py
        module3.py
```

`__init__.py`는 해당 디렉토리가 Python 패키지임을 알려주는 파일이다. 패키지가 import될 때 자동으로 실행된다.

---

# 라이브러리 생태계

## 모듈, 패키지, 라이브러리의 계층 관계

```
모듈 (.py 파일 하나)
  └─ 패키지 (모듈들을 담은 디렉토리)
       └─ 라이브러리 (패키지들의 모음, 특정 목적을 위한 완결된 도구)
```

예를 들어 `numpy`는 라이브러리이다. 내부적으로는 `numpy.core`, `numpy.linalg`, `numpy.random` 같은 여러 패키지로 구성되어 있다.

## 표준 라이브러리

Python을 설치하면 표준 라이브러리(Standard Library)가 함께 설치된다. 추가 설치 없이 `import`만으로 바로 사용할 수 있다.

| 라이브러리 | 용도 | 예시 |
|:---|:---|:---|
| `random` | 난수 생성 | `random.randint(1, 10)` |
| `math` | 수학 연산 | `math.sqrt(25)` |
| `datetime` | 날짜/시간 | `datetime.date.today()` |
| `os` | 운영체제 인터페이스 | `os.getcwd()` |

## 외부 라이브러리와 pip

표준 라이브러리가 커버하지 못하는 전문적인 기능은 외부 라이브러리를 통해 얻는다. `pip`으로 설치한다:

```bash
# 기본 설치
python -m pip install pandas

# 특정 버전 설치
python -m pip install pandas==2.0.0

# 여러 패키지 동시 설치
python -m pip install numpy pandas scikit-learn
```

## requirements.txt

프로젝트가 의존하는 라이브러리와 그 버전을 명시적으로 기록한 파일이다:

```text
# requirements.txt
numpy==1.24.0
pandas==2.0.0
scikit-learn==1.3.0
```

```bash
# requirements.txt에 명시된 라이브러리 전체 설치
python -m pip install -r requirements.txt

# 현재 환경의 설치 목록을 requirements.txt로 저장
python -m pip freeze > requirements.txt
```

## 가상환경

프로젝트별로 완전히 독립된 Python 환경을 만들어서 각 환경에 서로 다른 버전의 라이브러리를 설치할 수 있게 한다:

```bash
# 가상환경 생성
python -m venv myproject_env

# 가상환경 활성화 (Windows)
myproject_env\Scripts\activate

# 가상환경 활성화 (macOS/Linux)
source myproject_env/bin/activate

# 활성화 후 라이브러리 설치 (가상환경 안에만 설치됨)
pip install pandas numpy

# 가상환경 비활성화
deactivate
```

# 정리

이 글에서 다룬 내용을 연결해서 보면 하나의 흐름으로 이어진다:

| 개념 | 역할 |
|:---|:---|
| **함수** | 반복되는 코드를 재사용 가능한 단위로 묶는다 |
| **모듈** | 관련 함수들을 파일 단위로 조직화한다 |
| **패키지** | 관련 모듈들을 디렉토리 계층으로 묶는다 |
| **라이브러리** | 특정 목적을 위한 패키지들의 완결된 집합이다 |
| **가상환경** | 프로젝트별로 독립된 라이브러리 환경을 보장한다 |

이 계층 구조 전체가 하나의 목표를 향한다: **작성한 코드를 안전하게 재사용하고, 팀원과 공유하고, 다른 환경에서도 동일하게 실행되도록 만드는 것**이다.