---
title: "AI Agent Platform Architecture Design"
subtitle: "세 가지 관점 비교: 플랫폼 엔지니어링 vs 소프트웨어 아키텍처 vs 시스템 엔지니어링"
description: |
  AI 에이전트 플랫폼 구축 시 직면하는 아키텍처 설계 문제를 세 가지 관점에서 체계적으로 비교 분석한다.
  플랫폼 엔지니어링(Platform Engineering), 소프트웨어 아키텍처(Software Architecture), 
  시스템 엔지니어링(Systems Engineering) 각 관점의 정의, 핵심 질문, 담당 역할을 명확히 하고,
  AI 에이전트 플랫폼 설계에 가장 적합한 관점을 선택한다.
  모노레포 vs 멀티레포, 모듈 아키텍처, 인터페이스 표준화, 운영 자동화 등 
  실무 설계 고민 사항과 sociotechnical architecture design 원칙을 다루며,
  지속 가능한 플랫폼 구축을 위한 체계적 접근 방법을 제시한다.
categories:
  - Software Architecture
  - Platform Engineering
  - AI Agent
  - System Design
author: Kwangmin Kim
date: 01/27/2026
format: 
  html:
    code-fold: true
    toc: true
    number-sections: true
draft: False
---

## base_agent.py - Agent의 기본 인터페이스

**역할**: 모든 agent가 상속해야 하는 추상 기본 클래스

**포함되어야 할 기능**:

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from enum import Enum

class AgentStatus(Enum):
    IDLE = "idle" 
    PROCESSING = "processing"
    COMPLETED = "completed"
    ERROR = "error"

class BaseAgent(ABC):
    """모든 agent의 기본 인터페이스"""
    
    def __init__(self, agent_id: str, config: Dict[str, Any]):
        self.agent_id = agent_id
        self.config = config
        self.status = AgentStatus.IDLE
        self.metadata = {}
        
    # 핵심 추상 메서드 (모든 agent가 반드시 구현)
    @abstractmethod
    def process(self, input: Dict[str, Any]) -> Dict[str, Any]:
        """Agent의 핵심 로직"""
        pass
    
    @abstractmethod
    def validate_input(self, input: Dict[str, Any]) -> bool:
        """입력 데이터 검증"""
        pass
    
    @abstractmethod
    def validate_output(self, output: Dict[str, Any]) -> bool:
        """출력 데이터 검증"""
        pass
    
    # 공통 기능 (모든 agent가 공유)
    def get_status(self) -> AgentStatus:
        """현재 agent 상태 반환"""
        return self.status
    
    def get_metadata(self) -> Dict[str, Any]:
        """Agent 메타데이터 (버전, 설명 등)"""
        return self.metadata
    
    def log(self, level: str, message: str):
        """표준화된 로깅"""
        # shared.logging 호출
        pass
    
    # 평가 및 모니터링
    def evaluate(self, ground_truth: Any, prediction: Any) -> float:
        """성능 평가"""
        pass
    
    def get_metrics(self) -> Dict[str, float]:
        """실행 메트릭 (응답 시간, 토큰 사용량 등)"""
        pass
```

## lifecycle.py - Agent의 생명주기 관리

**역할**: Agent의 생성, 초기화, 실행, 종료 등 생명주기 관리

**포함되어야 할 기능**:

```python
from typing import Optional, Dict, Any
from enum import Enum

class LifecycleStage(Enum):
    CREATED = "created"
    INITIALIZED = "initialized"
    READY = "ready"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPED = "stopped"
    FAILED = "failed"

class AgentLifecycle:
    """Agent의 전체 생명주기 관리"""
    
    def __init__(self, agent: BaseAgent):
        self.agent = agent
        self.stage = LifecycleStage.CREATED
        self.history = []  # 생명주기 이벤트 기록
        
    # 생명주기 단계
    def initialize(self, config: Dict[str, Any]) -> bool:
        """
        Agent 초기화
        - 설정 파일 로드
        - 필요한 리소스 준비 (LLM 클라이언트, DB 연결 등)
        - 의존성 체크
        """
        self.stage = LifecycleStage.INITIALIZED
        self._log_event("initialized", config)
        return True
    
    def start(self) -> bool:
        """
        Agent 시작
        - 헬스체크
        - 준비 상태 확인
        """
        self.stage = LifecycleStage.RUNNING
        self._log_event("started")
        return True
    
    def pause(self) -> bool:
        """Agent 일시 정지 (긴 작업 중단)"""
        self.stage = LifecycleStage.PAUSED
        return True
    
    def resume(self) -> bool:
        """Agent 재개"""
        self.stage = LifecycleStage.RUNNING
        return True
    
    def stop(self, graceful: bool = True) -> bool:
        """
        Agent 종료
        - graceful=True: 현재 작업 완료 후 종료
        - graceful=False: 즉시 종료
        """
        if graceful:
            # 현재 작업 완료 대기
            pass
        self._cleanup()
        self.stage = LifecycleStage.STOPPED
        return True
    
    def restart(self) -> bool:
        """Agent 재시작"""
        self.stop()
        self.initialize(self.agent.config)
        self.start()
        return True
    
    def handle_error(self, error: Exception):
        """
        에러 처리
        - 로깅
        - 복구 시도
        - 필요시 재시작
        """
        self.stage = LifecycleStage.FAILED
        self._log_event("error", {"error": str(error)})
        
    # 헬스체크
    def health_check(self) -> Dict[str, Any]:
        """
        Agent 상태 확인
        - 리소스 사용률
        - 응답성 체크
        - 의존성 상태
        """
        return {
            "stage": self.stage.value,
            "healthy": self.stage == LifecycleStage.RUNNING,
            "uptime": self._get_uptime(),
            "memory_usage": self._get_memory_usage()
        }
    
    # 내부 유틸리티
    def _cleanup(self):
        """리소스 정리 (DB 연결 종료, 파일 닫기 등)"""
        pass
    
    def _log_event(self, event: str, data: Optional[Dict] = None):
        """생명주기 이벤트 기록"""
        self.history.append({
            "event": event,
            "timestamp": datetime.now(),
            "data": data
        })
```

## orchestrator.py - 여러 Agent 간 협업 조율

**역할**: 여러 agent를 조합하여 복잡한 워크플로우 실행

**포함되어야 할 기능**:

```python
from typing import List, Dict, Any, Optional
from enum import Enum

class ExecutionMode(Enum):
    SEQUENTIAL = "sequential"  # 순차 실행
    PARALLEL = "parallel"      # 병렬 실행
    CONDITIONAL = "conditional" # 조건부 실행
    PIPELINE = "pipeline"      # 파이프라인 (이전 출력 → 다음 입력)

class AgentOrchestrator:
    """여러 agent를 조율하여 복잡한 워크플로우 실행"""
    
    def __init__(self):
        self.agents = {}  # agent_id -> BaseAgent
        self.workflows = {}  # workflow_id -> WorkflowDefinition
        
    # Agent 등록 및 관리
    def register_agent(self, agent_id: str, agent: BaseAgent):
        """Agent를 orchestrator에 등록"""
        self.agents[agent_id] = agent
    
    def unregister_agent(self, agent_id: str):
        """Agent 등록 해제"""
        if agent_id in self.agents:
            del self.agents[agent_id]
    
    # 워크플로우 정의
    def create_workflow(
        self, 
        workflow_id: str,
        steps: List[Dict[str, Any]],
        mode: ExecutionMode = ExecutionMode.SEQUENTIAL
    ):
        """
        워크플로우 정의
        
        예시:
        steps = [
            {"agent": "code_analyzer", "input": {...}},
            {"agent": "data_standardizer", "input": {...}},
            {"agent": "knowledge_qna", "input": "from_previous"}
        ]
        """
        self.workflows[workflow_id] = {
            "steps": steps,
            "mode": mode
        }
    
    # 실행
    def execute_workflow(
        self, 
        workflow_id: str, 
        initial_input: Dict[str, Any]
    ) -> Dict[str, Any]:
        """워크플로우 실행"""
        workflow = self.workflows[workflow_id]
        mode = workflow["mode"]
        
        if mode == ExecutionMode.SEQUENTIAL:
            return self._execute_sequential(workflow["steps"], initial_input)
        elif mode == ExecutionMode.PARALLEL:
            return self._execute_parallel(workflow["steps"], initial_input)
        elif mode == ExecutionMode.PIPELINE:
            return self._execute_pipeline(workflow["steps"], initial_input)
    
    # 실행 모드별 구현
    def _execute_sequential(self, steps: List[Dict], input: Dict) -> Dict:
        """순차 실행"""
        results = []
        for step in steps:
            agent = self.agents[step["agent"]]
            result = agent.process(input)
            results.append(result)
        return {"results": results}
    
    def _execute_parallel(self, steps: List[Dict], input: Dict) -> Dict:
        """병렬 실행 (ThreadPoolExecutor 사용)"""
        from concurrent.futures import ThreadPoolExecutor, as_completed
        
        results = {}
        with ThreadPoolExecutor(max_workers=len(steps)) as executor:
            futures = {
                executor.submit(
                    self.agents[step["agent"]].process, 
                    input
                ): step["agent"] 
                for step in steps
            }
            
            for future in as_completed(futures):
                agent_id = futures[future]
                results[agent_id] = future.result()
        
        return results
    
    def _execute_pipeline(self, steps: List[Dict], input: Dict) -> Dict:
        """
        파이프라인 실행 (이전 agent 출력 → 다음 agent 입력)
        
        예: 코드 분석 → 표준화 → QnA 답변 생성
        """
        current_output = input
        
        for step in steps:
            agent = self.agents[step["agent"]]
            current_output = agent.process(current_output)
        
        return current_output
    
    # 조건부 실행 (지식 QnA의 동적 agent 선택)
    def route_to_agent(self, query: str, input: Dict) -> Dict[str, Any]:
        """
        쿼리 분석 후 적절한 agent로 라우팅
        
        예: 
        - "코드를..." → code_analyzer
        - "데이터 표준..." → data_standardizer
        """
        # 간단한 키워드 기반 라우팅 (실제로는 ML 분류기 사용)
        if "코드" in query or "함수" in query:
            return self.agents["code_analyzer"].process(input)
        elif "데이터" in query or "스키마" in query:
            return self.agents["data_standardizer"].process(input)
        else:
            return self.agents["knowledge_qna"].process(input)
    
    # 모니터링
    def get_workflow_status(self, workflow_id: str) -> Dict[str, Any]:
        """워크플로우 실행 상태 조회"""
        pass
    
    def get_agent_health(self) -> Dict[str, Dict]:
        """모든 등록된 agent의 헬스체크"""
        return {
            agent_id: agent.get_status() 
            for agent_id, agent in self.agents.items()
        }
```

## 실제 사용 예시

```python
# 1. Agent 정의 (개별 agent 구현)
class DataStandardizationAgent(BaseAgent):
    def process(self, input: Dict[str, Any]) -> Dict[str, Any]:
        # 데이터 표준화 로직
        return {"standardized_schema": "..."}
    
    def validate_input(self, input: Dict[str, Any]) -> bool:
        return "raw_schema" in input

# 2. Lifecycle로 agent 관리
agent = DataStandardizationAgent("data-std-v1", config)
lifecycle = AgentLifecycle(agent)
lifecycle.initialize(config)
lifecycle.start()

# 3. Orchestrator로 여러 agent 조합
orchestrator = AgentOrchestrator()
orchestrator.register_agent("code_analyzer", code_agent)
orchestrator.register_agent("data_standardizer", data_agent)
orchestrator.register_agent("knowledge_qna", qna_agent)

# 워크플로우 정의 및 실행
orchestrator.create_workflow(
    "analysis_pipeline",
    steps=[
        {"agent": "code_analyzer", "input": {...}},
        {"agent": "data_standardizer", "input": "from_previous"}
    ],
    mode=ExecutionMode.PIPELINE
)

result = orchestrator.execute_workflow("analysis_pipeline", initial_input)
```

이 세 파일이 core의 핵심이며, 이를 기반으로 모든 agent가 일관된 방식으로 동작하게 됩니다. 궁금한 점이 더 있으면 물어보세요!


정확한 지적입니다! 맞습니다. **LangChain과 LangGraph에 이미 이런 기능들이 구현되어 있습니다.**

## LangChain/LangGraph가 제공하는 것

### 1. BaseAgent 역할
- **LangChain의 `Agent`**: 기본 agent 추상화
- **`Runnable` 인터페이스**: 모든 컴포넌트의 공통 인터페이스 (`invoke`, `stream`, `batch`)
- **`Chain`**: 여러 단계를 연결하는 파이프라인

### 2. Lifecycle 역할
- **Callbacks**: 생명주기 이벤트 추적 (`on_chain_start`, `on_chain_end` 등)
- **LangSmith**: 모니터링, 로깅, 디버깅
- **Error handling**: 재시도, fallback 메커니즘

### 3. Orchestrator 역할
- **LangGraph**: 복잡한 agent 워크플로우 조율
  - 조건부 라우팅
  - 병렬 실행
  - 사이클 (반복 작업)
  - 상태 관리

## 그렇다면 실무에서는?

### 권장 접근: LangChain을 기반으로 도메인 특화 래퍼 구축

```python
# core/agent/base_agent.py
from langchain.agents import Agent
from langchain_core.runnables import Runnable
from typing import Dict, Any

class BaseAgent(Runnable):
    """
    LangChain Runnable을 상속하되,
    회사/프로젝트 특화 기능 추가
    """
    
    def __init__(self, agent_id: str, config: Dict[str, Any]):
        self.agent_id = agent_id
        self.config = config
        # LangChain agent 내부에서 사용
        self._langchain_agent = self._build_langchain_agent()
    
    def _build_langchain_agent(self):
        """LangChain agent 구성 (각 도메인에서 구현)"""
        pass
    
    # LangChain Runnable 인터페이스 구현
    def invoke(self, input: Dict[str, Any]) -> Dict[str, Any]:
        """LangChain의 표준 invoke 사용"""
        return self._langchain_agent.invoke(input)
    
    # 회사 특화 기능 추가
    def validate_company_policy(self, input: Dict) -> bool:
        """회사 정책 준수 여부 확인 (LangChain에는 없음)"""
        # 예: 민감 데이터 처리 규칙, 비용 제한 등
        pass
    
    def log_to_company_system(self, event: str):
        """회사 로깅 시스템 연동 (LangSmith 외 추가)"""
        pass
```

```python
# core/orchestration/orchestrator.py
from langgraph.graph import StateGraph, END
from typing import Dict, Any

class AgentOrchestrator:
    """
    LangGraph를 래핑하여 회사 특화 워크플로우 제공
    """
    
    def __init__(self):
        self.agents = {}
        self.graph = StateGraph(dict)  # LangGraph 사용
    
    def create_workflow(self, workflow_id: str, config: Dict):
        """
        LangGraph로 워크플로우 정의하되,
        회사 표준 패턴 제공
        """
        # 회사 표준 워크플로우 패턴
        if config["type"] == "approval_required":
            self._add_approval_node()  # 회사 특화
        
        # LangGraph 노드 추가
        self.graph.add_node("agent1", self.agents["agent1"])
        self.graph.add_node("agent2", self.agents["agent2"])
        
        # 조건부 라우팅 (LangGraph 기능)
        self.graph.add_conditional_edges(
            "agent1",
            self._route_based_on_output,
            {"continue": "agent2", "end": END}
        )
        
        return self.graph.compile()
```

## 실무적 권장사항

### ✅ 이렇게 하세요 (Best Practice)

**1. LangChain/LangGraph를 Foundation으로 사용**
```yaml
# pyproject.toml
dependencies = [
    "langchain>=0.1.0",
    "langgraph>=0.0.30",
    "langsmith>=0.1.0",  # 모니터링
]
```

**2. 회사/프로젝트 특화 레이어만 추가**
```python
core/
├── agent/
│   ├── base_agent.py          # LangChain Runnable 래핑
│   └── agent_registry.py      # 회사 특화: agent 등록/관리
├── orchestration/
│   ├── orchestrator.py        # LangGraph 래핑
│   └── workflow_templates.py  # 회사 특화: 표준 워크플로우
└── compliance/                # 회사 특화
    ├── policy_checker.py      # 데이터 처리 정책
    └── audit_logger.py        # 감사 로그
```

**3. 도메인 특화 기능만 직접 구현**
- 회사 정책 준수 검증
- 내부 시스템 연동 (DB, 모니터링)
- 도메인 특화 평가 메트릭
- 커스텀 프롬프트 템플릿 관리

### ❌ 이렇게 하지 마세요

**1. LangChain 기능을 처음부터 재구현**
```python
# ❌ 나쁜 예: 이미 LangChain에 있는데 다시 만듦
class CustomAgent:
    def __init__(self):
        # LLM 호출 로직 직접 구현
        # 재시도 로직 직접 구현
        # 스트리밍 직접 구현
        # ... (이미 LangChain에 다 있음)
```

**2. 모든 것을 직접 구현**
- 시간 낭비
- 버그 많음
- LangChain 생태계 혜택 못 받음 (LangSmith, 커뮤니티 도구)

## 당신의 프로젝트에 적용하면

```python
# agents/data_standardization/standardizer.py
from langchain.agents import AgentExecutor, create_openai_functions_agent
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from core.agent import BaseAgent  # 당신의 래퍼

class DataStandardizationAgent(BaseAgent):
    def _build_langchain_agent(self):
        """LangChain으로 실제 agent 구성"""
        llm = ChatOpenAI(model="gpt-4")
        
        prompt = ChatPromptTemplate.from_messages([
            ("system", "당신은 데이터 표준화 전문가입니다."),
            ("user", "{input}"),
            ("assistant", "{agent_scratchpad}"),
        ])
        
        # LangChain tools
        tools = [
            self._schema_analyzer_tool(),
            self._validation_tool()
        ]
        
        agent = create_openai_functions_agent(llm, tools, prompt)
        return AgentExecutor(agent=agent, tools=tools)
    
    def validate_company_policy(self, input: Dict) -> bool:
        """회사 특화: 민감 데이터 체크"""
        # 이런 건 직접 구현 (회사마다 다름)
        return not self._contains_pii(input)
```

```python
# core/orchestration/workflow.py
from langgraph.graph import StateGraph
from typing import TypedDict

class WorkflowState(TypedDict):
    input: str
    code_analysis: dict
    standardization: dict
    final_answer: str

def create_analysis_workflow():
    """LangGraph로 워크플로우 구성"""
    workflow = StateGraph(WorkflowState)
    
    # 노드 추가 (LangChain agent 사용)
    workflow.add_node("analyze_code", code_analyzer_agent)
    workflow.add_node("standardize", data_std_agent)
    workflow.add_node("answer", qna_agent)
    
    # 조건부 라우팅
    workflow.add_conditional_edges(
        "analyze_code",
        should_standardize,  # 회사 정책에 따라
        {True: "standardize", False: "answer"}
    )
    
    workflow.set_entry_point("analyze_code")
    
    return workflow.compile()
```

## 핵심 요약

| 항목 | LangChain 사용 | 직접 구현 |
|------|----------------|-----------|
| Agent 기본 구조 | ✅ LangChain Agent | ❌ |
| LLM 호출 | ✅ LangChain LLM | ❌ |
| 워크플로우 조율 | ✅ LangGraph | ❌ |
| 모니터링/로깅 | ✅ LangSmith | ❌ |
| **회사 정책 검증** | ❌ | ✅ 직접 구현 |
| **내부 시스템 연동** | ❌ | ✅ 직접 구현 |
| **도메인 특화 메트릭** | ❌ | ✅ 직접 구현 |

**결론**: "바퀴를 재발명하지 말고, LangChain 위에 회사 특화 레이어만 추가하라"

이게 실무에서 가장 효율적이고 안전한 접근입니다!