---
title: "AI Agent 플랫폼 저장소 전략: Monorepo에서 MSA로의 점진적 전환"
subtitle: "초기 개발부터 성숙 단계까지의 아키텍처 진화 전략"
description: |
  AI Agent를 지속적으로 생산하는 플랫폼 구축 시 직면하는 저장소 전략 문제를 실증 데이터와 산업 사례를 기반으로 분석한다.
  Monorepo와 Multi-repo의 trade-off를 정량적으로 비교하고, 팀 역량과 프로젝트 단계를 고려한 최적의 전환 전략을 제시한다.
  Google, Uber, Airbnb 등의 실제 사례를 통해 공통 모듈 재사용률, 개발 속도, 기술 부채 관리 측면에서의 구체적인 근거를 제공하며,
  안전하게 확장 가능한 플랫폼 아키텍처 설계 방법론을 다룬다.
categories:
  - Software Architecture
  - Platform Engineering
  - AI Agent
  - System Design  
author: Kwangmin Kim
date: 01/28/2026
format: 
  html:
    code-fold: true
    toc: true
    number-sections: true
draft: False
---

## 배경

AI Agent를 도메인별, 기능별로 지속적으로 생산하는 플랫폼을 구축할 때 가장 먼저 실무적으로 직면하는 설계 결정은 저장소(repository) 전략이다.  
하나의 플랫폼 저장소 안에 모든 agent를 하위 폴더로 관리할 것인가(Monorepo), 아니면 도메인별로 독립된 저장소를 생성할 것인가(Multi-repo)?  

이 질문은 단순히 코드를 어디에 저장할지의 문제가 아니다.  
배포 파이프라인, 의존성 관리, 공통 모듈 재사용, 팀 협업 방식, 그리고 장기적인 기술 부채 관리까지 모든 것에 영향을 미치는 전략적 선택이다.  

특히 다음과 같은 상황에서는 이 선택이 더욱 중요하다:  

- **프로젝트 초창기**: POC가 완료되고 본격적인 개발이 시작되는 단계  
- **공통 모듈 비중 높음**: 로깅, 모니터링, LLM 인터페이스 등 공통 SDK 개발 필요  
- **장기 로드맵 존재**: Docker + Kubernetes 기반 확장성 있는 아키텍처 지향  

글쓴이는 컴퓨터 공학 출신이 아닌 Data Scientist로서, 해당 내용의 지식이 부족하여 세 가지 주요 AI 서비스(Gemini, ChatGPT, Claude)와의 대화를 통해 글쓴이가 도출한 인사이트를 종합 및 요약하고, 실증 데이터와 산업 사례를 바탕으로 최적의 저장소 전략을 소개한다.  

## 프로젝트 현황 분석

### 현재 상태

**개발 단계**  
- POC 완료: 데이터 표준화 QnA chatbot, 데이터 표준화 도우미 agent 구현  
- 즉시 추가 예정: 코드베이스 분석 agent  
- 향후 계획: 도메인별 agent 지속 확장 (agent 양산 플랫폼)  

**팀 구성 및 제약사항**  
- PM(Data Scientist 출신)이 플랫폼 아키텍처 설계 주도  
- 리더급 백엔드 엔지니어 부재  
- 개발자들의 시스템 설계 및 비즈니스 고려 능력 제한  

**기술적 요구사항**  
- 공통 모듈 필요성 높음: SDK, 로그 분석 기능, 모니터링  
- 장기 로드맵: Docker + Kubernetes 기반 컨테이너 오케스트레이션  
- 각 agent의 성능 모니터링 및 관리 필요  

### 주요 Agent 특성

**지식 QnA Chatbot**  
- 문서 기반 여러 도메인 지식 응답  
- 여러 agent 통합 가능성 존재 (다른 agent를 백엔드에서 호출)  
- 사용자층: 혼합 (임원 및 여러 부서 공통 사용)  

**데이터 표준화 Agent**  
- 공통 모듈 생성 가능성 매우 높음  
- 여러 agent로 확장 예상 (스키마 분석, 매핑, 검증 등)  
- 사용자층: 데이터 관리자, 현업 담당자, 데이터 오너  

**코드베이스 분석 Agent**  
- 공통 모듈 생성 가능성 매우 높음  
- 여러 agent로 확장 예상 (AST 파싱, 의존성 분석, 리팩토링 제안 등)  
- 사용자층: 개발자, 연구원, 기획자  

이 세 가지 agent는 공통적으로 **높은 공통 모듈 재사용 가능성**과 **agent 간 협업 시나리오**를 가지고 있다.  

## 세 AI의 공통 권장사항: Monorepo 시작

Gemini, ChatGPT, Claude 세 AI 서비스 모두 동일한 결론에 도달했다.  

### 핵심 결론

**초기에는 Monorepo 구조로 시작**  
- Gemini: "모노레포 구조 강력히 추천"  
- ChatGPT: "지금은 단일 repo 고도화시 도메인별 폴더"  
- Claude: "Monorepo 구조를 강력히 권장"  

**공통 모듈의 중요성 강조**  
모든 AI가 LLM 인터페이스, 프롬프트 템플릿, 평가 프레임워크 등 공통 라이브러리 재사용이 핵심임을 지적했다.  
보통 기준 코드 재사용률은 30-70%에 달하는 것이 잘 설계된 플랫폼이다.  

**점진적 분리 전략 제안**  
처음부터 멀티레포로 시작하는 것은 비효율적이다.  
성숙 단계에서 필요시 선택적으로 분리하는 것이 안전하다.  

**공통 인프라 설계 우선**  
- BaseAgent 인터페이스 정의  
- Agent manifest/config 구조 표준화  
- 통합 CI/CD 파이프라인 구축  

### 정량적 근거

Claude가 제시한 산업 사례 데이터:  

**Google의 연구 (Potvin & Levenberg, 2016)**  
- 20억 줄 코드를 단일 저장소 관리  
- 코드 재사용률 35% 향상  
- 리팩토링 비용 60% 감소  

**Microsoft의 측정 결과**  
- Monorepo 전환 후 빌드 일관성 관련 버그 42% 감소  
- 의존성 충돌 발생률 78% 감소  

**Uber의 Michelangelo 플랫폼**  
- 100+ ML 모델을 Monorepo로 관리  
- 공통 모듈 재사용률 평균 67%  
- Feature engineering pipeline 재사용률 89%  

**Airbnb의 ML 플랫폼**  
- 초기 Polyrepo에서 공통 코드 중복으로 버그 전파 문제 발생  
- Monorepo 전환 후 새 도메인 agent 개발 시간 40% 단축  

## 세 AI의 차별화된 관점

각 AI는 서로 다른 관점에서 문제를 바라보았다.  

### Gemini: 비즈니스 및 거버넌스

**핵심 메시지**  
"지적 자산을 공유하는 플랫폼이라면 지식의 뿌리는 공유해야 한다"  

**주요 개념**  

**도메인 주도 설계(DDD, Domain Driven Design)**  
* 복잡한 비즈니스 로직을 도메인별로 분리하여 관리하는 설계 방법론이다.  
* 각 도메인별로 main agent(데이터 표준화, 코드 분석)를 독립적인 도메인으로 정의하고, 하위 agent들을 둘 수 있으며 도메인 전문가의 언어로 소프트웨어를 모델링한다.  
* 이를 통해 비즈니스 요구사항과 기술 구현 간의 간극을 줄일 수 있다.  

**Bounded Context**  
* DDD에서 특정 도메인 모델이 적용되는 명확한 경계를 의미한다.  
* 데이터 표준화 업무의 맥락(스키마, 규칙, 검증)과 코드 분석의 맥락(AST, 의존성, 리팩토링)은 서로 다른 Bounded Context에 속한다.  
* 이러한 경계를 명확히 하면 각 도메인이 독립적으로 진화할 수 있으면서도, 필요시 통합이 용이하다.  

**Multi-tenancy**  
* 하나의 플랫폼에서 여러 사용자 그룹(tenant)을 격리하여 서비스하는 아키텍처 패턴이다.  
* 데이터 관리자와 개발자라는 서로 다른 사용자 그룹이 동일한 플랫폼을 사용하지만, 각각 다른 agent와 기능에 접근한다.  
* 코드는 공유하되 배포와 접근 권한을 분리하여 보안과 효율성을 동시에 확보한다.  

**Micro-frontend**  
* 프론트엔드를 독립적인 기능 단위로 분리하여 개발하는 아키텍처 패턴이다.  
* 데이터 표준화 UI, 코드 분석 UI, QnA chatbot UI를 각각 독립적으로 개발하고 배포할 수 있다.  
* 이를 통해 사용자 그룹별로 최적화된 경험을 제공하면서도, 공통 플랫폼의 이점을 유지한다.  

**Ubiquitous Language**  
* 도메인 전문가와 개발자가 공통으로 사용하는 비즈니스 용어 체계다.  
* BT(생물학·진단 기술)와 IT 간의 용어 차이를 해소하기 위해, 모든 팀원이 동일한 용어로 소통한다.  
* 예: "데이터 표준화"를 "schema normalization"이 아닌 비즈니스 용어 그대로 사용  

**지식 흐름 설계**  
* 데이터 표준화 agent와 코드분석 agent가 생산한 지식이 QnA chatbot의 데이터 소스가 되는 선순환 구조가 이상적이다.  
* 각 agent가 생성한 문서, 규칙, 분석 결과는 벡터 DB에 저장되어, QnA chatbot이 RAG 방식으로 검색하여 답변에 활용한다.  
* 이는 단순한 기술 플랫폼을 넘어 조직의 지식 생태계를 구축하는 접근이다.  

### ChatGPT: 실무 엔지니어링

**핵심 메시지**  
"Core 분리 + Product 단위 repo 하이브리드 전략"  

**실용적 접근**  
- Agent 인터페이스 강제의 중요성 강조  
- "이 agent는 제품인가 실험인가" 구분 필요  
- Agent marketplace 런타임 개념 도입  

**하이브리드 구조 제안**  
```
agent-platform-core/          # Monorepo (핵심 플랫폼)
  ├── core/
  ├── shared/
  └── infra/

knowledge-qna-service/        # 독립 repo (공용 서비스)
data-standardization-product/ # 독립 repo (특정 사용자군)
code-analysis-product/        # 독립 repo (특정 사용자군)
```

지식 QnA chatbot은 제품이면서 동시에 "agent marketplace의 런타임" 역할을 한다.  

### Claude: 학술적·실증적

**핵심 메시지**  
"실증 데이터와 체계적 의사결정 프레임워크"  

**학술적 접근**  
- 논문 및 산업 사례 인용 (Google, Microsoft, Uber, Airbnb)  
- 정량적 메트릭 제시 (재사용률 67%, 버그 42% 감소)  
- 체크리스트 기반 의사결정 도구 제공  

**불확실성 영역 명시**  
- 팀 규모에 따른 영향  
- 릴리스 주기 차이  
- AI agent 특화 연구 부족 인정  

**측정 가능한 비교표**  

| 기준 | Monorepo | Polyrepo | 근거 |
|------|----------|----------|------|
| 공통 모듈 중복 | 0% | 45-60% | Airbnb 측정 |
| Agent 통합 테스트 | 가능 | 매우 어려움 | 3개 저장소 동기화 필요 |
| 새 Agent 추가 시간 | 2-3시간 | 1-2일 | Uber 측정 |
| 의존성 버전 충돌 | 없음 | 높음 (70%+) | LangChain, OpenAI SDK |

## 단계별 리스크 평가

### 옵션 1: 처음부터 Multi-repo (MSA)

**치명적 리스크**  
리더급 엔지니어 부재 상황에서 MSA 복잡도를 감당할 수 없다.  
마이크로서비스 아키텍처는 높은 운영 성숙도와 인프라 자동화를 요구한다.  

**기술적 문제**  
- 공통 모듈 중복 구현 → 기술 부채 급증  
- 버전 불일치로 인한 런타임 에러 위험  
- 초기 개발 속도 저하 (새 agent 추가 시간 2-3배)  
- 통합 테스트 불가능 (agent 조합 시나리오 검증 어려움)  

**운영 복잡도**  
- 여러 저장소 간 CI/CD 조율 필요  
- 공통 라이브러리 변경 시 모든 저장소에 PR 생성  
- 보안 패치 누락 위험 3.2배 증가 (Snyk 보고서, 2022)  

### 옵션 2: Monorepo 시작

**낮은 리스크**  
단순한 구조로 현재 팀 역량에 적합하다.  
하나의 저장소에서 모든 agent를 관리하므로 학습 곡선이 완만하다.  

**기술적 이점**  
- 공통 모듈 재사용으로 개발 속도 향상  
- 통합 테스트 및 버전 관리 용이  
- 원자적 변경(Atomic changes) 가능: 공통 라이브러리 수정 시 모든 agent 동시 업데이트  

**중간 리스크**  
프로젝트 성장 시 저장소 크기와 빌드 시간 증가 가능성  
하지만 Nx, Turborepo 같은 도구로 해결 가능  

### 옵션 3: Monorepo → MSA 점진적 전환

**최적 리스크 관리**  
초기 단순성과 미래 확장성을 동시에 확보한다.  
비즈니스 변화에 유연하게 대응 가능하다.  

**전환 시점 판단 기준**  
다음 중 2개 이상 충족 시 분리 고민:  
- [ ] 특정 도메인의 릴리스 주기가 다른 agent와 완전히 다름  
- [ ] 특정 agent만 외부 고객에게 배포 필요  
- [ ] 팀이 도메인별로 명확히 분리됨 (각 5명 이상)  
- [ ] Core 변경 없이 도메인만 독립 발전 가능  

**전환 비용**  
필요시에만 선택적 분리하므로 과도한 엔지니어링 방지  
Core를 pip 패키지로 배포하면 전환이 상대적으로 수월  

## 최종 권장 전략: Monorepo → 선택적 MSA

현재 상황에서 **옵션 3번이 유일한 정답**이다.  

### 명확한 근거

**팀 역량 현실**  
리더급 백엔드 엔지니어 부재 → 복잡한 MSA는 위험  
Monorepo는 관리가 단순하고 학습 곡선이 낮음  

**프로젝트 단계**  
POC 직후 초창기 → 구조 실험과 빠른 반복 필요  
Monorepo에서 agent 추가 비용이 매우 낮음 (2-3시간)  

**공통 모듈 비중**  
매우 높음 (SDK, 로그 분석, 공통 인프라)  
공통 모듈 재사용률이 30% 이상이면 Monorepo가 유리  

**Agent 특성**  
서로 조합 가능성 높음 (QnA가 다른 agent 호출)  
Agent 간 통신 프로토콜 표준화 필요 → Monorepo에서 강제 가능  

**실증 데이터 뒷받침**  
Google, Uber, Airbnb 사례 모두 초기 Monorepo에서 시작  
성공적인 플랫폼들은 Monorepo → 선택적 분리 경로를 따름  

### 의사결정 체크리스트

현재 상황에 적용:  

- ✅ 공통 모듈 재사용 >30%? → **YES** (SDK, 로깅, 공통 인프라)  
- ✅ Agent 간 협업 가능성? → **YES** (QnA가 다른 agent 호출)  
- ✅ 단일 팀 관리? → **YES**  
- ✅ 통합 테스트 필요? → **YES**  
- ✅ 초기 개발 속도 중요? → **YES** (POC 직후)  
- ✅ 리더급 엔지니어 부재? → **YES** (복잡한 MSA 위험)  

**결과: 6/6 항목이 Monorepo 선호 → Monorepo 시작이 명확한 답**  

## 구체적 실행 로드맵

### Phase 1: 초기 구축 (0-6개월, ~5개 agent)

**기본 구조**  

```
agent-platform/                # Monorepo
├── core/                      # 플랫폼 코어
│   ├── agent/
│   │   ├── base_agent.py     # 모든 agent의 부모 클래스
│   │   ├── lifecycle.py
│   │   └── orchestrator.py
│   ├── llm/
│   │   ├── clients/          # OpenAI, Anthropic 래퍼
│   │   ├── prompt_engine.py
│   │   └── context_manager.py
│   ├── memory/
│   ├── tools/
│   └── evaluation/
│
├── agents/                    # 도메인별 agent
│   ├── knowledge_qna/
│   │   ├── src/
│   │   ├── prompts/
│   │   └── tests/
│   ├── data_standardization/
│   │   ├── src/
│   │   ├── rules/
│   │   └── tests/
│   └── codebase_analysis/
│       ├── src/
│       ├── parsers/
│       └── tests/
│
├── shared/                    # 공통 모듈 (SDK)
│   ├── logging/              # 로그 분석 기능
│   ├── monitoring/           # 성능 모니터링
│   ├── document_processing/
│   └── vector_store/
│
├── infra/
│   ├── docker/
│   ├── k8s/                  # 미래 대비
│   └── ci_cd/
│
└── pyproject.toml            # 단일 의존성 관리
```

**핵심 설계 원칙**  

1. **Agent 간 직접 의존 금지**  
   각 agent는 `core`만 참조한다. Agent 간 직접 import를 금지한다.  

```python
# ❌ 절대 금지
from agents.data_standardization import Standardizer

# ✅ 반드시 이렇게
from core.agent import AgentRegistry
standardizer = AgentRegistry.get("data_standardization")
```

2. **공통 인터페이스 강제**  
   모든 agent는 BaseAgent를 상속해야 한다.  

```python
# shared/base/agent.py
from abc import ABC, abstractmethod
from typing import Dict, Any

class BaseAgent(ABC):
    """모든 agent가 상속해야 하는 기본 클래스"""
    
    @abstractmethod
    def process(self, input: Dict[str, Any]) -> Dict[str, Any]:
        """표준화된 입출력 인터페이스"""
        pass
    
    @abstractmethod
    def evaluate(self, ground_truth: Any, prediction: Any) -> float:
        """공통 평가 프레임워크"""
        pass
```

3. **Manifest 기반 관리**  
   각 agent는 설정 파일을 보유한다.  

```yaml
# agents/data_standardization/manifest.yaml
name: data_standardization_agent
version: "1.0.0"
domain: data_standardization
inputs:
  - raw_schema
outputs:
  - normalized_schema
tools:
  - regex_tool
  - schema_store
dependencies:
  - core.llm>=1.0.0
  - shared.logging>=1.0.0
```

**도구 선택**  
- Python: `Poetry` (의존성 관리)  
- Build tool: `Nx` (선택적, agent 5개 초과 시)  
- CI/CD: GitHub Actions (변경된 agent만 테스트)  
- 컨테이너: Docker Compose (로컬 개발), Kubernetes 준비  

**공통 모듈 예상 목록**  

| 모듈 | 재사용률 | 설명 |
|------|----------|------|
| `llm/` | ~100% | LLM API 호출, 프롬프트 템플릿 엔진 |
| `document_processing/` | ~80% | 문서 파싱 (PDF, Docx, 코드) |
| `vector_store/` | ~90% | RAG 인프라, 임베딩, 검색 |
| `validation/` | ~70% | 출력 검증, 품질 체크 |
| `evaluation/` | ~100% | 성능 평가, 벤치마크 |
| `logging/` | ~100% | 구조화된 로깅, 분석 |
| `monitoring/` | ~100% | 메트릭 수집, 대시보드 |

### Phase 2: 성장 단계 (6-12개월, 5-20개 agent)

**분리 신호 감지**  

다음 중 **2개 이상** 충족 시 선택적 분리 고민:  

- [ ] 특정 도메인의 릴리스 주기가 다른 agent와 완전히 다름  
- [ ] 특정 agent만 외부 고객에게 배포 필요  
- [ ] 팀이 도메인별로 명확히 분리됨 (각 5명 이상)  
- [ ] Core 변경 없이 도메인만 독립 발전 가능  

**하이브리드 구조 전환**  

```
agent-platform-core/          # Monorepo (핵심 플랫폼)
  ├── core/
  ├── shared/
  └── infra/

knowledge-qna-service/        # 독립 repo (공용 서비스)
  ├── agents/
  ├── ui/
  └── api/

data-standardization-product/ # 독립 repo (특정 사용자군)
code-analysis-product/        # 독립 repo (특정 사용자군)
```

**전환 전략**  
1. Core를 pip 패키지로 배포 (`agent-platform-core==1.0.0`)  
2. 독립 repo는 core에 의존 (`requirements.txt`에 명시)  
3. 공통 모듈은 계속 core에서 관리  
4. 변경 영향도 추적 시스템 구축 (어떤 agent가 영향받는지 자동 파악)  

**배포 분리 예시**  

```yaml
# k8s/data-std-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: data-std-agent
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: agent
        image: agent-platform-core:1.0.0  # 동일한 base image
        command: ["python", "-m", "agents.data_standardization"]
        env:
        - name: AGENT_TYPE
          value: "data_standardization"
```

### Phase 3: 성숙 단계 (12개월+, 20+ agent)

**완전 MSA 전환 고려** (필요시)  
- Agent별 독립 배포 파이프라인  
- Service mesh (Istio 등) 도입  
- Agent marketplace 플랫폼화  
- 각 agent의 SLA 독립 관리  

**단, 이 시점에도**  
- Core 플랫폼은 Monorepo 유지  
- 공통 SDK는 패키지 레지스트리로 관리  
- 표준 인터페이스 강제 유지  

## 반드시 피해야 할 실수

### 하지 말아야 할 것

**처음부터 멀티레포 구조로 시작**  
근거: 팀 역량 부족 + 공통 모듈 중복 → 개발 속도 50% 저하  
Claude의 측정 데이터: Polyrepo에서 공통 코드 45-60% 중복  

**Agent 간 직접 import**  

```python
# ❌ 절대 금지
from agents.data_standardization import Standardizer

# ✅ 반드시 이렇게
from core.agent import AgentRegistry
standardizer = AgentRegistry.get("data_standardization")
```

이렇게 하지 않으면 나중에 repo 분리가 불가능하다.  

**도구 없이 Monorepo 방치**  
Nx 또는 최소한 pre-commit hook 필수  
변경 영향도 분석 없이 코드 수정 시 예상치 못한 버그 발생  

**버전 관리 소홀**  
공통 라이브러리 breaking change 발생 시 모든 agent 영향  
Semantic versioning + Changelog 필수  

### 반드시 해야 할 것

**BaseAgent 인터페이스 초반에 확정**  
한번 정의하면 변경이 어려우므로 신중하게 설계  
입출력 스키마, 에러 처리, 로깅 규칙 포함  

**Agent manifest 파일 (YAML) 필수화**  
각 agent의 의존성, 버전, 설명을 명시적으로 관리  
자동화된 문서 생성 가능  

**통합 테스트 자동화**  
Agent 조합 시나리오 검증 필수  
QnA chatbot이 다른 agent를 호출하는 경우 통합 테스트 없이는 배포 불가  

**공통 모듈 변경 시 영향 범위 자동 확인**  

```yaml
# .github/workflows/ci.yml
name: Test Affected Agents
on: [push]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Detect changed modules
        id: changes
        run: |
          # core/ 또는 shared/ 변경 시 모든 agent 테스트
          if git diff --name-only HEAD~1 | grep -E '^(core|shared)/'; then
            echo "affected=all" >> $GITHUB_OUTPUT
          else
            # 특정 agent만 변경 시 해당 agent만 테스트
            echo "affected=$(git diff --name-only HEAD~1 | grep agents/ | cut -d'/' -f2 | sort -u)" >> $GITHUB_OUTPUT
          fi
      - name: Run tests
        run: pytest agents/${{ steps.changes.outputs.affected }}
```

## 사용자 그룹 분리와 저장소 전략

### 사용자 그룹이 다를 때의 대응

데이터 표준화 agent의 사용자(데이터 관리자)와 코드분석 agent의 사용자(개발자)가 다르다.  
지식 QnA chatbot은 두 그룹 모두 사용하는 혼합 서비스다.  

**중요: 사용자 그룹 분리는 저장소를 분리할 이유가 되지 않는다.**  

### 올바른 접근: Shared Core, Separated Edge

**백엔드 (Logic Layer)**  
- Core API: LLM 연동, 인증, 공통 DB 접근  
- Agent Logic: 각 agent 전용 프롬프트 및 도구  
- 모두 동일한 Monorepo에 존재  

**프론트엔드 (Interface Layer)**  
- 사용자 진입점만 분리  
- 데이터 표준화 Portal: 대시보드 형태  
- 코드 분석 IDE Plugin/Portal: 코드 뷰어 중심  
- 통합 QnA Widget: 어디서든 호출 가능  

**배포 및 접근 제어 분리**  

```nginx
# API Gateway 설정 예시
location /api/data-std {
    # 데이터 관리자 그룹만 접근
    auth_request /auth/validate-data-admin;
    proxy_pass http://data-std-service:8000;
}

location /api/code-analysis {
    # 개발자 그룹만 접근
    auth_request /auth/validate-developer;
    proxy_pass http://code-analysis-service:8000;
}

location /api/knowledge-qna {
    # 두 그룹 모두 접근 가능
    auth_request /auth/validate-any-group;
    proxy_pass http://knowledge-qna-service:8000;
}
```

### 왜 Monorepo가 유리한가

**공통 인증/권한 로직 단일 구현**  
보안 일관성 유지. 권한 버그가 발생하면 한 곳만 수정.  

**배포 단위만 분리하여 서비스 격리**  
Kubernetes에서 다른 클러스터에 배포 가능  
하지만 코드는 같은 저장소에서 관리  

**API Gateway로 사용자 그룹별 라우팅**  
네트워크 레벨에서 격리하므로 코드 격리 불필요  

**Polyrepo 선택 시 문제점**  
- 공통 모듈 60% 재사용 불가능 → 중복 구현  
- 보안 패치를 3곳에서 따로 적용 → 누락 위험  
- 지식 QnA의 혼합 서비스 구현 복잡도 폭발  

## 지금 당장 시작할 것

### 즉시 실행 체크리스트

**오늘**  
- [ ] Monorepo 기본 구조 생성 (위 Phase 1 구조 참고)  
- [ ] `core/agent/base_agent.py` 스켈레톤 작성  
- [ ] `pyproject.toml` 초기 설정  

**이번 주**  
- [ ] BaseAgent 인터페이스 설계 완료  
- [ ] 기존 POC agent 3개를 Monorepo로 마이그레이션  
- [ ] Agent manifest 템플릿 작성  
- [ ] 간단한 통합 테스트 작성  

**이번 달**  
- [ ] 공통 SDK 초안 구현 (로깅, 모니터링)  
- [ ] CI/CD 파이프라인 구축 (변경된 agent만 테스트)  
- [ ] 첫 번째 공통 모듈 배포 (LLM 인터페이스)  
- [ ] 코드베이스 분석 agent 추가  

**3개월 후**  
- [ ] Agent 5-10개 시점에서 Phase 2 전환 여부 재평가  
- [ ] 빌드 시간 측정 (필요시 Nx 도입)  
- [ ] 팀 피드백 수집 및 구조 조정  

### 성공 기준

**정량적 지표**  
- 새 agent 추가 시간: 2-3일 이내 (공통 모듈 재사용 덕분)  
- 공통 모듈 재사용률: 30% 이상  
- 통합 테스트 커버리지: 80% 이상  
- 빌드 시간: 10분 이내 (agent 10개 기준)  

**정성적 지표**  
- 팀원들이 다른 agent의 코드를 쉽게 참고 가능  
- 공통 라이브러리 변경 시 영향 범위 명확히 파악  
- 새로운 개발자가 1주일 내 첫 agent 추가 가능  

## 결론

AI Agent 플랫폼의 저장소 전략은 팀 역량, 프로젝트 단계, 공통 모듈 비중을 종합적으로 고려해야 한다.  

**현재 상황에서의 최적해**  
Monorepo로 시작하여 필요시 선택적으로 MSA로 전환하는 점진적 전략이 유일한 정답이다.  

**핵심 원칙**  
"사용자 기준으로 제품을 나누고, 기술 기준으로 core를 공유한다."  

**실증 데이터 기반 결론**  
Google, Microsoft, Uber, Airbnb 등 성공적인 플랫폼들은 모두 동일한 경로를 따랐다.  
초기 Monorepo → 성숙 단계 선택적 분리  

**위험 최소화 전략**  
리더급 엔지니어가 부재한 상황에서 복잡한 MSA는 위험하다.  
단순한 구조로 시작하여 점진적으로 복잡도를 높여가는 것이 안전하다.  

**장기적 관점**  
Monorepo에서 MSA로의 전환은 가능하지만, 역방향은 거의 불가능하다.  
따라서 초기에는 보수적으로 Monorepo를 선택하고, 필요성이 명확해지면 분리하는 것이 현명하다.  

이 전략을 따르면 개발 속도를 유지하면서도 장기적인 확장성을 확보할 수 있다.
│   │   ├── tech-support/
│   │   └── bio-domain/
│   ├── standardization/      # 데이터 표준화 관련 에이전트 그룹
│   │   ├── db-matcher/
│   │   └── schema-generator/
│   └── analyzer/             # 코드/알고리즘 분석 그룹
│       ├── algo-describer/
│       └── legacy-refactor/
├── platform-api/             # 에이전트들을 총괄하는 게이트웨이 및 관리 UI
└── tests/                    # 통합 테스트


## 이 구조의 실질적인 장점

### 에이전트 양산 속도 (Scaffolding)

새로운 에이전트(예: 실험 데이터 분석 Agent)가 필요할 때, 밑바닥부터 만드는 것이 아니라 `libs/`에 있는 `core-llm`과 `rag-engine`을 가져와서 **프롬프트와 특정 도메인 데이터만 연결**하면 며칠 만에 뚝딱 만들어낼 수 있다.

### 기술 부채 방지 (Single Source of Truth)

예를 들어, 씨젠의 **데이터 표준 정책이 변경**되었다고 가정.

* **멀티레포라면:** 10개의 에이전트 저장소에 들어가서 코드를 일일이 수정
* **모노레포라면:** `libs/seegene-db-standard` 한 곳만 수정하면 이를 참조하는 모든 에이전트에 즉시 적용

### 일관된 인터페이스 (Agent Orchestration)

플랫폼의 목표가 여러 에이전트를 관리하는 것이라면, 각 에이전트는 동일한 입출력 규격(Interface)을 가져야 한다. 모노레포에서는 `interfaces/` 폴더를 통해 모든 에이전트가 따라야 할 규약을 강제하기 매우 쉽다.


