{"title":"Programmers Code Problem Study","markdown":{"yaml":{"title":"Programmers Code Problem Study","author":"Kwangmin Kim","date":"2025/09/12","categories":["Code Test","Algorithm Test"]},"headingText":"문제 정보","containsRefs":false,"markdown":"\n\n\n-   제목: 완주하지 못한 선수\n-   링크: https://school.programmers.co.kr/learn/courses/30/lessons/42576\n-   **난이도**: 1\n-   **유형**: Hash\n-   풀이 시간: 10분\n\n# 문제 설명\n\n수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.\n\n마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.\n\n## 제한사항\n\n-   마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.\n-   completion의 길이는 participant의 길이보다 1 작습니다.\n-   참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.\n-   참가자 중에는 동명이인이 있을 수 있습니다.\n\n## 입출력 예\n\n| participant                                         | completion                                 | return   |\n|----------------------------|--------------------------|-------------------|\n| \\[\"leo\", \"kiki\", \"eden\"\\]                           | \\[\"eden\", \"kiki\"\\]                         | \"leo\"    |\n| \\[\"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\"\\] | \\[\"josipa\", \"filipa\", \"marina\", \"nikola\"\\] | \"vinko\"  |\n| \\[\"mislav\", \"stanko\", \"mislav\", \"ana\"\\]             | \\[\"stanko\", \"ana\", \"mislav\"\\]              | \"mislav\" |\n\n## 입출력 예 설명\n\n### 예제 #1\n\n\"leo\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\n\n### 예제 #2\n\n\"vinko\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\n\n### 예제 #3\n\n\"mislav\"는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.\n\n※ 공지 - 2023년 01월 25일 테스트케이스가 추가되었습니다.\n\n# 문제 해설\n\n## 문제 핵심 이해\n\n이 문제의 핵심은 **두 개의 배열에서 빠진 요소 하나를 찾는 것**\n\n-   참가자 배열: `participant` (n명)\n-   완주자 배열: `completion` (n-1명)\n-   목표: 완주하지 못한 1명 찾기\n\n## 중요한 조건들\n\n1.  **동명이인 존재 가능**: 단순히 이름만 비교하면 안 되고, 개수까지 고려해야 한다.\n2.  **대용량 데이터**: 최대 100,000명까지 가능하므로 효율적인 알고리즘이 필요하다.\n3.  **정확히 1명 차이**: completion 길이 = participant 길이 - 1\n\n## 해결 방법별 분석\n\n### 해시맵(Dictionary) 방법 (권장)\n\n**시간복잡도**: O(n) + O(n) + O(n) = O(n) **공간복잡도**: O(n) (최악의 경우 모든 참가자가 서로 다른 이름)\n\n``` python\n'''\n핵심 아이디어\n  - 해설: 완주하지 못한 선수는 참가했지만 완주 명단에서 차감되지 않은 유일한 사람이므로, 카운팅 차집합으로 정확히 찾을 수 있음 \n  - 전략: 참가자 카운트 - 완주자 카운트 = 미완주자의 차집합 원리를 해시맵으로 구현 \n알고리즘 동작\n  - 참가자 딕셔너리 생성: 각 참가자 이름별 개수를 해시맵에 저장\n  - 완주자 카운트 차감: 완주자 리스트를 순회하며 해당 이름의 카운트를 1씩 차감\n  - 미완주자 탐색: 카운트 값이 0보다 큰 이름을 찾아 반환\n왜 효율적인가?\n  - 해시맵의 O(1) 접근 시간을 활용하여 전체 O(n) 시간에 동명이인까지 정확히 처리할 수 있음\n'''\ndef solution(participant, completion):\n    participant_dict = {} # 최대 n개의 서로 다른 이름 저장 → O(n) 공간\n    \n    # 1단계: 참가자 카운트 - O(n)\n    for name in participant:  # n번 반복\n        participant_dict[name] = participant_dict.get(name, 0) + 1\n        # 잘못된 방법 - participant_dict[name] = participant_dict[name] + 1\n          # → KeyError: 'leo' (처음 등장하는 이름은 키가 없음)\n        # dict.get(key, default_value): 값을 가져오는 역할\n          # name이라는 키가 딕셔너리에 있으면 → 그 값을 반환\n          # name이라는 키가 딕셔너리에 없으면 → 0을 반환 (default 값)\n        # + 1 → 참가자 개수 증가 (동명이인 방지)\n          # 두 번째 \"leo\" (만약 동명이인이 있다면) → 1 + 1 = 2\n        # dict.get() = O(1), dict 할당 = O(1)\n        # 예시: [\"mislav\", \"stanko\", \"mislav\", \"ana\"] → {\"mislav\": 2, \"stanko\": 1, \"ana\": 1}\n          # # 1. name = \"mislav\" (첫 번째)\n          # participant_dict.get(\"mislav\", 0) + 1\n          # # → 0 + 1 = 1\n          # participant_dict[\"mislav\"] = 1\n          # # 현재 상태: {\"mislav\": 1}\n# \n          # # 2. name = \"stanko\"\n          # participant_dict.get(\"stanko\", 0) + 1  \n          # # → 0 + 1 = 1\n          # participant_dict[\"stanko\"] = 1\n          # # 현재 상태: {\"mislav\": 1, \"stanko\": 1}\n# \n          # # 3. name = \"mislav\" (두 번째, 동명이인!)\n          # participant_dict.get(\"mislav\", 0) + 1\n          # # → 1 + 1 = 2  (이미 \"mislav\"가 있어서 1을 반환)\n          # participant_dict[\"mislav\"] = 2\n          # # 현재 상태: {\"mislav\": 2, \"stanko\": 1}\n# \n          # # 4. name = \"ana\"\n          # participant_dict.get(\"ana\", 0) + 1\n          # # → 0 + 1 = 1\n          # participant_dict[\"ana\"] = 1\n          # # 최종 상태: {\"mislav\": 2, \"stanko\": 1, \"ana\": 1}\n    \n    # 2단계: 완주자 차감 - O(n-1) = O(n)\n    for name in completion:  # n-1번 반복\n        participant_dict[name] -= 1\n        # dict 접근 및 수정 = O(1)\n    \n    # 3단계: 결과 찾기 - O(n)\n    for name, count in participant_dict.items():  # 최대 n번 반복\n        if count == 1:\n            return name\n```\n\n**동작 원리**: - 참가자 이름별 개수를 카운트 - 완주자 이름별로 개수를 차감 - 남은 개수가 1인 사람이 미완주자\n\n### 정렬 방법\n\n**시간복잡도**: O(n log n) + O(n log n) + O(n) = O(n log n)\n\n- 분할 정복(Divide and Conquer) 원리\n  - 분할: 배열을 절반씩 나누기 → log n 단계 → n개의 요소를 계속 반으로 나누면서 1개가 남을 때까지의 분할 횟수가 log n\n  - n개의 요소를 계속 반으로 나누면서 1개가 남을 때까지의 분할 횟수가 log n\n  - n → n/2 → n/4 → n/8 → ... → n/2\\^k → ... → 1 - n/2\\^k = 1 → 2\\^k = n → k = log₂n → O(log n)\n  - 예시: 8개 요소 정렬 - \\[8, 3, 1, 7, 0, 10, 2, 5\\]\n    - 1단계: \\[8,3,1,7\\] \\| \\[0,10,2,5\\] ← 8 → 4, 4\n    - 2단계: \\[8,3\\|1,7\\] \\| \\[0,10\\|2,5\\] ← 4 → 2, 2\n    - 3단계: \\[8\\|3\\|1\\|7\\] \\| \\[0\\|10\\|2\\|5\\] ← 2 → 1, 1\n  - 총 단계 수: log₂(8) = 3단계 = log n\n  - 각 단계마다: 8개 요소 처리 = n개\n  - 반으로 나누는 것만으로도 문제 크기를 지수적으로 줄일 수 있어서 O(n) 보다 O(log n)이 더 효율적\n  - 정복: 각 단계에서 모든 요소를 비교/병합 → n 개 요소\n  - 결과: log n 단계 × n개 처리 = O(n log n)\n\n**공간복잡도**: O(1) (입력 배열 자체를 정렬) - O(1) = 상수 시간 (Constant Time)\n\n- 입력 크기에 상관없이 항상 일정한 시간이 걸리는 연산\n- 즉, 추가 메모리를 거의 사용하지 않는다는 뜻 - 모두 O(1) 연산들\n\n``` python\narr[0]           # 배열 인덱스 접근 = O(1)\ndict[key]        # 해시맵 접근 = O(1)\nx = 5            # 변수 할당\nif x > 0:        # 단순 비교\n    return x     # 반환\n```\n\n``` python\ndef solution(participant, completion):\n    participant.sort() # 시간: O(n log n), 공간: O(1)\n    completion.sort() # 시간: O(n log n), 공간: O(1)\n    \n    # 순서대로 비교하다가 다른 부분 발견 → 시간: O(n), 공간: O(1)\n    for i in range(len(completion)):  # n-1번 반복\n        if participant[i] != completion[i]: # O(1)\n            return participant[i]\n    \n    # 모두 같다면 마지막 사람이 미완주자\n    return participant[-1] # O(1)\n```\n\n따라서, 정렬 방법의 시간복잡도는 O(n log n)이고, 공간복잡도는 O(1)\n\n- 시간복잡도: O(n log n) + O(n log n) + O(n) = O(n log n)\n- 공간복잡도: O(1) + O(1) + O(1) = O(1)\n- 메모리 vs 속도 트레이드오프\n- 결론: 대부분 상황에서는 해시맵이 좋지만, 메모리가 부족한 환경에서는 정렬 방법을 고려할 수 있다\n\n| 방법   | 속도            | 메모리       | 상황                  |\n|--------|-----------------|--------------|-----------------------|\n| 해시맵 | 빠름 O(n)       | 많이 씀 O(n) | **일반적으로 권장**   |\n| 정렬   | 보통 O(n log n) | 적게 씀 O(1) | 메모리 제약이 있을 때 |\n\n### 최적 해답 (해시맵 사용)\n\n``` python\ndef solution(participant, completion):\n    # 방법 1: Counter 사용 (가장 간단)\n    from collections import Counter\n    \n    participant_counter = Counter(participant) # O(n)\n    completion_counter = Counter(completion) # O(n)\n    \n    # 차집합으로 미완주자 찾기\n    result = participant_counter - completion_counter # O(n)\n    return list(result.keys())[0] # O(1)\n```\n\n### 한 줄 해답 (고급)\n\n``` python\ndef solution(participant, completion):\n    from collections import Counter\n    return list((Counter(participant) - Counter(completion)).keys())[0]\n```\n\n### 브루트 포스 방법 (비권장)\n\n**시간복잡도**: O(n²)\\\n**공간복잡도**: O(1)\n\n``` python\ndef solution(participant, completion):\n    for p in participant:\n        if p not in completion:\n            return p\n        else:\n            completion.remove(p)  # 동명이인 처리\n```\n\n## 복잡도 비교표\n\n| 방법       | 시간복잡도 | 공간복잡도 | 특징                       |\n|------------|------------|------------|----------------------------|\n| 해시맵     | O(n)       | O(n)       | **최적 성능, 가독성 좋음** |\n| Counter    | O(n)       | O(n)       | **가장 간결, 최적 성능**   |\n| 정렬       | O(n log n) | O(1)       | 메모리 효율적              |\n| 브루트포스 | O(n²)      | O(1)       | 비효율적, 비권장           |\n\n## 왜 해시맵이 최적인가?\n\n1.  **해시 테이블의 특성**: 삽입, 조회, 수정이 모두 O(1)\n2.  **선형 탐색**: 각 배열을 한 번씩만 순회 → O(n)\n3.  **공간-시간 트레이드오프**: 메모리를 조금 더 사용해서 시간을 크게 단축\n4.  **시간 효율성**: O(n) - 각 배열을 한 번씩만 순회\n5.  **동명이인 처리**: 이름별 개수를 정확히 관리\n6.  **구현 단순성**: 직관적이고 이해하기 쉬운 로직\n7.  **확장성**: 미완주자가 여러 명이어도 쉽게 확장 가능\n\n## 핵심 포인트\n\n-   **Hash 자료구조의 특성 활용**: O(1) 삽입/조회로 효율성 극대화\n-   **카운팅 기법**: 단순 존재 여부가 아닌 개수 비교로 동명이인 문제 해결\n-   **차집합 개념**: 전체에서 일부를 빼는 방식으로 누락된 요소 찾기\n\n대용량 데이터(최대 100,000명)에서는 **O(n)**과 **O(n²)**의 차이가 매우 크기 때문에 해시맵 방식이 필수적이다\n\n## 예제별 동작 과정\n\n### 예제 1: `[\"leo\", \"kiki\", \"eden\"]`, `[\"eden\", \"kiki\"]`\n\n**해시맵 방법**: 1. participant_dict = {\"leo\": 1, \"kiki\": 1, \"eden\": 1} 2. \"eden\" 차감 → {\"leo\": 1, \"kiki\": 1, \"eden\": 0} 3. \"kiki\" 차감 → {\"leo\": 1, \"kiki\": 0, \"eden\": 0} 4. count가 1인 \"leo\" 반환\n\n### 예제 3: `[\"mislav\", \"stanko\", \"mislav\", \"ana\"]`, `[\"stanko\", \"ana\", \"mislav\"]`\n\n**해시맵 방법**: 1. participant_dict = {\"mislav\": 2, \"stanko\": 1, \"ana\": 1} 2. 완주자들 차감 후 → {\"mislav\": 1, \"stanko\": 0, \"ana\": 0} 3. count가 1인 \"mislav\" 반환\n\n# 해시맵 기초\n\n-   해시맵(해시테이블): 컴퓨터 과학 이론에서 사용하는 표준 학술 용어\n-   Python 딕셔너리 = 해시맵(해시테이블) = 해시 기반 키-값 저장소\n-   딕셔너리의 Key → 해시함수 → 인덱스 → 메모리 위치 → Value 할당\n\n## 딕셔너리의 내부 구현\n\n**Python의 `dict`는 실제로 해시테이블(Hash Table)로 구현**되어 있음 \n- 즉, 해시맵과 동일한 자료구조 \n- `my_dict = {\"key\": \"value\"}` \n- 내부적으로는 해시테이블이 동작 \n    - 1. \"key\"를 해시함수에 통과 → hash(\"key\") = 12345 \n    - 2. 12345 % 배열크기 = 인덱스 계산 \n    - 3. 해당 인덱스에 (\"key\", \"value\") 저장\n\n## 언어별 용어 차이\n\n| 언어           | 이름          | 실제로는   |\n|----------------|---------------|------------|\n| **Python**     | dict          | Hash Table |\n| **Java**       | HashMap       | Hash Table |\n| **C++**        | unordered_map | Hash Table |\n| **JavaScript** | Object, Map   | Hash Table |\n| **C#**         | Dictionary    | Hash Table |\n\n## 왜 \"해시맵\"이라고 부르는가?\n\n### 해시 함수 사용\n\n``` python\n# 내부 동작 과정\nkey = \"leo\"\nhash_value = hash(\"leo\")  # 예: 2578946130\nindex = hash_value % 8    # 배열 크기가 8이면 → 인덱스 2\n# dict_array[2] 위치에 (\"leo\", 1) 저장\n```\n\n### 키-값 매핑(Mapping)\n\n``` python\n# 키를 값으로 \"매핑(mapping)\"\n\"leo\" → 1\n\"kiki\" → 1  \n\"eden\" → 1\n```\n\n## 해시맵의 핵심 특성\n\n### O(1) 평균 시간복잡도\n\n``` python\n# 모두 O(1) 평균 시간\ndict[\"key\"]           # 조회\ndict[\"key\"] = value   # 삽입  \ndict[\"key\"] += 1      # 수정\n```\n\n### 해시 충돌 처리\n\n``` python\n# 서로 다른 키가 같은 해시값을 가질 때\nhash(\"leo\") % 8 = 2\nhash(\"ana\") % 8 = 2  # 충돌!\n\n# Python은 Open Addressing으로 해결\n# Open Addressing: 다음 빈 슬롯을 찾아 저장\n```","srcMarkdownNoYaml":"\n\n# 문제 정보\n\n-   제목: 완주하지 못한 선수\n-   링크: https://school.programmers.co.kr/learn/courses/30/lessons/42576\n-   **난이도**: 1\n-   **유형**: Hash\n-   풀이 시간: 10분\n\n# 문제 설명\n\n수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.\n\n마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.\n\n## 제한사항\n\n-   마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.\n-   completion의 길이는 participant의 길이보다 1 작습니다.\n-   참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.\n-   참가자 중에는 동명이인이 있을 수 있습니다.\n\n## 입출력 예\n\n| participant                                         | completion                                 | return   |\n|----------------------------|--------------------------|-------------------|\n| \\[\"leo\", \"kiki\", \"eden\"\\]                           | \\[\"eden\", \"kiki\"\\]                         | \"leo\"    |\n| \\[\"marina\", \"josipa\", \"nikola\", \"vinko\", \"filipa\"\\] | \\[\"josipa\", \"filipa\", \"marina\", \"nikola\"\\] | \"vinko\"  |\n| \\[\"mislav\", \"stanko\", \"mislav\", \"ana\"\\]             | \\[\"stanko\", \"ana\", \"mislav\"\\]              | \"mislav\" |\n\n## 입출력 예 설명\n\n### 예제 #1\n\n\"leo\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\n\n### 예제 #2\n\n\"vinko\"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.\n\n### 예제 #3\n\n\"mislav\"는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.\n\n※ 공지 - 2023년 01월 25일 테스트케이스가 추가되었습니다.\n\n# 문제 해설\n\n## 문제 핵심 이해\n\n이 문제의 핵심은 **두 개의 배열에서 빠진 요소 하나를 찾는 것**\n\n-   참가자 배열: `participant` (n명)\n-   완주자 배열: `completion` (n-1명)\n-   목표: 완주하지 못한 1명 찾기\n\n## 중요한 조건들\n\n1.  **동명이인 존재 가능**: 단순히 이름만 비교하면 안 되고, 개수까지 고려해야 한다.\n2.  **대용량 데이터**: 최대 100,000명까지 가능하므로 효율적인 알고리즘이 필요하다.\n3.  **정확히 1명 차이**: completion 길이 = participant 길이 - 1\n\n## 해결 방법별 분석\n\n### 해시맵(Dictionary) 방법 (권장)\n\n**시간복잡도**: O(n) + O(n) + O(n) = O(n) **공간복잡도**: O(n) (최악의 경우 모든 참가자가 서로 다른 이름)\n\n``` python\n'''\n핵심 아이디어\n  - 해설: 완주하지 못한 선수는 참가했지만 완주 명단에서 차감되지 않은 유일한 사람이므로, 카운팅 차집합으로 정확히 찾을 수 있음 \n  - 전략: 참가자 카운트 - 완주자 카운트 = 미완주자의 차집합 원리를 해시맵으로 구현 \n알고리즘 동작\n  - 참가자 딕셔너리 생성: 각 참가자 이름별 개수를 해시맵에 저장\n  - 완주자 카운트 차감: 완주자 리스트를 순회하며 해당 이름의 카운트를 1씩 차감\n  - 미완주자 탐색: 카운트 값이 0보다 큰 이름을 찾아 반환\n왜 효율적인가?\n  - 해시맵의 O(1) 접근 시간을 활용하여 전체 O(n) 시간에 동명이인까지 정확히 처리할 수 있음\n'''\ndef solution(participant, completion):\n    participant_dict = {} # 최대 n개의 서로 다른 이름 저장 → O(n) 공간\n    \n    # 1단계: 참가자 카운트 - O(n)\n    for name in participant:  # n번 반복\n        participant_dict[name] = participant_dict.get(name, 0) + 1\n        # 잘못된 방법 - participant_dict[name] = participant_dict[name] + 1\n          # → KeyError: 'leo' (처음 등장하는 이름은 키가 없음)\n        # dict.get(key, default_value): 값을 가져오는 역할\n          # name이라는 키가 딕셔너리에 있으면 → 그 값을 반환\n          # name이라는 키가 딕셔너리에 없으면 → 0을 반환 (default 값)\n        # + 1 → 참가자 개수 증가 (동명이인 방지)\n          # 두 번째 \"leo\" (만약 동명이인이 있다면) → 1 + 1 = 2\n        # dict.get() = O(1), dict 할당 = O(1)\n        # 예시: [\"mislav\", \"stanko\", \"mislav\", \"ana\"] → {\"mislav\": 2, \"stanko\": 1, \"ana\": 1}\n          # # 1. name = \"mislav\" (첫 번째)\n          # participant_dict.get(\"mislav\", 0) + 1\n          # # → 0 + 1 = 1\n          # participant_dict[\"mislav\"] = 1\n          # # 현재 상태: {\"mislav\": 1}\n# \n          # # 2. name = \"stanko\"\n          # participant_dict.get(\"stanko\", 0) + 1  \n          # # → 0 + 1 = 1\n          # participant_dict[\"stanko\"] = 1\n          # # 현재 상태: {\"mislav\": 1, \"stanko\": 1}\n# \n          # # 3. name = \"mislav\" (두 번째, 동명이인!)\n          # participant_dict.get(\"mislav\", 0) + 1\n          # # → 1 + 1 = 2  (이미 \"mislav\"가 있어서 1을 반환)\n          # participant_dict[\"mislav\"] = 2\n          # # 현재 상태: {\"mislav\": 2, \"stanko\": 1}\n# \n          # # 4. name = \"ana\"\n          # participant_dict.get(\"ana\", 0) + 1\n          # # → 0 + 1 = 1\n          # participant_dict[\"ana\"] = 1\n          # # 최종 상태: {\"mislav\": 2, \"stanko\": 1, \"ana\": 1}\n    \n    # 2단계: 완주자 차감 - O(n-1) = O(n)\n    for name in completion:  # n-1번 반복\n        participant_dict[name] -= 1\n        # dict 접근 및 수정 = O(1)\n    \n    # 3단계: 결과 찾기 - O(n)\n    for name, count in participant_dict.items():  # 최대 n번 반복\n        if count == 1:\n            return name\n```\n\n**동작 원리**: - 참가자 이름별 개수를 카운트 - 완주자 이름별로 개수를 차감 - 남은 개수가 1인 사람이 미완주자\n\n### 정렬 방법\n\n**시간복잡도**: O(n log n) + O(n log n) + O(n) = O(n log n)\n\n- 분할 정복(Divide and Conquer) 원리\n  - 분할: 배열을 절반씩 나누기 → log n 단계 → n개의 요소를 계속 반으로 나누면서 1개가 남을 때까지의 분할 횟수가 log n\n  - n개의 요소를 계속 반으로 나누면서 1개가 남을 때까지의 분할 횟수가 log n\n  - n → n/2 → n/4 → n/8 → ... → n/2\\^k → ... → 1 - n/2\\^k = 1 → 2\\^k = n → k = log₂n → O(log n)\n  - 예시: 8개 요소 정렬 - \\[8, 3, 1, 7, 0, 10, 2, 5\\]\n    - 1단계: \\[8,3,1,7\\] \\| \\[0,10,2,5\\] ← 8 → 4, 4\n    - 2단계: \\[8,3\\|1,7\\] \\| \\[0,10\\|2,5\\] ← 4 → 2, 2\n    - 3단계: \\[8\\|3\\|1\\|7\\] \\| \\[0\\|10\\|2\\|5\\] ← 2 → 1, 1\n  - 총 단계 수: log₂(8) = 3단계 = log n\n  - 각 단계마다: 8개 요소 처리 = n개\n  - 반으로 나누는 것만으로도 문제 크기를 지수적으로 줄일 수 있어서 O(n) 보다 O(log n)이 더 효율적\n  - 정복: 각 단계에서 모든 요소를 비교/병합 → n 개 요소\n  - 결과: log n 단계 × n개 처리 = O(n log n)\n\n**공간복잡도**: O(1) (입력 배열 자체를 정렬) - O(1) = 상수 시간 (Constant Time)\n\n- 입력 크기에 상관없이 항상 일정한 시간이 걸리는 연산\n- 즉, 추가 메모리를 거의 사용하지 않는다는 뜻 - 모두 O(1) 연산들\n\n``` python\narr[0]           # 배열 인덱스 접근 = O(1)\ndict[key]        # 해시맵 접근 = O(1)\nx = 5            # 변수 할당\nif x > 0:        # 단순 비교\n    return x     # 반환\n```\n\n``` python\ndef solution(participant, completion):\n    participant.sort() # 시간: O(n log n), 공간: O(1)\n    completion.sort() # 시간: O(n log n), 공간: O(1)\n    \n    # 순서대로 비교하다가 다른 부분 발견 → 시간: O(n), 공간: O(1)\n    for i in range(len(completion)):  # n-1번 반복\n        if participant[i] != completion[i]: # O(1)\n            return participant[i]\n    \n    # 모두 같다면 마지막 사람이 미완주자\n    return participant[-1] # O(1)\n```\n\n따라서, 정렬 방법의 시간복잡도는 O(n log n)이고, 공간복잡도는 O(1)\n\n- 시간복잡도: O(n log n) + O(n log n) + O(n) = O(n log n)\n- 공간복잡도: O(1) + O(1) + O(1) = O(1)\n- 메모리 vs 속도 트레이드오프\n- 결론: 대부분 상황에서는 해시맵이 좋지만, 메모리가 부족한 환경에서는 정렬 방법을 고려할 수 있다\n\n| 방법   | 속도            | 메모리       | 상황                  |\n|--------|-----------------|--------------|-----------------------|\n| 해시맵 | 빠름 O(n)       | 많이 씀 O(n) | **일반적으로 권장**   |\n| 정렬   | 보통 O(n log n) | 적게 씀 O(1) | 메모리 제약이 있을 때 |\n\n### 최적 해답 (해시맵 사용)\n\n``` python\ndef solution(participant, completion):\n    # 방법 1: Counter 사용 (가장 간단)\n    from collections import Counter\n    \n    participant_counter = Counter(participant) # O(n)\n    completion_counter = Counter(completion) # O(n)\n    \n    # 차집합으로 미완주자 찾기\n    result = participant_counter - completion_counter # O(n)\n    return list(result.keys())[0] # O(1)\n```\n\n### 한 줄 해답 (고급)\n\n``` python\ndef solution(participant, completion):\n    from collections import Counter\n    return list((Counter(participant) - Counter(completion)).keys())[0]\n```\n\n### 브루트 포스 방법 (비권장)\n\n**시간복잡도**: O(n²)\\\n**공간복잡도**: O(1)\n\n``` python\ndef solution(participant, completion):\n    for p in participant:\n        if p not in completion:\n            return p\n        else:\n            completion.remove(p)  # 동명이인 처리\n```\n\n## 복잡도 비교표\n\n| 방법       | 시간복잡도 | 공간복잡도 | 특징                       |\n|------------|------------|------------|----------------------------|\n| 해시맵     | O(n)       | O(n)       | **최적 성능, 가독성 좋음** |\n| Counter    | O(n)       | O(n)       | **가장 간결, 최적 성능**   |\n| 정렬       | O(n log n) | O(1)       | 메모리 효율적              |\n| 브루트포스 | O(n²)      | O(1)       | 비효율적, 비권장           |\n\n## 왜 해시맵이 최적인가?\n\n1.  **해시 테이블의 특성**: 삽입, 조회, 수정이 모두 O(1)\n2.  **선형 탐색**: 각 배열을 한 번씩만 순회 → O(n)\n3.  **공간-시간 트레이드오프**: 메모리를 조금 더 사용해서 시간을 크게 단축\n4.  **시간 효율성**: O(n) - 각 배열을 한 번씩만 순회\n5.  **동명이인 처리**: 이름별 개수를 정확히 관리\n6.  **구현 단순성**: 직관적이고 이해하기 쉬운 로직\n7.  **확장성**: 미완주자가 여러 명이어도 쉽게 확장 가능\n\n## 핵심 포인트\n\n-   **Hash 자료구조의 특성 활용**: O(1) 삽입/조회로 효율성 극대화\n-   **카운팅 기법**: 단순 존재 여부가 아닌 개수 비교로 동명이인 문제 해결\n-   **차집합 개념**: 전체에서 일부를 빼는 방식으로 누락된 요소 찾기\n\n대용량 데이터(최대 100,000명)에서는 **O(n)**과 **O(n²)**의 차이가 매우 크기 때문에 해시맵 방식이 필수적이다\n\n## 예제별 동작 과정\n\n### 예제 1: `[\"leo\", \"kiki\", \"eden\"]`, `[\"eden\", \"kiki\"]`\n\n**해시맵 방법**: 1. participant_dict = {\"leo\": 1, \"kiki\": 1, \"eden\": 1} 2. \"eden\" 차감 → {\"leo\": 1, \"kiki\": 1, \"eden\": 0} 3. \"kiki\" 차감 → {\"leo\": 1, \"kiki\": 0, \"eden\": 0} 4. count가 1인 \"leo\" 반환\n\n### 예제 3: `[\"mislav\", \"stanko\", \"mislav\", \"ana\"]`, `[\"stanko\", \"ana\", \"mislav\"]`\n\n**해시맵 방법**: 1. participant_dict = {\"mislav\": 2, \"stanko\": 1, \"ana\": 1} 2. 완주자들 차감 후 → {\"mislav\": 1, \"stanko\": 0, \"ana\": 0} 3. count가 1인 \"mislav\" 반환\n\n# 해시맵 기초\n\n-   해시맵(해시테이블): 컴퓨터 과학 이론에서 사용하는 표준 학술 용어\n-   Python 딕셔너리 = 해시맵(해시테이블) = 해시 기반 키-값 저장소\n-   딕셔너리의 Key → 해시함수 → 인덱스 → 메모리 위치 → Value 할당\n\n## 딕셔너리의 내부 구현\n\n**Python의 `dict`는 실제로 해시테이블(Hash Table)로 구현**되어 있음 \n- 즉, 해시맵과 동일한 자료구조 \n- `my_dict = {\"key\": \"value\"}` \n- 내부적으로는 해시테이블이 동작 \n    - 1. \"key\"를 해시함수에 통과 → hash(\"key\") = 12345 \n    - 2. 12345 % 배열크기 = 인덱스 계산 \n    - 3. 해당 인덱스에 (\"key\", \"value\") 저장\n\n## 언어별 용어 차이\n\n| 언어           | 이름          | 실제로는   |\n|----------------|---------------|------------|\n| **Python**     | dict          | Hash Table |\n| **Java**       | HashMap       | Hash Table |\n| **C++**        | unordered_map | Hash Table |\n| **JavaScript** | Object, Map   | Hash Table |\n| **C#**         | Dictionary    | Hash Table |\n\n## 왜 \"해시맵\"이라고 부르는가?\n\n### 해시 함수 사용\n\n``` python\n# 내부 동작 과정\nkey = \"leo\"\nhash_value = hash(\"leo\")  # 예: 2578946130\nindex = hash_value % 8    # 배열 크기가 8이면 → 인덱스 2\n# dict_array[2] 위치에 (\"leo\", 1) 저장\n```\n\n### 키-값 매핑(Mapping)\n\n``` python\n# 키를 값으로 \"매핑(mapping)\"\n\"leo\" → 1\n\"kiki\" → 1  \n\"eden\" → 1\n```\n\n## 해시맵의 핵심 특성\n\n### O(1) 평균 시간복잡도\n\n``` python\n# 모두 O(1) 평균 시간\ndict[\"key\"]           # 조회\ndict[\"key\"] = value   # 삽입  \ndict[\"key\"] += 1      # 수정\n```\n\n### 해시 충돌 처리\n\n``` python\n# 서로 다른 키가 같은 해시값을 가질 때\nhash(\"leo\") % 8 = 2\nhash(\"ana\") % 8 = 2  # 충돌!\n\n# Python은 Open Addressing으로 해결\n# Open Addressing: 다음 빈 슬롯을 찾아 저장\n```"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":true,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"github","css":["../../../../../styles.css"],"toc":true,"toc-depth":3,"number-sections":true,"include-in-header":[{"text":"<style>\n.custom-footer { \n  text-align: center; \n  font-size: 0.8em; \n  color: #666; \n  margin-top: 2rem; \n}\n</style>\n"}],"include-after-body":["../../../../../js.html","../../../signup.html"],"output-file":"hash_level1_runner.html"},"language":{"toc-title-document":"목차","toc-title-website":"목차","related-formats-title":"기타 형식","related-notebooks-title":"Notebooks","source-notebooks-prefix":"원천","other-links-title":"기타 링크","code-links-title":"코드 링크","launch-dev-container-title":"Dev 컨테이너 실행","launch-binder-title":"랜치 Binder","article-notebook-label":"기사 노트북","notebook-preview-download":"노트북 다운로드","notebook-preview-download-src":"소스 다운로드","notebook-preview-back":"기사로 돌아가기","manuscript-meca-bundle":"MECA 아카이브","section-title-abstract":"초록","section-title-appendices":"부록","section-title-footnotes":"각주","section-title-references":"참고문헌","section-title-reuse":"라이센스","section-title-copyright":"저작권","section-title-citation":"인용","appendix-attribution-cite-as":"인용방법","appendix-attribution-bibtex":"BibTeX 인용:","title-block-author-single":"저자","title-block-author-plural":"저자","title-block-affiliation-single":"소속","title-block-affiliation-plural":"소속","title-block-published":"공개","title-block-modified":"Modified","title-block-keywords":"키워드","callout-tip-title":"힌트","callout-note-title":"노트","callout-warning-title":"경고","callout-important-title":"중요","callout-caution-title":"주의","code-summary":"코드","code-tools-menu-caption":"코드","code-tools-show-all-code":"전체 코드 표시","code-tools-hide-all-code":"전체 코드 숨기기","code-tools-view-source":"소스 코드 표시","code-tools-source-code":"소스 코드","tools-share":"Share","tools-download":"Download","code-line":"선","code-lines":"윤곽","copy-button-tooltip":"클립보드 복사","copy-button-tooltip-success":"복사완료!","repo-action-links-edit":"편집","repo-action-links-source":"소스코드 보기","repo-action-links-issue":"이슈 보고","back-to-top":"맨 위로","search-no-results-text":"일치 없음","search-matching-documents-text":"일치된 문서","search-copy-link-title":"검색 링크 복사","search-hide-matches-text":"추가 검색 결과 숨기기","search-more-match-text":"추가 검색결과","search-more-matches-text":"추가 검색결과","search-clear-button-title":"제거","search-text-placeholder":"","search-detached-cancel-button-title":"취소","search-submit-button-title":"검색","search-label":"검색","toggle-section":"토글 섹션","toggle-sidebar":"사이드바 전환","toggle-dark-mode":"다크 모드 전환","toggle-reader-mode":"리더 모드 전환","toggle-navigation":"탐색 전환","crossref-fig-title":"그림","crossref-tbl-title":"표","crossref-lst-title":"목록","crossref-thm-title":"정리","crossref-lem-title":"보조정리","crossref-cor-title":"따름정리","crossref-prp-title":"명제","crossref-cnj-title":"추측","crossref-def-title":"정의","crossref-exm-title":"보기","crossref-exr-title":"예제","crossref-ch-prefix":"장","crossref-apx-prefix":"부록","crossref-sec-prefix":"섹션","crossref-eq-prefix":"방정식","crossref-lof-title":"그림 목록","crossref-lot-title":"표 목록","crossref-lol-title":"코드 목록","environment-proof-title":"증명","environment-remark-title":"주석","environment-solution-title":"해답","listing-page-order-by":"정렬","listing-page-order-by-default":"디폴트","listing-page-order-by-date-asc":"날짜(오름차순)","listing-page-order-by-date-desc":"날짜(내림차순)","listing-page-order-by-number-desc":"페이지 번호(내림차순)","listing-page-order-by-number-asc":"페이지 번호(오름차순)","listing-page-field-date":"날짜","listing-page-field-title":"제목","listing-page-field-description":"설명","listing-page-field-author":"저자","listing-page-field-filename":"파일명","listing-page-field-filemodified":"갱신일","listing-page-field-subtitle":"부제목","listing-page-field-readingtime":"읽기 시간","listing-page-field-wordcount":"단어 수","listing-page-field-categories":"분류","listing-page-minutes-compact":"{0} 분","listing-page-category-all":"전체","listing-page-no-matches":"일치 없음","listing-page-words":"{0} 단어"},"metadata":{"lang":"ko","fig-responsive":true,"quarto-version":"1.4.543","theme":{"light":["cosmo","../../../../../theme.scss"],"dark":["cosmo","../../../../../theme-dark.scss"]},"code-copy":true,"grid":{"sidebar-width":"200px","body-width":"1200px","margin-width":"200px"},"comments":{"giscus":{"repo":"kmink3225/blog","category":"Blog"}},"title-block-banner":"#EDF3F9","title-block-banner-color":"black","toc-location":"right","open-graph":true,"twitter-card":true,"search":true,"date-format":"YYYY년 MM월 DD일","title":"Programmers Code Problem Study","author":"Kwangmin Kim","date":"2025/09/12","categories":["Code Test","Algorithm Test"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}