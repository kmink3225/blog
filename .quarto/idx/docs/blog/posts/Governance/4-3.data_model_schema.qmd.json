{"title":"Data Governance Study - Data Model (4)","markdown":{"yaml":{"title":"Data Governance Study - Data Model (4)","subtitle":"데이터 모델링 기초: Data Modeling과 DB 설계 기초","description":"이 블로그에서는 데이터 모델링과 데이터베이스 설계의 핵심 개념을 다룬다. DB 스키마, 데이터 모델링과 DB 설계의 차이, 설계 단계, ERD(Entity-Relationship Diagram)의 구성 요소 등을 상세히 설명한다.","author":"Kwangmin Kim","categories":["Data Governance"],"date":"2024-08-07","format":{"html":{"toc":true,"code-fold":true,"code-copy":true,"code-overflow":"wrap","number-sections":true,"number-depth":4,"grid":{"sidebar-width":"200px","body-width":"1150px","margin-width":"300px"}}}},"headingText":"Data Modeling","containsRefs":false,"markdown":"\n\n\nData modeling은 DB Schema를 설계하는 과정이라 할 수 있다.\n\n### DB schema\n\n- DB 구조(table 종류), 데이터 타입, 그리고 제약 조건에 대한 명세 (Specification)\n- 테이블 (table or relation), 필드 (field), 관계 (relationship), 뷰 (view), 인덱스 등 데이터베이스 객체들의 논리적 구조를 설명\n- 데이터 베이스 설계 단계에서 명시 되며 자주 변경되지 않음\n- 실제 데이터베이스 시스템에서 구현될 수 있는 형태로 정의된다.\n- SQL DDL(Data Definition Language)로 표현될 수 있다.\n    - 테이블 (table or relation) & 필드 (field)\n        - 예시\n        ```markdown\n        -- example: the Student table\n        CREATE TABLE Student (\n            student_id INT PRIMARY KEY,\n            name VARCHAR(100) NOT NULL\n        );\n        -- example: the Course table\n        CREATE TABLE Course (\n            course_id INT PRIMARY KEY,\n            course_name VARCHAR(100) NOT NULL\n        );\n        ```\n    - 관계 (relationship)\n        - 외래 키(Foreign Key)를 통한 관계 표현: 주로 외래 키를 사용하여 테이블 간의 관계를 표현\n        - 즉, 한 테이블의 컬럼이 다른 테이블의 기본 키를 참조하도록 설정\n        - 관계 표현 방법\n            - ONE-TO-ONE (1:1) 관계\n                - 한 엔티티의 하나의 인스턴스가 다른 엔티티의 하나의 인스턴스와 연관된다.\n                - 한 테이블에 다른 테이블의 기본 키를 외래 키로 추가하고, 이를 유니크 제약조건으로 설정한다.                - \n                - 예: 한 사람은 하나의 여권을 가진다.\n            - ONE-TO-MANY (1:N) 관계\n                - 가장 흔한 관계로, 자식 테이블에 부모 테이블의 기본 키를 외래 키로 추가한다.\n                - 한 엔티티의 하나의 인스턴스가 다른 엔티티의 여러 인스턴스와 연관된다.\n                - 예: 한 부서는 여러 직원을 가질 수 있다.\n            - MANY-TO-MANY (M:N) 관계\n                - 중간 테이블(연결 테이블)을 생성하여 두 테이블의 관계를 표현한다.\n                - 한 엔티티의 여러 인스턴스가 다른 엔티티의 여러 인스턴스와 연관된다.\n                - 예: 학생들은 여러 과목을 수강하고, 각 과목은 여러 학생들에 의해 수강된다.\n        - 관계의 특성\n            - 선택성(Optionality): 관계가 필수적인지 선택적인지를 나타낸다.\n            - 기수성(Cardinality): 관계에 참여하는 엔티티 인스턴스의 수를 나타낸다.\n        - 관계의 역할\n            - 각 엔티티가 관계에서 어떤 역할을 하는지 설명할 수 있다.\n            - 예: '직원'과 '부서' 간의 관계에서 직원은 '소속됨', 부서는 '고용함'의 역할을 한다.\n        - 관계 엔티티\n            - 때로는 관계 자체가 속성을 가질 수 있으며, 이를 관계 엔티티로 모델링한다.\n            - 주로 다대다 관계를 해결하기 위해 사용됩니다.\n        - 재귀적 관계\n            - 한 엔티티가 자기 자신과 관계를 맺는 경우다.\n            - 예: '직원' 엔티티에서 '관리자'와 '부하직원' 관계\n\n        ```markdown\n         -- Course 테이블 생성\n        CREATE TABLE Course (\n            course_id VARCHAR(10) PRIMARY KEY,\n            course_name VARCHAR(100) NOT NULL,\n            credit_hours INT NOT NULL,\n            department VARCHAR(50) NOT NULL\n        );\n\n        -- Student 테이블 생성\n        CREATE TABLE Student (\n            student_id VARCHAR(8) PRIMARY KEY,\n            name VARCHAR(100) NOT NULL,\n            date_of_birth DATE,\n            major VARCHAR(50)\n        );\n\n        -- Section 테이블 생성\n        CREATE TABLE Section (\n            section_id VARCHAR(15) PRIMARY KEY,\n            course_id VARCHAR(10) NOT NULL,\n            semester VARCHAR(10) NOT NULL,\n            year INT NOT NULL,\n            instructor VARCHAR(100),\n            FOREIGN KEY (course_id) REFERENCES Course(course_id)\n        );\n\n        -- Grade_Report 테이블 생성\n        CREATE TABLE Grade_Report (\n            student_id VARCHAR(8),\n            section_id VARCHAR(15),\n            grade CHAR(2),\n            PRIMARY KEY (student_id, section_id),\n            FOREIGN KEY (student_id) REFERENCES Student(student_id),\n            FOREIGN KEY (section_id) REFERENCES Section(section_id)\n        );\n\n        -- 수강 테이블 (학생과 과목의 M:N 관계를 표현)\n        CREATE TABLE Enrollment (\n            student_id INT,\n            course_id INT,\n            enrollment_date DATE,\n            PRIMARY KEY (student_id, course_id),\n            FOREIGN KEY (student_id) REFERENCES Student(student_id),\n            FOREIGN KEY (course_id) REFERENCES Course(course_id)\n        );\n        ```\n\n### Data Modeling vs DB Design\n\n- DB schema를 만드는 과정을 Data Modeling 또는 DB design이라고 부름 (늬앙스 차이가있음)\n    * Data Modeling\n        - 현실 세계의 데이터를 추상화하여 컴퓨터 세계의 데이터로 표현하는 과정\n        - 특징 (데이터 거버넌스와 상대적으로 더 밀접한 관련이 있음)\n            - 주로 **개념적, 논리적 수준**에서 이루어짐\n            - 더 추상적이고 개념적인 수준\n            - 비즈니스 요구사항을 데이터 구조로 변환\n            - ERD(Entity-Relationship Diagram) 등을 사용하여 시각화\n        - 결과물: ERD, 개념적/논리적 데이터 모델\n        - 단계: 프로젝트 초기 단계\n            - 개념적 모델링: 핵심 엔티티와 관계 식별\n            - 논리적 모델링: 속성 정의, 정규화 수행\n        - 목적 \n            - 비즈니스 프로세스와 규칙을 이해하고 표현\n            - 데이터의 구조와 관계를 명확히 정의\n    * DB Design\n        - 데이터 모델을 실제 데이터베이스 구조로 변환하는 과정\n        - 특징\n            - **논리적, 물리적 수준**에서 이루어짐\n            - 더 구체적이고 구현에 가까운 수준\n            - 특정 DBMS와 하드웨어 환경을 고려\n            - SQL DDL 등을 사용하여 실제 스키마 생성\n        - 결과물: 데이터베이스 스키마, 테이블 정의, 인덱스 구조 등\n        - 단계: Data Modeling 이후, 실제 구현 전 단계\n            - 논리적 설계: 데이터 모델을 DBMS에 독립적인 형태로 변환\n            - 물리적 설계: 특정 DBMS에 맞는 물리적 구조 설계 (인덱스, 파티션 등)\n        - 목적\n            - 효율적인 데이터 저장, 접근, 관리 구조 설계\n            - 성능, 보안, 확장성 등을 고려한 최적화\n- 학계에서는 엄격하게 구별지으나 실무나 industry에서는 Data Modeling 이나 DB Design을 혼용해서 씀\n    - 편의상 이 블로그에선 Data Modeling = DB Design로 설정\n\n### DB Design 단계 (DB Schema Design)\n\n```{dot}\n//| fig-height: 14\n\ndigraph G {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\n    a0 [label=\"Real World\"];\n    \n\n\tsubgraph cluster_0 {\n\t\tstyle=filled;\n\t\tnode [style=filled,color=white];\n\t\ta1 [label=\"Mini-world\\n(Reduced Scope)\"];\n\t\tlabel = \"DB Design(Data Modeling)\";\n\n        a2 [label=\"Requirements\\nCollection & Analysis\"];\n        a3 [label=\"Documenting\\nData Requirements\"];\n\n        subgraph cluster_1 {\n\t\tnode [style=filled];\n        a4 [label=\"Conceptual Schema\\n(High Level Data Model)\"];\n        a5 [label=\"Entity-Relational Model\\n(Output:ERD)\"];\n        label = \"Conceptual Design\\n(Data Modeling)\";\n\t    }\n\n        subgraph cluster_2 {\n\t\tnode [style=filled];\n        a6 [label=\"Logical Schema\\n(Middle Level Data Model)\"];\n        a7 [label=\"Relational Model\\n(Output:ERD)\\n(Specific DBMS)\"];\n        label = \"Logical Design\\n(Data Modeling)\";\n\t    }\n\n        subgraph cluster_3 {\n\t\tnode [style=filled];\n        a8 [label=\"Physical Schema\\n(Low Level Data Model)\"];\n        a9 [label=\"Entity-Relational Model\\nOutput:ERD\"];\n        a10 [label=\"Logical\\nDesign(Data Modeling)\"];\n        label = \"Physical Design\\n(Data Modeling)\";\n\t    }\n\n        a11 [label=\"Internal Schema\"];\n\t}\n\n\n\ta0 -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> a11;\n    \n}\n\n```    \n\n\n### ERD (Entity-Relationship Diagram)\n\n- 데이터베이스의 구조를 시각적으로 표현한 다이어그램이다.\n- Entity(개체), 속성 (Attribute), 관계(Relationship)를 그래픽 요소로 나타낸다.\n- Entity(개체) \n    - 현실 세계에서 독립적으로 존재하는 객체나 개념을 나타냄\n    - 데이터 모델링 단계에서 사용되는 추상적인 개념\n    - 특징\n        - 보통 명사로 표현 (예: 학생, 강의, 교수)\n        - 속성(Attribute)을 가진다\n        - ERD에서 사각형으로 표현된다.\n        - 일반적으로 ERD의 엔티티는 데이터베이스 설계 과정에서 테이블로 변환된다.\n        - 하나의 엔티티는 대부분 하나의 테이블로 매핑된다.\n- 관계(Relationship)\n    - 엔티티(Entity) 간의 연관성이나 상호작용을 나타내고 Schema의 관계도를 \n    - 두 개 이상의 엔티티 간의 논리적 연결을 표현\n    - 표현 방식: 일반적으로 선으로 연결되며, 관계의 특성을 나타내는 기호나 레이블이 추가됨\n    \n    \n- 예시\n\n    ![ERD Example - Stack overflow by snowflake](../../../../images/governance/erd_example.PNG)\n\n    [link](https://stackoverflow.com/questions/42445390/database-design-erd-diagram-verification)  \n\n### DB Instance\n\n- 특정 시점에 DB에 실제로 저장되어 있는 데이터로 자주 변동된다.","srcMarkdownNoYaml":"\n\n## Data Modeling\n\nData modeling은 DB Schema를 설계하는 과정이라 할 수 있다.\n\n### DB schema\n\n- DB 구조(table 종류), 데이터 타입, 그리고 제약 조건에 대한 명세 (Specification)\n- 테이블 (table or relation), 필드 (field), 관계 (relationship), 뷰 (view), 인덱스 등 데이터베이스 객체들의 논리적 구조를 설명\n- 데이터 베이스 설계 단계에서 명시 되며 자주 변경되지 않음\n- 실제 데이터베이스 시스템에서 구현될 수 있는 형태로 정의된다.\n- SQL DDL(Data Definition Language)로 표현될 수 있다.\n    - 테이블 (table or relation) & 필드 (field)\n        - 예시\n        ```markdown\n        -- example: the Student table\n        CREATE TABLE Student (\n            student_id INT PRIMARY KEY,\n            name VARCHAR(100) NOT NULL\n        );\n        -- example: the Course table\n        CREATE TABLE Course (\n            course_id INT PRIMARY KEY,\n            course_name VARCHAR(100) NOT NULL\n        );\n        ```\n    - 관계 (relationship)\n        - 외래 키(Foreign Key)를 통한 관계 표현: 주로 외래 키를 사용하여 테이블 간의 관계를 표현\n        - 즉, 한 테이블의 컬럼이 다른 테이블의 기본 키를 참조하도록 설정\n        - 관계 표현 방법\n            - ONE-TO-ONE (1:1) 관계\n                - 한 엔티티의 하나의 인스턴스가 다른 엔티티의 하나의 인스턴스와 연관된다.\n                - 한 테이블에 다른 테이블의 기본 키를 외래 키로 추가하고, 이를 유니크 제약조건으로 설정한다.                - \n                - 예: 한 사람은 하나의 여권을 가진다.\n            - ONE-TO-MANY (1:N) 관계\n                - 가장 흔한 관계로, 자식 테이블에 부모 테이블의 기본 키를 외래 키로 추가한다.\n                - 한 엔티티의 하나의 인스턴스가 다른 엔티티의 여러 인스턴스와 연관된다.\n                - 예: 한 부서는 여러 직원을 가질 수 있다.\n            - MANY-TO-MANY (M:N) 관계\n                - 중간 테이블(연결 테이블)을 생성하여 두 테이블의 관계를 표현한다.\n                - 한 엔티티의 여러 인스턴스가 다른 엔티티의 여러 인스턴스와 연관된다.\n                - 예: 학생들은 여러 과목을 수강하고, 각 과목은 여러 학생들에 의해 수강된다.\n        - 관계의 특성\n            - 선택성(Optionality): 관계가 필수적인지 선택적인지를 나타낸다.\n            - 기수성(Cardinality): 관계에 참여하는 엔티티 인스턴스의 수를 나타낸다.\n        - 관계의 역할\n            - 각 엔티티가 관계에서 어떤 역할을 하는지 설명할 수 있다.\n            - 예: '직원'과 '부서' 간의 관계에서 직원은 '소속됨', 부서는 '고용함'의 역할을 한다.\n        - 관계 엔티티\n            - 때로는 관계 자체가 속성을 가질 수 있으며, 이를 관계 엔티티로 모델링한다.\n            - 주로 다대다 관계를 해결하기 위해 사용됩니다.\n        - 재귀적 관계\n            - 한 엔티티가 자기 자신과 관계를 맺는 경우다.\n            - 예: '직원' 엔티티에서 '관리자'와 '부하직원' 관계\n\n        ```markdown\n         -- Course 테이블 생성\n        CREATE TABLE Course (\n            course_id VARCHAR(10) PRIMARY KEY,\n            course_name VARCHAR(100) NOT NULL,\n            credit_hours INT NOT NULL,\n            department VARCHAR(50) NOT NULL\n        );\n\n        -- Student 테이블 생성\n        CREATE TABLE Student (\n            student_id VARCHAR(8) PRIMARY KEY,\n            name VARCHAR(100) NOT NULL,\n            date_of_birth DATE,\n            major VARCHAR(50)\n        );\n\n        -- Section 테이블 생성\n        CREATE TABLE Section (\n            section_id VARCHAR(15) PRIMARY KEY,\n            course_id VARCHAR(10) NOT NULL,\n            semester VARCHAR(10) NOT NULL,\n            year INT NOT NULL,\n            instructor VARCHAR(100),\n            FOREIGN KEY (course_id) REFERENCES Course(course_id)\n        );\n\n        -- Grade_Report 테이블 생성\n        CREATE TABLE Grade_Report (\n            student_id VARCHAR(8),\n            section_id VARCHAR(15),\n            grade CHAR(2),\n            PRIMARY KEY (student_id, section_id),\n            FOREIGN KEY (student_id) REFERENCES Student(student_id),\n            FOREIGN KEY (section_id) REFERENCES Section(section_id)\n        );\n\n        -- 수강 테이블 (학생과 과목의 M:N 관계를 표현)\n        CREATE TABLE Enrollment (\n            student_id INT,\n            course_id INT,\n            enrollment_date DATE,\n            PRIMARY KEY (student_id, course_id),\n            FOREIGN KEY (student_id) REFERENCES Student(student_id),\n            FOREIGN KEY (course_id) REFERENCES Course(course_id)\n        );\n        ```\n\n### Data Modeling vs DB Design\n\n- DB schema를 만드는 과정을 Data Modeling 또는 DB design이라고 부름 (늬앙스 차이가있음)\n    * Data Modeling\n        - 현실 세계의 데이터를 추상화하여 컴퓨터 세계의 데이터로 표현하는 과정\n        - 특징 (데이터 거버넌스와 상대적으로 더 밀접한 관련이 있음)\n            - 주로 **개념적, 논리적 수준**에서 이루어짐\n            - 더 추상적이고 개념적인 수준\n            - 비즈니스 요구사항을 데이터 구조로 변환\n            - ERD(Entity-Relationship Diagram) 등을 사용하여 시각화\n        - 결과물: ERD, 개념적/논리적 데이터 모델\n        - 단계: 프로젝트 초기 단계\n            - 개념적 모델링: 핵심 엔티티와 관계 식별\n            - 논리적 모델링: 속성 정의, 정규화 수행\n        - 목적 \n            - 비즈니스 프로세스와 규칙을 이해하고 표현\n            - 데이터의 구조와 관계를 명확히 정의\n    * DB Design\n        - 데이터 모델을 실제 데이터베이스 구조로 변환하는 과정\n        - 특징\n            - **논리적, 물리적 수준**에서 이루어짐\n            - 더 구체적이고 구현에 가까운 수준\n            - 특정 DBMS와 하드웨어 환경을 고려\n            - SQL DDL 등을 사용하여 실제 스키마 생성\n        - 결과물: 데이터베이스 스키마, 테이블 정의, 인덱스 구조 등\n        - 단계: Data Modeling 이후, 실제 구현 전 단계\n            - 논리적 설계: 데이터 모델을 DBMS에 독립적인 형태로 변환\n            - 물리적 설계: 특정 DBMS에 맞는 물리적 구조 설계 (인덱스, 파티션 등)\n        - 목적\n            - 효율적인 데이터 저장, 접근, 관리 구조 설계\n            - 성능, 보안, 확장성 등을 고려한 최적화\n- 학계에서는 엄격하게 구별지으나 실무나 industry에서는 Data Modeling 이나 DB Design을 혼용해서 씀\n    - 편의상 이 블로그에선 Data Modeling = DB Design로 설정\n\n### DB Design 단계 (DB Schema Design)\n\n```{dot}\n//| fig-height: 14\n\ndigraph G {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\n    a0 [label=\"Real World\"];\n    \n\n\tsubgraph cluster_0 {\n\t\tstyle=filled;\n\t\tnode [style=filled,color=white];\n\t\ta1 [label=\"Mini-world\\n(Reduced Scope)\"];\n\t\tlabel = \"DB Design(Data Modeling)\";\n\n        a2 [label=\"Requirements\\nCollection & Analysis\"];\n        a3 [label=\"Documenting\\nData Requirements\"];\n\n        subgraph cluster_1 {\n\t\tnode [style=filled];\n        a4 [label=\"Conceptual Schema\\n(High Level Data Model)\"];\n        a5 [label=\"Entity-Relational Model\\n(Output:ERD)\"];\n        label = \"Conceptual Design\\n(Data Modeling)\";\n\t    }\n\n        subgraph cluster_2 {\n\t\tnode [style=filled];\n        a6 [label=\"Logical Schema\\n(Middle Level Data Model)\"];\n        a7 [label=\"Relational Model\\n(Output:ERD)\\n(Specific DBMS)\"];\n        label = \"Logical Design\\n(Data Modeling)\";\n\t    }\n\n        subgraph cluster_3 {\n\t\tnode [style=filled];\n        a8 [label=\"Physical Schema\\n(Low Level Data Model)\"];\n        a9 [label=\"Entity-Relational Model\\nOutput:ERD\"];\n        a10 [label=\"Logical\\nDesign(Data Modeling)\"];\n        label = \"Physical Design\\n(Data Modeling)\";\n\t    }\n\n        a11 [label=\"Internal Schema\"];\n\t}\n\n\n\ta0 -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> a11;\n    \n}\n\n```    \n\n\n### ERD (Entity-Relationship Diagram)\n\n- 데이터베이스의 구조를 시각적으로 표현한 다이어그램이다.\n- Entity(개체), 속성 (Attribute), 관계(Relationship)를 그래픽 요소로 나타낸다.\n- Entity(개체) \n    - 현실 세계에서 독립적으로 존재하는 객체나 개념을 나타냄\n    - 데이터 모델링 단계에서 사용되는 추상적인 개념\n    - 특징\n        - 보통 명사로 표현 (예: 학생, 강의, 교수)\n        - 속성(Attribute)을 가진다\n        - ERD에서 사각형으로 표현된다.\n        - 일반적으로 ERD의 엔티티는 데이터베이스 설계 과정에서 테이블로 변환된다.\n        - 하나의 엔티티는 대부분 하나의 테이블로 매핑된다.\n- 관계(Relationship)\n    - 엔티티(Entity) 간의 연관성이나 상호작용을 나타내고 Schema의 관계도를 \n    - 두 개 이상의 엔티티 간의 논리적 연결을 표현\n    - 표현 방식: 일반적으로 선으로 연결되며, 관계의 특성을 나타내는 기호나 레이블이 추가됨\n    \n    \n- 예시\n\n    ![ERD Example - Stack overflow by snowflake](../../../../images/governance/erd_example.PNG)\n\n    [link](https://stackoverflow.com/questions/42445390/database-design-erd-diagram-verification)  \n\n### DB Instance\n\n- 특정 시점에 DB에 실제로 저장되어 있는 데이터로 자주 변동된다."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"github","css":["../../../../styles.css"],"toc":true,"toc-depth":3,"number-sections":true,"include-in-header":[{"text":"<style>\n.custom-footer { \n  text-align: center; \n  font-size: 0.8em; \n  color: #666; \n  margin-top: 2rem; \n}\n</style>\n"}],"include-after-body":["../../../../js.html","../../signup.html"],"output-file":"4-3.data_model_schema.html"},"language":{"toc-title-document":"목차","toc-title-website":"목차","related-formats-title":"기타 형식","related-notebooks-title":"Notebooks","source-notebooks-prefix":"원천","other-links-title":"기타 링크","code-links-title":"코드 링크","launch-dev-container-title":"Dev 컨테이너 실행","launch-binder-title":"랜치 Binder","article-notebook-label":"기사 노트북","notebook-preview-download":"노트북 다운로드","notebook-preview-download-src":"소스 다운로드","notebook-preview-back":"기사로 돌아가기","manuscript-meca-bundle":"MECA 아카이브","section-title-abstract":"초록","section-title-appendices":"부록","section-title-footnotes":"각주","section-title-references":"참고문헌","section-title-reuse":"라이센스","section-title-copyright":"저작권","section-title-citation":"인용","appendix-attribution-cite-as":"인용방법","appendix-attribution-bibtex":"BibTeX 인용:","title-block-author-single":"저자","title-block-author-plural":"저자","title-block-affiliation-single":"소속","title-block-affiliation-plural":"소속","title-block-published":"공개","title-block-modified":"Modified","title-block-keywords":"키워드","callout-tip-title":"힌트","callout-note-title":"노트","callout-warning-title":"경고","callout-important-title":"중요","callout-caution-title":"주의","code-summary":"코드","code-tools-menu-caption":"코드","code-tools-show-all-code":"전체 코드 표시","code-tools-hide-all-code":"전체 코드 숨기기","code-tools-view-source":"소스 코드 표시","code-tools-source-code":"소스 코드","tools-share":"Share","tools-download":"Download","code-line":"선","code-lines":"윤곽","copy-button-tooltip":"클립보드 복사","copy-button-tooltip-success":"복사완료!","repo-action-links-edit":"편집","repo-action-links-source":"소스코드 보기","repo-action-links-issue":"이슈 보고","back-to-top":"맨 위로","search-no-results-text":"일치 없음","search-matching-documents-text":"일치된 문서","search-copy-link-title":"검색 링크 복사","search-hide-matches-text":"추가 검색 결과 숨기기","search-more-match-text":"추가 검색결과","search-more-matches-text":"추가 검색결과","search-clear-button-title":"제거","search-text-placeholder":"","search-detached-cancel-button-title":"취소","search-submit-button-title":"검색","search-label":"검색","toggle-section":"토글 섹션","toggle-sidebar":"사이드바 전환","toggle-dark-mode":"다크 모드 전환","toggle-reader-mode":"리더 모드 전환","toggle-navigation":"탐색 전환","crossref-fig-title":"그림","crossref-tbl-title":"표","crossref-lst-title":"목록","crossref-thm-title":"정리","crossref-lem-title":"보조정리","crossref-cor-title":"따름정리","crossref-prp-title":"명제","crossref-cnj-title":"추측","crossref-def-title":"정의","crossref-exm-title":"보기","crossref-exr-title":"예제","crossref-ch-prefix":"장","crossref-apx-prefix":"부록","crossref-sec-prefix":"섹션","crossref-eq-prefix":"방정식","crossref-lof-title":"그림 목록","crossref-lot-title":"표 목록","crossref-lol-title":"코드 목록","environment-proof-title":"증명","environment-remark-title":"주석","environment-solution-title":"해답","listing-page-order-by":"정렬","listing-page-order-by-default":"디폴트","listing-page-order-by-date-asc":"날짜(오름차순)","listing-page-order-by-date-desc":"날짜(내림차순)","listing-page-order-by-number-desc":"페이지 번호(내림차순)","listing-page-order-by-number-asc":"페이지 번호(오름차순)","listing-page-field-date":"날짜","listing-page-field-title":"제목","listing-page-field-description":"설명","listing-page-field-author":"저자","listing-page-field-filename":"파일명","listing-page-field-filemodified":"갱신일","listing-page-field-subtitle":"부제목","listing-page-field-readingtime":"읽기 시간","listing-page-field-wordcount":"단어 수","listing-page-field-categories":"분류","listing-page-minutes-compact":"{0} 분","listing-page-category-all":"전체","listing-page-no-matches":"일치 없음","listing-page-words":"{0} 단어"},"metadata":{"lang":"ko","fig-responsive":true,"quarto-version":"1.4.543","theme":{"light":["cosmo","../../../../theme.scss"],"dark":["cosmo","../../../../theme-dark.scss"]},"code-copy":true,"grid":{"sidebar-width":"200px","body-width":"1150px","margin-width":"300px"},"comments":{"giscus":{"repo":"kmink3225/blog","category":"Blog"}},"title-block-banner":"#EDF3F9","title-block-banner-color":"black","toc-location":"right","open-graph":true,"twitter-card":true,"search":true,"date-format":"YYYY년 MM월 DD일","title":"Data Governance Study - Data Model (4)","subtitle":"데이터 모델링 기초: Data Modeling과 DB 설계 기초","description":"이 블로그에서는 데이터 모델링과 데이터베이스 설계의 핵심 개념을 다룬다. DB 스키마, 데이터 모델링과 DB 설계의 차이, 설계 단계, ERD(Entity-Relationship Diagram)의 구성 요소 등을 상세히 설명한다.","author":"Kwangmin Kim","categories":["Data Governance"],"date":"2024-08-07","number-depth":4},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}