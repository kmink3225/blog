{"title":"FDA Software Validation Guidance Summary","markdown":{"yaml":{"title":"FDA Software Validation Guidance Summary","subtitle":"Dcoument: General Principles of Software Validation","description":"The purpose of this blog is to get a rough concept of the FDA approval process by making a summary of the 'General Principles of the 'Software Validation; Final Guidance for Industry and FDA Staff' document issued on 2002-01-11. So far, the document seems to be still valid taking into account that its guidance for the FDA approval are broad, general, and comprehensive, and that many recent FDA documents supplement it.\n","categories":["Surveilance"],"author":"Kwangmin Kim","number-sections":true,"date":"12/15/2022","image":"FDA_medical.PNG"},"headingText":"Information on the Document","containsRefs":false,"markdown":"\n\n\n## Notice\n\n* I am so sorry not for providing a compfortab visualization. Although I have tried to use *revealjs* provided in the guide section in the *Quarto* website, I am still clumsy at handling it. I will update this article as I get proficient at *revealjs* using *Quarto*.\n* The FDA validation guidance document is a bit difficult to understand because its explanations provides abstract, general, and present broad cocepts. For this reason, I compiled and made a summary of the document with many diagrams. However, some diagrams are too small to see. Please, **scroll up your mouse wheel with the 'Ctrl' key on your keyboard pressed to zoom in on the small text in the diagrams**.\n* (Writing in Progress) It is hard to say that this version of summary is suitable for representing and covering the original document. Some of the content of this document has been excluded for personal use (less than 10% of it have been excluded).\n\n### Last Update\n* 2022-12-28, [download this article as PDF](sw_validation_ver1.pdf)\n* 2022-12-28, [summary with diagrams](../2023-01-27_FDA_sw_general_guidance_presentation/index.qmd)\n\n\n### Source\n[FDA: General Principles of Software Validation](https://www.fda.gov/regulatory-information/search-fda-guidance-documents/general-principles-software-validation)\n\n### Rationale\nFDA has reported the following analysis:\n\n* 242 of 3140 (7.7%) medical device recalls between 1992 and 1998 are attributable to software failures. \n* 192 of the 242 (79.3%) failures were caused by software defects that were introduced when changes were made to the software after its initial production and distribution. \n* The software validation check is a principal means of avoiding such defects and resultant recalls.\n\n### Main Institutions\n\n* Center for Devices and Radiological Health (CDRH)\n* U.S. Department Of Health and Human Services\n* Food and Drug Administration\n* Center for Biologics Evaluation and Research\n\n# Document Summary\n\n## Purpose\nThe purpose is to make a sketch of general validation principle of the validation of medical device software or software used to design or develop. \n\n## Scope\nThe scope of this guidance is broad. The important activities for the software validation include at least:\n\n* planning,\n* verfication, \n* testing, \n* traceability, and \n* configuration management. \n\nAll of the activities above should be \n\n* integrated \n* be able to describe software life cycle management and \n* be able to describe software risk management.\n\nThe software validation and verification activities should be focused into the entire software life cycle.\n(It does not necessarily mean that the activies must follow any technical models.)\n\nThe guidance is applicable to any software related to a regulated medical device and anyone who is employed in a bio or medical industry.\n\n### The Least Burdensome Approach\nThe guidance reflects that *the minimum list of the relavant scientific and legal requirements* that you must comply with. \n\n### Regulatory Requirements for Software Validation\n* Software validation: a requirement of **the Quality System regulation**, which was published in the Federal Register on October 7, 1996 and took effect on June 1, 1997. (See Title 21 Code of Federal Regulations (CFR) Part 820, and 61 Federal Register (FR) 52602, respectively.)\n* Specific requirements for validation of device software are found in 21 CFR §820.30(g). Other design controls, such as planning, input, verification, and reviews, are required for medical device software. (See 21 CFR §820.30.) \n* computer systems used to create, modify, and maintain electronic records and to manage electronic signatures are also subject to the validation requirements. (See 21 CFR §11.10(a).) \n\n#### Objective\nThe objective of software validation is to ensure:\n\n* accuracy\n* reliability\n* consistent intended performance, and \n* the ability to discern invalid or altered records.\n\n#### What to validate\n**Any software** used to automate device design, testing, component acceptance, manufacturing, labeling, packaging, distribution, complaint handling, or to automate any other aspect of the quality system, including any off-the-shelf software.\n\n### Quality System Regulation vs Pre-market Submissions\nThis document **does not address** any specific requirements **but** general ones.\nSpecific issues should be addressed to  \n\n* the Office of Device Evaluation (ODE), \n* Center for Devices and Radiological Health (CDRH) \n* the Office of Blood Research and Review, \n* Center for Biologics Evaluation and Research (CBER). \nSee the references in Appendix A for applicable FDA guidance documents for pre-market submissions.\n\n## Context for Software Validation\n\n* Validation elements that FDA expects to do for the Quality System regulation, using the principles and tasks are listed in Sections 4 and 5.\n* Additional specific information is available from many of the references listed in Appendix A\n\n### Definition and Terminology\nThe medical device Quality System regulation (21 CFR 820.3(k)) defines \n\n* \"establish\" = \"define, document, and implement\" \n* \"establish\" = \"established\"\n* Confusing terminology between the medical device Quality System regulation and the software industry:\n    * requirements, \n    * specification, \n    * verification, and \n    * validation.\n\n#### Requirements and Specifications\nThe Quality System regulation states  \n\n1. that design input requirements must be documented and\n1. that specified requirements must be verified\n\nBut, the regulation does not further clarify the distinction between the terms “requirement” and “specification.”\n\n* Requirement \n  * can be any need or expectation for a system or for its software. \n  * reflects the stated or implied needs of the customer: requirements may be \n    * market-based, \n    * contractual,\n    * statutory, or \n    * an organization's internal requirements. \n  * various examples of requirements \n    * design, functional, implementation, interface, performance, or physical requirements \n  * Software requirements derived from the system requirements for those aspects of system functionality \n  * Software requirements are typically stated in functional terms and are defined, refined, and updated as a development project progresses. \n  * Success in accurately and completely documenting software requirements is a crucial factor in successful validation of the resulting software.\n* Specification\n  * defined as “a document that states requirements.” (See 21 CFR §820.3(y).) \n  * It may refer to or include drawings, patterns, or other relevant documents \n  * It usually indicates the means and the criteria whereby conformity with the requirement can be checked. \n  * Various examples of written specifications\n    * system requirements specification, \n    * software requirements specification, \n    * software design specification, \n    * software test specification, \n    * software integration specification, etc. \n  * All of these documents are design outputs for which various forms of verification are necessary.\n\n#### Verifiaction and Validation\n\nThe Quality System regulation is harmonized with ISO 8402:1994, which treats “verification” and “validation” as separate and distinct terms.\n\n* Software verification \n  * It provides objective evidence that the design outputs of a particular phase of the software development life cycle meet all of the specified requirements for that phase. \n  * It looks for \n    * consistency, \n    * completeness, and \n    * correctness of the software and its supporting documentation\n  * **Software testing** \n    * verification activities intended to confirm that software development output meets its input requirements. \n  * Types of verification activities include\n    * various static and dynamic analyses, \n    * code and document inspections, \n    * walkthroughs, and other techniques.\n* Software Validation\n  *  Confirmation by examination and provision of the following objective evidence:\n    * Evidence 1: software specifications conform to **user needs and intended uses**, and \n    * Evidnece 2: the particular requirements implemented through software can be consistently fulfilled.\n    * Evidnece 3: all software requirements have been implemented **correctly and completely and are traceable** to system requirements. \n  * A conclusion that software is validated is highly dependent upon **comprehensive** software testing, inspections, analyses, and other verification tasks performed **at each stage of the software development life cycle**. \n  * **Testing** of device software functionality in a **simulated* use environment**, and **user site testing** are typically included as components of an overall design validation program for a software automated device.\n* Difficulty in Software verification and validation \n  * a developer cannot test forever, and \n  * it is difficult to know how much evidence is enough. \n  * In large measure, software validation is a matter of developing a **“level of confidence”** that the device meets all requirements and user expectations for the software automated functions and features of the device. \n  * Considerations for an acceptable level of confidence\n    * measures such as defects found in specifications documents, \n    * estimates of defects remaining, \n    * testing coverage, and other techniques are all used to develop  before shipping the product. \n    * However, a level of confidence varies depending upon the safety risk (hazard) posed by the automated functions of the device. (Info on safety risk is found in Section 4 and in the international standards ISO/IEC 14971-1 and IEC 60601-1-4 referenced in Appendix A).\n\n#### IQ/OQ/PQ\nIQ/OQ/PQ are the terminology related to user site software validation\n\n* Installation qualification (IQ)\n* Operational qualification (OQ) \n* Performance qualification (PQ). \n\nDefinitions of these terms may be found in FDA’s Guideline on General Principles of Process Validation, dated May 11, 1987, and in FDA’s Glossary of Computerized System and Software Development Terminology, dated August 1995.\nBoth FDA personnel and device manufacturers need to be aware of these differences in terminology as they ask for and provide information regarding software validation.\n\n### Software Development as Part of System Design\nSoftware validation must be considered within the context of the overall design validation for the system.\nA documented requirements specification represents \n\n  * the user's needs\n  * intended uses from which the product is developed. \n\nA primary goal of software validation is to then demonstrate that all completed software products comply with all documented software and system requirements.\n\n### Software Is Different from Hardware\nSoftware engineering needs an even greater level of managerial scrutiny and control than does hardware engineering.\n\n### Benefits of Software Validation\n\n* Increase the usability and reliability of the device, \n* Resulting in decreased failure rates, fewer recalls and corrective actions, less risk to patients and users, and reduced liability to device manufacturers. \n* Software validation can also reduce long term costs by making it easier and less costly to reliably modify software and revalidate software changes. \n\n### Design Review\nDesign reviews are documented, comprehensive, and systematic examinations of a design to evaluate \n\n* the adequacy of the design requirements, \n* the capability of the design to meet these requirements, and \n* to identify problems. \n\nDesign review is a primary tool for managing and evaluating development projects. \n\n* It is strongly recommended that it should be formal design because it is more structured than the informal one.\n* It includes participation from others outside the development team. \n* It may review reference or include results from other formal and informal reviews. \n* Design reviews should include \n  * examination of development plans, \n  * requirements specifications, \n  * design specifications, \n  * testing plans and procedures, \n  * all other documents and activities associated with the project, \n  * verification results from each stage of the defined life cycle, and \n  * validation results for the overall device.\n* The Quality System regulation requires that at least one formal design review be conducted during the device  design process. **However, it is recommended that multiple design reviews be conducted** \n  * (e.g., at the end of each software life cycle activity, in preparation for proceeding to the next activity). \n* Formal design reviews documented should include:\n  * the appropriate tasks and expected results, outputs, or products been established for each software life cycle activity\n  * correctness, completeness, consistency, and accuracy\n  * satisfaction for the standards, practices, and conventions of that activity\n  * establishment of a proper basis for initiating tasks for the next software life cycle activity\n\n## Principles of Software Validation\n\n### Requirements\n\nA documented software requirements specification provides a baseline for both validation and verification. **The software validation process must include an established software requirements specification** (Ref: 21 CFR 820.3(z) and (aa) and 820.30(f) and (g)).\n\n### Defect Prevention\n\nIn order to establish that confidence, software developers should use a mixture of methods and techniques to prevent software errors and to detect software errors that do occur. \n\n### Time and Effort\n\nPreparation for software validation should begin early, i.e., **during design and development planning and design input**. The final conclusion that the software is validated should be **based on evidence** collected from planned efforts conducted throughout the software lifecycle.\n\n### Software Life Cycle\n\n* Software validation takes place within the environment of an established software life cycle. \n* The software life cycle contains **software engineering tasks and documentation** necessary to support the software validation effort.\n* specific verification and validation tasks need to be appropriate for the intended use of the software\n\n### Plans\n\n* The software validation process is defined and controlled through the use of a plan. \n* The software validation plan defines “what” is to be accomplished through the software validation effort. \n* Software validation plans specify areas such as\n  * scope, \n  * approach, \n  * resources, \n  * schedules and the types and extent of activities, \n  * tasks, and \n  * work items.\n\n### Procedures\n\nThe software validation process is executed through the use of procedures. These procedures establish “how” to conduct the software validation effort. The procedures should identify the specific actions or sequence of actions that must be taken to complete individual validation activities, tasks, and work items.\n\n### Software Validation After a Change\n\n* Due to the complexity of software, a small local change may have a significant global system impact. \n* If a change exists in the software, the whole validation status of the software needs to be re-established. \n* need to determine the extent and impact of that change on the entire software system. \n* the software developer should then conduct an appropriate level of software regression testing to show that unchanged but vulnerable portions of the system have not been adversely affected. \n\n### Validation Coverage\n\n* Validation coverage should be based on the software’s complexity and safety risk. \n* The selection of validation activities, tasks, and work items should be commensurate with the complexity of the software design and the risk associated with the use of the software for the specified intended use. \n\n### Independence of Review\n\n* Validation activities should be based on the basic quality assurance precept of “independence of review.” \n* Self-validation is extremely difficult. \n* When possible, an independent evaluation is always better (like a contracted third-party independent verification and validation)\n* Another approach is to assign internal staff members that are not involved in a particular design or its implementation, but who have sufficient knowledge to evaluate the project and conduct the verification and validation activities. \n\n### Flexibility and Responsibility\n\nThe device manufacturer has flexibility in choosing how to apply these validation principles, but retains ultimate responsibility for demonstrating that the software has been validated.\nFDA regulated medical device applications include software that:\n\n* Is a component, part, or accessory of a medical device;\n  * components: e.g., application software, operating systems, compilers, debuggers, configuration management tools, and many more\n* Is itself a medical device; or\n* Is used in manufacturing, design and development, or other parts of the quality system.\n* No matter how complex and disperse the software is, the manufacturer is in charge of responsibility for software validation.\n\n## Activities and Tasks\n\nSoftware validation is accomplished through **a series of activities and tasks** that are planned and executed at various stages of the software development life cycle. \nThese tasks may be \n\n* one time occurrences \n* iterated many times\n\n### Software Life Cycle Activities\n\n* Software developers should establish a software life cycle model that is appropriate for their product and organization. \n* The selected software life cycle model should cover the software from its birth to its retirement. \n* Activities in a typical software life cycle model: \n  * Quality Planning\n  * System Requirements Definition\n  * Detailed Software Requirements Specification\n  * Software Design Specification\n  * Construction or Coding\n  * Testing\n  * Installation\n  * Operation and Support\n  * Maintenance\n  * Retirement\n* Verification, testing, and other tasks that support software validation occur during each of these activities. \n* Several software life cycle models defined in FDA’s Glossary of Computerized System and Software Development \n\nTerminology dated August 1995:\n\n  * waterfall\n  * spiral\n  * rapid prototyping\n  * incremental development, etc.\n\n### Typical Tasks Supporting Validation\n\nthe software developer should at least consider each of the risk-related tasks and should define and document which tasks are or are not appropriate for their specific application. \n\n#### Quality Planning\n\nDesign and development planning should culminate in a plan that identifies \n\n* necessary tasks, \n* procedures for anomaly reporting and resolution, \n* necessary resources, and \n* management review requirements including formal design reviews. \n\nThe plan should include:\n\n* The specific tasks for each life cycle activity;\n* Enumeration of important quality factors (e.g., reliability, maintainability, and usability);\n* Methods and procedures for each task;\n* Task acceptance criteria;\n* Criteria for defining and documenting outputs in terms that will allow evaluation of their conformance to input requirements;\n* Inputs for each task;\n* Outputs from each task;\n* Roles, resources, and responsibilities for each task;\n* Risks and assumptions; and\n* Documentation of user needs.\n\nThe plan should identify \n\n* the personnel, \n* the facility and equipment resources for each task, and \n* the role that risk (hazard) management will play. \n\nA configuration management plan should be developed that will guide and control multiple parallel development activities and ensure proper communications and documentation. \n\nControls are necessary to ensure positive and correct correspondence among all approved versions of the specifications documents, source code, object code, and test suites that comprise a software system. The controls also should ensure accurate identification of, and access to, the currently approved versions.\n\nProcedures should be created for reporting and resolving software anomalies found through validation or other activities. \n\nManagement should identify the reports and specify the contents, format, and responsible organizational elements for each report. Procedures also are necessary for the review and approval of software development results, including the responsible organizational elements for such reviews and approvals.\n\nTypical Tasks – Quality Planning\n\n* Risk (Hazard) Management Plan\n* Configuration Management Plan\n* Software Quality Assurance Plan\n  * Software Verification and Validation Plan\n    * Verification and Validation Tasks, and Acceptance Criteria\n    * Schedule and Resource Allocation (for software verification and validation activities)\n    * Reporting Requirements\n  * Formal Design Review Requirements\n  * Other Technical Review Requirements\n* Problem Reporting and Resolution Procedures\n* Other Support Activities\n\n#### Requirements\n\nRequirements development includes the \n\n* identification, \n* analysis, and \n* documentation of information about the device and its intended use. \n\nAreas of special importance include allocation of system functions to \n\n* hardware/software, \n* operating conditions, \n* user characteristics, \n* potential hazards, and\n* anticipated tasks.\n\nIn addition, the requirements should state clearly the intended use of the software.\nIt is not possible to validate software without predetermined and documented software requirements. \nTypical software requirements specify the following:\n\n* All software system inputs;\n* All software system outputs;\n* All functions that the software system will perform;\n* All performance requirements that the software will meet, (e.g., data throughput, reliability, and timing);\n* The definition of all external and user interfaces, as well as any internal software-to-system interfaces;\n* How users will interact with the system;\n* What constitutes an error and how errors should be handled;\n* Required response times;\n* The intended operating environment for the software, if this is a design constraint (e.g., hardware platform, operating system);\n* All ranges, limits, defaults, and specific values that the software will accept; and\n* All safety related requirements, specifications, features, or functions that will be implemented in software.\n\nSoftware requirement specifications should identify clearly the potential hazards that can result from a software failure in the system as well as any safety requirements to be implemented in software. \n\nThe consequences of software failure should be evaluated, along with means of mitigating such failures (e.g., hardware mitigation, defensive programming, etc.). \n\nThe Quality System regulation requires a mechanism for addressing incomplete, ambiguous, or conflicting requirements. (See 21 CFR 820.30(c).) Each requirement (e.g., hardware, software, user, operator interface, and safety) identified in the software requirements specification should be evaluated for accuracy, completeness, consistency, testability, correctness, and clarity. \n\nFor example, software requirements should be evaluated to verify that:\n\n* There are no internal inconsistencies among requirements;\n* All of the performance requirements for the system have been spelled out;\n* Fault tolerance, safety, and security requirements are complete and correct;\n* Allocation of software functions is accurate and complete;\n* Software requirements are appropriate for the system hazards; and\n* All requirements are expressed in terms that are measurable or objectively verifiable.\n\nA software requirements traceability analysis should be conducted to trace software requirements to\n(and from) system requirements and to risk analysis results. In addition to any other analyses and\ndocumentation used to verify software requirements, a formal design review is recommended to confirm\nthat requirements are fully specified and appropriate before extensive software design efforts begin.\nRequirements can be approved and released incrementally, but care should be taken that interactions\nand interfaces among software (and hardware) requirements are properly reviewed, analyzed, and\ncontrolled.\n\nTypical Tasks – Requirements\n\n* Preliminary Risk Analysis\n* Traceability Analysis\n  * Software Requirements to System Requirements (and vice versa)\n  * Software Requirements to Risk Analysis\n* Description of User Characteristics\n* Listing of Characteristics and Limitations of Primary and Secondary Memory\n* Software Requirements Evaluation\n* Software User Interface Requirements Analysis\n* System Test Plan Generation\n* Acceptance Test Plan Generation\n* Ambiguity Review or Analysis\n\n#### Design\n\nIn the design process, the software requirements specification is translated into a logical and physical\nrepresentation of the software to be implemented. The software design specification is a description of what the software should do and how it should do it. The design specification may contain both a high level summary of the design and detailed design information.\nHuman factors engineering should be woven into \n\n* the entire design and development process, \n* the device design requirements, \n* analyses, and \n* tests. \n\nDevice safety and usability issues should be considered when developing \n\n* flowcharts, \n* state diagrams, \n* prototyping tools, and \n* test plans. \n\nAlso, task and function analyses, risk analyses, prototype tests and reviews, and full usability tests should be\nperformed. Participants from the user population should be included when applying these methodologies.\n\nThe software design specification should include:\n\n* Software requirements specification, including predetermined criteria for acceptance of the software;\n* Software risk analysis;\n* Development procedures and coding guidelines (or other programming procedures);\n* Systems documentation (e.g., a narrative or a context diagram) that describes the systems context in which the program is intended to function, including the relationship of hardware, software, and the physical environment;\n* Hardware to be used;\n* Parameters to be measured or recorded;\n* Logical structure (including control logic) and logical processing steps (e.g., algorithms);\n* Data structures and data flow diagrams;\n* Definitions of variables (control and data) and description of where they are used;\n* Error, alarm, and warning messages;\n* Supporting software (e.g., operating systems, drivers, other application software);\n* Communication links (links among internal modules of the software, links with the supporting software, links with the hardware, and links with the user);\n* Security measures (both physical and logical security); and\n* Any additional constraints not identified in the above elements.\n\nThe first four of the elements noted above usually are separate pre-existing documents that are included\nby reference in the software design specification. \nSoftware requirements specification was discussed in the preceding section, as was software risk analysis. \n\nSoftware design evaluations criteria: \n\n* complete, \n* correct, \n* consistent, \n* unambiguous, \n* feasible,\n* maintainable,\n* analyses of control flow,\n* data flow, \n* complexity, \n* timing, \n* sizing, \n* memory allocation, \n* criticality analysis, and many other aspects of the design \n\nAppropriate consideration of software architecture (e.g., modular structure) during design can reduce the magnitude of future validation efforts when software changes are needed. \n\nA traceability analysis should be conducted to verify that the software design implements all of the software requirements. As a technique for identifying where requirements are not sufficient, the traceability analysis should also verify that all aspects of the design are traceable to software requirements. \n\nAn analysis of communication links should be conducted to evaluate the proposed design with respect to hardware, user, and related software requirements.\nAt the end of the software design activity, a Formal Design Review should be conducted to verify that the design is correct, consistent, complete, accurate, and testable, before moving to implement the design. \n\nSeveral versions of both the software requirement specification and the software design specification should be maintained. All approved versions should be archived and controlled in accordance with established configuration management procedures.\n\nTypical Tasks – Design\n\n* Updated Software Risk Analysis\n* Traceability Analysis - Design Specification to Software Requirements (and vice versa)\n* Software Design Evaluation\n* Design Communication Link Analysis\n* Module Test Plan Generation\n* Integration Test Plan Generation\n* Test Design Generation (module, integration, system, and acceptance)\n\n#### Construction or Coding\n\nSoftware may be constructed either by coding. Coding is the software activity where the detailed design specification is implemented as source code. It is the last stage in decomposition of the software requirements where module specifications are translated into a programming language.\n\nCoding usually involves the use of a high-level programming language, but may also entail the use of\nassembly language (or microcode) for time-critical operations. \n\nA source code traceability analysis is an important tool to verify that all code is linked to established specifications and established test procedures. A source code traceability analysis should be conducted\nand documented to verify that:\n\n* Each element of the software design specification has been implemented in code;\n* Modules and functions implemented in code can be traced back to an element in the software design specification and to the risk analysis;\n* Tests for modules and functions can be traced back to an element in the software design specification and to the risk analysis; and\n* Tests for modules and functions can be traced to source code for the same modules and functions.\n\nTypical Tasks – Construction or Coding\n\n* Traceability Analyses\n  * Source Code to Design Specification (and vice versa)\n  * Test Cases to Source Code and to Design Specification\n* Source Code and Source Code Documentation Evaluation\n* Source Code Interface Analysis\n* Test Procedure and Test Case Generation (module, integration, system, and acceptance)\n\n#### Testing by the Software Developer\n\nSoftware testing entails running software products under known conditions with defined inputs and documented outcomes that can be compared to their predefined expectations. It is a time consuming, difficult, and imperfect activity. \n\nAs such, it requires early planning in order to be effective and efficient. Test plans and test cases should be created as early in the software development process as feasible.\n\nThey should identify \n\n* the schedules, \n* environments, \n* resources (personnel, tools, etc.), \n* methodologies,\n* cases (inputs, procedures, outputs, expected results), \n* documentation, and \n* reporting criteria. \n\nDescriptions of categories of software and software testing effort appear in the literature\n\n* NIST Special Publication 500-235, Structured Testing: A Testing Methodology Using the Cyclomatic Complexity Metric;\n* NUREG/CR-6293, Verification and Validation Guidelines for High Integrity Systems; and\n* IEEE Computer Society Press, Handbook of Software Reliability Engineering. \n\nTesting of all program functionality does not mean all of the program has been tested. Testing of all of a program's code does not mean all necessary functionality is present in the program. Testing of all program functionality and all program code does not mean the program is 100% correct! Software testing that finds no errors should not be interpreted to mean that errors do not exist in the software product; it may mean the testing was superficial.\n\nAn essential element of a software test case is the expected result. It is the key detail that permits objective evaluation of the actual test result. This necessary testing information is obtained from the corresponding, predefined definition or specification. \n\nA software testing process should be based on principles that foster effective examinations of a software product. Applicable software testing tenets include:\n\n* The expected test outcome is predefined;\n* A good test case has a high probability of exposing an error;\n* A successful test is one that finds an error;\n* There is independence from coding;\n* Both application (user) and software (programming) expertise are employed;\n* Testers use different tools from coders;\n* Examining only the usual case is insufficient;\n* Test documentation permits its reuse and an independent confirmation of the pass/fail status of a test outcome during subsequent review.\n\nCode-based testing is also known as structural testing or \"white-box\" testing. It identifies test cases based on knowledge obtained from the source code, detailed design specification, and other development documents. Structural testing can identify \"dead\" code that is never executed when the program is run. Structural testing is accomplished primarily with unit (module) level testing, but can be extended to other levels of software testing.\n\nThe level of structural testing can be evaluated using **metrics that are designed to show what percentage of the software structure has been evaluated during structural testing**. These metrics are typically referred to as **“coverage”** and are a measure of completeness with respect to test selection criteria. The amount of structural coverage should be commensurate with the level of risk posed by the software. Use of the term “coverage” usually means 100% coverage. \nCommon structural coverage metrics include:\n\n* Statement Coverage – This criteria requires sufficient test cases for each program statement to be executed at least once; however, its achievement is insufficient to provide confidence in a software product's behavior.\n* Decision (Branch) Coverage – This criteria requires sufficient test cases for each program decision or branch to be executed so that each possible outcome occurs at least once. It is considered to be a minimum level of coverage for most software products, but decision coverage alone is insufficient for high-integrity applications.\n* Condition Coverage – This criteria requires sufficient test cases for each condition in a program decision to take on all possible outcomes at least once. It differs from branch coverage only when multiple conditions must be evaluated to reach a decision.\n* Multi-Condition Coverage – This criteria requires sufficient test cases to exercise all possible combinations of conditions in a program decision.\n* Loop Coverage – This criteria requires sufficient test cases for all program loops to be executed for zero, one, two, and many iterations covering initialization, typical running and termination (boundary) conditions.\n* Path Coverage – This criteria requires sufficient test cases for each feasible path, basis path, etc., from start to exit of a defined program segment, to be executed at least once. Because of the very large number of possible paths through a software program, path coverage is generally not achievable. The amount of path coverage is normally established based on the risk or criticality of the software under test.\n* Data Flow Coverage – This criteria requires sufficient test cases for each feasible data flow to be executed at least once. A number of data flow testing strategies are available.\n\nThe following types of functional software testing involve generally increasing levels of effort:\n\n* Normal Case – Testing with usual inputs is necessary. However, testing a software product only with expected, valid inputs does not thoroughly test that software product. By itself, normal case testing cannot provide sufficient confidence in the dependability of the software product.\n* Output Forcing – Choosing test inputs to ensure that selected (or all) software outputs are generated by testing.\n* Robustness – Software testing should demonstrate that a software product behaves correctly when given unexpected, invalid inputs. Methods for identifying a sufficient set of such test cases include Equivalence Class Partitioning, Boundary Value Analysis, and Special Case Identification (Error Guessing). While important and necessary, these techniques do not ensure that all of the most appropriate challenges to a software product have been identified for testing.\n* Combinations of Inputs – The functional testing methods identified above all emphasize individual or single test inputs. Most software products operate with multiple inputs under their conditions of use. Thorough software product testing should consider the combinations of inputs a software unit or system may encounter during operation. Error guessing can be extended to identify combinations of inputs, but it is an ad hoc technique. Cause-effect graphing is one functional software testing technique that systematically identifies combinations of inputs to a software product for inclusion in test cases. \n\nFunctional and structural software test case identification techniques provide specific inputs for testing, rather than random test inputs. One weakness of these techniques is the difficulty in linking structural and functional test completion criteria to a software product's reliability. \n\n**Advanced software testing methods**, such as statistical testing, can be employed to provide further assurance that a software product is dependable. Statistical testing uses randomly generated test data from defined distributions based on an operational profile (e.g., expected use, hazardous use, or malicious use of the software product). Large amounts of test data are generated and can be targeted to cover particular areas or concerns, providing an increased possibility of identifying individual and multiple rare operating conditions that were not anticipated by either the software product's designers or its testers. Statistical testing also provides high structural coverage. It does require a stable software product. Thus, structural and functional testing are prerequisites for statistical testing of a software product.\n\nAnother aspect of software testing is the testing of software changes. Changes occur frequently during software development. These changes are the result of \n\n1. debugging that finds an error and it is corrected, \n1. new or changed requirements (\"requirements creep\"), and \n1. modified designs as more effective or efficient implementations are found. \n\nOnce a software product has been baselined (approved), any change to that product should have its own “mini life cycle,” including testing. Testing of a changed software product requires additional effort. It should demonstrate \n\n* that the change was implemented correctly, and\n* that the change did not adversely impact other parts of the software product. \n\n**Regression analysis** is the determination of the impact of a change based on review of the relevant documentation in order to identify the necessary regression tests to be run. **Regression testing** is the rerunning of test cases that a program has previously executed correctly and **comparing the current result to the previous result in order to detect unintended effects of a software change**. Regression analysis and regression testing should also be employed when using integration methods to build a software product to ensure that newly integrated modules do not adversely impact the operation of previously integrated modules.\n\nIn order to provide a thorough and rigorous examination of a software product, development testing is typically organized into levels: unit, integration, and system levels of testing.\n\n(@) **Unit (module or component) level testing** focuses on the early examination of sub-program functionality and ensures that functionality not visible at the system level is examined by testing. Unit testing ensures that quality software units are furnished for integration into the finished software product.\n(@) **Integration level testing** focuses on *the transfer of data* and *control across a program's internal and external interfaces*. External interfaces are those with\n    i) other software (including operating system software),\n    i) system hardware, and\n    i) the users and can be described as communications links.\n(@) **System level testing** demonstrates that all specified functionality exists and that the software product\nis trustworthy. This testing verifies the as-built program's functionality and performance with respect to the requirements for the software product as exhibited on the specified operating platform(s).\nSystem level software testing addresses functional concerns and the following elements of a device's software that are related to the intended use(s):\n    * Performance issues (e.g., response times, reliability measurements);\n    * Responses to stress conditions, e.g., behavior under maximum load, continuous use;\n    * Operation of internal and external security features; \n    * Effectiveness of recovery procedures, including disaster recovery;\n    * Usability; [(Usability vs Utility??)](https://dbdlab.tistory.com/entry/usability) \n    * Compatibility with other software products; \n    * Behavior in each of the defined hardware configurations; and\n    * Accuracy of documentation.\n\nControl measures (e.g., a traceability analysis) should be used to ensure that the intended coverage is \nachieved.\n\nSystem level testing also exhibits the software product's behavior in the intended operating environment.\nThe location of such testing is dependent upon the software developer's ability to produce the target operating environment(s). Depending upon the circumstances, simulation and/or testing at (potential) customer locations may be utilized. \n\nTest plans should identify the controls needed to ensure \n\n* that the intended coverage is achieved and \n* that proper documentation is prepared \nwhen planned system level testing is conducted at sites not directly controlled by the software developer. \n\nTest procedures, test data, and test results \n\n* should be documented in a manner permitting objective pass/fail decisions to be reached. \n* should also be suitable for review and objective decision making subsequent to running the test, \n* should be suitable for use in any subsequent regression testing. \n\nErrors detected during testing should be\n\n* logged, \n* classified, \n* reviewed, and \n* resolved prior to release of the software. \n\nSoftware error data that is collected and analyzed during a development life cycle may be used to determine the suitability of the software product for release for commercial distribution. Test reports should comply with the requirements of the corresponding test plans.\n\nSoftware testing tools are frequently used to ensure consistency, thoroughness, and efficiency in the testing of such software products and to fulfill the requirements of the planned testing activities.\n\nAppropriate documentation providing evidence of the validation of these software tools for their intended use should be maintained (see section 6 of this guidance). \n\nTypical Tasks – Testing by the Software Developer\n\n* Test Planning\n* Structural Test Case Identification\n* Functional Test Case Identification\n* Traceability Analysis - Testing\n* Unit (Module) Tests to Detailed Design\n* Integration Tests to High Level Design\n* System Tests to Software Requirements\n* Unit (Module) Test Execution\n* Integration Test Execution\n* Functional Test Execution\n* System Test Execution\n* Acceptance Test Execution\n* Test Results Evaluation\n* Error Evaluation/Resolution\n* Final Test Report\n\n#### User Site Testing\n\nTesting at the user site is *an essential part of software validation*. \nThe Quality System regulation requires \n\n* installation and \n* inspection procedures (including testing where appropriate) as well as \n* documentation of inspection and \n* testing to demonstrate proper installation. (See 21 CFR §820.170.) \n\nLikewise, manufacturing equipment must meet specified requirements, and automated systems must be validated for their intended use. (See 21 CFR §820.70(g) and 21 CFR §820.70(i) respectively.)\n\nTerminology regarding user site testing can be confusing. Terms such as\n\n* beta test, \n* site validation, \n* user acceptance test, \n* installation verification, and \n* installation testing \nhave all been used to describe user site testing. \n\nFor the purposes of this guidance, the term “user site testing” encompasses all of these and any other testing that takes place *outside of the developer’s controlled environment*. \n\nThis testing should take place at a user's site with the actual hardware and software that will be part of the installed system configuration. The testing is accomplished through either actual or simulated use of the software being tested within the context in which it is intended to function.\n\nTest planners should check with the FDA Center(s) with the corresponding product jurisdiction to determine whether there are any additional regulatory requirements for user site testing.\n\nUser site testing should follow a pre-defined written plan with\n\n* a formal summary of testing and \n* a record of formal acceptance. \n\nThe following documented evidence should be retained:\n\n* all testing procedures, \n* test input data, and \n* test results\n\nThere should be evidence that hardware and software are installed and configured as specified.\nMeasures should ensure that all system components are exercised during the testing and that the versions of these components are those specified. The testing plan should specify testing throughout the full range of operating conditions and should specify continuation for a sufficient time to allow the system to encounter a wide spectrum of conditions and events in an effort to detect any latent faults that are not apparent during more normal activities.\n\nSome of the evaluations of the system's ability that have been performed earlier by the software developer at the developer's site should be repeated at the site of actual use. These may include tests for:\n\n* a high volume of data, \n* heavy loads or stresses, \n* security, \n* fault testing (avoidance, detection, tolerance, and recovery), \n* error messages, and \n* implementation of safety requirements. \n\nThere should be an evaluation of the ability of the users of the system to understand and correctly interface with it.   \nOperators should be able to perform the intended functions and respond in an appropriate and timely manner to all alarms, warnings, and error messages.   \nRecords should be maintained of both proper system performance and any system failures that are encountered.   \nThe revision of the system to compensate for faults detected during this user site testing should follow the same procedures and controls as for any other software change.\n\nThe developers of the software may or may not be involved in the user site testing. \n\n* If the developers are involved, they may seamlessly carry over to the user's site the last portions of design-level systems testing. \n* If the developers are not involved, it is all the more important that the user have persons who understand the importance of careful test planning, the definition of expected test results, and the recording of all test outputs.\n\nTypical Tasks – User Site Testing\n\n* Acceptance Test Execution\n* Test Results Evaluation\n* Error Evaluation/Resolution\n* Final Test Report\n\n#### Maintenance and Software Changes\n\n##### Hardware vs Software\n\nHardware maintenance typically includes \n\n* preventive hardware maintenance actions, \n* component replacement, and \n* corrective changes. \n\nSoftware maintenance includes \n\n* corrective,\n* perfective, and \n* adaptive maintenance \n* but does not include preventive maintenance actions or software component replacement.\n\n##### Maintenance Types\n\n* Corrective maintenance: Changes made to correct errors and faults in the software. \n* Perfective maintenance: Changes made to the software to improve the performance, maintainability, or other attributes of the software system . \n* Adaptive maintenance: Changes to make the software system usable in a changed environment.\n\nSufficient regression analysis and testing should be conducted to demonstrate that portions of the software not involved in the change were not adversely impacted. When changes are made to a software system, \n\n* either during initial development or \n* during post release maintenance,  \n\nThis is in addition to testing that evaluates the correctness of the implemented change(s).\nThe specific validation effort necessary for each software change is determined by \n\n* the type of change,\n* the development products affected, and the \n* impact of those products on the operation of the software.\n\n##### Factors of Limitting Validation Effort Needed When a Change Is Made\n\n* careful and complete documentation of the design structure and \n* careful and complete documentation of interrelationships of various modules, \n* interfaces, etc.\n* For example, \n  * test documentation, \n  * test cases, and \n  * results of previous verification and validation testing \nAll of them need to be archived if they are to be available for performing subsequent regression testing. \n\nThe following additional maintenance tasks should be addressed:\n\n* Software Validation Plan Revision - For software that was previously validated, the existing software validation plan should be revised to support the validation of the revised software. If no previous software validation plan exists, such a plan should be established to support the validation of the revised software.\n* Anomaly Evaluation – Software organizations frequently maintain documentation, such as software problem reports that describe software anomalies discovered and the specific corrective action taken to fix each anomaly. \n  * Too often, however, mistakes are repeated because software developers do not take the next step to determine the root causes of problems and make the process and procedural changes needed to avoid recurrence of the problem. \n  * Software anomalies should be evaluated in terms of their severity and their effects on system operation and safety, \n  * but they should also be treated as symptoms of process deficiencies in the quality system. \n  * A root cause analysis of anomalies can identify specific quality system deficiencies. \n  * Where trends are identified (e.g., recurrence of similar software anomalies), appropriate corrective and preventive actions must be implemented and documented to avoid further recurrence of similar quality problems. (See 21 CFR 820.100.)\n* Problem Identification and Resolution Tracking - All problems discovered during maintenance of the software should be documented. The resolution of each problem should be tracked to ensure it is fixed, for historical reference, and for trending.\n* Proposed Change Assessment - All proposed modifications, enhancements, or additions should be assessed to determine the effect each change would have on the system. This information should determine the extent to which verification and/or validation tasks need to be iterated.\n* Task Iteration - For approved software changes, all necessary verification and validation tasks should be performed to ensure that planned changes are implemented correctly, all documentation is complete and up to date, and no unacceptable changes have occurred in software performance.\n* Documentation Updating – Documentation should be carefully reviewed to determine which documents have been impacted by a change. All approved documents (e.g., specifications, test procedures, user manuals, etc.) that have been affected should be updated in accordance with configuration management procedures. Specifications should be updated before any maintenance and software changes are made.\n\n## Validation of Automated Process Equipment and Quality System Software\n\nThe Quality System regulation requires that “when computers or automated data processing systems are used as part of production or the quality system, the [device] manufacturer shall validate computer software for its intended use according to an established protocol.” (See 21 CFR §820.70(i)). This has been a regulatory requirement of FDA’s medical device Good Manufacturing Practice (GMP) regulations since 1978.\n\nComputer systems that implement part of a device manufacturer’s production processes or quality system (or that are used to create and maintain records required by any other FDA regulation) are subject to the Electronic Records; Electronic Signatures regulation. (See 21 CFR Part 11.) This regulation establishes additional security, data integrity, and validation requirements when records are created or maintained electronically. These additional Part 11 requirements should be carefully considered and included in system requirements and software requirements for any automated record `keeping systems`. System validation and software validation should demonstrate that all Part 11 requirements have been met.\n\nComputers and automated equipment are used extensively throughout all aspects of \n\n* medical device design, \n* laboratory testing and analysis, \n* product inspection and acceptance, \n* production and process control, \n* environmental controls, \n* packaging, \n* labeling, \n* traceability, \n* document control, \n* complaint management, and many other aspects of the quality system.\n\n Increasingly, automated plant floor operations can involve extensive use of embedded systems in:\n\n* programmable logic controllers;\n* digital function controllers;\n* statistical process control;\n* supervisory control and data acquisition;\n* robotics;\n* human-machine interfaces;\n* input/output devices; and\n* computer operating systems.\n\nAll software tools used for software design are subject to the requirement for software validation, but the validation approach used for each application can vary widely.\n\nValidation is typically supported by:\n\n* verifications of the outputs from each stage of that software development life cycle; and\n* checking for proper operation of the finished software in the device manufacturer’s intended use environment.\n\n### How Much Validation Evidence Is Needed?\n\nThe level of validation effort should be commensurate with \n\n* the risk posed by the automated operation,\n* the complexity of the process software,\n* the degree to which the device manufacturer is dependent upon that automated process to produce a safe and effective device\n\nDocumented requirements and risk analysis of the automated process help to define the scope of the evidence needed to show that the software is validated for its intended use. \nWithout a plan, extensive testing may be needed for:\n\n* a plant-wide electronic record and electronic signature system;\n* an automated controller for a sterilization cycle; or\n* automated test equipment used for inspection and acceptance of finished circuit boards in a lifesustaining / life-supporting device.\n\nHigh risk applications should not be running in the same operating environment with non-validated software functions, even if those software functions are not used. Risk mitigation techniques such as memory partitioning or other approaches to resource protection may need to be considered when high risk applications and lower risk applications are to be used in the same operating environment. \n\nWhen software is upgraded or any changes are made to the software, the device manufacturer should consider how those changes may impact the “used portions” of the software and must reconfirm the validation of those portions of the software that are used. (See 21 CFR §820.70(i).)\n\n### Defined User Equipment\n\nA very important key to software validation is a documented user requirements specification that defines:\n\n* the “intended use” of the software or automated equipment; and\n* the extent to which the device manufacturer is dependent upon that software or equipment for production of a quality medical device.\n\nThe device manufacturer (user) needs to define the expected operating environment including any required hardware and software configurations, software versions, utilities, etc. The user also needs to:\n\n* document requirements for system performance, quality, error handling, startup, shutdown, security, etc.;\n* identify any safety related functions or features, such as sensors, alarms, interlocks, logical processing steps, or command sequences; and\n* define objective criteria for determining acceptable performance.\n\nThe validation must be conducted in accordance with a documented protocol, and the validation results must also be documented. (See 21 CFR §820.70(i).) \nTest cases should be documented that will exercise the system to challenge its performance against the  pre-determined criteria, especially for its most critical parameters. \n\nTest cases should address \n\n* error and alarm conditions, \n* startup, shutdown, \n* all applicable user functions and operator controls, \n* potential operator errors, \n* maximum and minimum ranges of allowed values, and \n* stress conditions applicable to the intended use of the equipment. \n\nThe test cases should be executed and the results should be recorded and evaluated to determine whether the results support a conclusion that the software is validated for its intended use.\n\nA device manufacturer may conduct a validation using their own personnel or may depend on a third party such as the equipment/software vendor or a consultant. In any case, the device manufacturer retains the ultimate responsibility for ensuring that the production and quality system software:\n\n* is validated according to a written procedure for the particular intended use; and\n* will perform as intended in the chosen application.\n\nThe device manufacturer should have documentation including:\n\n* defined user requirements;\n* validation protocol used;\n* acceptance criteria;\n* test cases and results; and\n* a validation summary\nthat objectively confirms that the software is validated for its intended use.\n\n### Validation of Off-The-Shelf Software and Automated Equipment\n\nMost of the automated equipment and systems used by device manufacturers are supplied by thirdparty vendors and are purchased off-the-shelf (OTS). *The device manufacturer is responsible for ensuring that the product development methodologies used by the OTS software developer are appropriate and sufficient for the device manufacturer’s intended use of that OTS software.* \n \nWhere possible and depending upon the device risk involved, the device manufacturer should consider auditing the vendor’s design and development methodologies used in the construction of the OTS software and should assess the development and validation documentation generated for the OTS software. Such audits can be conducted by the device manufacturer or by a qualified third party. \n\nThe audit should demonstrate that the vendor’s procedures for and results of the verification and validation activities performed the OTS software are appropriate and sufficient for the safety and effectiveness requirements of the medical device to be produced using that software.\n\n","srcMarkdownNoYaml":"\n\n# Information on the Document\n\n## Notice\n\n* I am so sorry not for providing a compfortab visualization. Although I have tried to use *revealjs* provided in the guide section in the *Quarto* website, I am still clumsy at handling it. I will update this article as I get proficient at *revealjs* using *Quarto*.\n* The FDA validation guidance document is a bit difficult to understand because its explanations provides abstract, general, and present broad cocepts. For this reason, I compiled and made a summary of the document with many diagrams. However, some diagrams are too small to see. Please, **scroll up your mouse wheel with the 'Ctrl' key on your keyboard pressed to zoom in on the small text in the diagrams**.\n* (Writing in Progress) It is hard to say that this version of summary is suitable for representing and covering the original document. Some of the content of this document has been excluded for personal use (less than 10% of it have been excluded).\n\n### Last Update\n* 2022-12-28, [download this article as PDF](sw_validation_ver1.pdf)\n* 2022-12-28, [summary with diagrams](../2023-01-27_FDA_sw_general_guidance_presentation/index.qmd)\n\n\n### Source\n[FDA: General Principles of Software Validation](https://www.fda.gov/regulatory-information/search-fda-guidance-documents/general-principles-software-validation)\n\n### Rationale\nFDA has reported the following analysis:\n\n* 242 of 3140 (7.7%) medical device recalls between 1992 and 1998 are attributable to software failures. \n* 192 of the 242 (79.3%) failures were caused by software defects that were introduced when changes were made to the software after its initial production and distribution. \n* The software validation check is a principal means of avoiding such defects and resultant recalls.\n\n### Main Institutions\n\n* Center for Devices and Radiological Health (CDRH)\n* U.S. Department Of Health and Human Services\n* Food and Drug Administration\n* Center for Biologics Evaluation and Research\n\n# Document Summary\n\n## Purpose\nThe purpose is to make a sketch of general validation principle of the validation of medical device software or software used to design or develop. \n\n## Scope\nThe scope of this guidance is broad. The important activities for the software validation include at least:\n\n* planning,\n* verfication, \n* testing, \n* traceability, and \n* configuration management. \n\nAll of the activities above should be \n\n* integrated \n* be able to describe software life cycle management and \n* be able to describe software risk management.\n\nThe software validation and verification activities should be focused into the entire software life cycle.\n(It does not necessarily mean that the activies must follow any technical models.)\n\nThe guidance is applicable to any software related to a regulated medical device and anyone who is employed in a bio or medical industry.\n\n### The Least Burdensome Approach\nThe guidance reflects that *the minimum list of the relavant scientific and legal requirements* that you must comply with. \n\n### Regulatory Requirements for Software Validation\n* Software validation: a requirement of **the Quality System regulation**, which was published in the Federal Register on October 7, 1996 and took effect on June 1, 1997. (See Title 21 Code of Federal Regulations (CFR) Part 820, and 61 Federal Register (FR) 52602, respectively.)\n* Specific requirements for validation of device software are found in 21 CFR §820.30(g). Other design controls, such as planning, input, verification, and reviews, are required for medical device software. (See 21 CFR §820.30.) \n* computer systems used to create, modify, and maintain electronic records and to manage electronic signatures are also subject to the validation requirements. (See 21 CFR §11.10(a).) \n\n#### Objective\nThe objective of software validation is to ensure:\n\n* accuracy\n* reliability\n* consistent intended performance, and \n* the ability to discern invalid or altered records.\n\n#### What to validate\n**Any software** used to automate device design, testing, component acceptance, manufacturing, labeling, packaging, distribution, complaint handling, or to automate any other aspect of the quality system, including any off-the-shelf software.\n\n### Quality System Regulation vs Pre-market Submissions\nThis document **does not address** any specific requirements **but** general ones.\nSpecific issues should be addressed to  \n\n* the Office of Device Evaluation (ODE), \n* Center for Devices and Radiological Health (CDRH) \n* the Office of Blood Research and Review, \n* Center for Biologics Evaluation and Research (CBER). \nSee the references in Appendix A for applicable FDA guidance documents for pre-market submissions.\n\n## Context for Software Validation\n\n* Validation elements that FDA expects to do for the Quality System regulation, using the principles and tasks are listed in Sections 4 and 5.\n* Additional specific information is available from many of the references listed in Appendix A\n\n### Definition and Terminology\nThe medical device Quality System regulation (21 CFR 820.3(k)) defines \n\n* \"establish\" = \"define, document, and implement\" \n* \"establish\" = \"established\"\n* Confusing terminology between the medical device Quality System regulation and the software industry:\n    * requirements, \n    * specification, \n    * verification, and \n    * validation.\n\n#### Requirements and Specifications\nThe Quality System regulation states  \n\n1. that design input requirements must be documented and\n1. that specified requirements must be verified\n\nBut, the regulation does not further clarify the distinction between the terms “requirement” and “specification.”\n\n* Requirement \n  * can be any need or expectation for a system or for its software. \n  * reflects the stated or implied needs of the customer: requirements may be \n    * market-based, \n    * contractual,\n    * statutory, or \n    * an organization's internal requirements. \n  * various examples of requirements \n    * design, functional, implementation, interface, performance, or physical requirements \n  * Software requirements derived from the system requirements for those aspects of system functionality \n  * Software requirements are typically stated in functional terms and are defined, refined, and updated as a development project progresses. \n  * Success in accurately and completely documenting software requirements is a crucial factor in successful validation of the resulting software.\n* Specification\n  * defined as “a document that states requirements.” (See 21 CFR §820.3(y).) \n  * It may refer to or include drawings, patterns, or other relevant documents \n  * It usually indicates the means and the criteria whereby conformity with the requirement can be checked. \n  * Various examples of written specifications\n    * system requirements specification, \n    * software requirements specification, \n    * software design specification, \n    * software test specification, \n    * software integration specification, etc. \n  * All of these documents are design outputs for which various forms of verification are necessary.\n\n#### Verifiaction and Validation\n\nThe Quality System regulation is harmonized with ISO 8402:1994, which treats “verification” and “validation” as separate and distinct terms.\n\n* Software verification \n  * It provides objective evidence that the design outputs of a particular phase of the software development life cycle meet all of the specified requirements for that phase. \n  * It looks for \n    * consistency, \n    * completeness, and \n    * correctness of the software and its supporting documentation\n  * **Software testing** \n    * verification activities intended to confirm that software development output meets its input requirements. \n  * Types of verification activities include\n    * various static and dynamic analyses, \n    * code and document inspections, \n    * walkthroughs, and other techniques.\n* Software Validation\n  *  Confirmation by examination and provision of the following objective evidence:\n    * Evidence 1: software specifications conform to **user needs and intended uses**, and \n    * Evidnece 2: the particular requirements implemented through software can be consistently fulfilled.\n    * Evidnece 3: all software requirements have been implemented **correctly and completely and are traceable** to system requirements. \n  * A conclusion that software is validated is highly dependent upon **comprehensive** software testing, inspections, analyses, and other verification tasks performed **at each stage of the software development life cycle**. \n  * **Testing** of device software functionality in a **simulated* use environment**, and **user site testing** are typically included as components of an overall design validation program for a software automated device.\n* Difficulty in Software verification and validation \n  * a developer cannot test forever, and \n  * it is difficult to know how much evidence is enough. \n  * In large measure, software validation is a matter of developing a **“level of confidence”** that the device meets all requirements and user expectations for the software automated functions and features of the device. \n  * Considerations for an acceptable level of confidence\n    * measures such as defects found in specifications documents, \n    * estimates of defects remaining, \n    * testing coverage, and other techniques are all used to develop  before shipping the product. \n    * However, a level of confidence varies depending upon the safety risk (hazard) posed by the automated functions of the device. (Info on safety risk is found in Section 4 and in the international standards ISO/IEC 14971-1 and IEC 60601-1-4 referenced in Appendix A).\n\n#### IQ/OQ/PQ\nIQ/OQ/PQ are the terminology related to user site software validation\n\n* Installation qualification (IQ)\n* Operational qualification (OQ) \n* Performance qualification (PQ). \n\nDefinitions of these terms may be found in FDA’s Guideline on General Principles of Process Validation, dated May 11, 1987, and in FDA’s Glossary of Computerized System and Software Development Terminology, dated August 1995.\nBoth FDA personnel and device manufacturers need to be aware of these differences in terminology as they ask for and provide information regarding software validation.\n\n### Software Development as Part of System Design\nSoftware validation must be considered within the context of the overall design validation for the system.\nA documented requirements specification represents \n\n  * the user's needs\n  * intended uses from which the product is developed. \n\nA primary goal of software validation is to then demonstrate that all completed software products comply with all documented software and system requirements.\n\n### Software Is Different from Hardware\nSoftware engineering needs an even greater level of managerial scrutiny and control than does hardware engineering.\n\n### Benefits of Software Validation\n\n* Increase the usability and reliability of the device, \n* Resulting in decreased failure rates, fewer recalls and corrective actions, less risk to patients and users, and reduced liability to device manufacturers. \n* Software validation can also reduce long term costs by making it easier and less costly to reliably modify software and revalidate software changes. \n\n### Design Review\nDesign reviews are documented, comprehensive, and systematic examinations of a design to evaluate \n\n* the adequacy of the design requirements, \n* the capability of the design to meet these requirements, and \n* to identify problems. \n\nDesign review is a primary tool for managing and evaluating development projects. \n\n* It is strongly recommended that it should be formal design because it is more structured than the informal one.\n* It includes participation from others outside the development team. \n* It may review reference or include results from other formal and informal reviews. \n* Design reviews should include \n  * examination of development plans, \n  * requirements specifications, \n  * design specifications, \n  * testing plans and procedures, \n  * all other documents and activities associated with the project, \n  * verification results from each stage of the defined life cycle, and \n  * validation results for the overall device.\n* The Quality System regulation requires that at least one formal design review be conducted during the device  design process. **However, it is recommended that multiple design reviews be conducted** \n  * (e.g., at the end of each software life cycle activity, in preparation for proceeding to the next activity). \n* Formal design reviews documented should include:\n  * the appropriate tasks and expected results, outputs, or products been established for each software life cycle activity\n  * correctness, completeness, consistency, and accuracy\n  * satisfaction for the standards, practices, and conventions of that activity\n  * establishment of a proper basis for initiating tasks for the next software life cycle activity\n\n## Principles of Software Validation\n\n### Requirements\n\nA documented software requirements specification provides a baseline for both validation and verification. **The software validation process must include an established software requirements specification** (Ref: 21 CFR 820.3(z) and (aa) and 820.30(f) and (g)).\n\n### Defect Prevention\n\nIn order to establish that confidence, software developers should use a mixture of methods and techniques to prevent software errors and to detect software errors that do occur. \n\n### Time and Effort\n\nPreparation for software validation should begin early, i.e., **during design and development planning and design input**. The final conclusion that the software is validated should be **based on evidence** collected from planned efforts conducted throughout the software lifecycle.\n\n### Software Life Cycle\n\n* Software validation takes place within the environment of an established software life cycle. \n* The software life cycle contains **software engineering tasks and documentation** necessary to support the software validation effort.\n* specific verification and validation tasks need to be appropriate for the intended use of the software\n\n### Plans\n\n* The software validation process is defined and controlled through the use of a plan. \n* The software validation plan defines “what” is to be accomplished through the software validation effort. \n* Software validation plans specify areas such as\n  * scope, \n  * approach, \n  * resources, \n  * schedules and the types and extent of activities, \n  * tasks, and \n  * work items.\n\n### Procedures\n\nThe software validation process is executed through the use of procedures. These procedures establish “how” to conduct the software validation effort. The procedures should identify the specific actions or sequence of actions that must be taken to complete individual validation activities, tasks, and work items.\n\n### Software Validation After a Change\n\n* Due to the complexity of software, a small local change may have a significant global system impact. \n* If a change exists in the software, the whole validation status of the software needs to be re-established. \n* need to determine the extent and impact of that change on the entire software system. \n* the software developer should then conduct an appropriate level of software regression testing to show that unchanged but vulnerable portions of the system have not been adversely affected. \n\n### Validation Coverage\n\n* Validation coverage should be based on the software’s complexity and safety risk. \n* The selection of validation activities, tasks, and work items should be commensurate with the complexity of the software design and the risk associated with the use of the software for the specified intended use. \n\n### Independence of Review\n\n* Validation activities should be based on the basic quality assurance precept of “independence of review.” \n* Self-validation is extremely difficult. \n* When possible, an independent evaluation is always better (like a contracted third-party independent verification and validation)\n* Another approach is to assign internal staff members that are not involved in a particular design or its implementation, but who have sufficient knowledge to evaluate the project and conduct the verification and validation activities. \n\n### Flexibility and Responsibility\n\nThe device manufacturer has flexibility in choosing how to apply these validation principles, but retains ultimate responsibility for demonstrating that the software has been validated.\nFDA regulated medical device applications include software that:\n\n* Is a component, part, or accessory of a medical device;\n  * components: e.g., application software, operating systems, compilers, debuggers, configuration management tools, and many more\n* Is itself a medical device; or\n* Is used in manufacturing, design and development, or other parts of the quality system.\n* No matter how complex and disperse the software is, the manufacturer is in charge of responsibility for software validation.\n\n## Activities and Tasks\n\nSoftware validation is accomplished through **a series of activities and tasks** that are planned and executed at various stages of the software development life cycle. \nThese tasks may be \n\n* one time occurrences \n* iterated many times\n\n### Software Life Cycle Activities\n\n* Software developers should establish a software life cycle model that is appropriate for their product and organization. \n* The selected software life cycle model should cover the software from its birth to its retirement. \n* Activities in a typical software life cycle model: \n  * Quality Planning\n  * System Requirements Definition\n  * Detailed Software Requirements Specification\n  * Software Design Specification\n  * Construction or Coding\n  * Testing\n  * Installation\n  * Operation and Support\n  * Maintenance\n  * Retirement\n* Verification, testing, and other tasks that support software validation occur during each of these activities. \n* Several software life cycle models defined in FDA’s Glossary of Computerized System and Software Development \n\nTerminology dated August 1995:\n\n  * waterfall\n  * spiral\n  * rapid prototyping\n  * incremental development, etc.\n\n### Typical Tasks Supporting Validation\n\nthe software developer should at least consider each of the risk-related tasks and should define and document which tasks are or are not appropriate for their specific application. \n\n#### Quality Planning\n\nDesign and development planning should culminate in a plan that identifies \n\n* necessary tasks, \n* procedures for anomaly reporting and resolution, \n* necessary resources, and \n* management review requirements including formal design reviews. \n\nThe plan should include:\n\n* The specific tasks for each life cycle activity;\n* Enumeration of important quality factors (e.g., reliability, maintainability, and usability);\n* Methods and procedures for each task;\n* Task acceptance criteria;\n* Criteria for defining and documenting outputs in terms that will allow evaluation of their conformance to input requirements;\n* Inputs for each task;\n* Outputs from each task;\n* Roles, resources, and responsibilities for each task;\n* Risks and assumptions; and\n* Documentation of user needs.\n\nThe plan should identify \n\n* the personnel, \n* the facility and equipment resources for each task, and \n* the role that risk (hazard) management will play. \n\nA configuration management plan should be developed that will guide and control multiple parallel development activities and ensure proper communications and documentation. \n\nControls are necessary to ensure positive and correct correspondence among all approved versions of the specifications documents, source code, object code, and test suites that comprise a software system. The controls also should ensure accurate identification of, and access to, the currently approved versions.\n\nProcedures should be created for reporting and resolving software anomalies found through validation or other activities. \n\nManagement should identify the reports and specify the contents, format, and responsible organizational elements for each report. Procedures also are necessary for the review and approval of software development results, including the responsible organizational elements for such reviews and approvals.\n\nTypical Tasks – Quality Planning\n\n* Risk (Hazard) Management Plan\n* Configuration Management Plan\n* Software Quality Assurance Plan\n  * Software Verification and Validation Plan\n    * Verification and Validation Tasks, and Acceptance Criteria\n    * Schedule and Resource Allocation (for software verification and validation activities)\n    * Reporting Requirements\n  * Formal Design Review Requirements\n  * Other Technical Review Requirements\n* Problem Reporting and Resolution Procedures\n* Other Support Activities\n\n#### Requirements\n\nRequirements development includes the \n\n* identification, \n* analysis, and \n* documentation of information about the device and its intended use. \n\nAreas of special importance include allocation of system functions to \n\n* hardware/software, \n* operating conditions, \n* user characteristics, \n* potential hazards, and\n* anticipated tasks.\n\nIn addition, the requirements should state clearly the intended use of the software.\nIt is not possible to validate software without predetermined and documented software requirements. \nTypical software requirements specify the following:\n\n* All software system inputs;\n* All software system outputs;\n* All functions that the software system will perform;\n* All performance requirements that the software will meet, (e.g., data throughput, reliability, and timing);\n* The definition of all external and user interfaces, as well as any internal software-to-system interfaces;\n* How users will interact with the system;\n* What constitutes an error and how errors should be handled;\n* Required response times;\n* The intended operating environment for the software, if this is a design constraint (e.g., hardware platform, operating system);\n* All ranges, limits, defaults, and specific values that the software will accept; and\n* All safety related requirements, specifications, features, or functions that will be implemented in software.\n\nSoftware requirement specifications should identify clearly the potential hazards that can result from a software failure in the system as well as any safety requirements to be implemented in software. \n\nThe consequences of software failure should be evaluated, along with means of mitigating such failures (e.g., hardware mitigation, defensive programming, etc.). \n\nThe Quality System regulation requires a mechanism for addressing incomplete, ambiguous, or conflicting requirements. (See 21 CFR 820.30(c).) Each requirement (e.g., hardware, software, user, operator interface, and safety) identified in the software requirements specification should be evaluated for accuracy, completeness, consistency, testability, correctness, and clarity. \n\nFor example, software requirements should be evaluated to verify that:\n\n* There are no internal inconsistencies among requirements;\n* All of the performance requirements for the system have been spelled out;\n* Fault tolerance, safety, and security requirements are complete and correct;\n* Allocation of software functions is accurate and complete;\n* Software requirements are appropriate for the system hazards; and\n* All requirements are expressed in terms that are measurable or objectively verifiable.\n\nA software requirements traceability analysis should be conducted to trace software requirements to\n(and from) system requirements and to risk analysis results. In addition to any other analyses and\ndocumentation used to verify software requirements, a formal design review is recommended to confirm\nthat requirements are fully specified and appropriate before extensive software design efforts begin.\nRequirements can be approved and released incrementally, but care should be taken that interactions\nand interfaces among software (and hardware) requirements are properly reviewed, analyzed, and\ncontrolled.\n\nTypical Tasks – Requirements\n\n* Preliminary Risk Analysis\n* Traceability Analysis\n  * Software Requirements to System Requirements (and vice versa)\n  * Software Requirements to Risk Analysis\n* Description of User Characteristics\n* Listing of Characteristics and Limitations of Primary and Secondary Memory\n* Software Requirements Evaluation\n* Software User Interface Requirements Analysis\n* System Test Plan Generation\n* Acceptance Test Plan Generation\n* Ambiguity Review or Analysis\n\n#### Design\n\nIn the design process, the software requirements specification is translated into a logical and physical\nrepresentation of the software to be implemented. The software design specification is a description of what the software should do and how it should do it. The design specification may contain both a high level summary of the design and detailed design information.\nHuman factors engineering should be woven into \n\n* the entire design and development process, \n* the device design requirements, \n* analyses, and \n* tests. \n\nDevice safety and usability issues should be considered when developing \n\n* flowcharts, \n* state diagrams, \n* prototyping tools, and \n* test plans. \n\nAlso, task and function analyses, risk analyses, prototype tests and reviews, and full usability tests should be\nperformed. Participants from the user population should be included when applying these methodologies.\n\nThe software design specification should include:\n\n* Software requirements specification, including predetermined criteria for acceptance of the software;\n* Software risk analysis;\n* Development procedures and coding guidelines (or other programming procedures);\n* Systems documentation (e.g., a narrative or a context diagram) that describes the systems context in which the program is intended to function, including the relationship of hardware, software, and the physical environment;\n* Hardware to be used;\n* Parameters to be measured or recorded;\n* Logical structure (including control logic) and logical processing steps (e.g., algorithms);\n* Data structures and data flow diagrams;\n* Definitions of variables (control and data) and description of where they are used;\n* Error, alarm, and warning messages;\n* Supporting software (e.g., operating systems, drivers, other application software);\n* Communication links (links among internal modules of the software, links with the supporting software, links with the hardware, and links with the user);\n* Security measures (both physical and logical security); and\n* Any additional constraints not identified in the above elements.\n\nThe first four of the elements noted above usually are separate pre-existing documents that are included\nby reference in the software design specification. \nSoftware requirements specification was discussed in the preceding section, as was software risk analysis. \n\nSoftware design evaluations criteria: \n\n* complete, \n* correct, \n* consistent, \n* unambiguous, \n* feasible,\n* maintainable,\n* analyses of control flow,\n* data flow, \n* complexity, \n* timing, \n* sizing, \n* memory allocation, \n* criticality analysis, and many other aspects of the design \n\nAppropriate consideration of software architecture (e.g., modular structure) during design can reduce the magnitude of future validation efforts when software changes are needed. \n\nA traceability analysis should be conducted to verify that the software design implements all of the software requirements. As a technique for identifying where requirements are not sufficient, the traceability analysis should also verify that all aspects of the design are traceable to software requirements. \n\nAn analysis of communication links should be conducted to evaluate the proposed design with respect to hardware, user, and related software requirements.\nAt the end of the software design activity, a Formal Design Review should be conducted to verify that the design is correct, consistent, complete, accurate, and testable, before moving to implement the design. \n\nSeveral versions of both the software requirement specification and the software design specification should be maintained. All approved versions should be archived and controlled in accordance with established configuration management procedures.\n\nTypical Tasks – Design\n\n* Updated Software Risk Analysis\n* Traceability Analysis - Design Specification to Software Requirements (and vice versa)\n* Software Design Evaluation\n* Design Communication Link Analysis\n* Module Test Plan Generation\n* Integration Test Plan Generation\n* Test Design Generation (module, integration, system, and acceptance)\n\n#### Construction or Coding\n\nSoftware may be constructed either by coding. Coding is the software activity where the detailed design specification is implemented as source code. It is the last stage in decomposition of the software requirements where module specifications are translated into a programming language.\n\nCoding usually involves the use of a high-level programming language, but may also entail the use of\nassembly language (or microcode) for time-critical operations. \n\nA source code traceability analysis is an important tool to verify that all code is linked to established specifications and established test procedures. A source code traceability analysis should be conducted\nand documented to verify that:\n\n* Each element of the software design specification has been implemented in code;\n* Modules and functions implemented in code can be traced back to an element in the software design specification and to the risk analysis;\n* Tests for modules and functions can be traced back to an element in the software design specification and to the risk analysis; and\n* Tests for modules and functions can be traced to source code for the same modules and functions.\n\nTypical Tasks – Construction or Coding\n\n* Traceability Analyses\n  * Source Code to Design Specification (and vice versa)\n  * Test Cases to Source Code and to Design Specification\n* Source Code and Source Code Documentation Evaluation\n* Source Code Interface Analysis\n* Test Procedure and Test Case Generation (module, integration, system, and acceptance)\n\n#### Testing by the Software Developer\n\nSoftware testing entails running software products under known conditions with defined inputs and documented outcomes that can be compared to their predefined expectations. It is a time consuming, difficult, and imperfect activity. \n\nAs such, it requires early planning in order to be effective and efficient. Test plans and test cases should be created as early in the software development process as feasible.\n\nThey should identify \n\n* the schedules, \n* environments, \n* resources (personnel, tools, etc.), \n* methodologies,\n* cases (inputs, procedures, outputs, expected results), \n* documentation, and \n* reporting criteria. \n\nDescriptions of categories of software and software testing effort appear in the literature\n\n* NIST Special Publication 500-235, Structured Testing: A Testing Methodology Using the Cyclomatic Complexity Metric;\n* NUREG/CR-6293, Verification and Validation Guidelines for High Integrity Systems; and\n* IEEE Computer Society Press, Handbook of Software Reliability Engineering. \n\nTesting of all program functionality does not mean all of the program has been tested. Testing of all of a program's code does not mean all necessary functionality is present in the program. Testing of all program functionality and all program code does not mean the program is 100% correct! Software testing that finds no errors should not be interpreted to mean that errors do not exist in the software product; it may mean the testing was superficial.\n\nAn essential element of a software test case is the expected result. It is the key detail that permits objective evaluation of the actual test result. This necessary testing information is obtained from the corresponding, predefined definition or specification. \n\nA software testing process should be based on principles that foster effective examinations of a software product. Applicable software testing tenets include:\n\n* The expected test outcome is predefined;\n* A good test case has a high probability of exposing an error;\n* A successful test is one that finds an error;\n* There is independence from coding;\n* Both application (user) and software (programming) expertise are employed;\n* Testers use different tools from coders;\n* Examining only the usual case is insufficient;\n* Test documentation permits its reuse and an independent confirmation of the pass/fail status of a test outcome during subsequent review.\n\nCode-based testing is also known as structural testing or \"white-box\" testing. It identifies test cases based on knowledge obtained from the source code, detailed design specification, and other development documents. Structural testing can identify \"dead\" code that is never executed when the program is run. Structural testing is accomplished primarily with unit (module) level testing, but can be extended to other levels of software testing.\n\nThe level of structural testing can be evaluated using **metrics that are designed to show what percentage of the software structure has been evaluated during structural testing**. These metrics are typically referred to as **“coverage”** and are a measure of completeness with respect to test selection criteria. The amount of structural coverage should be commensurate with the level of risk posed by the software. Use of the term “coverage” usually means 100% coverage. \nCommon structural coverage metrics include:\n\n* Statement Coverage – This criteria requires sufficient test cases for each program statement to be executed at least once; however, its achievement is insufficient to provide confidence in a software product's behavior.\n* Decision (Branch) Coverage – This criteria requires sufficient test cases for each program decision or branch to be executed so that each possible outcome occurs at least once. It is considered to be a minimum level of coverage for most software products, but decision coverage alone is insufficient for high-integrity applications.\n* Condition Coverage – This criteria requires sufficient test cases for each condition in a program decision to take on all possible outcomes at least once. It differs from branch coverage only when multiple conditions must be evaluated to reach a decision.\n* Multi-Condition Coverage – This criteria requires sufficient test cases to exercise all possible combinations of conditions in a program decision.\n* Loop Coverage – This criteria requires sufficient test cases for all program loops to be executed for zero, one, two, and many iterations covering initialization, typical running and termination (boundary) conditions.\n* Path Coverage – This criteria requires sufficient test cases for each feasible path, basis path, etc., from start to exit of a defined program segment, to be executed at least once. Because of the very large number of possible paths through a software program, path coverage is generally not achievable. The amount of path coverage is normally established based on the risk or criticality of the software under test.\n* Data Flow Coverage – This criteria requires sufficient test cases for each feasible data flow to be executed at least once. A number of data flow testing strategies are available.\n\nThe following types of functional software testing involve generally increasing levels of effort:\n\n* Normal Case – Testing with usual inputs is necessary. However, testing a software product only with expected, valid inputs does not thoroughly test that software product. By itself, normal case testing cannot provide sufficient confidence in the dependability of the software product.\n* Output Forcing – Choosing test inputs to ensure that selected (or all) software outputs are generated by testing.\n* Robustness – Software testing should demonstrate that a software product behaves correctly when given unexpected, invalid inputs. Methods for identifying a sufficient set of such test cases include Equivalence Class Partitioning, Boundary Value Analysis, and Special Case Identification (Error Guessing). While important and necessary, these techniques do not ensure that all of the most appropriate challenges to a software product have been identified for testing.\n* Combinations of Inputs – The functional testing methods identified above all emphasize individual or single test inputs. Most software products operate with multiple inputs under their conditions of use. Thorough software product testing should consider the combinations of inputs a software unit or system may encounter during operation. Error guessing can be extended to identify combinations of inputs, but it is an ad hoc technique. Cause-effect graphing is one functional software testing technique that systematically identifies combinations of inputs to a software product for inclusion in test cases. \n\nFunctional and structural software test case identification techniques provide specific inputs for testing, rather than random test inputs. One weakness of these techniques is the difficulty in linking structural and functional test completion criteria to a software product's reliability. \n\n**Advanced software testing methods**, such as statistical testing, can be employed to provide further assurance that a software product is dependable. Statistical testing uses randomly generated test data from defined distributions based on an operational profile (e.g., expected use, hazardous use, or malicious use of the software product). Large amounts of test data are generated and can be targeted to cover particular areas or concerns, providing an increased possibility of identifying individual and multiple rare operating conditions that were not anticipated by either the software product's designers or its testers. Statistical testing also provides high structural coverage. It does require a stable software product. Thus, structural and functional testing are prerequisites for statistical testing of a software product.\n\nAnother aspect of software testing is the testing of software changes. Changes occur frequently during software development. These changes are the result of \n\n1. debugging that finds an error and it is corrected, \n1. new or changed requirements (\"requirements creep\"), and \n1. modified designs as more effective or efficient implementations are found. \n\nOnce a software product has been baselined (approved), any change to that product should have its own “mini life cycle,” including testing. Testing of a changed software product requires additional effort. It should demonstrate \n\n* that the change was implemented correctly, and\n* that the change did not adversely impact other parts of the software product. \n\n**Regression analysis** is the determination of the impact of a change based on review of the relevant documentation in order to identify the necessary regression tests to be run. **Regression testing** is the rerunning of test cases that a program has previously executed correctly and **comparing the current result to the previous result in order to detect unintended effects of a software change**. Regression analysis and regression testing should also be employed when using integration methods to build a software product to ensure that newly integrated modules do not adversely impact the operation of previously integrated modules.\n\nIn order to provide a thorough and rigorous examination of a software product, development testing is typically organized into levels: unit, integration, and system levels of testing.\n\n(@) **Unit (module or component) level testing** focuses on the early examination of sub-program functionality and ensures that functionality not visible at the system level is examined by testing. Unit testing ensures that quality software units are furnished for integration into the finished software product.\n(@) **Integration level testing** focuses on *the transfer of data* and *control across a program's internal and external interfaces*. External interfaces are those with\n    i) other software (including operating system software),\n    i) system hardware, and\n    i) the users and can be described as communications links.\n(@) **System level testing** demonstrates that all specified functionality exists and that the software product\nis trustworthy. This testing verifies the as-built program's functionality and performance with respect to the requirements for the software product as exhibited on the specified operating platform(s).\nSystem level software testing addresses functional concerns and the following elements of a device's software that are related to the intended use(s):\n    * Performance issues (e.g., response times, reliability measurements);\n    * Responses to stress conditions, e.g., behavior under maximum load, continuous use;\n    * Operation of internal and external security features; \n    * Effectiveness of recovery procedures, including disaster recovery;\n    * Usability; [(Usability vs Utility??)](https://dbdlab.tistory.com/entry/usability) \n    * Compatibility with other software products; \n    * Behavior in each of the defined hardware configurations; and\n    * Accuracy of documentation.\n\nControl measures (e.g., a traceability analysis) should be used to ensure that the intended coverage is \nachieved.\n\nSystem level testing also exhibits the software product's behavior in the intended operating environment.\nThe location of such testing is dependent upon the software developer's ability to produce the target operating environment(s). Depending upon the circumstances, simulation and/or testing at (potential) customer locations may be utilized. \n\nTest plans should identify the controls needed to ensure \n\n* that the intended coverage is achieved and \n* that proper documentation is prepared \nwhen planned system level testing is conducted at sites not directly controlled by the software developer. \n\nTest procedures, test data, and test results \n\n* should be documented in a manner permitting objective pass/fail decisions to be reached. \n* should also be suitable for review and objective decision making subsequent to running the test, \n* should be suitable for use in any subsequent regression testing. \n\nErrors detected during testing should be\n\n* logged, \n* classified, \n* reviewed, and \n* resolved prior to release of the software. \n\nSoftware error data that is collected and analyzed during a development life cycle may be used to determine the suitability of the software product for release for commercial distribution. Test reports should comply with the requirements of the corresponding test plans.\n\nSoftware testing tools are frequently used to ensure consistency, thoroughness, and efficiency in the testing of such software products and to fulfill the requirements of the planned testing activities.\n\nAppropriate documentation providing evidence of the validation of these software tools for their intended use should be maintained (see section 6 of this guidance). \n\nTypical Tasks – Testing by the Software Developer\n\n* Test Planning\n* Structural Test Case Identification\n* Functional Test Case Identification\n* Traceability Analysis - Testing\n* Unit (Module) Tests to Detailed Design\n* Integration Tests to High Level Design\n* System Tests to Software Requirements\n* Unit (Module) Test Execution\n* Integration Test Execution\n* Functional Test Execution\n* System Test Execution\n* Acceptance Test Execution\n* Test Results Evaluation\n* Error Evaluation/Resolution\n* Final Test Report\n\n#### User Site Testing\n\nTesting at the user site is *an essential part of software validation*. \nThe Quality System regulation requires \n\n* installation and \n* inspection procedures (including testing where appropriate) as well as \n* documentation of inspection and \n* testing to demonstrate proper installation. (See 21 CFR §820.170.) \n\nLikewise, manufacturing equipment must meet specified requirements, and automated systems must be validated for their intended use. (See 21 CFR §820.70(g) and 21 CFR §820.70(i) respectively.)\n\nTerminology regarding user site testing can be confusing. Terms such as\n\n* beta test, \n* site validation, \n* user acceptance test, \n* installation verification, and \n* installation testing \nhave all been used to describe user site testing. \n\nFor the purposes of this guidance, the term “user site testing” encompasses all of these and any other testing that takes place *outside of the developer’s controlled environment*. \n\nThis testing should take place at a user's site with the actual hardware and software that will be part of the installed system configuration. The testing is accomplished through either actual or simulated use of the software being tested within the context in which it is intended to function.\n\nTest planners should check with the FDA Center(s) with the corresponding product jurisdiction to determine whether there are any additional regulatory requirements for user site testing.\n\nUser site testing should follow a pre-defined written plan with\n\n* a formal summary of testing and \n* a record of formal acceptance. \n\nThe following documented evidence should be retained:\n\n* all testing procedures, \n* test input data, and \n* test results\n\nThere should be evidence that hardware and software are installed and configured as specified.\nMeasures should ensure that all system components are exercised during the testing and that the versions of these components are those specified. The testing plan should specify testing throughout the full range of operating conditions and should specify continuation for a sufficient time to allow the system to encounter a wide spectrum of conditions and events in an effort to detect any latent faults that are not apparent during more normal activities.\n\nSome of the evaluations of the system's ability that have been performed earlier by the software developer at the developer's site should be repeated at the site of actual use. These may include tests for:\n\n* a high volume of data, \n* heavy loads or stresses, \n* security, \n* fault testing (avoidance, detection, tolerance, and recovery), \n* error messages, and \n* implementation of safety requirements. \n\nThere should be an evaluation of the ability of the users of the system to understand and correctly interface with it.   \nOperators should be able to perform the intended functions and respond in an appropriate and timely manner to all alarms, warnings, and error messages.   \nRecords should be maintained of both proper system performance and any system failures that are encountered.   \nThe revision of the system to compensate for faults detected during this user site testing should follow the same procedures and controls as for any other software change.\n\nThe developers of the software may or may not be involved in the user site testing. \n\n* If the developers are involved, they may seamlessly carry over to the user's site the last portions of design-level systems testing. \n* If the developers are not involved, it is all the more important that the user have persons who understand the importance of careful test planning, the definition of expected test results, and the recording of all test outputs.\n\nTypical Tasks – User Site Testing\n\n* Acceptance Test Execution\n* Test Results Evaluation\n* Error Evaluation/Resolution\n* Final Test Report\n\n#### Maintenance and Software Changes\n\n##### Hardware vs Software\n\nHardware maintenance typically includes \n\n* preventive hardware maintenance actions, \n* component replacement, and \n* corrective changes. \n\nSoftware maintenance includes \n\n* corrective,\n* perfective, and \n* adaptive maintenance \n* but does not include preventive maintenance actions or software component replacement.\n\n##### Maintenance Types\n\n* Corrective maintenance: Changes made to correct errors and faults in the software. \n* Perfective maintenance: Changes made to the software to improve the performance, maintainability, or other attributes of the software system . \n* Adaptive maintenance: Changes to make the software system usable in a changed environment.\n\nSufficient regression analysis and testing should be conducted to demonstrate that portions of the software not involved in the change were not adversely impacted. When changes are made to a software system, \n\n* either during initial development or \n* during post release maintenance,  \n\nThis is in addition to testing that evaluates the correctness of the implemented change(s).\nThe specific validation effort necessary for each software change is determined by \n\n* the type of change,\n* the development products affected, and the \n* impact of those products on the operation of the software.\n\n##### Factors of Limitting Validation Effort Needed When a Change Is Made\n\n* careful and complete documentation of the design structure and \n* careful and complete documentation of interrelationships of various modules, \n* interfaces, etc.\n* For example, \n  * test documentation, \n  * test cases, and \n  * results of previous verification and validation testing \nAll of them need to be archived if they are to be available for performing subsequent regression testing. \n\nThe following additional maintenance tasks should be addressed:\n\n* Software Validation Plan Revision - For software that was previously validated, the existing software validation plan should be revised to support the validation of the revised software. If no previous software validation plan exists, such a plan should be established to support the validation of the revised software.\n* Anomaly Evaluation – Software organizations frequently maintain documentation, such as software problem reports that describe software anomalies discovered and the specific corrective action taken to fix each anomaly. \n  * Too often, however, mistakes are repeated because software developers do not take the next step to determine the root causes of problems and make the process and procedural changes needed to avoid recurrence of the problem. \n  * Software anomalies should be evaluated in terms of their severity and their effects on system operation and safety, \n  * but they should also be treated as symptoms of process deficiencies in the quality system. \n  * A root cause analysis of anomalies can identify specific quality system deficiencies. \n  * Where trends are identified (e.g., recurrence of similar software anomalies), appropriate corrective and preventive actions must be implemented and documented to avoid further recurrence of similar quality problems. (See 21 CFR 820.100.)\n* Problem Identification and Resolution Tracking - All problems discovered during maintenance of the software should be documented. The resolution of each problem should be tracked to ensure it is fixed, for historical reference, and for trending.\n* Proposed Change Assessment - All proposed modifications, enhancements, or additions should be assessed to determine the effect each change would have on the system. This information should determine the extent to which verification and/or validation tasks need to be iterated.\n* Task Iteration - For approved software changes, all necessary verification and validation tasks should be performed to ensure that planned changes are implemented correctly, all documentation is complete and up to date, and no unacceptable changes have occurred in software performance.\n* Documentation Updating – Documentation should be carefully reviewed to determine which documents have been impacted by a change. All approved documents (e.g., specifications, test procedures, user manuals, etc.) that have been affected should be updated in accordance with configuration management procedures. Specifications should be updated before any maintenance and software changes are made.\n\n## Validation of Automated Process Equipment and Quality System Software\n\nThe Quality System regulation requires that “when computers or automated data processing systems are used as part of production or the quality system, the [device] manufacturer shall validate computer software for its intended use according to an established protocol.” (See 21 CFR §820.70(i)). This has been a regulatory requirement of FDA’s medical device Good Manufacturing Practice (GMP) regulations since 1978.\n\nComputer systems that implement part of a device manufacturer’s production processes or quality system (or that are used to create and maintain records required by any other FDA regulation) are subject to the Electronic Records; Electronic Signatures regulation. (See 21 CFR Part 11.) This regulation establishes additional security, data integrity, and validation requirements when records are created or maintained electronically. These additional Part 11 requirements should be carefully considered and included in system requirements and software requirements for any automated record `keeping systems`. System validation and software validation should demonstrate that all Part 11 requirements have been met.\n\nComputers and automated equipment are used extensively throughout all aspects of \n\n* medical device design, \n* laboratory testing and analysis, \n* product inspection and acceptance, \n* production and process control, \n* environmental controls, \n* packaging, \n* labeling, \n* traceability, \n* document control, \n* complaint management, and many other aspects of the quality system.\n\n Increasingly, automated plant floor operations can involve extensive use of embedded systems in:\n\n* programmable logic controllers;\n* digital function controllers;\n* statistical process control;\n* supervisory control and data acquisition;\n* robotics;\n* human-machine interfaces;\n* input/output devices; and\n* computer operating systems.\n\nAll software tools used for software design are subject to the requirement for software validation, but the validation approach used for each application can vary widely.\n\nValidation is typically supported by:\n\n* verifications of the outputs from each stage of that software development life cycle; and\n* checking for proper operation of the finished software in the device manufacturer’s intended use environment.\n\n### How Much Validation Evidence Is Needed?\n\nThe level of validation effort should be commensurate with \n\n* the risk posed by the automated operation,\n* the complexity of the process software,\n* the degree to which the device manufacturer is dependent upon that automated process to produce a safe and effective device\n\nDocumented requirements and risk analysis of the automated process help to define the scope of the evidence needed to show that the software is validated for its intended use. \nWithout a plan, extensive testing may be needed for:\n\n* a plant-wide electronic record and electronic signature system;\n* an automated controller for a sterilization cycle; or\n* automated test equipment used for inspection and acceptance of finished circuit boards in a lifesustaining / life-supporting device.\n\nHigh risk applications should not be running in the same operating environment with non-validated software functions, even if those software functions are not used. Risk mitigation techniques such as memory partitioning or other approaches to resource protection may need to be considered when high risk applications and lower risk applications are to be used in the same operating environment. \n\nWhen software is upgraded or any changes are made to the software, the device manufacturer should consider how those changes may impact the “used portions” of the software and must reconfirm the validation of those portions of the software that are used. (See 21 CFR §820.70(i).)\n\n### Defined User Equipment\n\nA very important key to software validation is a documented user requirements specification that defines:\n\n* the “intended use” of the software or automated equipment; and\n* the extent to which the device manufacturer is dependent upon that software or equipment for production of a quality medical device.\n\nThe device manufacturer (user) needs to define the expected operating environment including any required hardware and software configurations, software versions, utilities, etc. The user also needs to:\n\n* document requirements for system performance, quality, error handling, startup, shutdown, security, etc.;\n* identify any safety related functions or features, such as sensors, alarms, interlocks, logical processing steps, or command sequences; and\n* define objective criteria for determining acceptable performance.\n\nThe validation must be conducted in accordance with a documented protocol, and the validation results must also be documented. (See 21 CFR §820.70(i).) \nTest cases should be documented that will exercise the system to challenge its performance against the  pre-determined criteria, especially for its most critical parameters. \n\nTest cases should address \n\n* error and alarm conditions, \n* startup, shutdown, \n* all applicable user functions and operator controls, \n* potential operator errors, \n* maximum and minimum ranges of allowed values, and \n* stress conditions applicable to the intended use of the equipment. \n\nThe test cases should be executed and the results should be recorded and evaluated to determine whether the results support a conclusion that the software is validated for its intended use.\n\nA device manufacturer may conduct a validation using their own personnel or may depend on a third party such as the equipment/software vendor or a consultant. In any case, the device manufacturer retains the ultimate responsibility for ensuring that the production and quality system software:\n\n* is validated according to a written procedure for the particular intended use; and\n* will perform as intended in the chosen application.\n\nThe device manufacturer should have documentation including:\n\n* defined user requirements;\n* validation protocol used;\n* acceptance criteria;\n* test cases and results; and\n* a validation summary\nthat objectively confirms that the software is validated for its intended use.\n\n### Validation of Off-The-Shelf Software and Automated Equipment\n\nMost of the automated equipment and systems used by device manufacturers are supplied by thirdparty vendors and are purchased off-the-shelf (OTS). *The device manufacturer is responsible for ensuring that the product development methodologies used by the OTS software developer are appropriate and sufficient for the device manufacturer’s intended use of that OTS software.* \n \nWhere possible and depending upon the device risk involved, the device manufacturer should consider auditing the vendor’s design and development methodologies used in the construction of the OTS software and should assess the development and validation documentation generated for the OTS software. Such audits can be conducted by the device manufacturer or by a qualified third party. \n\nThe audit should demonstrate that the vendor’s procedures for and results of the verification and validation activities performed the OTS software are appropriate and sufficient for the safety and effectiveness requirements of the medical device to be produced using that software.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"github","css":["../../../../../styles.css"],"toc":true,"toc-depth":3,"number-sections":true,"include-in-header":[{"text":"<style>\n.custom-footer { \n  text-align: center; \n  font-size: 0.8em; \n  color: #666; \n  margin-top: 2rem; \n}\n</style>\n"}],"include-after-body":["../../../../../js.html","../../../signup.html"],"output-file":"index.html"},"language":{"toc-title-document":"목차","toc-title-website":"목차","related-formats-title":"기타 형식","related-notebooks-title":"Notebooks","source-notebooks-prefix":"원천","other-links-title":"기타 링크","code-links-title":"코드 링크","launch-dev-container-title":"Dev 컨테이너 실행","launch-binder-title":"랜치 Binder","article-notebook-label":"기사 노트북","notebook-preview-download":"노트북 다운로드","notebook-preview-download-src":"소스 다운로드","notebook-preview-back":"기사로 돌아가기","manuscript-meca-bundle":"MECA 아카이브","section-title-abstract":"초록","section-title-appendices":"부록","section-title-footnotes":"각주","section-title-references":"참고문헌","section-title-reuse":"라이센스","section-title-copyright":"저작권","section-title-citation":"인용","appendix-attribution-cite-as":"인용방법","appendix-attribution-bibtex":"BibTeX 인용:","title-block-author-single":"저자","title-block-author-plural":"저자","title-block-affiliation-single":"소속","title-block-affiliation-plural":"소속","title-block-published":"공개","title-block-modified":"Modified","title-block-keywords":"키워드","callout-tip-title":"힌트","callout-note-title":"노트","callout-warning-title":"경고","callout-important-title":"중요","callout-caution-title":"주의","code-summary":"코드","code-tools-menu-caption":"코드","code-tools-show-all-code":"전체 코드 표시","code-tools-hide-all-code":"전체 코드 숨기기","code-tools-view-source":"소스 코드 표시","code-tools-source-code":"소스 코드","tools-share":"Share","tools-download":"Download","code-line":"선","code-lines":"윤곽","copy-button-tooltip":"클립보드 복사","copy-button-tooltip-success":"복사완료!","repo-action-links-edit":"편집","repo-action-links-source":"소스코드 보기","repo-action-links-issue":"이슈 보고","back-to-top":"맨 위로","search-no-results-text":"일치 없음","search-matching-documents-text":"일치된 문서","search-copy-link-title":"검색 링크 복사","search-hide-matches-text":"추가 검색 결과 숨기기","search-more-match-text":"추가 검색결과","search-more-matches-text":"추가 검색결과","search-clear-button-title":"제거","search-text-placeholder":"","search-detached-cancel-button-title":"취소","search-submit-button-title":"검색","search-label":"검색","toggle-section":"토글 섹션","toggle-sidebar":"사이드바 전환","toggle-dark-mode":"다크 모드 전환","toggle-reader-mode":"리더 모드 전환","toggle-navigation":"탐색 전환","crossref-fig-title":"그림","crossref-tbl-title":"표","crossref-lst-title":"목록","crossref-thm-title":"정리","crossref-lem-title":"보조정리","crossref-cor-title":"따름정리","crossref-prp-title":"명제","crossref-cnj-title":"추측","crossref-def-title":"정의","crossref-exm-title":"보기","crossref-exr-title":"예제","crossref-ch-prefix":"장","crossref-apx-prefix":"부록","crossref-sec-prefix":"섹션","crossref-eq-prefix":"방정식","crossref-lof-title":"그림 목록","crossref-lot-title":"표 목록","crossref-lol-title":"코드 목록","environment-proof-title":"증명","environment-remark-title":"주석","environment-solution-title":"해답","listing-page-order-by":"정렬","listing-page-order-by-default":"디폴트","listing-page-order-by-date-asc":"날짜(오름차순)","listing-page-order-by-date-desc":"날짜(내림차순)","listing-page-order-by-number-desc":"페이지 번호(내림차순)","listing-page-order-by-number-asc":"페이지 번호(오름차순)","listing-page-field-date":"날짜","listing-page-field-title":"제목","listing-page-field-description":"설명","listing-page-field-author":"저자","listing-page-field-filename":"파일명","listing-page-field-filemodified":"갱신일","listing-page-field-subtitle":"부제목","listing-page-field-readingtime":"읽기 시간","listing-page-field-wordcount":"단어 수","listing-page-field-categories":"분류","listing-page-minutes-compact":"{0} 분","listing-page-category-all":"전체","listing-page-no-matches":"일치 없음","listing-page-words":"{0} 단어"},"metadata":{"lang":"ko","fig-responsive":true,"quarto-version":"1.4.543","theme":{"light":["cosmo","../../../../../theme.scss"],"dark":["cosmo","../../../../../theme-dark.scss"]},"code-copy":true,"grid":{"sidebar-width":"200px","body-width":"1200px","margin-width":"200px"},"comments":{"giscus":{"repo":"kmink3225/blog","category":"Blog"}},"title-block-banner":"#EDF3F9","title-block-banner-color":"black","toc-location":"right","open-graph":true,"twitter-card":true,"search":true,"date-format":"YYYY년 MM월 DD일","title":"FDA Software Validation Guidance Summary","subtitle":"Dcoument: General Principles of Software Validation","description":"The purpose of this blog is to get a rough concept of the FDA approval process by making a summary of the 'General Principles of the 'Software Validation; Final Guidance for Industry and FDA Staff' document issued on 2002-01-11. So far, the document seems to be still valid taking into account that its guidance for the FDA approval are broad, general, and comprehensive, and that many recent FDA documents supplement it.\n","categories":["Surveilance"],"author":"Kwangmin Kim","date":"12/15/2022","image":"FDA_medical.PNG"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}