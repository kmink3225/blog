{"title":"비동기 프로그래밍 (Asynchronous Programming)","markdown":{"yaml":{"title":"비동기 프로그래밍 (Asynchronous Programming)","subtitle":"단일 스레드 환경에서의 동시성 구현","description":"비동기 프로그래밍의 개념, 작동 원리, 이벤트 루프와 코루틴을 활용한 효율적인 I/O 처리 방법","author":"Kwangmin Kim","categories":["Engineering"],"date":"2025-10-30"},"headingText":"비동기 프로그래밍 (Asynchronous Programming) 개요","containsRefs":false,"markdown":"\n\n\n* 비동기 프로그래밍은 **단일 스레드(Single Thread)** 환경에서 I/O 작업으로 인한 대기 시간(Latency)을 효율적으로 활용하여 **동시성(Concurrency)**을 달성하고 시스템의 **처리량(Throughput)**을 극대화하는 프로그래밍 패러다임\n* 동시에 여러 이벤트를 효율적으로 처리할 수 있지만 병렬작업과는 완전히 다른 개념\n\n### 비동기란?\n\n비동기 방식의 핵심은 **\"빠른 주체(CPU)를 느린 주체(I/O 장치)가 멈추게 하지 않도록 보호\"**하는 것\n\n* **배경:** 프로그램 실행 주체인 **CPU**는 초고속이지만, **I/O 작업** (네트워크 통신, 파일 접근, 데이터베이스 조회 등)은 수백~수천 배 느림\n* **동기(Synchronous) 방식의 문제:** CPU가 느린 I/O 작업이 끝날 때까지 멈춰서 **강제로 대기(Blocking)**하며 에너지를 낭비\n* **비동기 방식으로 해결:** CPU는 느린 I/O 작업을 **OS 커널에 위임**하고, 완료를 기다리지 않고 **그 시간 동안 다른 요청을 처리**\n\n**결론:** 비동기는 물리적인 동시 실행(병렬)보다는 **CPU의 유휴(노는) 시간을 제거**하여 프로그램의 반응성과 효율을 높이는 데 초점\n\n### 핵심 작동 원리: 이벤트 루프와 협력\n\n비동기 프로그래밍이 순서가 꼬이지 않고 안정적으로 작동할 수 있는 핵심은 **이벤트 루프(Event Loop)**와 **협력적 멀티태스킹**\n\n* **이벤트 루프 (Event Loop):** \n    * 비동기 작업의 **교통 정리 관제탑**\n    * CPU(메인 스레드)의 상태와 I/O 작업의 완료 여부를 끊임없이 감시하며, CPU가 비어 있을 때 처리할 다음 작업을 스케줄링\n* **코루틴 (Coroutine):** `async def`로 정의된 함수로, 실행을 **일시 중지**했다가 나중에 **재개**할 수 있는 특별한 실행 단위\n* **`await` 키워드:** \n    * 코루틴 내에서 **I/O 대기**가 필요한 지점을 **명시적으로 표시**\n    * CPU가 `await`을 만나면 **스스로 제어권을 이벤트 루프에게 반납**하고, 이벤트 루프는 그 시간에 다른 준비된 코루틴을 실행\n    * 주의) CPU가 `await`을 만나면 **무조건 제어권을 이벤트 루프에게 반납하진 않음**\n\n### 비동기 프로그래밍 설계 시 유의사항 (CPU 작업의 함정)\n\n비동기 환경에서 가장 중요한 원칙은 **CPU의 블로킹을 절대 허용하지 않는 것**\n\n* **CPU 집약적 연산의 위험:** `await`이 없는 **오래 걸리는 순수 CPU 연산** (예: 복잡한 계산, 머신러닝 최적화)은 CPU가 제어권을 이벤트 루프에게 반납할 수 있는 **논리적인 틈이 없기 때문**에, **메인 스레드를 블로킹**하여 비동기 시스템 전체를 마비시킴\n* **올바른 설계:** \n    * 코루틴 내부에는 **I/O 작업(`await`)**과 **매우 짧은 CPU 연산**만 배치하는 것이 원칙\n    * 오래 걸리는 CPU 작업은 `asyncio.to_thread()` 등을 사용하여 **별도의 스레드에 위임(병렬 처리)**해야함\n\n## 세부 설명\n\n### 비동기 프로그래밍의 등장 배경: 속도의 불균형\n\n앞서 배경에서 언급했듯이, 하나의 프로그램을 실행하는 데 관여하는 **주체들(Components)의 연산 속도 차이가 매우 심하다**는 것이라는 것을 명심.\n\n* **CPU (중앙 처리 장치):** 초당 수십억 번의 연산을 수행하는 '매우 빠른 주체'.\n* **I/O (입출력 장치):** 네트워크 통신, 디스크 파일 읽기/쓰기, 데이터베이스 조회 등 '매우 느린 주체'.\n\n전통적인 **동기(Synchronous) 방식**에서는 CPU가 코드를 순서대로 실행하다가 I/O 작업을 만나면, 그 느린 작업이 완료될 때까지 **CPU는 아무 일도 하지 않고 멈춰서 대기(Blocking)** 하는 것은 엄청난 자원 낭비로 이어짐.\n\n### 비동기(Asynchronous) 방식의 핵심 목표: 효율성\n\n비동기 프로그래밍은 이 낭비를 막기 위해 등장\n\n> **\"빠른 주체(CPU)가 느린 주체(I/O)를 기다리며 쉴 틈을 주지 않고, 그 시간에 다른 일을 하게 만드는 것.\"**\n\n* 이것이 궁극적으로 도출된 비동기 프로그래밍의 핵심 목표. \n* 즉, 비동기는 **CPU의 유휴 시간(Idle Time)을 최소화**하여 시스템 전체의 효율(처리량)을 극대화하는 방식\n\n### 비동기 vs. 병렬: 중요한 구분\n\n우리는 이것이 **병렬 작업(Parallelism)**과 다르다는 점을 명확히 해야함\n\n* **병렬 작업:** 여러 개의 CPU 코어를 동원해 **하나의 무거운 계산(CPU 작업)**을 동시에 처리하여 '총 작업 시간'을 줄이는 것. (예: 머신러닝 학습)\n* **비동기 작업 (동시성):** **하나의 CPU 코어**가 여러 개의 **느린 I/O 작업** 사이를 효율적으로 오가며 '대기 시간'을 활용하는 것\n\n### '어떻게' 비동기 프로그래밍을 구현하나? (Await 태깅과 이벤트 루프)\n\n* 그렇다면 CPU가 어떻게 I/O 작업을 기다리지 않고 다른 일을 할 수 있을까? \n* 여기서 `async`와 `await`의 진짜 의미가 등장\n\n#### 프로그래머의 약속: `async`와 `await` 태깅\n\n프로그래머가 CPU와 I/O가 할 일을 **구분해서 코딩**해야함\n\n* **`async def` (태깅):** \n    * 함수를 일반 함수가 아닌 **'코루틴(Coroutine)'** 객체로 선언 \n    * \"이 함수는 내부에 I/O 대기(`await`)가 있을 수 있으니, 비동기적으로 관리되어야 합니다\"라는 **태그**를 붙이는 행위\n* **`await` (마킹):** \n    * 코루틴 내부에서 **실제로 느린 I/O 작업**이 발생하는 지점을 **마킹**\n    * 즉, `await`은 프로그래머가 CPU에게 보내는 신호\n\n> **\"이 명령어(`await`)는 외부 I/O 작업이라 오래 걸릴 거야. 그러니 이 작업은 OS 커널 같은 다른 주체에게 맡기고, 너(CPU)는 멈춰서 기다리지 말고 다른 일 하러 가.\"**\n\n#### 교통 정리의 핵심: 이벤트 루프 (Event Loop)\n\n* `await`을 만난 CPU는 `await` 명령문의 연산 제어권을 포기하고 이 제어권은 **이벤트 루프**로 이동.\n* 즉, 이벤트 루프는 **\"비동기 이벤트의 교통 정리 관제탑\"**\n* **역할:** \n    * 이벤트 루프는 **단일 스레드** 내에서 수많은 코루틴(Task)들의 상태를 관리\n    * CPU가 놀지 않도록 다음에 실행할 작업을 **스케줄링**\n* **작동 방식 (교통 정리):**\n    1.  CPU가 **Task A**를 실행하다가 `await` (I/O 작업 1)을 만난다.\n    2.  CPU는 I/O 작업 1을 OS 커널에 위임하고 **제어권을 이벤트 루프에게 반납**.\n    3.  이벤트 루프는 CPU가 비었으니, 대기 중인 **Task B**를 CPU에게 넘긴다.\n    4.  CPU가 Task B를 실행하다가 `await` (I/O 작업 2)을 만난다.\n    5.  CPU는 I/O 작업 2를 위임하고 **제어권을 다시 반납**한다.\n    6.  이벤트 루프는 CPU가 비었지만, 만약 다른 Task가 없다면 대기\n    7.  이때, OS 커널로부터 \"I/O 작업 1이 완료되었습니다!\"라는 **알림(콜백)**이 도착\n    8.  이벤트 루프는 이 알림을 받고, \"Task A의 다음 작업을 실행할 차례\"라고 판단하여 **Task A**를 다시 CPU에게 넘긴다.\n    9.  CPU는 Task A의 `await` 다음 줄부터 연산을 재개\n\n이 모든 과정이 **큐(Queue)**와 **콜백(Callback)**이라는 알고리즘을 기반으로 순서가 뒤죽박죽되지 않고 안정적으로 처리\n\n#### 예시\n\n이 예시는 **단일 스레드** 내에서 여러 개의 코루틴(메서드)이 어떻게 CPU와 I/O 작업을 **협력적으로** 처리하며 전체 시간을 단축하는지를 보여줌\n\n## 복합 비동기 시나리오 예시: `OrderProcessor`\n\n* 온라인 쇼핑몰의 주문을 처리하는 `OrderProcessor` 클래스를 가정\n* 주문 처리 과정은 여러 단계를 거치며, 각 단계에는 CPU 연산과 I/O 대기(DB 조회, 결제)가 혼합되어 있다.\n\n```python\nimport asyncio\nimport time\n\nclass OrderProcessor:\n    def __init__(self, order_id):\n        self.order_id = order_id\n        self.data = {}\n        print(f\"[{order_id}] 주문 프로세서 초기화 시작.\") # <--- CPU 작업\n\n    # 1. 코루틴: 사용자 정보를 비동기적으로 조회\n    async def fetch_user_info(self):\n        # [CPU 작업] 현재 시각 기록 및 로그 메시지 출력\n        start = time.time()\n        print(f\"[{self.order_id}] 1. 사용자 정보 조회 요청...\")\n\n        # [I/O 위임 (await)] 1초간 네트워크 대기 시뮬레이션\n        # <--- 제어권 반납 (이벤트 루프가 다른 Task로 전환)\n        await asyncio.sleep(1) \n        \n        # [CPU 작업] I/O 완료 후 데이터 처리\n        user_info = f\"User-{self.order_id}-Data\"\n        self.data['user'] = user_info\n        print(f\"[{self.order_id}] 1. 사용자 정보 조회 완료. ({time.time() - start:.2f}초 소요)\")\n        return user_info\n\n    # 2. 코루틴: 재고 확인 (CPU 집약적인 로직 가정)\n    # 일반 CPU 연산이므로 await을 사용하지 않아야 하지만, 시간이 너무 길면 블로킹 위험.\n    # 여기서는 비동기 흐름을 깨지 않는 짧은 CPU 연산으로 가정.\n    async def check_inventory(self):\n        # [CPU 작업] 시작 시간 기록\n        start = time.time()\n        print(f\"[{self.order_id}] 2. 재고 복잡 연산 시작...\")\n\n        # [CPU 작업] 복잡한 재고 연산을 시뮬레이션 (블로킹이 없다고 가정)\n        inventory_status = \"Available\"\n        \n        # [CPU 작업] 결과 저장 및 출력\n        self.data['inventory'] = inventory_status\n        print(f\"[{self.order_id}] 2. 재고 연산 완료. ({time.time() - start:.2f}초 소요)\")\n        return inventory_status\n\n    # 3. 코루틴: 결제 요청 (가장 오래 걸리는 I/O)\n    async def process_payment(self):\n        # [CPU 작업] 시작 시간 기록\n        start = time.time()\n        print(f\"[{self.order_id}] 3. 결제 요청 시작...\")\n\n        # [I/O 위임 (await)] 4초간 외부 결제 API 대기 시뮬레이션\n        # <--- 제어권 반납 (이벤트 루프가 다른 Task로 전환)\n        await asyncio.sleep(4) \n        \n        # [CPU 작업] I/O 완료 후 결과 처리\n        payment_result = \"Success\"\n        self.data['payment'] = payment_result\n        print(f\"[{self.order_id}] 3. 결제 완료. ({time.time() - start:.2f}초 소요)\")\n        return payment_result\n    \n    # 4. 코루틴: 모든 단계를 비동기적으로 실행하고 결과를 취합\n    # 이 메서드 자체가 여러 코루틴을 묶는 상위 코루틴입니다.\n    async def run_full_process(self):\n        print(f\"[{self.order_id}] >>> 전체 주문 처리 파이프라인 시작 <<<\")\n\n        # 4-1. [CPU/I/O] 사용자 정보 조회\n        user_info = await self.fetch_user_info() \n        \n        # 4-2. [CPU] 재고 확인\n        inventory = await self.check_inventory()\n        \n        # 4-3. [CPU/I/O] 결제 처리\n        payment = await self.process_payment()\n        \n        # 4-4. [CPU] 최종 결과 조합 및 출력\n        final_status = f\"Order {self.order_id}: {user_info}, {inventory}, {payment}\"\n        print(f\"[{self.order_id}] >>> 최종 결과: {final_status} <<<\")\n        return final_status\n\n# -------------------------------------------------------------\n# 메인 실행 로직\nasync def main():\n    start_time = time.time()\n    print(\"--- 2개의 주문을 비동기적으로 처리 시작 ---\")\n\n    # 두 개의 독립적인 주문 프로세스를 생성 (서로 다른 Task)\n    order_a = OrderProcessor(\"Order-A\")\n    order_b = OrderProcessor(\"Order-B\")\n\n    # 두 개의 run_full_process 코루틴을 Task로 만들고 동시에 실행\n    # 여기서 비동기 동시성(Concurrency)이 발생합니다.\n    task_a = asyncio.create_task(order_a.run_full_process())\n    task_b = asyncio.create_task(order_b.run_full_process())\n\n    # 두 Task가 모두 완료될 때까지 기다림\n    await asyncio.gather(task_a, task_b)\n    \n    end_time = time.time()\n    print(f\"\\n--- 최종 소요 시간: {end_time - start_time:.2f}초 ---\")\n\nif __name__ == \"__main__\":\n    # 동기적으로 실행했다면: (1+4)초 + (1+4)초 = 약 10초 소요\n    # 비동기적으로 실행하면: 가장 긴 I/O 시간인 4초에 가까워야 함\n    asyncio.run(main())\n```\n\n**연산 처리 순서 및 흐름 설명**\n\n총 소요 시간은 $4\\text{초} + \\text{약간의 CPU 시간}$에 가깝게 나와야함.\n\n| 시간대 (대략) | CPU(메인 스레드) 역할 | Order-A (Task A) | Order-B (Task B) |\n| :--- | :--- | :--- | :--- |\n| **0.0초** | **Task A 시작** | `run_full_process` 실행 | 대기 |\n| **0.0초** | **Task B 시작** | `fetch_user_info` 실행 (CPU) | 대기 |\n| **0.0초** | **제어권 반납** | **await 1초 대기 (I/O 위임)** | 대기 |\n| **0.0초** | **Task B 전환** | 대기 (I/O 진행 중) | `run_full_process` 실행 |\n| **0.0초** | **제어권 반납** | 대기 (I/O 진행 중) | **await 1초 대기 (I/O 위임)** |\n| **0.0초** | **이벤트 루프 유휴** | I/O 진행 중 | I/O 진행 중 |\n| **1.0초** | **Task A 재개** | I/O 완료, 재고 연산 (CPU) | 대기 |\n| **1.0초** | **제어권 반납** | `process_payment` 실행 (CPU) | I/O 완료, 재고 연산 (CPU) |\n| **1.0초** | **Task B 재개** | 대기 | `process_payment` 실행 (CPU) |\n| **1.0초** | **제어권 반납** | **await 4초 대기 (I/O 위임)** | **await 4초 대기 (I/O 위임)** |\n| **1.0 \\~ 5.0초** | **I/O 진행 중** | 결제 I/O 진행 중 | 결제 I/O 진행 중 |\n| **5.0초** | **Task A 재개** | 결제 완료, 최종 출력 (CPU) | 대기 |\n| **5.0초** | **Task B 재개** | 완료 | 결제 완료, 최종 출력 (CPU) |\n| **5.0초** | **모든 Task 완료** | 완료 | 완료 |\n\n**결론: 동시성 달성**\n\n* CPU는 **Order-A의 1초 I/O 대기 시간**이 발생했을 때 **Order-B의 1초 I/O 요청**을 처리하는 데 활용\n* **Order-A와 Order-B의 4초 결제 대기 시간** 동안 CPU는 **아무 작업도 하지 않고 대기**하는 대신, **두 결제 요청을 동시에 진행**\n* 결과적으로 두 주문의 총 I/O 대기 시간(4초)에 가까운 시간 안에 모든 작업이 완료되어 **효율적인 동시 처리**가 이루어진다.\n\n### '무엇을' 조심해야 하는가? (CPU 연산의 함정)\n\n* 이 논리대로라면, 프로그래머가 `async def`와 `await`을 잘 설계하는 것이 핵심\n* 프로그래머는 모든 명령문에 대해서 CPU작업과 I/O작업을 구분짓기 힘들 수 있음\n\n#### 코루틴의 구성: CPU 작업과 I/O 작업의 혼재\n\n우리는 코루틴 내부가 **\"CPU가 할 일과 OS(I/O)가 할 일이 섞여 있을 수밖에 없다\"**는 것을 확인\n\n* **CPU가 할 일 (Await이 없는 코드):** 변수 할당, 간단한 연산, 로그 찍기.\n* **OS가 할 일 (Await이 있는 코드):** `await asyncio.sleep(1)`, `await client.get(url)`.\n\n비동기 함수는 이 두 가지가 번갈아 나타나는 **\"얇은 껍질(Thin Wrapper)\"**처럼 설계되어, CPU가 간단한 연산을 빠르게 처리하고 즉시 `await`에서 제어권을 반납하도록 유도해야 바람직하다.\n\n#### 치명적인 실수: CPU 집약적 작업에 `await`을 붙인다면?\n\n만약 머신러닝의 '가중치 최적화' 같은 **무거운 CPU 연산**에 `await`을 붙이면 어떻게 될까?\n\n* **잘못된 가정:** `await`을 붙였으니 CPU가 이 작업을 I/O처럼 다른 곳에 위임하고 다른 일을 할 것이다.\n* **현실:** \n    * CPU 연산은 OS 커널에 **위임할 수 없다.** \n    * CPU 자신이 **직접** 처리해야 하는 일이다.\n    * 즉, CPU 연산에 `await`을 마킹해도 CPU연산이 일어남\n    * 즉, `await`을 붙이더라도, CPU는 \"이건 내가 해야 하는 계산이네\"라고 판단하고, 그 **계산이 끝날 때까지 제어권을 이벤트 루프에게 반납하지 않는다.**\n\n> **결과: 이벤트 루프가 멈춘다 (Blocking).**\n\n* CPU가 무거운 계산을 하는 동안 이벤트 루프는 스케줄링을 할 수 없게 되고, \n* 다른 모든 비동기 작업(네트워크 요청, 다른 사용자의 응답)이 **완전히 정지**\n* 이는 `async`를 쓰지 않고 동기 코드를 실행한 것과 똑같거나 오히려 더 나쁜 결과를 초래\n\n#### 최종 결론: 올바른 비동기 설계\n\n* 비동기 프로그램은 **I/O 대기 시간**이 긴 작업(네트워크, DB)에 압도적으로 유리\n* 비동기 코루틴(`async def`) 안에는 **무거운 CPU 연산**을 절대로 배치해서는 안 된다.\n* 만약 무거운 CPU 연산이 필요하다면, `asyncio.to_thread()` 등을 사용해 **별도의 스레드(병렬 처리)**로 분리하여 이벤트 루프를 막지 않도록 설계해야 한다.\n","srcMarkdownNoYaml":"\n\n## 비동기 프로그래밍 (Asynchronous Programming) 개요\n\n* 비동기 프로그래밍은 **단일 스레드(Single Thread)** 환경에서 I/O 작업으로 인한 대기 시간(Latency)을 효율적으로 활용하여 **동시성(Concurrency)**을 달성하고 시스템의 **처리량(Throughput)**을 극대화하는 프로그래밍 패러다임\n* 동시에 여러 이벤트를 효율적으로 처리할 수 있지만 병렬작업과는 완전히 다른 개념\n\n### 비동기란?\n\n비동기 방식의 핵심은 **\"빠른 주체(CPU)를 느린 주체(I/O 장치)가 멈추게 하지 않도록 보호\"**하는 것\n\n* **배경:** 프로그램 실행 주체인 **CPU**는 초고속이지만, **I/O 작업** (네트워크 통신, 파일 접근, 데이터베이스 조회 등)은 수백~수천 배 느림\n* **동기(Synchronous) 방식의 문제:** CPU가 느린 I/O 작업이 끝날 때까지 멈춰서 **강제로 대기(Blocking)**하며 에너지를 낭비\n* **비동기 방식으로 해결:** CPU는 느린 I/O 작업을 **OS 커널에 위임**하고, 완료를 기다리지 않고 **그 시간 동안 다른 요청을 처리**\n\n**결론:** 비동기는 물리적인 동시 실행(병렬)보다는 **CPU의 유휴(노는) 시간을 제거**하여 프로그램의 반응성과 효율을 높이는 데 초점\n\n### 핵심 작동 원리: 이벤트 루프와 협력\n\n비동기 프로그래밍이 순서가 꼬이지 않고 안정적으로 작동할 수 있는 핵심은 **이벤트 루프(Event Loop)**와 **협력적 멀티태스킹**\n\n* **이벤트 루프 (Event Loop):** \n    * 비동기 작업의 **교통 정리 관제탑**\n    * CPU(메인 스레드)의 상태와 I/O 작업의 완료 여부를 끊임없이 감시하며, CPU가 비어 있을 때 처리할 다음 작업을 스케줄링\n* **코루틴 (Coroutine):** `async def`로 정의된 함수로, 실행을 **일시 중지**했다가 나중에 **재개**할 수 있는 특별한 실행 단위\n* **`await` 키워드:** \n    * 코루틴 내에서 **I/O 대기**가 필요한 지점을 **명시적으로 표시**\n    * CPU가 `await`을 만나면 **스스로 제어권을 이벤트 루프에게 반납**하고, 이벤트 루프는 그 시간에 다른 준비된 코루틴을 실행\n    * 주의) CPU가 `await`을 만나면 **무조건 제어권을 이벤트 루프에게 반납하진 않음**\n\n### 비동기 프로그래밍 설계 시 유의사항 (CPU 작업의 함정)\n\n비동기 환경에서 가장 중요한 원칙은 **CPU의 블로킹을 절대 허용하지 않는 것**\n\n* **CPU 집약적 연산의 위험:** `await`이 없는 **오래 걸리는 순수 CPU 연산** (예: 복잡한 계산, 머신러닝 최적화)은 CPU가 제어권을 이벤트 루프에게 반납할 수 있는 **논리적인 틈이 없기 때문**에, **메인 스레드를 블로킹**하여 비동기 시스템 전체를 마비시킴\n* **올바른 설계:** \n    * 코루틴 내부에는 **I/O 작업(`await`)**과 **매우 짧은 CPU 연산**만 배치하는 것이 원칙\n    * 오래 걸리는 CPU 작업은 `asyncio.to_thread()` 등을 사용하여 **별도의 스레드에 위임(병렬 처리)**해야함\n\n## 세부 설명\n\n### 비동기 프로그래밍의 등장 배경: 속도의 불균형\n\n앞서 배경에서 언급했듯이, 하나의 프로그램을 실행하는 데 관여하는 **주체들(Components)의 연산 속도 차이가 매우 심하다**는 것이라는 것을 명심.\n\n* **CPU (중앙 처리 장치):** 초당 수십억 번의 연산을 수행하는 '매우 빠른 주체'.\n* **I/O (입출력 장치):** 네트워크 통신, 디스크 파일 읽기/쓰기, 데이터베이스 조회 등 '매우 느린 주체'.\n\n전통적인 **동기(Synchronous) 방식**에서는 CPU가 코드를 순서대로 실행하다가 I/O 작업을 만나면, 그 느린 작업이 완료될 때까지 **CPU는 아무 일도 하지 않고 멈춰서 대기(Blocking)** 하는 것은 엄청난 자원 낭비로 이어짐.\n\n### 비동기(Asynchronous) 방식의 핵심 목표: 효율성\n\n비동기 프로그래밍은 이 낭비를 막기 위해 등장\n\n> **\"빠른 주체(CPU)가 느린 주체(I/O)를 기다리며 쉴 틈을 주지 않고, 그 시간에 다른 일을 하게 만드는 것.\"**\n\n* 이것이 궁극적으로 도출된 비동기 프로그래밍의 핵심 목표. \n* 즉, 비동기는 **CPU의 유휴 시간(Idle Time)을 최소화**하여 시스템 전체의 효율(처리량)을 극대화하는 방식\n\n### 비동기 vs. 병렬: 중요한 구분\n\n우리는 이것이 **병렬 작업(Parallelism)**과 다르다는 점을 명확히 해야함\n\n* **병렬 작업:** 여러 개의 CPU 코어를 동원해 **하나의 무거운 계산(CPU 작업)**을 동시에 처리하여 '총 작업 시간'을 줄이는 것. (예: 머신러닝 학습)\n* **비동기 작업 (동시성):** **하나의 CPU 코어**가 여러 개의 **느린 I/O 작업** 사이를 효율적으로 오가며 '대기 시간'을 활용하는 것\n\n### '어떻게' 비동기 프로그래밍을 구현하나? (Await 태깅과 이벤트 루프)\n\n* 그렇다면 CPU가 어떻게 I/O 작업을 기다리지 않고 다른 일을 할 수 있을까? \n* 여기서 `async`와 `await`의 진짜 의미가 등장\n\n#### 프로그래머의 약속: `async`와 `await` 태깅\n\n프로그래머가 CPU와 I/O가 할 일을 **구분해서 코딩**해야함\n\n* **`async def` (태깅):** \n    * 함수를 일반 함수가 아닌 **'코루틴(Coroutine)'** 객체로 선언 \n    * \"이 함수는 내부에 I/O 대기(`await`)가 있을 수 있으니, 비동기적으로 관리되어야 합니다\"라는 **태그**를 붙이는 행위\n* **`await` (마킹):** \n    * 코루틴 내부에서 **실제로 느린 I/O 작업**이 발생하는 지점을 **마킹**\n    * 즉, `await`은 프로그래머가 CPU에게 보내는 신호\n\n> **\"이 명령어(`await`)는 외부 I/O 작업이라 오래 걸릴 거야. 그러니 이 작업은 OS 커널 같은 다른 주체에게 맡기고, 너(CPU)는 멈춰서 기다리지 말고 다른 일 하러 가.\"**\n\n#### 교통 정리의 핵심: 이벤트 루프 (Event Loop)\n\n* `await`을 만난 CPU는 `await` 명령문의 연산 제어권을 포기하고 이 제어권은 **이벤트 루프**로 이동.\n* 즉, 이벤트 루프는 **\"비동기 이벤트의 교통 정리 관제탑\"**\n* **역할:** \n    * 이벤트 루프는 **단일 스레드** 내에서 수많은 코루틴(Task)들의 상태를 관리\n    * CPU가 놀지 않도록 다음에 실행할 작업을 **스케줄링**\n* **작동 방식 (교통 정리):**\n    1.  CPU가 **Task A**를 실행하다가 `await` (I/O 작업 1)을 만난다.\n    2.  CPU는 I/O 작업 1을 OS 커널에 위임하고 **제어권을 이벤트 루프에게 반납**.\n    3.  이벤트 루프는 CPU가 비었으니, 대기 중인 **Task B**를 CPU에게 넘긴다.\n    4.  CPU가 Task B를 실행하다가 `await` (I/O 작업 2)을 만난다.\n    5.  CPU는 I/O 작업 2를 위임하고 **제어권을 다시 반납**한다.\n    6.  이벤트 루프는 CPU가 비었지만, 만약 다른 Task가 없다면 대기\n    7.  이때, OS 커널로부터 \"I/O 작업 1이 완료되었습니다!\"라는 **알림(콜백)**이 도착\n    8.  이벤트 루프는 이 알림을 받고, \"Task A의 다음 작업을 실행할 차례\"라고 판단하여 **Task A**를 다시 CPU에게 넘긴다.\n    9.  CPU는 Task A의 `await` 다음 줄부터 연산을 재개\n\n이 모든 과정이 **큐(Queue)**와 **콜백(Callback)**이라는 알고리즘을 기반으로 순서가 뒤죽박죽되지 않고 안정적으로 처리\n\n#### 예시\n\n이 예시는 **단일 스레드** 내에서 여러 개의 코루틴(메서드)이 어떻게 CPU와 I/O 작업을 **협력적으로** 처리하며 전체 시간을 단축하는지를 보여줌\n\n## 복합 비동기 시나리오 예시: `OrderProcessor`\n\n* 온라인 쇼핑몰의 주문을 처리하는 `OrderProcessor` 클래스를 가정\n* 주문 처리 과정은 여러 단계를 거치며, 각 단계에는 CPU 연산과 I/O 대기(DB 조회, 결제)가 혼합되어 있다.\n\n```python\nimport asyncio\nimport time\n\nclass OrderProcessor:\n    def __init__(self, order_id):\n        self.order_id = order_id\n        self.data = {}\n        print(f\"[{order_id}] 주문 프로세서 초기화 시작.\") # <--- CPU 작업\n\n    # 1. 코루틴: 사용자 정보를 비동기적으로 조회\n    async def fetch_user_info(self):\n        # [CPU 작업] 현재 시각 기록 및 로그 메시지 출력\n        start = time.time()\n        print(f\"[{self.order_id}] 1. 사용자 정보 조회 요청...\")\n\n        # [I/O 위임 (await)] 1초간 네트워크 대기 시뮬레이션\n        # <--- 제어권 반납 (이벤트 루프가 다른 Task로 전환)\n        await asyncio.sleep(1) \n        \n        # [CPU 작업] I/O 완료 후 데이터 처리\n        user_info = f\"User-{self.order_id}-Data\"\n        self.data['user'] = user_info\n        print(f\"[{self.order_id}] 1. 사용자 정보 조회 완료. ({time.time() - start:.2f}초 소요)\")\n        return user_info\n\n    # 2. 코루틴: 재고 확인 (CPU 집약적인 로직 가정)\n    # 일반 CPU 연산이므로 await을 사용하지 않아야 하지만, 시간이 너무 길면 블로킹 위험.\n    # 여기서는 비동기 흐름을 깨지 않는 짧은 CPU 연산으로 가정.\n    async def check_inventory(self):\n        # [CPU 작업] 시작 시간 기록\n        start = time.time()\n        print(f\"[{self.order_id}] 2. 재고 복잡 연산 시작...\")\n\n        # [CPU 작업] 복잡한 재고 연산을 시뮬레이션 (블로킹이 없다고 가정)\n        inventory_status = \"Available\"\n        \n        # [CPU 작업] 결과 저장 및 출력\n        self.data['inventory'] = inventory_status\n        print(f\"[{self.order_id}] 2. 재고 연산 완료. ({time.time() - start:.2f}초 소요)\")\n        return inventory_status\n\n    # 3. 코루틴: 결제 요청 (가장 오래 걸리는 I/O)\n    async def process_payment(self):\n        # [CPU 작업] 시작 시간 기록\n        start = time.time()\n        print(f\"[{self.order_id}] 3. 결제 요청 시작...\")\n\n        # [I/O 위임 (await)] 4초간 외부 결제 API 대기 시뮬레이션\n        # <--- 제어권 반납 (이벤트 루프가 다른 Task로 전환)\n        await asyncio.sleep(4) \n        \n        # [CPU 작업] I/O 완료 후 결과 처리\n        payment_result = \"Success\"\n        self.data['payment'] = payment_result\n        print(f\"[{self.order_id}] 3. 결제 완료. ({time.time() - start:.2f}초 소요)\")\n        return payment_result\n    \n    # 4. 코루틴: 모든 단계를 비동기적으로 실행하고 결과를 취합\n    # 이 메서드 자체가 여러 코루틴을 묶는 상위 코루틴입니다.\n    async def run_full_process(self):\n        print(f\"[{self.order_id}] >>> 전체 주문 처리 파이프라인 시작 <<<\")\n\n        # 4-1. [CPU/I/O] 사용자 정보 조회\n        user_info = await self.fetch_user_info() \n        \n        # 4-2. [CPU] 재고 확인\n        inventory = await self.check_inventory()\n        \n        # 4-3. [CPU/I/O] 결제 처리\n        payment = await self.process_payment()\n        \n        # 4-4. [CPU] 최종 결과 조합 및 출력\n        final_status = f\"Order {self.order_id}: {user_info}, {inventory}, {payment}\"\n        print(f\"[{self.order_id}] >>> 최종 결과: {final_status} <<<\")\n        return final_status\n\n# -------------------------------------------------------------\n# 메인 실행 로직\nasync def main():\n    start_time = time.time()\n    print(\"--- 2개의 주문을 비동기적으로 처리 시작 ---\")\n\n    # 두 개의 독립적인 주문 프로세스를 생성 (서로 다른 Task)\n    order_a = OrderProcessor(\"Order-A\")\n    order_b = OrderProcessor(\"Order-B\")\n\n    # 두 개의 run_full_process 코루틴을 Task로 만들고 동시에 실행\n    # 여기서 비동기 동시성(Concurrency)이 발생합니다.\n    task_a = asyncio.create_task(order_a.run_full_process())\n    task_b = asyncio.create_task(order_b.run_full_process())\n\n    # 두 Task가 모두 완료될 때까지 기다림\n    await asyncio.gather(task_a, task_b)\n    \n    end_time = time.time()\n    print(f\"\\n--- 최종 소요 시간: {end_time - start_time:.2f}초 ---\")\n\nif __name__ == \"__main__\":\n    # 동기적으로 실행했다면: (1+4)초 + (1+4)초 = 약 10초 소요\n    # 비동기적으로 실행하면: 가장 긴 I/O 시간인 4초에 가까워야 함\n    asyncio.run(main())\n```\n\n**연산 처리 순서 및 흐름 설명**\n\n총 소요 시간은 $4\\text{초} + \\text{약간의 CPU 시간}$에 가깝게 나와야함.\n\n| 시간대 (대략) | CPU(메인 스레드) 역할 | Order-A (Task A) | Order-B (Task B) |\n| :--- | :--- | :--- | :--- |\n| **0.0초** | **Task A 시작** | `run_full_process` 실행 | 대기 |\n| **0.0초** | **Task B 시작** | `fetch_user_info` 실행 (CPU) | 대기 |\n| **0.0초** | **제어권 반납** | **await 1초 대기 (I/O 위임)** | 대기 |\n| **0.0초** | **Task B 전환** | 대기 (I/O 진행 중) | `run_full_process` 실행 |\n| **0.0초** | **제어권 반납** | 대기 (I/O 진행 중) | **await 1초 대기 (I/O 위임)** |\n| **0.0초** | **이벤트 루프 유휴** | I/O 진행 중 | I/O 진행 중 |\n| **1.0초** | **Task A 재개** | I/O 완료, 재고 연산 (CPU) | 대기 |\n| **1.0초** | **제어권 반납** | `process_payment` 실행 (CPU) | I/O 완료, 재고 연산 (CPU) |\n| **1.0초** | **Task B 재개** | 대기 | `process_payment` 실행 (CPU) |\n| **1.0초** | **제어권 반납** | **await 4초 대기 (I/O 위임)** | **await 4초 대기 (I/O 위임)** |\n| **1.0 \\~ 5.0초** | **I/O 진행 중** | 결제 I/O 진행 중 | 결제 I/O 진행 중 |\n| **5.0초** | **Task A 재개** | 결제 완료, 최종 출력 (CPU) | 대기 |\n| **5.0초** | **Task B 재개** | 완료 | 결제 완료, 최종 출력 (CPU) |\n| **5.0초** | **모든 Task 완료** | 완료 | 완료 |\n\n**결론: 동시성 달성**\n\n* CPU는 **Order-A의 1초 I/O 대기 시간**이 발생했을 때 **Order-B의 1초 I/O 요청**을 처리하는 데 활용\n* **Order-A와 Order-B의 4초 결제 대기 시간** 동안 CPU는 **아무 작업도 하지 않고 대기**하는 대신, **두 결제 요청을 동시에 진행**\n* 결과적으로 두 주문의 총 I/O 대기 시간(4초)에 가까운 시간 안에 모든 작업이 완료되어 **효율적인 동시 처리**가 이루어진다.\n\n### '무엇을' 조심해야 하는가? (CPU 연산의 함정)\n\n* 이 논리대로라면, 프로그래머가 `async def`와 `await`을 잘 설계하는 것이 핵심\n* 프로그래머는 모든 명령문에 대해서 CPU작업과 I/O작업을 구분짓기 힘들 수 있음\n\n#### 코루틴의 구성: CPU 작업과 I/O 작업의 혼재\n\n우리는 코루틴 내부가 **\"CPU가 할 일과 OS(I/O)가 할 일이 섞여 있을 수밖에 없다\"**는 것을 확인\n\n* **CPU가 할 일 (Await이 없는 코드):** 변수 할당, 간단한 연산, 로그 찍기.\n* **OS가 할 일 (Await이 있는 코드):** `await asyncio.sleep(1)`, `await client.get(url)`.\n\n비동기 함수는 이 두 가지가 번갈아 나타나는 **\"얇은 껍질(Thin Wrapper)\"**처럼 설계되어, CPU가 간단한 연산을 빠르게 처리하고 즉시 `await`에서 제어권을 반납하도록 유도해야 바람직하다.\n\n#### 치명적인 실수: CPU 집약적 작업에 `await`을 붙인다면?\n\n만약 머신러닝의 '가중치 최적화' 같은 **무거운 CPU 연산**에 `await`을 붙이면 어떻게 될까?\n\n* **잘못된 가정:** `await`을 붙였으니 CPU가 이 작업을 I/O처럼 다른 곳에 위임하고 다른 일을 할 것이다.\n* **현실:** \n    * CPU 연산은 OS 커널에 **위임할 수 없다.** \n    * CPU 자신이 **직접** 처리해야 하는 일이다.\n    * 즉, CPU 연산에 `await`을 마킹해도 CPU연산이 일어남\n    * 즉, `await`을 붙이더라도, CPU는 \"이건 내가 해야 하는 계산이네\"라고 판단하고, 그 **계산이 끝날 때까지 제어권을 이벤트 루프에게 반납하지 않는다.**\n\n> **결과: 이벤트 루프가 멈춘다 (Blocking).**\n\n* CPU가 무거운 계산을 하는 동안 이벤트 루프는 스케줄링을 할 수 없게 되고, \n* 다른 모든 비동기 작업(네트워크 요청, 다른 사용자의 응답)이 **완전히 정지**\n* 이는 `async`를 쓰지 않고 동기 코드를 실행한 것과 똑같거나 오히려 더 나쁜 결과를 초래\n\n#### 최종 결론: 올바른 비동기 설계\n\n* 비동기 프로그램은 **I/O 대기 시간**이 긴 작업(네트워크, DB)에 압도적으로 유리\n* 비동기 코루틴(`async def`) 안에는 **무거운 CPU 연산**을 절대로 배치해서는 안 된다.\n* 만약 무거운 CPU 연산이 필요하다면, `asyncio.to_thread()` 등을 사용해 **별도의 스레드(병렬 처리)**로 분리하여 이벤트 루프를 막지 않도록 설계해야 한다.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":true,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"github","css":["../../../../styles.css"],"toc":true,"toc-depth":3,"number-sections":true,"include-in-header":[{"text":"<style>\n.custom-footer { \n  text-align: center; \n  font-size: 0.8em; \n  color: #666; \n  margin-top: 2rem; \n}\n</style>\n"}],"include-after-body":["../../../../js.html","../../signup.html"],"output-file":"async.html"},"language":{"toc-title-document":"목차","toc-title-website":"목차","related-formats-title":"기타 형식","related-notebooks-title":"Notebooks","source-notebooks-prefix":"원천","other-links-title":"기타 링크","code-links-title":"코드 링크","launch-dev-container-title":"Dev 컨테이너 실행","launch-binder-title":"랜치 Binder","article-notebook-label":"기사 노트북","notebook-preview-download":"노트북 다운로드","notebook-preview-download-src":"소스 다운로드","notebook-preview-back":"기사로 돌아가기","manuscript-meca-bundle":"MECA 아카이브","section-title-abstract":"초록","section-title-appendices":"부록","section-title-footnotes":"각주","section-title-references":"참고문헌","section-title-reuse":"라이센스","section-title-copyright":"저작권","section-title-citation":"인용","appendix-attribution-cite-as":"인용방법","appendix-attribution-bibtex":"BibTeX 인용:","title-block-author-single":"저자","title-block-author-plural":"저자","title-block-affiliation-single":"소속","title-block-affiliation-plural":"소속","title-block-published":"공개","title-block-modified":"Modified","title-block-keywords":"키워드","callout-tip-title":"힌트","callout-note-title":"노트","callout-warning-title":"경고","callout-important-title":"중요","callout-caution-title":"주의","code-summary":"코드","code-tools-menu-caption":"코드","code-tools-show-all-code":"전체 코드 표시","code-tools-hide-all-code":"전체 코드 숨기기","code-tools-view-source":"소스 코드 표시","code-tools-source-code":"소스 코드","tools-share":"Share","tools-download":"Download","code-line":"선","code-lines":"윤곽","copy-button-tooltip":"클립보드 복사","copy-button-tooltip-success":"복사완료!","repo-action-links-edit":"편집","repo-action-links-source":"소스코드 보기","repo-action-links-issue":"이슈 보고","back-to-top":"맨 위로","search-no-results-text":"일치 없음","search-matching-documents-text":"일치된 문서","search-copy-link-title":"검색 링크 복사","search-hide-matches-text":"추가 검색 결과 숨기기","search-more-match-text":"추가 검색결과","search-more-matches-text":"추가 검색결과","search-clear-button-title":"제거","search-text-placeholder":"","search-detached-cancel-button-title":"취소","search-submit-button-title":"검색","search-label":"검색","toggle-section":"토글 섹션","toggle-sidebar":"사이드바 전환","toggle-dark-mode":"다크 모드 전환","toggle-reader-mode":"리더 모드 전환","toggle-navigation":"탐색 전환","crossref-fig-title":"그림","crossref-tbl-title":"표","crossref-lst-title":"목록","crossref-thm-title":"정리","crossref-lem-title":"보조정리","crossref-cor-title":"따름정리","crossref-prp-title":"명제","crossref-cnj-title":"추측","crossref-def-title":"정의","crossref-exm-title":"보기","crossref-exr-title":"예제","crossref-ch-prefix":"장","crossref-apx-prefix":"부록","crossref-sec-prefix":"섹션","crossref-eq-prefix":"방정식","crossref-lof-title":"그림 목록","crossref-lot-title":"표 목록","crossref-lol-title":"코드 목록","environment-proof-title":"증명","environment-remark-title":"주석","environment-solution-title":"해답","listing-page-order-by":"정렬","listing-page-order-by-default":"디폴트","listing-page-order-by-date-asc":"날짜(오름차순)","listing-page-order-by-date-desc":"날짜(내림차순)","listing-page-order-by-number-desc":"페이지 번호(내림차순)","listing-page-order-by-number-asc":"페이지 번호(오름차순)","listing-page-field-date":"날짜","listing-page-field-title":"제목","listing-page-field-description":"설명","listing-page-field-author":"저자","listing-page-field-filename":"파일명","listing-page-field-filemodified":"갱신일","listing-page-field-subtitle":"부제목","listing-page-field-readingtime":"읽기 시간","listing-page-field-wordcount":"단어 수","listing-page-field-categories":"분류","listing-page-minutes-compact":"{0} 분","listing-page-category-all":"전체","listing-page-no-matches":"일치 없음","listing-page-words":"{0} 단어"},"metadata":{"lang":"ko","fig-responsive":true,"quarto-version":"1.4.543","theme":{"light":["cosmo","../../../../theme.scss"],"dark":["cosmo","../../../../theme-dark.scss"]},"code-copy":true,"grid":{"sidebar-width":"200px","body-width":"1200px","margin-width":"200px"},"comments":{"giscus":{"repo":"kmink3225/blog","category":"Blog"}},"title-block-banner":"#EDF3F9","title-block-banner-color":"black","toc-location":"right","open-graph":true,"twitter-card":true,"search":true,"date-format":"YYYY년 MM월 DD일","title":"비동기 프로그래밍 (Asynchronous Programming)","subtitle":"단일 스레드 환경에서의 동시성 구현","description":"비동기 프로그래밍의 개념, 작동 원리, 이벤트 루프와 코루틴을 활용한 효율적인 I/O 처리 방법","author":"Kwangmin Kim","categories":["Engineering"],"date":"2025-10-30"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}