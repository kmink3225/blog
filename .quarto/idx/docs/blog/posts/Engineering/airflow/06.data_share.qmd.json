{"title":"Data Share","markdown":{"yaml":{"title":"Data Share","subtitle":"Python Operator with Xcom, Bash Operator with Xcom, Xcom between Python Operator and Bash Operator, Xcom between Python Operator and Email Operator, Global Share Variable","description":"template\n","categories":["Engineering"],"author":"Kwangmin Kim","date":"05/01/2023","format":{"html":{"page-layout":"full","code-fold":true,"toc":true,"number-sections":true}},"comments":{"utterances":{"repo":"./docs/comments"}},"draft":false},"headingText":"Xcom Definition","containsRefs":false,"markdown":"\n\n<ul class=\"nav nav-pills\" id=\"language-tab\" role=\"tablist\">\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link active\" id=\"Korean-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#Korean\" type=\"button\" role=\"tab\" aria-controls=\"Korean\" aria-selected=\"true\">Korean</button>\n  </li>\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link\" id=\"English-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#English\" type=\"button\" role=\"tab\" aria-controls=\"knitr\" aria-selected=\"false\">English</button>\n  </li>\n\n<div class=\"tab-content\" id=\"language-tabcontent\">\n\n<div class=\"tab-pane fade  show active\" id=\"Korean\" role=\"tabpanel\" aria-labelledby=\"Korean-tab\">\n\n::: {#Korean .tab-pane .fade .show .active role=\"tabpanel\" aria-labelledby=\"Korean-tab\"}\n\n\n* Xcom stands for Cross Communication.\n* Airflow DAG 안 Task 간 작은 데이터 (or Message) 공유를 위해 사용되는 기술 (1개의 Dag 안에 있는 task끼리만 data 공유)\n    * 예를 들어, Task1의 수행 중 내용이나 결과를 Task2에서 사용 또는 입력으로 주고 싶은 경우\n    * task1 은 push, task2는 pull과 같은 tasks간 데이터 공유에 유용\n* 주로 작은 규모의 데이터 공유를 위해 사용\n    * Xcom 내용은 meta DB의 Xcom 테이블에 값이 저장됨    \n    * 1GB 이상의 대용량 데이터 공유를 위해서는 외부 솔루션 사용 필요 (AWS의 S3, GCP의 GCS, HDFS (Hadoop File System) 등)\n\n# Python 오퍼레이터 With Xcom\n\n## Python 오퍼레이터에서 Xcom 사용하기\n\n* 크게 두 가지 방법으로 Xcom 사용 가능\n    1. **kwargs에 존재하는 ti (task_instance) 객체 활용\n    \n    ```markdown\n    @task(task_id='python_xcom_push_task')\n    def xcom_push(**kwargs):\n        ti = kwargs['ti']\n        ti.xcom_push(key=\"result1\", value=\"value_1\") \n        ti.xcom_push(key=\"result2\", value=[1,2,3])\n        #xcom_push: xcom에다가 data를 올릴 수 있음\n        #data를 올릴 때는 key:value 형태로 올리기\n        #template 변수에서 task_instance 라는 객체를 얻을 수 있으며 task_instance 객체가 가진 xcom_push 메서드를 활용할 수 있음\n\n    @task(task_id='python_xcom_pull_task')\n    def xcom_pull(**kwargs):\n        ti = kwargs['ti']\n        value_key1 = ti.xcom_pull(key=\"result1\") # value_1이 value_key1에 저장됨\n        value_key2 = ti.xcom_pull(key=\"result2\",\n        task_ids='python_xcom_push_task') # [1,2,3]이 value_key2에 저장됨\n        #xcom_pull: xcom으로부터 data를 내려 받을 수 있음\n        #data를 올릴 때는 key:value 형태로 올리기\n        print(value_key1)\n        print(value_key2)\n    ```\n    * xcome_pull()을 할때 key값만 줘도 되고 key값과 task_ids값을 둘다 줘도 된다.\n        * key값만 줘도 될때\n            * xcom_push를 한 task가 1개 밖에 없을 때 사용 가능\n            * 혹은, key값이 중복될 때 xcom_push를 한 task가 여러 개 있을 때도 사용 가능한데 가장 마지막 (최신) task의 key값을 호출 한다.\n            * 만약, key값이 중복이 되지 않는 다면 key값만으로도 data를 내려 받을 수 있다.\n        * key값과 task_ids둘다 줘야할 때\n            * key값이 중복되는 xcom_push를 한 task가 여러 개 있을 때 \n            선택적으로 원하는 task의 data를 가지고 오고 싶으면 해당 task의 task_ids를 명시적으로 적어줘야한다.\n        * 예를 들어,\n        ```markdown\n        # 5개의 tasks 존재하는\n        # task1: xcom_push(key='result1'...)\n        # task2: xcom_push(key='result1'...)\n        # task3: xcom_push(key='result2'...)\n        # task4: xcom_pull(key='result1'...)\n        # task5: xcom_pull(key='result1',task_ids=...)\n        ```\n        * task4가 수행이 될때 task1의 xcom을 가져우는게 아니라 가장 최신에 수행된 task2의 xcom을 가져오게 된다.\n        * task1의 xcom을 가지고 오고 싶을땐 task5와 같이 task1의 task_id를 task5의 task_ids에 명시해주면 된다.\n        * 가장 안전한 방법은 task의 key값과 task_ids를 명시적으로 적어주는 것이다. 아니면 tasks의 key값을 절대 중복이 되지않도록 적어주는 것이다.\n\n    2. 파이썬 함수의 return 값 활용 \n        * (1안)\n        ```markdown\n        @task(task_id='xcom_push_by_return')\n        def xcom_push_by_return(**kwargs):\n            transaction_value = 'status Good'\n            return transaction_value\n        @task(task_id='xcom_pull_by_return')\n        def xcom_pull_by_return(status, **kwargs):\n            print(status)\n        xcom_pull_by_return(xcom_push_by_return()) \n        ```\n        * xcom을 이용한 task의 flow 정해주는 또 다른 방식\n        * 암묵적인 task의 순서: xcom_push_by_return() >> xcom_pull_by_return()\n        * 위의 스크립트에서 xcom_pull() 또는 xcom_push()가 명시적으로 쓰이지진 않았지만 airflow에서는 **Task 데커레이터 사용시** 함수 입력/출력 관계만으로 Task flow 정의가 된다. 즉, `xcom_pull_by_return(xcom_push_by_return()) ` = `xcom_push_by_return() >> xcom_pull_by_return() `\n        * **Task 데커레이터 사용시** custom 함수가 return을 하게 되면 자동으로 xcom에 data가 올라가게 된다.\n\n        * (2안)\n        ```markdown    \n\n        @task(task_id='xcom_push_by_return')\n        def xcom_push_return(**kwargs):\n            transaction_value = 'status Good'\n            return transaction_value\n            # return 한 값은 자동으로 xcom에 key='return_value', task_ids=task_id 로 저장됨\n\n        @task(task_id='xcom_pull_by_return')\n        def xcom_pull_return_by_method(**kwargs):\n            ti = kwargs['ti']\n            pull_value = ti.xcom_pull(key='return_value', task_ids='xcom_push_by_return')\n            # ti.xcom_pull()을 이용하여 return 한 값을 꺼낼 때는 key를 명시하지 않아도 됨. (자동으로 key=return_value 를 찾음)\n            # task_ids='xcom_push_by_return' return한 Task가 여러개 있을 때는 task_ids 를 지정\n            print(pull_value)\n\n        xcom_push_by_return() >> xcom_pull_by_return() # 2안에서는 task flow를 명시적으로 적어줘야함.\n        ```\n* DAG Full Example\n    * 1안 DAG Full Exmaple\n        ```markdown\n        from airflow import DAG\n        import pendulum\n        import datetime\n        from airflow.decorators import task\n\n        with DAG(\n            dag_id=\"dags_python_with_xcom_eg2\",\n            schedule=\"30 6 * * *\",\n            start_date=pendulum.datetime(2023, 3, 1, tz=\"Asia/Seoul\"),\n            catchup=False\n        ) as dag:\n\n            @task(task_id='python_xcom_push_by_return')\n            def xcom_push_result(**kwargs):\n                return 'Success'\n\n\n            @task(task_id='python_xcom_pull_1')\n            def xcom_pull_1(**kwargs):\n                ti = kwargs['ti']\n                value1 = ti.xcom_pull(task_ids='python_xcom_push_by_return')\n                print('xcom_pull 메서드로 직접 찾은 리턴 값:' + value1)\n\n            @task(task_id='python_xcom_pull_2')\n            def xcom_pull_2(status, **kwargs):\n                print('함수 입력값으로 받은 값:' + status)\n\n\n            python_xcom_push_by_return = xcom_push_result() \n            # airflow의 task decorator가 쓰였기 때문에 python_xcom_push_by_return에 \n            # 단순한 'Sucess' 스트링이 할당되는게 아니라 decorator object가 할당된다.\n            xcom_pull_2(python_xcom_push_by_return)\n            python_xcom_push_by_return >> xcom_pull_1()\n\n            # 암묵적인 task flow는\n            # xcom_push_result >>[xcom_pull_2, xcom_pull_1] 형태임\n        ```\n    * 2안 DAG Full Example\n        ```markdown\n        from airflow import DAG\n        import pendulum\n        import datetime\n        from airflow.decorators import task\n\n        with DAG(\n            dag_id=\"dags_python_with_xcom_eg1\",\n            schedule=\"30 6 * * *\",\n            start_date=pendulum.datetime(2023, 3, 1, tz=\"Asia/Seoul\"),\n            catchup=False\n        ) as dag:\n\n            @task(task_id='python_xcom_push_task1')\n            def xcom_push1(**kwargs):\n                ti = kwargs['ti']\n                ti.xcom_push(key=\"result1\", value=\"value_1\")\n                ti.xcom_push(key=\"result2\", value=[1,2,3])\n\n            @task(task_id='python_xcom_push_task2')\n            def xcom_push2(**kwargs):\n                ti = kwargs['ti']\n                ti.xcom_push(key=\"result1\", value=\"value_2\") \n                # python_xcom_push_task1의 key값은 같지만 value는 다름\n                ti.xcom_push(key=\"result2\", value=[1,2,3,4])\n\n            @task(task_id='python_xcom_pull_task')\n            def xcom_pull(**kwargs):\n                ti = kwargs['ti']\n                value1 = ti.xcom_pull(key=\"result1\")\n                value2 = ti.xcom_pull(key=\"result2\", task_ids='python_xcom_push_task1')\n                print(value1)\n                print(value2)\n\n\n            xcom_push1() >> xcom_push2() >> xcom_pull()\n            # xcom_pull()에서 key값이 result1으로만 명시되었기 때문에 value1에는 xcom_push2()의 'value_2'가 들어감    \n        ```\n* airflow web service에서 log 대신 xcom을 사용해 결과값을 확인\n\n## Summary \n\n* Xcom push 방법\n    * ti.xcom_push 명시적 사용\n    * 함수 return\n* Xcom pull 방법\n    * ti.xcom_pull 명시적 사용\n    * return 값을 input으로 사용\n\n# Bash 오퍼레이터 With Xcom\n\n## Bash 오퍼레이터에서 Xcom 사용하기 \n\n* Bash 오퍼레이터에서 template 문법을 쓸수 있는 parameters: env, bash_command\n* template 이용하여 push/pull\n\n```markdown\nbash_push = BashOperator(\n    task_id='bash_push',\n    bash_command=\"echo START && \"\n                \"echo XCOM_PUSHED \"\n                \"{{ ti.xcom_push(key='bash_pushed',value='first_bash_message') }} && \"\n                \"echo COMPLETE\" \n                # bash 같은 경우엔 출력하는 값이 return값으로 간주됨. \n                # 위의 경우와 같이 여러 출력물(&&로 연결된 3개의 출력물)이 있을 경우 마지막 출력물(COMPLETE)이 자동으로 return_value 에 저장됨\n)\nbash_pull = BashOperator(\n    task_id='bash_pull',\n    env={'PUSHED_VALUE':\"{{ ti.xcom_pull(key='bash_pushed') }}\",\n        'RETURN_VALUE':\"{{ ti.xcom_pull(task_ids='bash_push') }}\"}, \n        # env 는 key: value 형태로 데이터를 받음\n        # task_ids 만 지정하면 key='return_value' 를 의미함\n        # RETURN_VALUE에 'complete'이 들어감\n    bash_command=\"echo $PUSHED_VALUE && echo $RETURN_VALUE \",\n    do_xcom_push=False \n    # bash_command에서 출력되는 \"echo $PUSHED_VALUE && echo $RETURN_VALUE \"의 \n    # 출력문을 자동으로 xcom에 올리지 말라는 의미\n)\n\n```\n\n* Dags Full Example\n\n```markdown\nfrom airflow import DAG\nimport pendulum\nimport datetime\nfrom airflow.operators.bash import BashOperator\n\nwith DAG(\n    dag_id=\"dags_bash_with_xcom\",\n    schedule=\"10 0 * * *\",\n    start_date=pendulum.datetime(2023, 3, 1, tz=\"Asia/Seoul\"),\n    catchup=False\n) as dag:\n    bash_push = BashOperator(\n    task_id='bash_push',\n    bash_command=\"echo START && \"\n                 \"echo XCOM_PUSHED \"\n                 \"{{ ti.xcom_push(key='bash_pushed',value='first_bash_message') }} && \"\n                 \"echo COMPLETE\"\n    )\n\n    bash_pull = BashOperator(\n        task_id='bash_pull',\n        env={'PUSHED_VALUE':\"{{ ti.xcom_pull(key='bash_pushed') }}\",\n            'RETURN_VALUE':\"{{ ti.xcom_pull(task_ids='bash_push') }}\"},\n        bash_command=\"echo $PUSHED_VALUE && echo $RETURN_VALUE \",\n        do_xcom_push=False\n    )\n\n    bash_push >> bash_pull\n\n```\n\n## Summary\n\n* Bash_command에 의해 출력된 값은 자동으로 return_value로 저장된다 (마지막 출력 문장만)\n* return_value를 꺼낼 때는 xcom_pull에서 task_ids 값만 줘도 된다.\n* 키가 지정된 xcom 값을 꺼낼 때는 key 값만 줘도 된다 (단, 다른 task에서 동일 key로 push 하지 않았을 때만)\n\n# Python & Bash 오퍼레이터 With Xcom\n\n## Python $\\rightarrow$ Bash 오퍼레이터 Xcom 전달\n\n```markdown\n@task task_id =='python push'\ndef python_push_xcom\n    result_dict = {'status':' Good','data':[1,2,3],'options_cnt': 100}\n    return result_dict\nbash_pull = BashOperator(\n    task_id='bash_pull',\n    env={\n        'STATUS': '{{ti.xcom_pull(task ids=\"python push\")[\"status\"]}}', #task_ids만 있으면 위의 파이썬 함수에서 리턴값을 자동으로 받음\n        'DATA': '{{ti.xcom_pull(task ids=\"python push\")[\"data\"]}}',\n        'OPTIONS_CNT': '{{ti.xcom_pull(task_ids=\"python_push\")[\"options_cnt\"]}}'\n    },\n    bash_command = 'echo $STATUS && echo $DATA && echo $OPTIONS_CNT'\n)\n \npython_push_xcom() >> bash_pull\n```\n## Bash $\\rightarrow$ Python 오퍼레이터 Xcom 전달\n\n```markdown\nbash_push = BashOperator(\ntask_id ='bash_push',\nbash_command='echo PUSH_START'\n    '{{ti.xcom_push(key=\"bash_pushed\",value=200) }}&& 'echo PUSH_COMPLETE'\n)\n\n@task(task_id =='python_pull')\ndef python_pull_xcom(**kwargs): \n    ti = kwargs ['ti']\n    status_value= ti.xcom_pull(key ='bash_pushed')\n    return_value= ti.xcom_pull(task_ids ='bash_push')\n    print('status_value:'+ str (status_value))\n    print('return_value:'+ return_value)\n    bash_push>> python_pull_xcom()\n```\n\n* DAG Full Example\n\n```markdown\nfrom airflow import DAG\nimport pendulum\nfrom airflow.decorators import task\nfrom airflow.operators.bash import BashOperator\n\nwith DAG(\n    dag_id=\"dags_bash_python_with_xcom\",\n    schedule=\"30 9 * * *\",\n    start_date=pendulum.datetime(2023, 4, 1, tz=\"Asia/Seoul\"),\n    catchup=False\n) as dag:\n\n    @task(task_id='python_push')\n    def python_push_xcom():\n        result_dict = {'status':'Good','data':[1,2,3],'options_cnt':100}\n        return result_dict\n\n    bash_pull = BashOperator(\n        task_id='bash_pull',\n        env={\n            'STATUS':'{{ti.xcom_pull(task_ids=\"python_push\")[\"status\"]}}',\n            'DATA':'{{ti.xcom_pull(task_ids=\"python_push\")[\"data\"]}}',\n            'OPTIONS_CNT':'{{ti.xcom_pull(task_ids=\"python_push\")[\"options_cnt\"]}}'\n\n        },\n        bash_command='echo $STATUS && echo $DATA && echo $OPTIONS_CNT'\n    )\n    python_push_xcom() >> bash_pull\n\n    bash_push = BashOperator(\n    task_id='bash_push',\n    bash_command='echo PUSH_START '\n                 '{{ti.xcom_push(key=\"bash_pushed\",value=200)}} && '\n                 'echo PUSH_COMPLETE'\n    )\n\n    @task(task_id='python_pull')\n    def python_pull_xcom(**kwargs):\n        ti = kwargs['ti']\n        status_value = ti.xcom_pull(key='bash_pushed')\n        return_value = ti.xcom_pull(task_ids='bash_push')\n        print('status_value:' + str(status_value))\n        print('return_value:' + return_value)\n\n    bash_push >> python_pull_xcom()\n\n```\n\n# Python & Email 오퍼레이터 With Xcom\n\n## Python → Email 오퍼레이터 Xcom 전달\n\n* Email 오퍼레이터를 이용하여 Xcom을 받아와야함\n* Email 오퍼레이터는 어떤 파라미터에 Template를 쓸 수 있는가?\n* 파라미터\n    * to\n    * subject\n    * html_content\n    * files\n    * cc\n    * bcc\n    * nime_subtype\n    * mime_charset\n    * custom_headers\n\n```markdown\n@task(task_id='something_task') # python operator를 task decorator로 만듦\ndef some_logic(**kwargs):\n    from random import choice \n    #choice 함수: list, tuple, string 중 아무 값이나 꺼낼 수 있게 해주는 함수\n    return choice(['Success','Fail']) # either Success or Fail is return됨\nsend_email = EmailOperator(\n    task_id='send_email',\n    to='hjkim_sun@naver.com',\n    subject='{{ data_interval_end.in_timezone(\"Asia/Seoul\") | ds }} some_logic 처리결과',\n    html_content='{{ data_interval_end.in_timezone(\"Asia/Seoul\") | ds }} 처리 결과는 <br> \\ {{ti.xcom_pull(task_ids=\"something_task\")}} 했습니다 <br>'\n)\n\n```\n\n* DAG Full Example\n\n```markdown\nfrom airflow import DAG\nimport pendulum\nimport datetime\nfrom airflow.decorators import task\nfrom airflow.operators.email import EmailOperator\n\nwith DAG(\n    dag_id=\"dags_python_email_operator\",\n    schedule=\"0 8 1 * *\",\n    start_date=pendulum.datetime(2023, 3, 1, tz=\"Asia/Seoul\"),\n    catchup=False\n) as dag:\n    \n    @task(task_id='something_task')\n    def some_logic(**kwargs):\n        from random import choice \n        return choice(['Success','Fail'])\n\n\n    send_email = EmailOperator(\n        task_id='send_email',\n        to='hjkim_sun@naver.com',\n        subject='{{ data_interval_end.in_timezone(\"Asia/Seoul\") | ds }} some_logic 처리결과',\n        html_content='{{ data_interval_end.in_timezone(\"Asia/Seoul\") | ds }} 처리 결과는 <br> \\\n                    {{ti.xcom_pull(task_ids=\"something_task\")}} 했습니다 <br>'\n    )\n\n    some_logic() >> send_email\n\n\n```\n\n# 전역변수 Variable 이용하기\n\n* Xcom: 특정 DAG, 특정 schedule 에 수행되는 Task 간에만 공유 (즉, 어제 수행한 task와 오늘 수행한 task간에는 xcom을 사용하여 데이터 공유가 안됨)\n* variable: 모든 DAG 이 공유할 수 있는 전역 변수 사용\n* Variable 등록하기\n    * airflow web service에서 전역 변수 등록 가능\n        * airflow web service의 Admin >> Variables >> Plus Button >> Key, Val, Description 작성 >> save\n    * 전역 변수 사용하기: 실제 Variable 의 Key, Value 값은 메타 DB 에 저장됨 (variable 테이블)\n        1. 방법1) Variable 라이브러리 이용 , 파이썬 문법을 이용해 미리 가져오기\n        ```markdown\n        from airflow operators bash import BashOperator\n        from airflow models import Variable \n\n        var_value = Variable.get('sample_key')\n        bash_var_1= BashOperator(\n            task_id = \"bash_var_1\",\n            bash_command = f \"echo variable:{var_value}\"\" \n        )\n\n        ```\n        * 스케줄러의 주기적 DAG 파싱시 Variable.get 개수만큼 DB 연결을 일으켜 불필요한 부하 발생 스케줄러 과부하 원인 중 하나 (권고하지 않음)\n            * 주기적으로 아래 코드를 실행함\n            ```markdown\n            from airflow models import Variable \n            var_value = Variable.get('sample_key')\n            ```\n        2. 방법2) Jinja 템플릿 이용 , 오퍼레이터 내부에서 가져오기 (권고)\n            * 스케쥴러는 Operator 안에 작성된 내용은 parsing 및 실행해보지 않음\n        ```markdown\n        from airflow operators bash import BashOperator\n        bash_var_2= BashOperator(\n            task_id=\"bash_var_2\",\n            bash_command= f \"echo variable: {{var.value.sample_key}}\"\n        )\n        ```\n        \n* 그런데 이 전역변수는 언제 , 어떻게 쓰면 좋을까\n    * 협업 환경에서 표준화된 dag 을 만들기 위해 주로 사용. 개발자들마다 서로 다르게 사용하지 말아야할 주로 상수 (CONST) 로 지정해서 사용할 변수들 셋팅할 때 사용\n    * 예) base_sh_dir = /opt/airflow/plugins/shell. shell file 의 위치를 고정\n    * 예) base_file_dir = /opt/airflow/plugins/files\n    * 예) email, Alert 메시지를 받을 담당자의 email 주소 정보\n* Dags Full Example\n\n```markdown\n\nfrom airflow import DAG\nimport pendulum\nfrom airflow.operators.bash import BashOperator\nfrom airflow.models import Variable\n\nwith DAG(\n    dag_id=\"dags_bash_with_variable\",\n    schedule=\"10 9 * * *\",\n    start_date=pendulum.datetime(2023, 4, 1, tz=\"Asia/Seoul\"),\n    catchup=False\n) as dag:\n    \n    #권고하지 않음\n    var_value = Variable.get(\"sample_key\")\n    bash_var_1 = BashOperator(\n    task_id=\"bash_var_1\",\n    bash_command=f\"echo variable:{var_value}\"\n    )\n\n    #권고함\n    bash_var_2 = BashOperator(\n    task_id=\"bash_var_2\",\n    bash_command=\"echo variable:{{var.value.sample_key}}\"\n    )\n```\n:::\n</div>\n\n<div class=\"tab-pane fade\" id=\"English\" role=\"tabpanel\" aria-labelledby=\"English-tab\">\n\n::: {#English .tab-pane .fade role=\"tabpanel\" aria-labelledby=\"English-tab\"}\n\n:::\n\n\n</div>\n\n# Go to Blog Content List\n\n[Blog Content List](../../content_list.qmd)  \n[Engineering Content List](../../Engineering/guide_map/index.qmd)","srcMarkdownNoYaml":"\n\n<ul class=\"nav nav-pills\" id=\"language-tab\" role=\"tablist\">\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link active\" id=\"Korean-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#Korean\" type=\"button\" role=\"tab\" aria-controls=\"Korean\" aria-selected=\"true\">Korean</button>\n  </li>\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link\" id=\"English-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#English\" type=\"button\" role=\"tab\" aria-controls=\"knitr\" aria-selected=\"false\">English</button>\n  </li>\n\n<div class=\"tab-content\" id=\"language-tabcontent\">\n\n<div class=\"tab-pane fade  show active\" id=\"Korean\" role=\"tabpanel\" aria-labelledby=\"Korean-tab\">\n\n::: {#Korean .tab-pane .fade .show .active role=\"tabpanel\" aria-labelledby=\"Korean-tab\"}\n\n# Xcom Definition\n\n* Xcom stands for Cross Communication.\n* Airflow DAG 안 Task 간 작은 데이터 (or Message) 공유를 위해 사용되는 기술 (1개의 Dag 안에 있는 task끼리만 data 공유)\n    * 예를 들어, Task1의 수행 중 내용이나 결과를 Task2에서 사용 또는 입력으로 주고 싶은 경우\n    * task1 은 push, task2는 pull과 같은 tasks간 데이터 공유에 유용\n* 주로 작은 규모의 데이터 공유를 위해 사용\n    * Xcom 내용은 meta DB의 Xcom 테이블에 값이 저장됨    \n    * 1GB 이상의 대용량 데이터 공유를 위해서는 외부 솔루션 사용 필요 (AWS의 S3, GCP의 GCS, HDFS (Hadoop File System) 등)\n\n# Python 오퍼레이터 With Xcom\n\n## Python 오퍼레이터에서 Xcom 사용하기\n\n* 크게 두 가지 방법으로 Xcom 사용 가능\n    1. **kwargs에 존재하는 ti (task_instance) 객체 활용\n    \n    ```markdown\n    @task(task_id='python_xcom_push_task')\n    def xcom_push(**kwargs):\n        ti = kwargs['ti']\n        ti.xcom_push(key=\"result1\", value=\"value_1\") \n        ti.xcom_push(key=\"result2\", value=[1,2,3])\n        #xcom_push: xcom에다가 data를 올릴 수 있음\n        #data를 올릴 때는 key:value 형태로 올리기\n        #template 변수에서 task_instance 라는 객체를 얻을 수 있으며 task_instance 객체가 가진 xcom_push 메서드를 활용할 수 있음\n\n    @task(task_id='python_xcom_pull_task')\n    def xcom_pull(**kwargs):\n        ti = kwargs['ti']\n        value_key1 = ti.xcom_pull(key=\"result1\") # value_1이 value_key1에 저장됨\n        value_key2 = ti.xcom_pull(key=\"result2\",\n        task_ids='python_xcom_push_task') # [1,2,3]이 value_key2에 저장됨\n        #xcom_pull: xcom으로부터 data를 내려 받을 수 있음\n        #data를 올릴 때는 key:value 형태로 올리기\n        print(value_key1)\n        print(value_key2)\n    ```\n    * xcome_pull()을 할때 key값만 줘도 되고 key값과 task_ids값을 둘다 줘도 된다.\n        * key값만 줘도 될때\n            * xcom_push를 한 task가 1개 밖에 없을 때 사용 가능\n            * 혹은, key값이 중복될 때 xcom_push를 한 task가 여러 개 있을 때도 사용 가능한데 가장 마지막 (최신) task의 key값을 호출 한다.\n            * 만약, key값이 중복이 되지 않는 다면 key값만으로도 data를 내려 받을 수 있다.\n        * key값과 task_ids둘다 줘야할 때\n            * key값이 중복되는 xcom_push를 한 task가 여러 개 있을 때 \n            선택적으로 원하는 task의 data를 가지고 오고 싶으면 해당 task의 task_ids를 명시적으로 적어줘야한다.\n        * 예를 들어,\n        ```markdown\n        # 5개의 tasks 존재하는\n        # task1: xcom_push(key='result1'...)\n        # task2: xcom_push(key='result1'...)\n        # task3: xcom_push(key='result2'...)\n        # task4: xcom_pull(key='result1'...)\n        # task5: xcom_pull(key='result1',task_ids=...)\n        ```\n        * task4가 수행이 될때 task1의 xcom을 가져우는게 아니라 가장 최신에 수행된 task2의 xcom을 가져오게 된다.\n        * task1의 xcom을 가지고 오고 싶을땐 task5와 같이 task1의 task_id를 task5의 task_ids에 명시해주면 된다.\n        * 가장 안전한 방법은 task의 key값과 task_ids를 명시적으로 적어주는 것이다. 아니면 tasks의 key값을 절대 중복이 되지않도록 적어주는 것이다.\n\n    2. 파이썬 함수의 return 값 활용 \n        * (1안)\n        ```markdown\n        @task(task_id='xcom_push_by_return')\n        def xcom_push_by_return(**kwargs):\n            transaction_value = 'status Good'\n            return transaction_value\n        @task(task_id='xcom_pull_by_return')\n        def xcom_pull_by_return(status, **kwargs):\n            print(status)\n        xcom_pull_by_return(xcom_push_by_return()) \n        ```\n        * xcom을 이용한 task의 flow 정해주는 또 다른 방식\n        * 암묵적인 task의 순서: xcom_push_by_return() >> xcom_pull_by_return()\n        * 위의 스크립트에서 xcom_pull() 또는 xcom_push()가 명시적으로 쓰이지진 않았지만 airflow에서는 **Task 데커레이터 사용시** 함수 입력/출력 관계만으로 Task flow 정의가 된다. 즉, `xcom_pull_by_return(xcom_push_by_return()) ` = `xcom_push_by_return() >> xcom_pull_by_return() `\n        * **Task 데커레이터 사용시** custom 함수가 return을 하게 되면 자동으로 xcom에 data가 올라가게 된다.\n\n        * (2안)\n        ```markdown    \n\n        @task(task_id='xcom_push_by_return')\n        def xcom_push_return(**kwargs):\n            transaction_value = 'status Good'\n            return transaction_value\n            # return 한 값은 자동으로 xcom에 key='return_value', task_ids=task_id 로 저장됨\n\n        @task(task_id='xcom_pull_by_return')\n        def xcom_pull_return_by_method(**kwargs):\n            ti = kwargs['ti']\n            pull_value = ti.xcom_pull(key='return_value', task_ids='xcom_push_by_return')\n            # ti.xcom_pull()을 이용하여 return 한 값을 꺼낼 때는 key를 명시하지 않아도 됨. (자동으로 key=return_value 를 찾음)\n            # task_ids='xcom_push_by_return' return한 Task가 여러개 있을 때는 task_ids 를 지정\n            print(pull_value)\n\n        xcom_push_by_return() >> xcom_pull_by_return() # 2안에서는 task flow를 명시적으로 적어줘야함.\n        ```\n* DAG Full Example\n    * 1안 DAG Full Exmaple\n        ```markdown\n        from airflow import DAG\n        import pendulum\n        import datetime\n        from airflow.decorators import task\n\n        with DAG(\n            dag_id=\"dags_python_with_xcom_eg2\",\n            schedule=\"30 6 * * *\",\n            start_date=pendulum.datetime(2023, 3, 1, tz=\"Asia/Seoul\"),\n            catchup=False\n        ) as dag:\n\n            @task(task_id='python_xcom_push_by_return')\n            def xcom_push_result(**kwargs):\n                return 'Success'\n\n\n            @task(task_id='python_xcom_pull_1')\n            def xcom_pull_1(**kwargs):\n                ti = kwargs['ti']\n                value1 = ti.xcom_pull(task_ids='python_xcom_push_by_return')\n                print('xcom_pull 메서드로 직접 찾은 리턴 값:' + value1)\n\n            @task(task_id='python_xcom_pull_2')\n            def xcom_pull_2(status, **kwargs):\n                print('함수 입력값으로 받은 값:' + status)\n\n\n            python_xcom_push_by_return = xcom_push_result() \n            # airflow의 task decorator가 쓰였기 때문에 python_xcom_push_by_return에 \n            # 단순한 'Sucess' 스트링이 할당되는게 아니라 decorator object가 할당된다.\n            xcom_pull_2(python_xcom_push_by_return)\n            python_xcom_push_by_return >> xcom_pull_1()\n\n            # 암묵적인 task flow는\n            # xcom_push_result >>[xcom_pull_2, xcom_pull_1] 형태임\n        ```\n    * 2안 DAG Full Example\n        ```markdown\n        from airflow import DAG\n        import pendulum\n        import datetime\n        from airflow.decorators import task\n\n        with DAG(\n            dag_id=\"dags_python_with_xcom_eg1\",\n            schedule=\"30 6 * * *\",\n            start_date=pendulum.datetime(2023, 3, 1, tz=\"Asia/Seoul\"),\n            catchup=False\n        ) as dag:\n\n            @task(task_id='python_xcom_push_task1')\n            def xcom_push1(**kwargs):\n                ti = kwargs['ti']\n                ti.xcom_push(key=\"result1\", value=\"value_1\")\n                ti.xcom_push(key=\"result2\", value=[1,2,3])\n\n            @task(task_id='python_xcom_push_task2')\n            def xcom_push2(**kwargs):\n                ti = kwargs['ti']\n                ti.xcom_push(key=\"result1\", value=\"value_2\") \n                # python_xcom_push_task1의 key값은 같지만 value는 다름\n                ti.xcom_push(key=\"result2\", value=[1,2,3,4])\n\n            @task(task_id='python_xcom_pull_task')\n            def xcom_pull(**kwargs):\n                ti = kwargs['ti']\n                value1 = ti.xcom_pull(key=\"result1\")\n                value2 = ti.xcom_pull(key=\"result2\", task_ids='python_xcom_push_task1')\n                print(value1)\n                print(value2)\n\n\n            xcom_push1() >> xcom_push2() >> xcom_pull()\n            # xcom_pull()에서 key값이 result1으로만 명시되었기 때문에 value1에는 xcom_push2()의 'value_2'가 들어감    \n        ```\n* airflow web service에서 log 대신 xcom을 사용해 결과값을 확인\n\n## Summary \n\n* Xcom push 방법\n    * ti.xcom_push 명시적 사용\n    * 함수 return\n* Xcom pull 방법\n    * ti.xcom_pull 명시적 사용\n    * return 값을 input으로 사용\n\n# Bash 오퍼레이터 With Xcom\n\n## Bash 오퍼레이터에서 Xcom 사용하기 \n\n* Bash 오퍼레이터에서 template 문법을 쓸수 있는 parameters: env, bash_command\n* template 이용하여 push/pull\n\n```markdown\nbash_push = BashOperator(\n    task_id='bash_push',\n    bash_command=\"echo START && \"\n                \"echo XCOM_PUSHED \"\n                \"{{ ti.xcom_push(key='bash_pushed',value='first_bash_message') }} && \"\n                \"echo COMPLETE\" \n                # bash 같은 경우엔 출력하는 값이 return값으로 간주됨. \n                # 위의 경우와 같이 여러 출력물(&&로 연결된 3개의 출력물)이 있을 경우 마지막 출력물(COMPLETE)이 자동으로 return_value 에 저장됨\n)\nbash_pull = BashOperator(\n    task_id='bash_pull',\n    env={'PUSHED_VALUE':\"{{ ti.xcom_pull(key='bash_pushed') }}\",\n        'RETURN_VALUE':\"{{ ti.xcom_pull(task_ids='bash_push') }}\"}, \n        # env 는 key: value 형태로 데이터를 받음\n        # task_ids 만 지정하면 key='return_value' 를 의미함\n        # RETURN_VALUE에 'complete'이 들어감\n    bash_command=\"echo $PUSHED_VALUE && echo $RETURN_VALUE \",\n    do_xcom_push=False \n    # bash_command에서 출력되는 \"echo $PUSHED_VALUE && echo $RETURN_VALUE \"의 \n    # 출력문을 자동으로 xcom에 올리지 말라는 의미\n)\n\n```\n\n* Dags Full Example\n\n```markdown\nfrom airflow import DAG\nimport pendulum\nimport datetime\nfrom airflow.operators.bash import BashOperator\n\nwith DAG(\n    dag_id=\"dags_bash_with_xcom\",\n    schedule=\"10 0 * * *\",\n    start_date=pendulum.datetime(2023, 3, 1, tz=\"Asia/Seoul\"),\n    catchup=False\n) as dag:\n    bash_push = BashOperator(\n    task_id='bash_push',\n    bash_command=\"echo START && \"\n                 \"echo XCOM_PUSHED \"\n                 \"{{ ti.xcom_push(key='bash_pushed',value='first_bash_message') }} && \"\n                 \"echo COMPLETE\"\n    )\n\n    bash_pull = BashOperator(\n        task_id='bash_pull',\n        env={'PUSHED_VALUE':\"{{ ti.xcom_pull(key='bash_pushed') }}\",\n            'RETURN_VALUE':\"{{ ti.xcom_pull(task_ids='bash_push') }}\"},\n        bash_command=\"echo $PUSHED_VALUE && echo $RETURN_VALUE \",\n        do_xcom_push=False\n    )\n\n    bash_push >> bash_pull\n\n```\n\n## Summary\n\n* Bash_command에 의해 출력된 값은 자동으로 return_value로 저장된다 (마지막 출력 문장만)\n* return_value를 꺼낼 때는 xcom_pull에서 task_ids 값만 줘도 된다.\n* 키가 지정된 xcom 값을 꺼낼 때는 key 값만 줘도 된다 (단, 다른 task에서 동일 key로 push 하지 않았을 때만)\n\n# Python & Bash 오퍼레이터 With Xcom\n\n## Python $\\rightarrow$ Bash 오퍼레이터 Xcom 전달\n\n```markdown\n@task task_id =='python push'\ndef python_push_xcom\n    result_dict = {'status':' Good','data':[1,2,3],'options_cnt': 100}\n    return result_dict\nbash_pull = BashOperator(\n    task_id='bash_pull',\n    env={\n        'STATUS': '{{ti.xcom_pull(task ids=\"python push\")[\"status\"]}}', #task_ids만 있으면 위의 파이썬 함수에서 리턴값을 자동으로 받음\n        'DATA': '{{ti.xcom_pull(task ids=\"python push\")[\"data\"]}}',\n        'OPTIONS_CNT': '{{ti.xcom_pull(task_ids=\"python_push\")[\"options_cnt\"]}}'\n    },\n    bash_command = 'echo $STATUS && echo $DATA && echo $OPTIONS_CNT'\n)\n \npython_push_xcom() >> bash_pull\n```\n## Bash $\\rightarrow$ Python 오퍼레이터 Xcom 전달\n\n```markdown\nbash_push = BashOperator(\ntask_id ='bash_push',\nbash_command='echo PUSH_START'\n    '{{ti.xcom_push(key=\"bash_pushed\",value=200) }}&& 'echo PUSH_COMPLETE'\n)\n\n@task(task_id =='python_pull')\ndef python_pull_xcom(**kwargs): \n    ti = kwargs ['ti']\n    status_value= ti.xcom_pull(key ='bash_pushed')\n    return_value= ti.xcom_pull(task_ids ='bash_push')\n    print('status_value:'+ str (status_value))\n    print('return_value:'+ return_value)\n    bash_push>> python_pull_xcom()\n```\n\n* DAG Full Example\n\n```markdown\nfrom airflow import DAG\nimport pendulum\nfrom airflow.decorators import task\nfrom airflow.operators.bash import BashOperator\n\nwith DAG(\n    dag_id=\"dags_bash_python_with_xcom\",\n    schedule=\"30 9 * * *\",\n    start_date=pendulum.datetime(2023, 4, 1, tz=\"Asia/Seoul\"),\n    catchup=False\n) as dag:\n\n    @task(task_id='python_push')\n    def python_push_xcom():\n        result_dict = {'status':'Good','data':[1,2,3],'options_cnt':100}\n        return result_dict\n\n    bash_pull = BashOperator(\n        task_id='bash_pull',\n        env={\n            'STATUS':'{{ti.xcom_pull(task_ids=\"python_push\")[\"status\"]}}',\n            'DATA':'{{ti.xcom_pull(task_ids=\"python_push\")[\"data\"]}}',\n            'OPTIONS_CNT':'{{ti.xcom_pull(task_ids=\"python_push\")[\"options_cnt\"]}}'\n\n        },\n        bash_command='echo $STATUS && echo $DATA && echo $OPTIONS_CNT'\n    )\n    python_push_xcom() >> bash_pull\n\n    bash_push = BashOperator(\n    task_id='bash_push',\n    bash_command='echo PUSH_START '\n                 '{{ti.xcom_push(key=\"bash_pushed\",value=200)}} && '\n                 'echo PUSH_COMPLETE'\n    )\n\n    @task(task_id='python_pull')\n    def python_pull_xcom(**kwargs):\n        ti = kwargs['ti']\n        status_value = ti.xcom_pull(key='bash_pushed')\n        return_value = ti.xcom_pull(task_ids='bash_push')\n        print('status_value:' + str(status_value))\n        print('return_value:' + return_value)\n\n    bash_push >> python_pull_xcom()\n\n```\n\n# Python & Email 오퍼레이터 With Xcom\n\n## Python → Email 오퍼레이터 Xcom 전달\n\n* Email 오퍼레이터를 이용하여 Xcom을 받아와야함\n* Email 오퍼레이터는 어떤 파라미터에 Template를 쓸 수 있는가?\n* 파라미터\n    * to\n    * subject\n    * html_content\n    * files\n    * cc\n    * bcc\n    * nime_subtype\n    * mime_charset\n    * custom_headers\n\n```markdown\n@task(task_id='something_task') # python operator를 task decorator로 만듦\ndef some_logic(**kwargs):\n    from random import choice \n    #choice 함수: list, tuple, string 중 아무 값이나 꺼낼 수 있게 해주는 함수\n    return choice(['Success','Fail']) # either Success or Fail is return됨\nsend_email = EmailOperator(\n    task_id='send_email',\n    to='hjkim_sun@naver.com',\n    subject='{{ data_interval_end.in_timezone(\"Asia/Seoul\") | ds }} some_logic 처리결과',\n    html_content='{{ data_interval_end.in_timezone(\"Asia/Seoul\") | ds }} 처리 결과는 <br> \\ {{ti.xcom_pull(task_ids=\"something_task\")}} 했습니다 <br>'\n)\n\n```\n\n* DAG Full Example\n\n```markdown\nfrom airflow import DAG\nimport pendulum\nimport datetime\nfrom airflow.decorators import task\nfrom airflow.operators.email import EmailOperator\n\nwith DAG(\n    dag_id=\"dags_python_email_operator\",\n    schedule=\"0 8 1 * *\",\n    start_date=pendulum.datetime(2023, 3, 1, tz=\"Asia/Seoul\"),\n    catchup=False\n) as dag:\n    \n    @task(task_id='something_task')\n    def some_logic(**kwargs):\n        from random import choice \n        return choice(['Success','Fail'])\n\n\n    send_email = EmailOperator(\n        task_id='send_email',\n        to='hjkim_sun@naver.com',\n        subject='{{ data_interval_end.in_timezone(\"Asia/Seoul\") | ds }} some_logic 처리결과',\n        html_content='{{ data_interval_end.in_timezone(\"Asia/Seoul\") | ds }} 처리 결과는 <br> \\\n                    {{ti.xcom_pull(task_ids=\"something_task\")}} 했습니다 <br>'\n    )\n\n    some_logic() >> send_email\n\n\n```\n\n# 전역변수 Variable 이용하기\n\n* Xcom: 특정 DAG, 특정 schedule 에 수행되는 Task 간에만 공유 (즉, 어제 수행한 task와 오늘 수행한 task간에는 xcom을 사용하여 데이터 공유가 안됨)\n* variable: 모든 DAG 이 공유할 수 있는 전역 변수 사용\n* Variable 등록하기\n    * airflow web service에서 전역 변수 등록 가능\n        * airflow web service의 Admin >> Variables >> Plus Button >> Key, Val, Description 작성 >> save\n    * 전역 변수 사용하기: 실제 Variable 의 Key, Value 값은 메타 DB 에 저장됨 (variable 테이블)\n        1. 방법1) Variable 라이브러리 이용 , 파이썬 문법을 이용해 미리 가져오기\n        ```markdown\n        from airflow operators bash import BashOperator\n        from airflow models import Variable \n\n        var_value = Variable.get('sample_key')\n        bash_var_1= BashOperator(\n            task_id = \"bash_var_1\",\n            bash_command = f \"echo variable:{var_value}\"\" \n        )\n\n        ```\n        * 스케줄러의 주기적 DAG 파싱시 Variable.get 개수만큼 DB 연결을 일으켜 불필요한 부하 발생 스케줄러 과부하 원인 중 하나 (권고하지 않음)\n            * 주기적으로 아래 코드를 실행함\n            ```markdown\n            from airflow models import Variable \n            var_value = Variable.get('sample_key')\n            ```\n        2. 방법2) Jinja 템플릿 이용 , 오퍼레이터 내부에서 가져오기 (권고)\n            * 스케쥴러는 Operator 안에 작성된 내용은 parsing 및 실행해보지 않음\n        ```markdown\n        from airflow operators bash import BashOperator\n        bash_var_2= BashOperator(\n            task_id=\"bash_var_2\",\n            bash_command= f \"echo variable: {{var.value.sample_key}}\"\n        )\n        ```\n        \n* 그런데 이 전역변수는 언제 , 어떻게 쓰면 좋을까\n    * 협업 환경에서 표준화된 dag 을 만들기 위해 주로 사용. 개발자들마다 서로 다르게 사용하지 말아야할 주로 상수 (CONST) 로 지정해서 사용할 변수들 셋팅할 때 사용\n    * 예) base_sh_dir = /opt/airflow/plugins/shell. shell file 의 위치를 고정\n    * 예) base_file_dir = /opt/airflow/plugins/files\n    * 예) email, Alert 메시지를 받을 담당자의 email 주소 정보\n* Dags Full Example\n\n```markdown\n\nfrom airflow import DAG\nimport pendulum\nfrom airflow.operators.bash import BashOperator\nfrom airflow.models import Variable\n\nwith DAG(\n    dag_id=\"dags_bash_with_variable\",\n    schedule=\"10 9 * * *\",\n    start_date=pendulum.datetime(2023, 4, 1, tz=\"Asia/Seoul\"),\n    catchup=False\n) as dag:\n    \n    #권고하지 않음\n    var_value = Variable.get(\"sample_key\")\n    bash_var_1 = BashOperator(\n    task_id=\"bash_var_1\",\n    bash_command=f\"echo variable:{var_value}\"\n    )\n\n    #권고함\n    bash_var_2 = BashOperator(\n    task_id=\"bash_var_2\",\n    bash_command=\"echo variable:{{var.value.sample_key}}\"\n    )\n```\n:::\n</div>\n\n<div class=\"tab-pane fade\" id=\"English\" role=\"tabpanel\" aria-labelledby=\"English-tab\">\n\n::: {#English .tab-pane .fade role=\"tabpanel\" aria-labelledby=\"English-tab\"}\n\n:::\n\n\n</div>\n\n# Go to Blog Content List\n\n[Blog Content List](../../content_list.qmd)  \n[Engineering Content List](../../Engineering/guide_map/index.qmd)"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"github","css":["../../../../../styles.css"],"toc":true,"toc-depth":3,"number-sections":true,"include-in-header":[{"text":"<style>\n.custom-footer { \n  text-align: center; \n  font-size: 0.8em; \n  color: #666; \n  margin-top: 2rem; \n}\n</style>\n"}],"include-after-body":["../../../../../js.html","../../../signup.html"],"output-file":"06.data_share.html"},"language":{"toc-title-document":"목차","toc-title-website":"목차","related-formats-title":"기타 형식","related-notebooks-title":"Notebooks","source-notebooks-prefix":"원천","other-links-title":"기타 링크","code-links-title":"코드 링크","launch-dev-container-title":"Dev 컨테이너 실행","launch-binder-title":"랜치 Binder","article-notebook-label":"기사 노트북","notebook-preview-download":"노트북 다운로드","notebook-preview-download-src":"소스 다운로드","notebook-preview-back":"기사로 돌아가기","manuscript-meca-bundle":"MECA 아카이브","section-title-abstract":"초록","section-title-appendices":"부록","section-title-footnotes":"각주","section-title-references":"참고문헌","section-title-reuse":"라이센스","section-title-copyright":"저작권","section-title-citation":"인용","appendix-attribution-cite-as":"인용방법","appendix-attribution-bibtex":"BibTeX 인용:","title-block-author-single":"저자","title-block-author-plural":"저자","title-block-affiliation-single":"소속","title-block-affiliation-plural":"소속","title-block-published":"공개","title-block-modified":"Modified","title-block-keywords":"키워드","callout-tip-title":"힌트","callout-note-title":"노트","callout-warning-title":"경고","callout-important-title":"중요","callout-caution-title":"주의","code-summary":"코드","code-tools-menu-caption":"코드","code-tools-show-all-code":"전체 코드 표시","code-tools-hide-all-code":"전체 코드 숨기기","code-tools-view-source":"소스 코드 표시","code-tools-source-code":"소스 코드","tools-share":"Share","tools-download":"Download","code-line":"선","code-lines":"윤곽","copy-button-tooltip":"클립보드 복사","copy-button-tooltip-success":"복사완료!","repo-action-links-edit":"편집","repo-action-links-source":"소스코드 보기","repo-action-links-issue":"이슈 보고","back-to-top":"맨 위로","search-no-results-text":"일치 없음","search-matching-documents-text":"일치된 문서","search-copy-link-title":"검색 링크 복사","search-hide-matches-text":"추가 검색 결과 숨기기","search-more-match-text":"추가 검색결과","search-more-matches-text":"추가 검색결과","search-clear-button-title":"제거","search-text-placeholder":"","search-detached-cancel-button-title":"취소","search-submit-button-title":"검색","search-label":"검색","toggle-section":"토글 섹션","toggle-sidebar":"사이드바 전환","toggle-dark-mode":"다크 모드 전환","toggle-reader-mode":"리더 모드 전환","toggle-navigation":"탐색 전환","crossref-fig-title":"그림","crossref-tbl-title":"표","crossref-lst-title":"목록","crossref-thm-title":"정리","crossref-lem-title":"보조정리","crossref-cor-title":"따름정리","crossref-prp-title":"명제","crossref-cnj-title":"추측","crossref-def-title":"정의","crossref-exm-title":"보기","crossref-exr-title":"예제","crossref-ch-prefix":"장","crossref-apx-prefix":"부록","crossref-sec-prefix":"섹션","crossref-eq-prefix":"방정식","crossref-lof-title":"그림 목록","crossref-lot-title":"표 목록","crossref-lol-title":"코드 목록","environment-proof-title":"증명","environment-remark-title":"주석","environment-solution-title":"해답","listing-page-order-by":"정렬","listing-page-order-by-default":"디폴트","listing-page-order-by-date-asc":"날짜(오름차순)","listing-page-order-by-date-desc":"날짜(내림차순)","listing-page-order-by-number-desc":"페이지 번호(내림차순)","listing-page-order-by-number-asc":"페이지 번호(오름차순)","listing-page-field-date":"날짜","listing-page-field-title":"제목","listing-page-field-description":"설명","listing-page-field-author":"저자","listing-page-field-filename":"파일명","listing-page-field-filemodified":"갱신일","listing-page-field-subtitle":"부제목","listing-page-field-readingtime":"읽기 시간","listing-page-field-wordcount":"단어 수","listing-page-field-categories":"분류","listing-page-minutes-compact":"{0} 분","listing-page-category-all":"전체","listing-page-no-matches":"일치 없음","listing-page-words":"{0} 단어"},"metadata":{"lang":"ko","fig-responsive":true,"quarto-version":"1.4.543","theme":{"light":["cosmo","../../../../../theme.scss"],"dark":["cosmo","../../../../../theme-dark.scss"]},"code-copy":true,"grid":{"sidebar-width":"200px","body-width":"1200px","margin-width":"200px"},"comments":{"giscus":{"repo":"kmink3225/blog","category":"Blog"},"utterances":{"repo":"./docs/comments"}},"title-block-banner":"#EDF3F9","title-block-banner-color":"black","toc-location":"right","open-graph":true,"twitter-card":true,"search":true,"date-format":"YYYY년 MM월 DD일","title":"Data Share","subtitle":"Python Operator with Xcom, Bash Operator with Xcom, Xcom between Python Operator and Bash Operator, Xcom between Python Operator and Email Operator, Global Share Variable","description":"template\n","categories":["Engineering"],"author":"Kwangmin Kim","date":"05/01/2023","draft":false,"page-layout":"full"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}