{"title":"Python Abstract Base Classes (ABC)","markdown":{"yaml":{"title":"Python Abstract Base Classes (ABC)","subtitle":"Defining Interfaces and Abstract Classes","description":"파이썬 추상 베이스 클래스(Abstract Base Classes, ABC)는 클래스의 인터페이스를 정의하고 강제하는 메커니즘이다. abc 모듈을 사용하여 추상 메서드와 추상 프로퍼티를 정의할 수 있으며, 이를 통해 객체지향 프로그래밍의 다형성과 인터페이스 계약을 보장할 수 있다. ABC를 사용하면 코드의 구조를 명확히 하고 런타임에 인터페이스 준수 여부를 검증할 수 있다.\n","categories":["Engineering","Python"],"author":"Kwangmin Kim","date":"07/02/2023","draft":false,"format":{"html":{"toc":true,"number-sections":true,"code-fold":true,"page-layout":"full"}},"execute":{"warning":false,"message":false,"eval":false,"echo":true}},"headingText":"Python Abstract Base Classes (ABC)","containsRefs":false,"markdown":"\n\n\n* 파이썬 추상 베이스 클래스(Abstract Base Classes, ABC)는 클래스의 인터페이스를 정의하고 강제하는 메커니즘이다. \n* ABC를 사용하면 객체지향 프로그래밍에서 중요한 개념인 다형성과 인터페이스 계약을 파이썬에서도 명확하게 구현할 수 있다.\n\n### ABC의 정의\n\n* 추상 베이스 클래스는 직접 인스턴스화할 수 없는 클래스로, 하나 이상의 추상 메서드를 포함한다. \n* 추상 메서드는 메서드의 시그니처만 정의하고 구현은 하지 않으며, 이를 상속받는 하위 클래스에서 반드시 구현해야 한다.\n\n### abc 모듈 소개\n\n* 파이썬에서는 `abc` 모듈을 통해 추상 베이스 클래스를 정의할 수 있다:\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        \"\"\"도형의 면적을 계산한다\"\"\"\n        pass\n    \n    @abstractmethod\n    def perimeter(self):\n        \"\"\"도형의 둘레를 계산한다\"\"\"\n        pass\n\n# 추상 클래스는 직접 인스턴스화할 수 없다\n# shape = Shape()  # TypeError: Can't instantiate abstract class Shape\n```\n\n### 기본 ABC 구현 예제\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        \"\"\"도형의 면적을 계산한다\"\"\"\n        pass\n    \n    @abstractmethod\n    def perimeter(self):\n        \"\"\"도형의 둘레를 계산한다\"\"\"\n        pass\n    \n    # 구체적인 메서드도 포함할 수 있다\n    def describe(self):\n        return f\"이 도형의 면적은 {self.area()}이고 둘레는 {self.perimeter()}입니다.\"\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return 3.14159 * self.radius ** 2\n    \n    def perimeter(self):\n        return 2 * 3.14159 * self.radius\n\n# 사용 예제\nrect = Rectangle(5, 3)\ncircle = Circle(4)\n\nprint(rect.describe())  # 이 도형의 면적은 15이고 둘레는 16입니다.\nprint(circle.describe())  # 이 도형의 면적은 50.26544이고 둘레는 25.13272입니다.\n```\n\n### abstractmethod 데코레이터\n\n* 추상 메서드는 `@abstractmethod` 데코레이터를 사용하여 정의한다.\n* 하위 클래스에서 반드시 구현해야 하는 메서드를 지정\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def make_sound(self):\n        pass\n\n# 올바른 구현\nclass Dog(Animal):\n    def make_sound(self):\n        return \"멍멍\"\n\n# 잘못된 구현 (구현 누락)\nclass Cat(Animal):\n    pass  # make_sound 구현하지 않음\n\ndog = Dog()  # 정상 동작\n# cat = Cat()  # TypeError 발생!\n```\n\n\n### 추상 프로퍼티 (Abstract Properties)\n\n* 프로퍼티(property)는 메서드를 마치 속성(attribute)처럼 접근할 수 있게 만드는 기능\n* 추상 프로퍼티를 정의하여 하위 클래스에서 특정 속성을 구현하도록 강제할 수 있다\n\n```python\n# @property 없이\nclass WithoutProperty:\n    def __init__(self):\n        self._speed = 100\n    \n    def get_max_speed(self):\n        return self._speed\n\ncar1 = WithoutProperty()\nprint(car1.get_max_speed())  # 메서드 호출 - 괄호 필요\n\n# @property 사용\nclass WithProperty:\n    def __init__(self):\n        self._speed = 100\n    \n    @property\n    def max_speed(self):\n        return self._speed\n\ncar2 = WithProperty()\nprint(car2.max_speed)  # 속성처럼 접근 - 괄호 불필요\n```\n\n### property + abstractmethod 데코레이터\n\n* 속성처럼 접근 가능하면서도 반드시 구현해야 하는 요소\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Vehicle(ABC):\n    @property\n    @abstractmethod\n    def max_speed(self):\n        pass\n    \n    @property\n    @abstractmethod\n    def fuel_type(self):\n        pass\n    \n    @abstractmethod\n    def start_engine(self):\n        pass\n\nclass Car(Vehicle):\n    def __init__(self, brand, model):\n        self.brand = brand\n        self.model = model\n        self._max_speed = 200\n        self._fuel_type = \"gasoline\"\n    \n    @property\n    def max_speed(self):\n        return self._max_speed\n    \n    @property\n    def fuel_type(self):\n        return self._fuel_type\n    \n    def start_engine(self):\n        return f\"{self.brand} {self.model}의 엔진이 시작되었습니다.\"\n\nclass ElectricCar(Vehicle):\n    def __init__(self, brand, model, battery_capacity):\n        self.brand = brand\n        self.model = model\n        self.battery_capacity = battery_capacity\n        self._max_speed = 180\n        self._fuel_type = \"electric\"\n    \n    @property\n    def max_speed(self):\n        return self._max_speed\n    \n    @property\n    def fuel_type(self):\n        return self._fuel_type\n    \n    def start_engine(self):\n        return f\"{self.brand} {self.model}의 전기 모터가 시작되었습니다.\"\n\n# 사용 예제\ncar = Car(\"현대\", \"소나타\")\nelectric_car = ElectricCar(\"테슬라\", \"모델 3\", 75)\n\nprint(f\"연료 타입: {car.fuel_type}, 최고 속도: {car.max_speed}km/h\")\n# 연료 타입: gasoline, 최고 속도: 200km/h\nprint(car.start_engine())\n# 현대 소나타의 엔진이 시작되었습니다.\n\nprint(f\"연료 타입: {electric_car.fuel_type}, 최고 속도: {electric_car.max_speed}km/h\")\n# 연료 타입: electric, 최고 속도: 180km/h\nprint(electric_car.start_engine())\n# 테슬라 모델 3의 전기 모터가 시작되었습니다.\n```\n\n### 추상 클래스 메서드와 정적 메서드\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass DatabaseConnection(ABC):\n    @abstractmethod\n    def connect(self):\n        pass\n    \n    @abstractmethod\n    def disconnect(self):\n        pass\n    \n    @abstractclassmethod\n    def get_driver_name(cls):\n        pass\n    \n    @abstractstaticmethod\n    def validate_connection_string(connection_string):\n        pass\n\nclass MySQLConnection(DatabaseConnection):\n    def __init__(self, host, database):\n        self.host = host\n        self.database = database\n    \n    def connect(self):\n        return f\"MySQL 데이터베이스 {self.database}에 연결되었습니다.\"\n    \n    def disconnect(self):\n        return f\"MySQL 데이터베이스 {self.database}와의 연결이 종료되었습니다.\"\n    \n    @classmethod\n    def get_driver_name(cls):\n        return \"MySQL Driver\"\n    \n    @staticmethod\n    def validate_connection_string(connection_string):\n        return \"mysql://\" in connection_string\n\nmysql_conn = MySQLConnection(\"localhost\", \"my_database\")\nprint(mysql_conn.connect())\n# MySQL 데이터베이스 my_database에 연결되었습니다.\nprint(mysql_conn.disconnect())\n# MySQL 데이터베이스 my_database와의 연결이 종료되었습니다.\nprint(mysql_conn.get_driver_name())\n# MySQL Driver\nprint(mysql_conn.validate_connection_string(\"mysql://localhost/my_database\"))\n# True  \n```\n\n### 실용적인 ABC 예제\n\n#### 데이터 처리 파이프라인\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Any, List\n\nclass DataProcessor(ABC):\n    @abstractmethod\n    def load_data(self, source: str) -> Any:\n        \"\"\"데이터를 로드한다\"\"\"\n        pass\n    \n    @abstractmethod\n    def process_data(self, data: Any) -> Any:\n        \"\"\"데이터를 처리한다\"\"\"\n        pass\n    \n    @abstractmethod\n    def save_data(self, data: Any, destination: str) -> bool:\n        \"\"\"처리된 데이터를 저장한다\"\"\"\n        pass\n    \n    # 템플릿 메서드 패턴\n    def run_pipeline(self, source: str, destination: str):\n        print(\"데이터 파이프라인 시작\")\n        data = self.load_data(source)\n        processed_data = self.process_data(data)\n        success = self.save_data(processed_data, destination)\n        print(f\"데이터 파이프라인 완료: {'성공' if success else '실패'}\")\n        return success\n\nclass CSVProcessor(DataProcessor):\n    def load_data(self, source: str) -> List[dict]:\n        print(f\"CSV 파일 {source}를 로드합니다\")\n        # 실제로는 pandas나 csv 모듈을 사용\n        return [{\"name\": \"홍길동\", \"age\": 30}, {\"name\": \"김철수\", \"age\": 25}]\n    \n    def process_data(self, data: List[dict]) -> List[dict]:\n        print(\"CSV 데이터를 처리합니다\")\n        # 나이에 1을 더하는 처리\n        for record in data:\n            record[\"age\"] += 1\n        return data\n    \n    def save_data(self, data: List[dict], destination: str) -> bool:\n        print(f\"처리된 데이터를 {destination}에 저장합니다\")\n        print(f\"저장된 데이터: {data}\")\n        return True\n\nclass JSONProcessor(DataProcessor):\n    def load_data(self, source: str) -> dict:\n        print(f\"JSON 파일 {source}를 로드합니다\")\n        return {\"users\": [{\"name\": \"이영희\", \"score\": 85}]}\n    \n    def process_data(self, data: dict) -> dict:\n        print(\"JSON 데이터를 처리합니다\")\n        # 점수에 10을 더하는 처리\n        for user in data[\"users\"]:\n            user[\"score\"] += 10\n        return data\n    \n    def save_data(self, data: dict, destination: str) -> bool:\n        print(f\"처리된 데이터를 {destination}에 저장합니다\")\n        print(f\"저장된 데이터: {data}\")\n        return True\n\n# 사용 예제\ncsv_processor = CSVProcessor()\njson_processor = JSONProcessor()\n\ncsv_processor.run_pipeline(\"input.csv\", \"output.csv\")\nprint(\"=\" * 50)\njson_processor.run_pipeline(\"input.json\", \"output.json\")\n# 데이터 파이프라인 시작\n# CSV 파일 input.csv를 로드합니다\n# CSV 데이터를 처리합니다\n# 처리된 데이터를 output.csv에 저장합니다\n# 데이터 파이프라인 완료: 성공\n# ==================================================\n# JSON 파일 input.json를 로드합니다\n# JSON 데이터를 처리합니다\n# 처리된 데이터를 output.json에 저장합니다\n# 데이터 파이프라인 완료: 성공\n```\n\n#### 알림 시스템\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any\n\nclass NotificationSender(ABC):\n    @abstractmethod\n    def send_notification(self, recipient: str, message: str, **kwargs) -> bool:\n        \"\"\"알림을 발송한다\"\"\"\n        pass\n    \n    @abstractmethod\n    def validate_recipient(self, recipient: str) -> bool:\n        \"\"\"수신자 정보가 유효한지 검증한다\"\"\"\n        pass\n    \n    def send_with_validation(self, recipient: str, message: str, **kwargs) -> bool:\n        if not self.validate_recipient(recipient):\n            print(f\"유효하지 않은 수신자: {recipient}\")\n            return False\n        \n        return self.send_notification(recipient, message, **kwargs)\n\nclass EmailSender(NotificationSender):\n    def send_notification(self, recipient: str, message: str, **kwargs) -> bool:\n        subject = kwargs.get(\"subject\", \"알림\")\n        print(f\"이메일 발송: {recipient}\")\n        print(f\"제목: {subject}\")\n        print(f\"내용: {message}\")\n        return True\n    \n    def validate_recipient(self, recipient: str) -> bool:\n        return \"@\" in recipient and \".\" in recipient\n\nclass SMSSender(NotificationSender):\n    def send_notification(self, recipient: str, message: str, **kwargs) -> bool:\n        print(f\"SMS 발송: {recipient}\")\n        print(f\"내용: {message}\")\n        return True\n    \n    def validate_recipient(self, recipient: str) -> bool:\n        return recipient.isdigit() and len(recipient) >= 10\n\nclass PushNotificationSender(NotificationSender):\n    def send_notification(self, recipient: str, message: str, **kwargs) -> bool:\n        title = kwargs.get(\"title\", \"푸시 알림\")\n        print(f\"푸시 알림 발송: {recipient}\")\n        print(f\"제목: {title}\")\n        print(f\"내용: {message}\")\n        return True\n    \n    def validate_recipient(self, recipient: str) -> bool:\n        return len(recipient) > 10  # 디바이스 토큰 길이 검증\n\n# 알림 매니저 클래스\nclass NotificationManager:\n    def __init__(self):\n        self.senders: Dict[str, NotificationSender] = {}\n    \n    def register_sender(self, name: str, sender: NotificationSender):\n        self.senders[name] = sender\n    \n    def send_notification(self, sender_type: str, recipient: str, message: str, **kwargs):\n        if sender_type not in self.senders:\n            print(f\"알 수 없는 발송자 타입: {sender_type}\")\n            return False\n        \n        sender = self.senders[sender_type]\n        return sender.send_with_validation(recipient, message, **kwargs)\n\n# 사용 예제\nmanager = NotificationManager()\nmanager.register_sender(\"email\", EmailSender())\nmanager.register_sender(\"sms\", SMSSender())\nmanager.register_sender(\"push\", PushNotificationSender())\n\n# 다양한 방식으로 알림 발송\nmanager.send_notification(\"email\", \"user@example.com\", \"환영합니다!\", subject=\"회원가입 완료\")\nmanager.send_notification(\"sms\", \"01012345678\", \"인증 코드: 123456\")\nmanager.send_notification(\"push\", \"device_token_12345\", \"새로운 메시지가 있습니다\", title=\"메시지 알림\")\n# 이메일 발송: user@example.com\n# 제목: 회원가입 완료\n# 내용: 환영합니다!\n# SMS 발송: 01012345678\n# 내용: 인증 코드: 123456\n# 푸시 알림 발송: device_token_12345\n# 제목: 메시지 알림\n# 내용: 새로운 메시지가 있습니다\n```\n\n### isinstance()와 ABC\n\nABC는 `isinstance()` 및 `issubclass()` 함수와 함께 사용하여 타입 검증에 활용할 수 있다:\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Drawable(ABC):\n    @abstractmethod\n    def draw(self):\n        pass\n\nclass Circle(Drawable):\n    def draw(self):\n        return \"원을 그립니다\"\n\nclass Square(Drawable):\n    def draw(self):\n        return \"사각형을 그립니다\"\n\ndef render_shape(shape):\n    if isinstance(shape, Drawable):\n        return shape.draw()\n    else:\n        raise TypeError(\"Drawable 객체가 아닙니다\")\n\n# 사용 예제\ncircle = Circle()\nsquare = Square()\n\nprint(render_shape(circle))  # 원을 그립니다\nprint(render_shape(square))  # 사각형을 그립니다\n\n# 타입 검증\nprint(isinstance(circle, Drawable))  # True\nprint(issubclass(Circle, Drawable))  # True\n```\n\n### ABC의 장점\n\n1. **인터페이스 강제**: 하위 클래스에서 반드시 구현해야 할 메서드를 명확히 정의\n2. **코드 문서화**: 클래스의 의도와 계약을 명확히 표현\n3. **런타임 검증**: 인터페이스 준수 여부를 런타임에 검증\n4. **다형성 지원**: 동일한 인터페이스를 구현하는 다양한 클래스들의 일관된 사용\n5. **설계 개선**: 객체지향 설계 원칙을 강제하여 더 나은 코드 구조 유도\n\n### ABC 사용 시 고려사항\n\n1. **복잡성**: 간단한 프로젝트에서는 과도한 추상화가 될 수 있음\n2. **성능**: 추상화 레이어 추가로 인한 약간의 성능 오버헤드\n3. **학습 곡선**: 초보자에게는 개념 이해가 어려울 수 있음\n\n## 결론\n\n파이썬 추상 베이스 클래스(ABC)는 객체지향 프로그래밍의 인터페이스와 다형성을 구현하는 강력한 도구다. 클래스의 계약을 명확히 정의하고 강제함으로써 코드의 구조를 개선하고 유지보수성을 높일 수 있다. 특히 큰 프로젝트나 팀 개발에서 일관된 인터페이스를 유지하고 싶을 때 매우 유용하다. ABC를 적절히 활용하면 더 견고하고 확장 가능한 파이썬 애플리케이션을 개발할 수 있다.\n\n","srcMarkdownNoYaml":"\n\n## Python Abstract Base Classes (ABC)\n\n* 파이썬 추상 베이스 클래스(Abstract Base Classes, ABC)는 클래스의 인터페이스를 정의하고 강제하는 메커니즘이다. \n* ABC를 사용하면 객체지향 프로그래밍에서 중요한 개념인 다형성과 인터페이스 계약을 파이썬에서도 명확하게 구현할 수 있다.\n\n### ABC의 정의\n\n* 추상 베이스 클래스는 직접 인스턴스화할 수 없는 클래스로, 하나 이상의 추상 메서드를 포함한다. \n* 추상 메서드는 메서드의 시그니처만 정의하고 구현은 하지 않으며, 이를 상속받는 하위 클래스에서 반드시 구현해야 한다.\n\n### abc 모듈 소개\n\n* 파이썬에서는 `abc` 모듈을 통해 추상 베이스 클래스를 정의할 수 있다:\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        \"\"\"도형의 면적을 계산한다\"\"\"\n        pass\n    \n    @abstractmethod\n    def perimeter(self):\n        \"\"\"도형의 둘레를 계산한다\"\"\"\n        pass\n\n# 추상 클래스는 직접 인스턴스화할 수 없다\n# shape = Shape()  # TypeError: Can't instantiate abstract class Shape\n```\n\n### 기본 ABC 구현 예제\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        \"\"\"도형의 면적을 계산한다\"\"\"\n        pass\n    \n    @abstractmethod\n    def perimeter(self):\n        \"\"\"도형의 둘레를 계산한다\"\"\"\n        pass\n    \n    # 구체적인 메서드도 포함할 수 있다\n    def describe(self):\n        return f\"이 도형의 면적은 {self.area()}이고 둘레는 {self.perimeter()}입니다.\"\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return 3.14159 * self.radius ** 2\n    \n    def perimeter(self):\n        return 2 * 3.14159 * self.radius\n\n# 사용 예제\nrect = Rectangle(5, 3)\ncircle = Circle(4)\n\nprint(rect.describe())  # 이 도형의 면적은 15이고 둘레는 16입니다.\nprint(circle.describe())  # 이 도형의 면적은 50.26544이고 둘레는 25.13272입니다.\n```\n\n### abstractmethod 데코레이터\n\n* 추상 메서드는 `@abstractmethod` 데코레이터를 사용하여 정의한다.\n* 하위 클래스에서 반드시 구현해야 하는 메서드를 지정\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def make_sound(self):\n        pass\n\n# 올바른 구현\nclass Dog(Animal):\n    def make_sound(self):\n        return \"멍멍\"\n\n# 잘못된 구현 (구현 누락)\nclass Cat(Animal):\n    pass  # make_sound 구현하지 않음\n\ndog = Dog()  # 정상 동작\n# cat = Cat()  # TypeError 발생!\n```\n\n\n### 추상 프로퍼티 (Abstract Properties)\n\n* 프로퍼티(property)는 메서드를 마치 속성(attribute)처럼 접근할 수 있게 만드는 기능\n* 추상 프로퍼티를 정의하여 하위 클래스에서 특정 속성을 구현하도록 강제할 수 있다\n\n```python\n# @property 없이\nclass WithoutProperty:\n    def __init__(self):\n        self._speed = 100\n    \n    def get_max_speed(self):\n        return self._speed\n\ncar1 = WithoutProperty()\nprint(car1.get_max_speed())  # 메서드 호출 - 괄호 필요\n\n# @property 사용\nclass WithProperty:\n    def __init__(self):\n        self._speed = 100\n    \n    @property\n    def max_speed(self):\n        return self._speed\n\ncar2 = WithProperty()\nprint(car2.max_speed)  # 속성처럼 접근 - 괄호 불필요\n```\n\n### property + abstractmethod 데코레이터\n\n* 속성처럼 접근 가능하면서도 반드시 구현해야 하는 요소\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Vehicle(ABC):\n    @property\n    @abstractmethod\n    def max_speed(self):\n        pass\n    \n    @property\n    @abstractmethod\n    def fuel_type(self):\n        pass\n    \n    @abstractmethod\n    def start_engine(self):\n        pass\n\nclass Car(Vehicle):\n    def __init__(self, brand, model):\n        self.brand = brand\n        self.model = model\n        self._max_speed = 200\n        self._fuel_type = \"gasoline\"\n    \n    @property\n    def max_speed(self):\n        return self._max_speed\n    \n    @property\n    def fuel_type(self):\n        return self._fuel_type\n    \n    def start_engine(self):\n        return f\"{self.brand} {self.model}의 엔진이 시작되었습니다.\"\n\nclass ElectricCar(Vehicle):\n    def __init__(self, brand, model, battery_capacity):\n        self.brand = brand\n        self.model = model\n        self.battery_capacity = battery_capacity\n        self._max_speed = 180\n        self._fuel_type = \"electric\"\n    \n    @property\n    def max_speed(self):\n        return self._max_speed\n    \n    @property\n    def fuel_type(self):\n        return self._fuel_type\n    \n    def start_engine(self):\n        return f\"{self.brand} {self.model}의 전기 모터가 시작되었습니다.\"\n\n# 사용 예제\ncar = Car(\"현대\", \"소나타\")\nelectric_car = ElectricCar(\"테슬라\", \"모델 3\", 75)\n\nprint(f\"연료 타입: {car.fuel_type}, 최고 속도: {car.max_speed}km/h\")\n# 연료 타입: gasoline, 최고 속도: 200km/h\nprint(car.start_engine())\n# 현대 소나타의 엔진이 시작되었습니다.\n\nprint(f\"연료 타입: {electric_car.fuel_type}, 최고 속도: {electric_car.max_speed}km/h\")\n# 연료 타입: electric, 최고 속도: 180km/h\nprint(electric_car.start_engine())\n# 테슬라 모델 3의 전기 모터가 시작되었습니다.\n```\n\n### 추상 클래스 메서드와 정적 메서드\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass DatabaseConnection(ABC):\n    @abstractmethod\n    def connect(self):\n        pass\n    \n    @abstractmethod\n    def disconnect(self):\n        pass\n    \n    @abstractclassmethod\n    def get_driver_name(cls):\n        pass\n    \n    @abstractstaticmethod\n    def validate_connection_string(connection_string):\n        pass\n\nclass MySQLConnection(DatabaseConnection):\n    def __init__(self, host, database):\n        self.host = host\n        self.database = database\n    \n    def connect(self):\n        return f\"MySQL 데이터베이스 {self.database}에 연결되었습니다.\"\n    \n    def disconnect(self):\n        return f\"MySQL 데이터베이스 {self.database}와의 연결이 종료되었습니다.\"\n    \n    @classmethod\n    def get_driver_name(cls):\n        return \"MySQL Driver\"\n    \n    @staticmethod\n    def validate_connection_string(connection_string):\n        return \"mysql://\" in connection_string\n\nmysql_conn = MySQLConnection(\"localhost\", \"my_database\")\nprint(mysql_conn.connect())\n# MySQL 데이터베이스 my_database에 연결되었습니다.\nprint(mysql_conn.disconnect())\n# MySQL 데이터베이스 my_database와의 연결이 종료되었습니다.\nprint(mysql_conn.get_driver_name())\n# MySQL Driver\nprint(mysql_conn.validate_connection_string(\"mysql://localhost/my_database\"))\n# True  \n```\n\n### 실용적인 ABC 예제\n\n#### 데이터 처리 파이프라인\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Any, List\n\nclass DataProcessor(ABC):\n    @abstractmethod\n    def load_data(self, source: str) -> Any:\n        \"\"\"데이터를 로드한다\"\"\"\n        pass\n    \n    @abstractmethod\n    def process_data(self, data: Any) -> Any:\n        \"\"\"데이터를 처리한다\"\"\"\n        pass\n    \n    @abstractmethod\n    def save_data(self, data: Any, destination: str) -> bool:\n        \"\"\"처리된 데이터를 저장한다\"\"\"\n        pass\n    \n    # 템플릿 메서드 패턴\n    def run_pipeline(self, source: str, destination: str):\n        print(\"데이터 파이프라인 시작\")\n        data = self.load_data(source)\n        processed_data = self.process_data(data)\n        success = self.save_data(processed_data, destination)\n        print(f\"데이터 파이프라인 완료: {'성공' if success else '실패'}\")\n        return success\n\nclass CSVProcessor(DataProcessor):\n    def load_data(self, source: str) -> List[dict]:\n        print(f\"CSV 파일 {source}를 로드합니다\")\n        # 실제로는 pandas나 csv 모듈을 사용\n        return [{\"name\": \"홍길동\", \"age\": 30}, {\"name\": \"김철수\", \"age\": 25}]\n    \n    def process_data(self, data: List[dict]) -> List[dict]:\n        print(\"CSV 데이터를 처리합니다\")\n        # 나이에 1을 더하는 처리\n        for record in data:\n            record[\"age\"] += 1\n        return data\n    \n    def save_data(self, data: List[dict], destination: str) -> bool:\n        print(f\"처리된 데이터를 {destination}에 저장합니다\")\n        print(f\"저장된 데이터: {data}\")\n        return True\n\nclass JSONProcessor(DataProcessor):\n    def load_data(self, source: str) -> dict:\n        print(f\"JSON 파일 {source}를 로드합니다\")\n        return {\"users\": [{\"name\": \"이영희\", \"score\": 85}]}\n    \n    def process_data(self, data: dict) -> dict:\n        print(\"JSON 데이터를 처리합니다\")\n        # 점수에 10을 더하는 처리\n        for user in data[\"users\"]:\n            user[\"score\"] += 10\n        return data\n    \n    def save_data(self, data: dict, destination: str) -> bool:\n        print(f\"처리된 데이터를 {destination}에 저장합니다\")\n        print(f\"저장된 데이터: {data}\")\n        return True\n\n# 사용 예제\ncsv_processor = CSVProcessor()\njson_processor = JSONProcessor()\n\ncsv_processor.run_pipeline(\"input.csv\", \"output.csv\")\nprint(\"=\" * 50)\njson_processor.run_pipeline(\"input.json\", \"output.json\")\n# 데이터 파이프라인 시작\n# CSV 파일 input.csv를 로드합니다\n# CSV 데이터를 처리합니다\n# 처리된 데이터를 output.csv에 저장합니다\n# 데이터 파이프라인 완료: 성공\n# ==================================================\n# JSON 파일 input.json를 로드합니다\n# JSON 데이터를 처리합니다\n# 처리된 데이터를 output.json에 저장합니다\n# 데이터 파이프라인 완료: 성공\n```\n\n#### 알림 시스템\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any\n\nclass NotificationSender(ABC):\n    @abstractmethod\n    def send_notification(self, recipient: str, message: str, **kwargs) -> bool:\n        \"\"\"알림을 발송한다\"\"\"\n        pass\n    \n    @abstractmethod\n    def validate_recipient(self, recipient: str) -> bool:\n        \"\"\"수신자 정보가 유효한지 검증한다\"\"\"\n        pass\n    \n    def send_with_validation(self, recipient: str, message: str, **kwargs) -> bool:\n        if not self.validate_recipient(recipient):\n            print(f\"유효하지 않은 수신자: {recipient}\")\n            return False\n        \n        return self.send_notification(recipient, message, **kwargs)\n\nclass EmailSender(NotificationSender):\n    def send_notification(self, recipient: str, message: str, **kwargs) -> bool:\n        subject = kwargs.get(\"subject\", \"알림\")\n        print(f\"이메일 발송: {recipient}\")\n        print(f\"제목: {subject}\")\n        print(f\"내용: {message}\")\n        return True\n    \n    def validate_recipient(self, recipient: str) -> bool:\n        return \"@\" in recipient and \".\" in recipient\n\nclass SMSSender(NotificationSender):\n    def send_notification(self, recipient: str, message: str, **kwargs) -> bool:\n        print(f\"SMS 발송: {recipient}\")\n        print(f\"내용: {message}\")\n        return True\n    \n    def validate_recipient(self, recipient: str) -> bool:\n        return recipient.isdigit() and len(recipient) >= 10\n\nclass PushNotificationSender(NotificationSender):\n    def send_notification(self, recipient: str, message: str, **kwargs) -> bool:\n        title = kwargs.get(\"title\", \"푸시 알림\")\n        print(f\"푸시 알림 발송: {recipient}\")\n        print(f\"제목: {title}\")\n        print(f\"내용: {message}\")\n        return True\n    \n    def validate_recipient(self, recipient: str) -> bool:\n        return len(recipient) > 10  # 디바이스 토큰 길이 검증\n\n# 알림 매니저 클래스\nclass NotificationManager:\n    def __init__(self):\n        self.senders: Dict[str, NotificationSender] = {}\n    \n    def register_sender(self, name: str, sender: NotificationSender):\n        self.senders[name] = sender\n    \n    def send_notification(self, sender_type: str, recipient: str, message: str, **kwargs):\n        if sender_type not in self.senders:\n            print(f\"알 수 없는 발송자 타입: {sender_type}\")\n            return False\n        \n        sender = self.senders[sender_type]\n        return sender.send_with_validation(recipient, message, **kwargs)\n\n# 사용 예제\nmanager = NotificationManager()\nmanager.register_sender(\"email\", EmailSender())\nmanager.register_sender(\"sms\", SMSSender())\nmanager.register_sender(\"push\", PushNotificationSender())\n\n# 다양한 방식으로 알림 발송\nmanager.send_notification(\"email\", \"user@example.com\", \"환영합니다!\", subject=\"회원가입 완료\")\nmanager.send_notification(\"sms\", \"01012345678\", \"인증 코드: 123456\")\nmanager.send_notification(\"push\", \"device_token_12345\", \"새로운 메시지가 있습니다\", title=\"메시지 알림\")\n# 이메일 발송: user@example.com\n# 제목: 회원가입 완료\n# 내용: 환영합니다!\n# SMS 발송: 01012345678\n# 내용: 인증 코드: 123456\n# 푸시 알림 발송: device_token_12345\n# 제목: 메시지 알림\n# 내용: 새로운 메시지가 있습니다\n```\n\n### isinstance()와 ABC\n\nABC는 `isinstance()` 및 `issubclass()` 함수와 함께 사용하여 타입 검증에 활용할 수 있다:\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Drawable(ABC):\n    @abstractmethod\n    def draw(self):\n        pass\n\nclass Circle(Drawable):\n    def draw(self):\n        return \"원을 그립니다\"\n\nclass Square(Drawable):\n    def draw(self):\n        return \"사각형을 그립니다\"\n\ndef render_shape(shape):\n    if isinstance(shape, Drawable):\n        return shape.draw()\n    else:\n        raise TypeError(\"Drawable 객체가 아닙니다\")\n\n# 사용 예제\ncircle = Circle()\nsquare = Square()\n\nprint(render_shape(circle))  # 원을 그립니다\nprint(render_shape(square))  # 사각형을 그립니다\n\n# 타입 검증\nprint(isinstance(circle, Drawable))  # True\nprint(issubclass(Circle, Drawable))  # True\n```\n\n### ABC의 장점\n\n1. **인터페이스 강제**: 하위 클래스에서 반드시 구현해야 할 메서드를 명확히 정의\n2. **코드 문서화**: 클래스의 의도와 계약을 명확히 표현\n3. **런타임 검증**: 인터페이스 준수 여부를 런타임에 검증\n4. **다형성 지원**: 동일한 인터페이스를 구현하는 다양한 클래스들의 일관된 사용\n5. **설계 개선**: 객체지향 설계 원칙을 강제하여 더 나은 코드 구조 유도\n\n### ABC 사용 시 고려사항\n\n1. **복잡성**: 간단한 프로젝트에서는 과도한 추상화가 될 수 있음\n2. **성능**: 추상화 레이어 추가로 인한 약간의 성능 오버헤드\n3. **학습 곡선**: 초보자에게는 개념 이해가 어려울 수 있음\n\n## 결론\n\n파이썬 추상 베이스 클래스(ABC)는 객체지향 프로그래밍의 인터페이스와 다형성을 구현하는 강력한 도구다. 클래스의 계약을 명확히 정의하고 강제함으로써 코드의 구조를 개선하고 유지보수성을 높일 수 있다. 특히 큰 프로젝트나 팀 개발에서 일관된 인터페이스를 유지하고 싶을 때 매우 유용하다. ABC를 적절히 활용하면 더 견고하고 확장 가능한 파이썬 애플리케이션을 개발할 수 있다.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"github","css":["../../../../../styles.css"],"toc":true,"toc-depth":3,"number-sections":true,"include-in-header":[{"text":"<style>\n.custom-footer { \n  text-align: center; \n  font-size: 0.8em; \n  color: #666; \n  margin-top: 2rem; \n}\n</style>\n"}],"include-after-body":["../../../../../js.html","../../../signup.html"],"output-file":"abc.html"},"language":{"toc-title-document":"목차","toc-title-website":"목차","related-formats-title":"기타 형식","related-notebooks-title":"Notebooks","source-notebooks-prefix":"원천","other-links-title":"기타 링크","code-links-title":"코드 링크","launch-dev-container-title":"Dev 컨테이너 실행","launch-binder-title":"랜치 Binder","article-notebook-label":"기사 노트북","notebook-preview-download":"노트북 다운로드","notebook-preview-download-src":"소스 다운로드","notebook-preview-back":"기사로 돌아가기","manuscript-meca-bundle":"MECA 아카이브","section-title-abstract":"초록","section-title-appendices":"부록","section-title-footnotes":"각주","section-title-references":"참고문헌","section-title-reuse":"라이센스","section-title-copyright":"저작권","section-title-citation":"인용","appendix-attribution-cite-as":"인용방법","appendix-attribution-bibtex":"BibTeX 인용:","title-block-author-single":"저자","title-block-author-plural":"저자","title-block-affiliation-single":"소속","title-block-affiliation-plural":"소속","title-block-published":"공개","title-block-modified":"Modified","title-block-keywords":"키워드","callout-tip-title":"힌트","callout-note-title":"노트","callout-warning-title":"경고","callout-important-title":"중요","callout-caution-title":"주의","code-summary":"코드","code-tools-menu-caption":"코드","code-tools-show-all-code":"전체 코드 표시","code-tools-hide-all-code":"전체 코드 숨기기","code-tools-view-source":"소스 코드 표시","code-tools-source-code":"소스 코드","tools-share":"Share","tools-download":"Download","code-line":"선","code-lines":"윤곽","copy-button-tooltip":"클립보드 복사","copy-button-tooltip-success":"복사완료!","repo-action-links-edit":"편집","repo-action-links-source":"소스코드 보기","repo-action-links-issue":"이슈 보고","back-to-top":"맨 위로","search-no-results-text":"일치 없음","search-matching-documents-text":"일치된 문서","search-copy-link-title":"검색 링크 복사","search-hide-matches-text":"추가 검색 결과 숨기기","search-more-match-text":"추가 검색결과","search-more-matches-text":"추가 검색결과","search-clear-button-title":"제거","search-text-placeholder":"","search-detached-cancel-button-title":"취소","search-submit-button-title":"검색","search-label":"검색","toggle-section":"토글 섹션","toggle-sidebar":"사이드바 전환","toggle-dark-mode":"다크 모드 전환","toggle-reader-mode":"리더 모드 전환","toggle-navigation":"탐색 전환","crossref-fig-title":"그림","crossref-tbl-title":"표","crossref-lst-title":"목록","crossref-thm-title":"정리","crossref-lem-title":"보조정리","crossref-cor-title":"따름정리","crossref-prp-title":"명제","crossref-cnj-title":"추측","crossref-def-title":"정의","crossref-exm-title":"보기","crossref-exr-title":"예제","crossref-ch-prefix":"장","crossref-apx-prefix":"부록","crossref-sec-prefix":"섹션","crossref-eq-prefix":"방정식","crossref-lof-title":"그림 목록","crossref-lot-title":"표 목록","crossref-lol-title":"코드 목록","environment-proof-title":"증명","environment-remark-title":"주석","environment-solution-title":"해답","listing-page-order-by":"정렬","listing-page-order-by-default":"디폴트","listing-page-order-by-date-asc":"날짜(오름차순)","listing-page-order-by-date-desc":"날짜(내림차순)","listing-page-order-by-number-desc":"페이지 번호(내림차순)","listing-page-order-by-number-asc":"페이지 번호(오름차순)","listing-page-field-date":"날짜","listing-page-field-title":"제목","listing-page-field-description":"설명","listing-page-field-author":"저자","listing-page-field-filename":"파일명","listing-page-field-filemodified":"갱신일","listing-page-field-subtitle":"부제목","listing-page-field-readingtime":"읽기 시간","listing-page-field-wordcount":"단어 수","listing-page-field-categories":"분류","listing-page-minutes-compact":"{0} 분","listing-page-category-all":"전체","listing-page-no-matches":"일치 없음","listing-page-words":"{0} 단어"},"metadata":{"lang":"ko","fig-responsive":true,"quarto-version":"1.4.543","theme":{"light":["cosmo","../../../../../theme.scss"],"dark":["cosmo","../../../../../theme-dark.scss"]},"code-copy":true,"grid":{"sidebar-width":"200px","body-width":"1200px","margin-width":"200px"},"comments":{"giscus":{"repo":"kmink3225/blog","category":"Blog"}},"title-block-banner":"#EDF3F9","title-block-banner-color":"black","toc-location":"right","open-graph":true,"twitter-card":true,"search":true,"date-format":"YYYY년 MM월 DD일","title":"Python Abstract Base Classes (ABC)","subtitle":"Defining Interfaces and Abstract Classes","description":"파이썬 추상 베이스 클래스(Abstract Base Classes, ABC)는 클래스의 인터페이스를 정의하고 강제하는 메커니즘이다. abc 모듈을 사용하여 추상 메서드와 추상 프로퍼티를 정의할 수 있으며, 이를 통해 객체지향 프로그래밍의 다형성과 인터페이스 계약을 보장할 수 있다. ABC를 사용하면 코드의 구조를 명확히 하고 런타임에 인터페이스 준수 여부를 검증할 수 있다.\n","categories":["Engineering","Python"],"author":"Kwangmin Kim","date":"07/02/2023","draft":false,"page-layout":"full"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}