{"title":"Git 브랜치: 개념부터 실전 전략까지","markdown":{"yaml":{"title":"Git 브랜치: 개념부터 실전 전략까지","subtitle":"코드 버전 관리의 핵심, 브랜치 다루기","description":"Git 브랜치의 개념, 주요 명령어(생성, 전환, 병합, 삭제), 원격 브랜치 관리, 충돌 해결, 다양한 브랜치 전략 및 푸시 워크플로우를 상세히 알아본다.\n","categories":["Engineering","Git"],"author":"Kwangmin Kim","date":"05/03/2023","format":{"html":{"page-layout":"full","code-fold":true,"toc":true,"number-sections":true}},"draft":false},"headingText":"Git 브랜치 개요","containsRefs":false,"markdown":"\n\n\nGit 브랜치는 프로젝트의 독립적인 작업과 효율적인 협업을 가능하게 하는 핵심 기능이다. 브랜치를 통해 여러 개발자가 동시에 다른 기능을 개발하거나 버그를 수정할 수 있으며, 코드의 안정성을 유지하면서 체계적인 코드 관리가 가능하다.\n\n## 기본 브랜치 명령어\n\nGit 브랜치 관련 주요 명령어는 다음과 같다. 이를 통해 브랜치를 생성, 확인, 전환, 병합, 삭제하는 과정을 통해 코드 관리를 체계적으로 수행할 수 있다.\n\n### 브랜치 생성\n\n새로운 기능 개발이나 버그 수정 등 독립적인 작업을 시작할 때 새로운 브랜치를 생성한다.\n\n```bash\ngit branch <branch_name>\n```\n\n예를 들어, `feature/login-page`라는 브랜치를 생성하려면 다음과 같이 입력한다.\n\n```bash\ngit branch feature/login-page\n```\n\n### 브랜치 이동 (전환)\n\n작업하려는 브랜치로 전환한다. Git 버전에 따라 `checkout` 또는 `switch` 명령어를 사용한다.\n\n```bash\n# Git version 2.23 미만\ngit checkout <branch_name>\n\n# Git version 2.23 이상\ngit switch <branch_name>\n```\n\n예를 들어, `feature/login-page` 브랜치로 이동하려면 다음과 같이 입력한다.\n\n```bash\ngit switch feature/login-page\n```\n\n### 브랜치 병합\n\n특정 브랜치에서 완료된 작업을 다른 브랜치(주로 `main` 또는 `develop`)로 통합할 때 사용한다.\n\n```bash\ngit merge <branch_name_to_merge>\n```\n\n예를 들어, `feature/login-page` 브랜치의 변경 사항을 현재 브랜치(예: `main`)로 병합하려면 먼저 `main` 브랜치로 이동한 후 다음 명령어를 실행한다.\n\n```bash\n# 1. main 브랜치로 이동 (이미 main 브랜치라면 생략 가능)\ngit switch main\n\n# 2. feature/login-page 브랜치 병합\ngit merge feature/login-page\n```\n\n### 브랜치 삭제\n\n더 이상 필요 없는 브랜치를 삭제하여 프로젝트를 깔끔하게 관리한다. 로컬 브랜치와 원격 브랜치 삭제 방법이 다르다.\n\n#### 로컬 브랜치 삭제\n\n개발자의 로컬 컴퓨터에 생성된 브랜치를 삭제한다.\n\n```bash\ngit branch -d <local_branch_name> # 병합된 브랜치 삭제\ngit branch -D <local_branch_name> # 병합되지 않은 브랜치 강제 삭제\n```\n\n예시: 로컬에서 `feature/login-page` 브랜치 삭제\n\n```bash\ngit branch -d feature/login-page\n```\n\n#### 원격 브랜치 삭제\n\nGitHub와 같은 원격 저장소에 있는 브랜치를 삭제한다.\n\n```bash\ngit push origin --delete <remote_branch_name>\n```\n\n예시: 원격에서 `feature/login-page` 브랜치 삭제\n\n```bash\ngit push origin --delete feature/login-page\n```\n\n#### 원격 브랜치 삭제 후 로컬 정리\n\n원격에서 브랜치가 삭제된 후, 로컬 저장소에도 해당 정보를 반영하고 정리할 필요가 있다.\n\n1.  **로컬에서도 해당 브랜치 삭제**: 만약 로컬에 동일한 이름의 브랜치가 있다면 직접 삭제한다.\n    ```bash\n    git branch -d <branch_name> \n    ```\n2.  **삭제된 원격 브랜치 정보 로컬 반영 (Pruning)**: 원격 저장소에서 삭제된 브랜치에 대한 참조를 로컬에서 정리한다.\n    ```bash\n    git fetch --prune \n    # 또는 git fetch -p\n    ```\n    이 명령어는 `origin/<remote_branch_name>`과 같이 더 이상 원격에 존재하지 않는 브랜치에 대한 로컬 참조를 제거한다.\n\n### 브랜치 목록 확인\n\n로컬 및 원격 브랜치 목록과 현재 상태를 확인한다.\n\n```bash\ngit branch # 로컬 브랜치 목록\ngit branch -r # 원격 브랜치 목록 (추적 브랜치)\ngit branch -a # 로컬 및 원격 브랜치를 포함한 전체 목록\ngit branch -vv # 로컬 브랜치와 연결된 업스트림(원격) 브랜치 정보를 함께 표시\n```\n\n원격 저장소의 최신 상태를 가져온 후 전체 브랜치를 확인하는 예시는 다음과 같다.\n\n```bash\ngit fetch --all # 모든 원격 저장소의 최신 상태를 가져옴\ngit branch -a   # 로컬 및 원격의 모든 브랜치를 확인함\n```\n\n## 원격 브랜치 관리\n\n### 원격 브랜치 추적 (Tracking)\n\n원격 저장소에 있는 특정 브랜치를 기반으로 로컬 브랜치를 생성하고, 해당 원격 브랜치를 추적하도록 설정한다. 이렇게 하면 `git pull`, `git push` 명령을 실행할 때 로컬 브랜치가 어떤 원격 브랜치와 통신해야 하는지 알 수 있다.\n\n```bash\n# 방법 1: 원격 브랜치와 동일한 이름으로 로컬 브랜치 생성 및 추적\ngit checkout --track origin/<remote_branch_name>\n\n# 방법 2: 다른 이름으로 로컬 브랜치 생성 및 특정 원격 브랜치 추적\ngit checkout -b <local_branch_name> origin/<remote_branch_name>\n```\n\n**설명**:\n\n*   `<local_branch_name>`: 로컬에서 생성할 새로운 브랜치 이름.\n*   `origin/<remote_branch_name>`: 추적할 원격 저장소(기본적으로 `origin`)의 브랜치 이름.\n\n**사용 예시**: 원격의 `feature/new-feature` 브랜치를 `my-new-feature`라는 로컬 브랜치로 생성하고 추적하려면 다음과 같이 한다.\n\n```bash\ngit checkout -b my-new-feature origin/feature/new-feature\n```\n\n만약 로컬 브랜치와 원격 브랜치 이름을 동일하게 하려면 다음과 같이 간단히 할 수 있다.\n\n```bash\ngit switch feature/new-feature # Git 2.23+\n# 또는 git checkout feature/new-feature\n# 위 명령어는 로컬에 feature/new-feature 브랜치가 없고, \n# 원격(origin)에만 해당 이름의 브랜치가 하나 있을 때 자동으로 추적 관계를 설정하며 로컬 브랜치를 생성한다.\n```\n\n### 업스트림 브랜치 설정 및 푸시\n\n로컬 브랜치의 변경 사항을 원격 저장소에 푸시할 때, 해당 로컬 브랜치가 어떤 원격 브랜치와 연결되어야 하는지 명시해야 한다. 이를 \"업스트림(upstream) 브랜치 설정\"이라고 한다.\n\n#### 새로운 로컬 브랜치를 처음 푸시할 때\n\n새로운 로컬 브랜치를 만들고 작업을 완료한 후 처음 원격 저장소로 푸시할 때는 업스트림 정보를 함께 설정해주는 것이 일반적이다.\n\n```bash\ngit push --set-upstream origin <local_branch_name>\n# 줄여서 git push -u origin <local_branch_name>\n```\n\n이 명령어는 다음 두 가지 작업을 수행한다:\n\n1.  로컬 브랜치 `<local_branch_name>`의 내용을 `origin` 원격 저장소에 동일한 이름의 브랜치로 푸시한다. (만약 원격에 해당 브랜치가 없다면 새로 생성된다.)\n2.  로컬 브랜치 `<local_branch_name>`이 원격 저장소 `origin`의 `<local_branch_name>` 브랜치를 추적하도록 업스트림 관계를 설정한다.\n\n**사용 예시**: `feature/submit-button` 로컬 브랜치를 원격에 푸시하고 업스트림으로 설정하려면 다음과 같이 한다.\n\n```bash\ngit push -u origin feature/submit-button\n```\n\n이렇게 한번 업스트림 관계를 설정하고 나면, 이후 해당 브랜치에서는 `git push` 와 `git pull` 명령어만으로도 Git이 자동으로 연결된 원격 브랜치와 통신한다.\n\n#### 현재 브랜치의 업스트림 연결 상태 확인\n\n```bash\ngit branch -vv\n```\n\n이 명령어를 실행하면 각 로컬 브랜치 옆에 어떤 원격 브랜치를 추적하고 있는지 (예: `[origin/main]`) 표시된다.\n\n## 충돌 해결 (Merge Conflict)\n\n브랜치를 병합하는 과정에서 동일한 파일의 같은 부분을 여러 브랜치에서 다르게 수정한 경우 \"병합 충돌(merge conflict)\"이 발생할 수 있다.\n\n충돌이 발생하면 Git은 자동으로 병합을 멈추고 개발자에게 충돌을 해결하도록 요청한다. 충돌이 발생한 파일은 다음과 같은 형태로 표시된다.\n\n```\n<<<<<<< HEAD\n현재 브랜치(예: main)의 내용\n=======\n병합하려는 브랜치(예: feature/login-page)의 내용\n>>>>>>> feature/login-page\n```\n\n**충돌 해결 과정**:\n\n1.  **충돌 파일 확인**: `git status` 명령으로 충돌이 발생한 파일 목록을 확인한다.\n2.  **충돌 내용 수정**: 해당 파일을 열어 `<<<<<<<`, `=======`, `>>>>>>>` 마커를 참고하여 원하는 최종 코드로 직접 수정한다. 마커들도 함께 제거해야 한다.\n3.  **수정된 파일 스테이징**: 충돌을 해결한 파일을 `git add` 명령으로 스테이징한다.\n    ```bash\n    git add <conflicted_file_name>\n    # 또는 모든 수정사항을 스테이징하려면: git add .\n    ```\n4.  **병합 커밋 완료**: 모든 충돌을 해결하고 파일을 스테이징한 후, `git commit` 명령으로 병합을 완료한다. (Git이 자동으로 병합 커밋 메시지를 제안해준다. 특별한 이유가 없다면 그대로 사용해도 된다.)\n    ```bash\n    git commit \n    ```\n    만약 `git merge` 명령 실행 시 `--no-ff` 옵션 없이 fast-forward 병합이 아닌 경우 자동으로 병합 커밋이 생성되므로, 충돌 해결 후 `git commit`만 실행하면 된다. 만약 `rebase` 중 충돌이 발생했다면 `git rebase --continue`를 사용한다.\n\n## 브랜치 병합 예시\n\n### 시나리오 1: `dev-yjlee5` 브랜치의 변경 사항을 `main` 브랜치로 병합하기\n\n1.  **병합 대상 브랜치(`main`)로 이동**:\n    ```bash\n    git switch main\n    ```\n2.  **원격 `dev-yjlee5` 브랜치의 최신 내용 가져오기 (선택 사항, 로컬에 최신 내용이 없다면)**:\n    ```bash\n    git fetch origin dev-yjlee5 \n    # 이 명령은 원격 브랜치의 내용을 가져와 로컬에 origin/dev-yjlee5 로 업데이트한다.\n    # 실제 병합은 로컬에 있는 브랜치를 기준으로 한다.\n    ```\n3.  **`dev-yjlee5` (또는 `origin/dev-yjlee5`)를 `main` 브랜치에 병합**:\n    ```bash\n    # 만약 dev-yjlee5가 로컬에도 있고 최신 상태라면:\n    git merge dev-yjlee5\n    \n    # 만약 로컬 dev-yjlee5 대신 원격의 최신 내용을 바로 병합하고 싶다면:\n    # (이미 fetch를 통해 origin/dev-yjlee5가 최신 상태여야 함)\n    git merge origin/dev-yjlee5 \n    ```\n4.  **충돌 해결**: 충돌 발생 시 위에서 설명한 충돌 해결 과정을 따른다.\n5.  **병합 결과 원격 저장소에 푸시**:\n    ```bash\n    git push origin main\n    ```\n\n### 시나리오 2: `main` 브랜치의 변경 사항을 `dev-yjlee5` 브랜치로 병합하기 (최신 상태 유지)\n\n1.  **작업 브랜치(`dev-yjlee5`)로 이동**:\n    ```bash\n    git switch dev-yjlee5\n    ```\n2.  **원격 `main` 브랜치의 최신 내용 가져오기**:\n    ```bash\n    git fetch origin main\n    ```\n3.  **`origin/main`을 `dev-yjlee5` 브랜치에 병합**:\n    ```bash\n    git merge origin/main\n    ```\n4.  **충돌 해결**: 충돌 발생 시 충돌 해결 과정을 따른다.\n5.  **병합 결과 원격 저장소에 푸시**:\n    ```bash\n    git push origin dev-yjlee5\n    ```\n\n\n### 작업 워크플로우\n\n#### 운영 코드 작업 및 팀 리뷰 요청\n\n```bash\n# 현재 작업 브랜치를 팀 리뷰용 브랜치로 변경\ngit switch feature/token-processor-improvements\n\n# 운영 코드 수정 (예: 8_token_analyzer/token_processor.py)\n# ... 코드 수정 ...\n\n# 변경 사항 스테이징 및 커밋\ngit add 8_token_analyzer/token_processor.py\ngit commit -m \"feat: 토큰 분석기 성능 개선\"\n\n# 원격 저장소에 푸시하여 팀원들에게 리뷰 요청\ngit push origin feature/token-processor-improvements \n```\n\n#### 개인 실험 또는 파일 백업\n\n```bash\n# 개인 작업용 브랜치로 변경\ngit switch personal/kmkim-workspace\n\n# 개인 폴더(kmkim/)에 파일 추가 또는 수정\n# ... 개인 작업 ...\n\n# 변경 사항 스테이징 및 커밋\ngit add kmkim/\ngit commit -m \"개인 작업: 새로운 아이디어 스케치 및 자료 백업\"\n\n# 원격 저장소에 푸시하여 개인 작업 내용 백업\ngit push origin personal/kmkim-workspace\n```\n\n#### 다른 장소에서 개인 작업 이어가기\n\n```bash\n# 프로젝트 클론 (처음 작업 환경을 설정하는 경우)\ngit clone https://github.com/SeegeneDevelopmentPlatform/data_standardization.git\ncd data_standardization\n\n# 개인 작업용 브랜치로 변경하여 작업 내용 복원\ngit switch personal/kmkim-workspace \n# 또는 git checkout personal/kmkim-workspace (원격에만 있다면 추적하며 생성)\n```\n이제 `kmkim/` 폴더의 개인 작업 내용을 확인하고 이어서 작업할 수 있다.\n\n## 결론\n\nGit 브랜치는 코드 버전 관리와 협업의 핵심 도구이다. 다양한 명령어를 익히고, 상황에 맞는 브랜치 전략을 수립하여 활용하면 개발 생산성을 크게 향상시키고 안정적인 프로젝트 관리를 할 수 있다.","srcMarkdownNoYaml":"\n\n## Git 브랜치 개요\n\nGit 브랜치는 프로젝트의 독립적인 작업과 효율적인 협업을 가능하게 하는 핵심 기능이다. 브랜치를 통해 여러 개발자가 동시에 다른 기능을 개발하거나 버그를 수정할 수 있으며, 코드의 안정성을 유지하면서 체계적인 코드 관리가 가능하다.\n\n## 기본 브랜치 명령어\n\nGit 브랜치 관련 주요 명령어는 다음과 같다. 이를 통해 브랜치를 생성, 확인, 전환, 병합, 삭제하는 과정을 통해 코드 관리를 체계적으로 수행할 수 있다.\n\n### 브랜치 생성\n\n새로운 기능 개발이나 버그 수정 등 독립적인 작업을 시작할 때 새로운 브랜치를 생성한다.\n\n```bash\ngit branch <branch_name>\n```\n\n예를 들어, `feature/login-page`라는 브랜치를 생성하려면 다음과 같이 입력한다.\n\n```bash\ngit branch feature/login-page\n```\n\n### 브랜치 이동 (전환)\n\n작업하려는 브랜치로 전환한다. Git 버전에 따라 `checkout` 또는 `switch` 명령어를 사용한다.\n\n```bash\n# Git version 2.23 미만\ngit checkout <branch_name>\n\n# Git version 2.23 이상\ngit switch <branch_name>\n```\n\n예를 들어, `feature/login-page` 브랜치로 이동하려면 다음과 같이 입력한다.\n\n```bash\ngit switch feature/login-page\n```\n\n### 브랜치 병합\n\n특정 브랜치에서 완료된 작업을 다른 브랜치(주로 `main` 또는 `develop`)로 통합할 때 사용한다.\n\n```bash\ngit merge <branch_name_to_merge>\n```\n\n예를 들어, `feature/login-page` 브랜치의 변경 사항을 현재 브랜치(예: `main`)로 병합하려면 먼저 `main` 브랜치로 이동한 후 다음 명령어를 실행한다.\n\n```bash\n# 1. main 브랜치로 이동 (이미 main 브랜치라면 생략 가능)\ngit switch main\n\n# 2. feature/login-page 브랜치 병합\ngit merge feature/login-page\n```\n\n### 브랜치 삭제\n\n더 이상 필요 없는 브랜치를 삭제하여 프로젝트를 깔끔하게 관리한다. 로컬 브랜치와 원격 브랜치 삭제 방법이 다르다.\n\n#### 로컬 브랜치 삭제\n\n개발자의 로컬 컴퓨터에 생성된 브랜치를 삭제한다.\n\n```bash\ngit branch -d <local_branch_name> # 병합된 브랜치 삭제\ngit branch -D <local_branch_name> # 병합되지 않은 브랜치 강제 삭제\n```\n\n예시: 로컬에서 `feature/login-page` 브랜치 삭제\n\n```bash\ngit branch -d feature/login-page\n```\n\n#### 원격 브랜치 삭제\n\nGitHub와 같은 원격 저장소에 있는 브랜치를 삭제한다.\n\n```bash\ngit push origin --delete <remote_branch_name>\n```\n\n예시: 원격에서 `feature/login-page` 브랜치 삭제\n\n```bash\ngit push origin --delete feature/login-page\n```\n\n#### 원격 브랜치 삭제 후 로컬 정리\n\n원격에서 브랜치가 삭제된 후, 로컬 저장소에도 해당 정보를 반영하고 정리할 필요가 있다.\n\n1.  **로컬에서도 해당 브랜치 삭제**: 만약 로컬에 동일한 이름의 브랜치가 있다면 직접 삭제한다.\n    ```bash\n    git branch -d <branch_name> \n    ```\n2.  **삭제된 원격 브랜치 정보 로컬 반영 (Pruning)**: 원격 저장소에서 삭제된 브랜치에 대한 참조를 로컬에서 정리한다.\n    ```bash\n    git fetch --prune \n    # 또는 git fetch -p\n    ```\n    이 명령어는 `origin/<remote_branch_name>`과 같이 더 이상 원격에 존재하지 않는 브랜치에 대한 로컬 참조를 제거한다.\n\n### 브랜치 목록 확인\n\n로컬 및 원격 브랜치 목록과 현재 상태를 확인한다.\n\n```bash\ngit branch # 로컬 브랜치 목록\ngit branch -r # 원격 브랜치 목록 (추적 브랜치)\ngit branch -a # 로컬 및 원격 브랜치를 포함한 전체 목록\ngit branch -vv # 로컬 브랜치와 연결된 업스트림(원격) 브랜치 정보를 함께 표시\n```\n\n원격 저장소의 최신 상태를 가져온 후 전체 브랜치를 확인하는 예시는 다음과 같다.\n\n```bash\ngit fetch --all # 모든 원격 저장소의 최신 상태를 가져옴\ngit branch -a   # 로컬 및 원격의 모든 브랜치를 확인함\n```\n\n## 원격 브랜치 관리\n\n### 원격 브랜치 추적 (Tracking)\n\n원격 저장소에 있는 특정 브랜치를 기반으로 로컬 브랜치를 생성하고, 해당 원격 브랜치를 추적하도록 설정한다. 이렇게 하면 `git pull`, `git push` 명령을 실행할 때 로컬 브랜치가 어떤 원격 브랜치와 통신해야 하는지 알 수 있다.\n\n```bash\n# 방법 1: 원격 브랜치와 동일한 이름으로 로컬 브랜치 생성 및 추적\ngit checkout --track origin/<remote_branch_name>\n\n# 방법 2: 다른 이름으로 로컬 브랜치 생성 및 특정 원격 브랜치 추적\ngit checkout -b <local_branch_name> origin/<remote_branch_name>\n```\n\n**설명**:\n\n*   `<local_branch_name>`: 로컬에서 생성할 새로운 브랜치 이름.\n*   `origin/<remote_branch_name>`: 추적할 원격 저장소(기본적으로 `origin`)의 브랜치 이름.\n\n**사용 예시**: 원격의 `feature/new-feature` 브랜치를 `my-new-feature`라는 로컬 브랜치로 생성하고 추적하려면 다음과 같이 한다.\n\n```bash\ngit checkout -b my-new-feature origin/feature/new-feature\n```\n\n만약 로컬 브랜치와 원격 브랜치 이름을 동일하게 하려면 다음과 같이 간단히 할 수 있다.\n\n```bash\ngit switch feature/new-feature # Git 2.23+\n# 또는 git checkout feature/new-feature\n# 위 명령어는 로컬에 feature/new-feature 브랜치가 없고, \n# 원격(origin)에만 해당 이름의 브랜치가 하나 있을 때 자동으로 추적 관계를 설정하며 로컬 브랜치를 생성한다.\n```\n\n### 업스트림 브랜치 설정 및 푸시\n\n로컬 브랜치의 변경 사항을 원격 저장소에 푸시할 때, 해당 로컬 브랜치가 어떤 원격 브랜치와 연결되어야 하는지 명시해야 한다. 이를 \"업스트림(upstream) 브랜치 설정\"이라고 한다.\n\n#### 새로운 로컬 브랜치를 처음 푸시할 때\n\n새로운 로컬 브랜치를 만들고 작업을 완료한 후 처음 원격 저장소로 푸시할 때는 업스트림 정보를 함께 설정해주는 것이 일반적이다.\n\n```bash\ngit push --set-upstream origin <local_branch_name>\n# 줄여서 git push -u origin <local_branch_name>\n```\n\n이 명령어는 다음 두 가지 작업을 수행한다:\n\n1.  로컬 브랜치 `<local_branch_name>`의 내용을 `origin` 원격 저장소에 동일한 이름의 브랜치로 푸시한다. (만약 원격에 해당 브랜치가 없다면 새로 생성된다.)\n2.  로컬 브랜치 `<local_branch_name>`이 원격 저장소 `origin`의 `<local_branch_name>` 브랜치를 추적하도록 업스트림 관계를 설정한다.\n\n**사용 예시**: `feature/submit-button` 로컬 브랜치를 원격에 푸시하고 업스트림으로 설정하려면 다음과 같이 한다.\n\n```bash\ngit push -u origin feature/submit-button\n```\n\n이렇게 한번 업스트림 관계를 설정하고 나면, 이후 해당 브랜치에서는 `git push` 와 `git pull` 명령어만으로도 Git이 자동으로 연결된 원격 브랜치와 통신한다.\n\n#### 현재 브랜치의 업스트림 연결 상태 확인\n\n```bash\ngit branch -vv\n```\n\n이 명령어를 실행하면 각 로컬 브랜치 옆에 어떤 원격 브랜치를 추적하고 있는지 (예: `[origin/main]`) 표시된다.\n\n## 충돌 해결 (Merge Conflict)\n\n브랜치를 병합하는 과정에서 동일한 파일의 같은 부분을 여러 브랜치에서 다르게 수정한 경우 \"병합 충돌(merge conflict)\"이 발생할 수 있다.\n\n충돌이 발생하면 Git은 자동으로 병합을 멈추고 개발자에게 충돌을 해결하도록 요청한다. 충돌이 발생한 파일은 다음과 같은 형태로 표시된다.\n\n```\n<<<<<<< HEAD\n현재 브랜치(예: main)의 내용\n=======\n병합하려는 브랜치(예: feature/login-page)의 내용\n>>>>>>> feature/login-page\n```\n\n**충돌 해결 과정**:\n\n1.  **충돌 파일 확인**: `git status` 명령으로 충돌이 발생한 파일 목록을 확인한다.\n2.  **충돌 내용 수정**: 해당 파일을 열어 `<<<<<<<`, `=======`, `>>>>>>>` 마커를 참고하여 원하는 최종 코드로 직접 수정한다. 마커들도 함께 제거해야 한다.\n3.  **수정된 파일 스테이징**: 충돌을 해결한 파일을 `git add` 명령으로 스테이징한다.\n    ```bash\n    git add <conflicted_file_name>\n    # 또는 모든 수정사항을 스테이징하려면: git add .\n    ```\n4.  **병합 커밋 완료**: 모든 충돌을 해결하고 파일을 스테이징한 후, `git commit` 명령으로 병합을 완료한다. (Git이 자동으로 병합 커밋 메시지를 제안해준다. 특별한 이유가 없다면 그대로 사용해도 된다.)\n    ```bash\n    git commit \n    ```\n    만약 `git merge` 명령 실행 시 `--no-ff` 옵션 없이 fast-forward 병합이 아닌 경우 자동으로 병합 커밋이 생성되므로, 충돌 해결 후 `git commit`만 실행하면 된다. 만약 `rebase` 중 충돌이 발생했다면 `git rebase --continue`를 사용한다.\n\n## 브랜치 병합 예시\n\n### 시나리오 1: `dev-yjlee5` 브랜치의 변경 사항을 `main` 브랜치로 병합하기\n\n1.  **병합 대상 브랜치(`main`)로 이동**:\n    ```bash\n    git switch main\n    ```\n2.  **원격 `dev-yjlee5` 브랜치의 최신 내용 가져오기 (선택 사항, 로컬에 최신 내용이 없다면)**:\n    ```bash\n    git fetch origin dev-yjlee5 \n    # 이 명령은 원격 브랜치의 내용을 가져와 로컬에 origin/dev-yjlee5 로 업데이트한다.\n    # 실제 병합은 로컬에 있는 브랜치를 기준으로 한다.\n    ```\n3.  **`dev-yjlee5` (또는 `origin/dev-yjlee5`)를 `main` 브랜치에 병합**:\n    ```bash\n    # 만약 dev-yjlee5가 로컬에도 있고 최신 상태라면:\n    git merge dev-yjlee5\n    \n    # 만약 로컬 dev-yjlee5 대신 원격의 최신 내용을 바로 병합하고 싶다면:\n    # (이미 fetch를 통해 origin/dev-yjlee5가 최신 상태여야 함)\n    git merge origin/dev-yjlee5 \n    ```\n4.  **충돌 해결**: 충돌 발생 시 위에서 설명한 충돌 해결 과정을 따른다.\n5.  **병합 결과 원격 저장소에 푸시**:\n    ```bash\n    git push origin main\n    ```\n\n### 시나리오 2: `main` 브랜치의 변경 사항을 `dev-yjlee5` 브랜치로 병합하기 (최신 상태 유지)\n\n1.  **작업 브랜치(`dev-yjlee5`)로 이동**:\n    ```bash\n    git switch dev-yjlee5\n    ```\n2.  **원격 `main` 브랜치의 최신 내용 가져오기**:\n    ```bash\n    git fetch origin main\n    ```\n3.  **`origin/main`을 `dev-yjlee5` 브랜치에 병합**:\n    ```bash\n    git merge origin/main\n    ```\n4.  **충돌 해결**: 충돌 발생 시 충돌 해결 과정을 따른다.\n5.  **병합 결과 원격 저장소에 푸시**:\n    ```bash\n    git push origin dev-yjlee5\n    ```\n\n\n### 작업 워크플로우\n\n#### 운영 코드 작업 및 팀 리뷰 요청\n\n```bash\n# 현재 작업 브랜치를 팀 리뷰용 브랜치로 변경\ngit switch feature/token-processor-improvements\n\n# 운영 코드 수정 (예: 8_token_analyzer/token_processor.py)\n# ... 코드 수정 ...\n\n# 변경 사항 스테이징 및 커밋\ngit add 8_token_analyzer/token_processor.py\ngit commit -m \"feat: 토큰 분석기 성능 개선\"\n\n# 원격 저장소에 푸시하여 팀원들에게 리뷰 요청\ngit push origin feature/token-processor-improvements \n```\n\n#### 개인 실험 또는 파일 백업\n\n```bash\n# 개인 작업용 브랜치로 변경\ngit switch personal/kmkim-workspace\n\n# 개인 폴더(kmkim/)에 파일 추가 또는 수정\n# ... 개인 작업 ...\n\n# 변경 사항 스테이징 및 커밋\ngit add kmkim/\ngit commit -m \"개인 작업: 새로운 아이디어 스케치 및 자료 백업\"\n\n# 원격 저장소에 푸시하여 개인 작업 내용 백업\ngit push origin personal/kmkim-workspace\n```\n\n#### 다른 장소에서 개인 작업 이어가기\n\n```bash\n# 프로젝트 클론 (처음 작업 환경을 설정하는 경우)\ngit clone https://github.com/SeegeneDevelopmentPlatform/data_standardization.git\ncd data_standardization\n\n# 개인 작업용 브랜치로 변경하여 작업 내용 복원\ngit switch personal/kmkim-workspace \n# 또는 git checkout personal/kmkim-workspace (원격에만 있다면 추적하며 생성)\n```\n이제 `kmkim/` 폴더의 개인 작업 내용을 확인하고 이어서 작업할 수 있다.\n\n## 결론\n\nGit 브랜치는 코드 버전 관리와 협업의 핵심 도구이다. 다양한 명령어를 익히고, 상황에 맞는 브랜치 전략을 수립하여 활용하면 개발 생산성을 크게 향상시키고 안정적인 프로젝트 관리를 할 수 있다."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"github","css":["../../../../../styles.css"],"toc":true,"toc-depth":3,"number-sections":true,"include-in-header":[{"text":"<style>\n.custom-footer { \n  text-align: center; \n  font-size: 0.8em; \n  color: #666; \n  margin-top: 2rem; \n}\n</style>\n"}],"include-after-body":["../../../../../js.html","../../../signup.html"],"output-file":"3.git_branch.html"},"language":{"toc-title-document":"목차","toc-title-website":"목차","related-formats-title":"기타 형식","related-notebooks-title":"Notebooks","source-notebooks-prefix":"원천","other-links-title":"기타 링크","code-links-title":"코드 링크","launch-dev-container-title":"Dev 컨테이너 실행","launch-binder-title":"랜치 Binder","article-notebook-label":"기사 노트북","notebook-preview-download":"노트북 다운로드","notebook-preview-download-src":"소스 다운로드","notebook-preview-back":"기사로 돌아가기","manuscript-meca-bundle":"MECA 아카이브","section-title-abstract":"초록","section-title-appendices":"부록","section-title-footnotes":"각주","section-title-references":"참고문헌","section-title-reuse":"라이센스","section-title-copyright":"저작권","section-title-citation":"인용","appendix-attribution-cite-as":"인용방법","appendix-attribution-bibtex":"BibTeX 인용:","title-block-author-single":"저자","title-block-author-plural":"저자","title-block-affiliation-single":"소속","title-block-affiliation-plural":"소속","title-block-published":"공개","title-block-modified":"Modified","title-block-keywords":"키워드","callout-tip-title":"힌트","callout-note-title":"노트","callout-warning-title":"경고","callout-important-title":"중요","callout-caution-title":"주의","code-summary":"코드","code-tools-menu-caption":"코드","code-tools-show-all-code":"전체 코드 표시","code-tools-hide-all-code":"전체 코드 숨기기","code-tools-view-source":"소스 코드 표시","code-tools-source-code":"소스 코드","tools-share":"Share","tools-download":"Download","code-line":"선","code-lines":"윤곽","copy-button-tooltip":"클립보드 복사","copy-button-tooltip-success":"복사완료!","repo-action-links-edit":"편집","repo-action-links-source":"소스코드 보기","repo-action-links-issue":"이슈 보고","back-to-top":"맨 위로","search-no-results-text":"일치 없음","search-matching-documents-text":"일치된 문서","search-copy-link-title":"검색 링크 복사","search-hide-matches-text":"추가 검색 결과 숨기기","search-more-match-text":"추가 검색결과","search-more-matches-text":"추가 검색결과","search-clear-button-title":"제거","search-text-placeholder":"","search-detached-cancel-button-title":"취소","search-submit-button-title":"검색","search-label":"검색","toggle-section":"토글 섹션","toggle-sidebar":"사이드바 전환","toggle-dark-mode":"다크 모드 전환","toggle-reader-mode":"리더 모드 전환","toggle-navigation":"탐색 전환","crossref-fig-title":"그림","crossref-tbl-title":"표","crossref-lst-title":"목록","crossref-thm-title":"정리","crossref-lem-title":"보조정리","crossref-cor-title":"따름정리","crossref-prp-title":"명제","crossref-cnj-title":"추측","crossref-def-title":"정의","crossref-exm-title":"보기","crossref-exr-title":"예제","crossref-ch-prefix":"장","crossref-apx-prefix":"부록","crossref-sec-prefix":"섹션","crossref-eq-prefix":"방정식","crossref-lof-title":"그림 목록","crossref-lot-title":"표 목록","crossref-lol-title":"코드 목록","environment-proof-title":"증명","environment-remark-title":"주석","environment-solution-title":"해답","listing-page-order-by":"정렬","listing-page-order-by-default":"디폴트","listing-page-order-by-date-asc":"날짜(오름차순)","listing-page-order-by-date-desc":"날짜(내림차순)","listing-page-order-by-number-desc":"페이지 번호(내림차순)","listing-page-order-by-number-asc":"페이지 번호(오름차순)","listing-page-field-date":"날짜","listing-page-field-title":"제목","listing-page-field-description":"설명","listing-page-field-author":"저자","listing-page-field-filename":"파일명","listing-page-field-filemodified":"갱신일","listing-page-field-subtitle":"부제목","listing-page-field-readingtime":"읽기 시간","listing-page-field-wordcount":"단어 수","listing-page-field-categories":"분류","listing-page-minutes-compact":"{0} 분","listing-page-category-all":"전체","listing-page-no-matches":"일치 없음","listing-page-words":"{0} 단어"},"metadata":{"lang":"ko","fig-responsive":true,"quarto-version":"1.4.543","theme":{"light":["cosmo","../../../../../theme.scss"],"dark":["cosmo","../../../../../theme-dark.scss"]},"code-copy":true,"grid":{"sidebar-width":"200px","body-width":"1200px","margin-width":"200px"},"comments":{"giscus":{"repo":"kmink3225/blog","category":"Blog"}},"title-block-banner":"#EDF3F9","title-block-banner-color":"black","toc-location":"right","open-graph":true,"twitter-card":true,"search":true,"date-format":"YYYY년 MM월 DD일","title":"Git 브랜치: 개념부터 실전 전략까지","subtitle":"코드 버전 관리의 핵심, 브랜치 다루기","description":"Git 브랜치의 개념, 주요 명령어(생성, 전환, 병합, 삭제), 원격 브랜치 관리, 충돌 해결, 다양한 브랜치 전략 및 푸시 워크플로우를 상세히 알아본다.\n","categories":["Engineering","Git"],"author":"Kwangmin Kim","date":"05/03/2023","draft":false,"page-layout":"full"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}