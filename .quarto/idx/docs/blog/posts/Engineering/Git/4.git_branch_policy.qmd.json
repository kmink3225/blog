{"title":"Git Branch Policy","markdown":{"yaml":{"title":"Git Branch Policy","subtitle":"효율적인 협업을 위한 Git 브랜치 전략 가이드","description":"다양한 Git 브랜치 전략(Git Flow, GitHub Flow, GitLab Flow)을 비교 분석하고, 각 전략의 특징, 장단점, 적합한 프로젝트 유형을 설명하여 팀에 맞는 최적의 브랜치 전략 선택을 돕는다.\n","categories":["Engineering","Git"],"author":"Kwangmin Kim","date":"05/04/2023","format":{"html":{"page-layout":"full","code-fold":true,"toc":true,"number-sections":true}}},"headingText":"Git Flow 브랜치 전략 가이드","containsRefs":false,"markdown":"\n\n\n## Git Flow 핵심 개념\n\n**Git Flow**: 브랜치를 역할별로 체계적으로 관리하여 안정적인 개발과 배포를 가능하게 하는 브랜치 전략\n\n## 브랜치 구조 및 역할\n\n### 메인 브랜치 (영구 브랜치)\n\n**`main` (Production 브랜치)**\n- **역할**: 배포 가능한 안정적인 코드만 관리\n- **특징**: \n  - 실제 서비스되는 코드\n  - 버그가 없어야 함\n  - 직접 커밋 금지 (보호 설정 필요)\n- **병합 대상**: `release/*`, `hotfix/*`에서만 병합\n\n**`develop` (통합 개발 브랜치)**\n- **역할**: 다음 릴리스를 위한 기능들이 통합되는 브랜치\n- **특징**:\n  - 모든 기능 개발의 중심\n  - 지속적인 통합 테스트 진행\n  - `main`보다 앞선 최신 개발 상태\n- **병합 대상**: `feature/*` 브랜치들이 병합\n\n### 보조 브랜치 (임시 브랜치)\n\n**`feature/*` (기능 개발 브랜치)**\n- **역할**: 개별 기능 개발\n- **네이밍**: `feature/기능명` (예: `feature/user-login`, `feature/payment-system`)\n- **생성 위치**: `develop`에서 분기\n- **병합 대상**: `develop`으로 병합 후 삭제\n\n**`release/*` (릴리스 준비 브랜치)**\n- **역할**: 배포 버전 최종 준비 및 테스트\n- **네이밍**: `release/버전` (예: `release/v1.2.0`)\n- **생성 위치**: `develop`에서 분기\n- **병합 대상**: `main`과 `develop` 양쪽으로 병합\n\n**`hotfix/*` (긴급 수정 브랜치)**\n- **역할**: 운영 환경 긴급 버그 수정\n- **네이밍**: `hotfix/버그명` (예: `hotfix/critical-login-bug`)\n- **생성 위치**: `main`에서 분기\n- **병합 대상**: `main`과 `develop` 양쪽으로 병합\n\n## Git Flow 작업 흐름\n\n### 기능 개발 프로세스\n\n```\n1. 새 기능 시작\n   develop → feature/새기능 분기\n\n2. 기능 개발\n   feature/새기능에서 작업\n\n3. 기능 완료\n   feature/새기능 → develop 병합\n```\n\n### 릴리스 프로세스\n\n```\n1. 릴리스 준비\n   develop → release/v1.0.0 분기\n\n2. 릴리스 테스트 및 버그 수정\n   release/v1.0.0에서 작업\n\n3. 릴리스 배포\n   release/v1.0.0 → main 병합\n   release/v1.0.0 → develop 병합\n```\n\n### 핫픽스 프로세스\n\n```\n1. 긴급 수정 시작\n   main → hotfix/버그명 분기\n\n2. 버그 수정\n   hotfix/버그명에서 작업\n\n3. 긴급 배포\n   hotfix/버그명 → main 병합\n   hotfix/버그명 → develop 병합\n```\n\n## 실제 Git 명령어\n\n### 새 기능 개발 시작\n\n```bash\n# develop 브랜치로 이동 및 최신 상태 동기화\ngit checkout develop\ngit pull origin develop\n\n# 새 기능 브랜치 생성\ngit checkout -b feature/새기능명\n\n# 작업 후 커밋\ngit add .\ngit commit -m \"feat: 새 기능 구현\"\ngit push origin feature/새기능명\n```\n\n### 기능 개발 완료 (병합)\n\n```bash\n# develop으로 이동 및 최신 상태 확인\ngit checkout develop\ngit pull origin develop\n\n# feature 브랜치 병합\ngit merge feature/새기능명\ngit push origin develop\n\n# feature 브랜치 삭제\ngit branch -d feature/새기능명\ngit push origin --delete feature/새기능명\n```\n\n### 릴리스 배포\n\n```bash\n# 릴리스 브랜치 생성\ngit checkout develop\ngit checkout -b release/v1.0.0\n\n# 릴리스 테스트 및 버그 수정 후\n# main으로 병합\ngit checkout main\ngit merge release/v1.0.0\ngit tag v1.0.0\ngit push origin main --tags\n\n# develop으로도 병합\ngit checkout develop\ngit merge release/v1.0.0\ngit push origin develop\n```\n\n## 브랜치 보호 정책\n\n### main 브랜치 보호 설정 (GitHub 기준)\n\n1. **Repository Settings → Branches → Add Rule**\n2. **필수 설정**:\n   - ✅ Require pull request reviews before merging\n   - ✅ Require status checks to pass before merging\n   - ✅ Include administrators\n   - ✅ Restrict pushes that create files larger than 100MB\n\n3. **추가 권장 설정**:\n   - ✅ Require branches to be up to date before merging\n   - ✅ Require linear history\n\n## Git Flow의 장점\n\n1. **안정성**: main 브랜치 보호로 안정적인 배포 보장\n2. **협업**: 역할별 브랜치로 팀 협업 효율성 증대\n3. **추적성**: 명확한 브랜치 구조로 변경 이력 추적 용이\n4. **롤백**: 문제 발생 시 쉬운 되돌리기\n5. **병렬 개발**: 여러 기능 동시 개발 가능\n\n## 주의사항\n\n- **브랜치 네이밍**: 일관된 네이밍 컨벤션 준수\n- **정기적 동기화**: develop 브랜치와 정기적 동기화\n- **작은 단위 커밋**: 기능별 작은 단위로 커밋\n- **코드 리뷰**: PR/MR을 통한 코드 리뷰 필수\n- **브랜치 정리**: 병합 완료된 feature 브랜치는 즉시 삭제\n\n이러한 Git Flow 전략을 통해 체계적이고 안정적인 코드 관리가 가능하다.\n\n\n---\n## TL;DR\n\n1. Azure DevOps 기반으로 Feature 브랜치를 생성합니다\n2. `develop` 브랜치가 업데이트되면 dev 환경에 배포됩니다\n    1. 과정에 PR은 필요하지 않습니다\n    2. `master`와 rebase한 뒤 배포하는 것을 권장합니다\n3. `master` 브랜치로 한 번만 PR을 진행합니다\n    1. 최신 커밋은 반드시 `develop`에 배포한 이력이 있어야 합니다\n4. `master` 브랜치가 업데이트되면 stg 환경에 배포됩니다\n5. `release/*` 형태로 브랜치를 생성하면 prd 환경에 배포합니다\n    1. 배포에는 팀장 이상 직책자의 승인이 필요합니다\n6. 긴급한 수정 사항이 발생하면 `hotfix` 브랜치를 생성합니다\n    1. `master` 브랜치로 PR을 진행합니다\n    2. `release/*` 브랜치에선 수정 사항을 cherry pick 합니다\n\n## 브랜치 설명\n\n| 브랜치명 | 목적 | 제약 | 비고 |\n| --- | --- | --- | --- |\n| develop | - 개발 및 테스트를 위한 브랜치입니다\n- feature 완료 후 병합되어 dev 환경에 배포되어 테스트  |  | - 차후 개발 서버를 증설하면 이름이 변경될 수 있습니다 |\n| main(master) | - 새로운 feature 브랜치 생성의 기준이 되는 브랜치입니다\n- 배포 / 새로운 feature 생성이 항상 가능해야 하기에, 안정된 상태를 유지해야 합니다 | - PR 없이 직접 업데이트할 수 없습니다\n- PR은 리뷰 및 자동화된 테스트가 완료되어야 병합할 수 있습니다 |  |\n| feature/{이슈번호 또는 기능명} | - 새로운 기능 개발을 위한 브랜치입니다 |  |  |\n| hotfix/{이슈번호 또는 버그명} | - 긴급 버그 수정을 위한 브랜치입니다 |  |  |\n| release/{날짜 또는 버전명} | - 운영 환경 배포를 위한 브랜치입니다 |  |  |\n\n## 배포 환경\n\n| 환경 | 배포 조건 | 설명 | 제약 |\n| --- | --- | --- | --- |\n| dev | `develop` 브랜치 업데이트 | 개발 테스트 환경으로, 누구나 자유롭게 사용할 수 있습니다 | 없음 |\n| stg | `master` 브랜치 업데이트 | 최종 테스트 환경으로, 안정된 코드만 배포될 수 있습니다 | 배포에 코드 리뷰가 필요합니다 |\n| prd | `release/*` 브랜치 업데이트 | 실제 운영 환경입니다 | 배포에 팀장 이상 직책자의 승인이 필요합니다 |\n\n# 개발 및 배포 프로세스\n\n## **1. 기능 개발 시작**\n\n- GitHub Issue 생성: 새로운 기능에 대한 GitHub Issue를 생성합니다.\n- master 브랜치에서 `feature/{이슈번호 또는 기능명}` 브랜치를 생성합니다. (예: feature/123-add-login)\n\n## **2. 기능 개발 완료**\n\n- `feature` 브랜치에서 기능을 개발하고 코드를 커밋합니다.\n- 커밋 메시지는 [Conventional Commits](https://www.conventionalcommits.org/) 규약을 따르는 것을 권장합니다.\n\n## **3. 개발 테스트**\n\n- `feature` 브랜치에서 수정한 내용을 develop 브랜치를 업데이트합니다.\n    - 혹은, Pull Request를 생성하고, 해당 PR에 `/deploy` 라는 comment를 추가합니다.\n    - 이때, 자동으로 개발(dev) 환경에 배포됩니다.\n- 작업한 내용이 올바르게 동작하는지 확인합니다.\n\n### Actions\n\n- 개발자: 기능이 올바르게 동작하는지 개발 서버에서 확인합니다.\n\n## **4. main에 병합**\n\n- `feature` 브랜치에서 `main` 브랜치로 Pull Request를 생성합니다.\n    - 이때, 자동으로 테스트가 수행됩니다.\n- 팀 내에서 코드에 대한 리뷰를 진행합니다.\n    - 수정할 내용이 발생하면 2번으로 돌아갑니다.\n    - 리뷰가 완료되면, Pull Request를 병합합니다.\n        - 이때, 자동으로 검증(stg) 환경에 배포됩니다.\n\n### Actions\n\n- 개발자: 코드에 대한 오너십을 가지고 리뷰에 임합니다.\n- 리뷰어: 소스코드가 main branch에 병합되어도 될만큼 안정된 코드인지 확인합니다.\n    - 필요한 경우 `/deploy` 명령어를 통해 해당 PR에 수정된 코드가 잘 동작하는지 개발 서버에서 확인합니다.\n\n## **5. 최종 테스트**\n\n- 검증(stg) 환경에서 `main` 브랜치 코드를 기반으로 최종 테스트를 진행합니다.\n    - 수정할 내용이 발생하면 2번으로 돌아갑니다.\n\n## **6. 운영 환경 배포**\n\n- `release/*` 브랜치를 테스트가 완료된 `main` 브랜치로부터 생성합니다.\n    - 이때, 운영(prd) 환경에 배포하기 위한 준비(빌드 등)가 시작됩니다.\n    - 실제 배포(Manifest repository | Storage Account 업데이트)가 이뤄지기 위해선 팀장 이상 직책자가 GitHub에서 workflow 수행을 승인해야 합니다.\n\n### Actions\n\n- 개발자: 소스코드가 올바르게 빌드되는지 확인하고, 운영 배포 이후 이상이 없는지 모니터링합니다.\n- 직책자: 코드가 빠르고 안전하게 배포될 수 있도록 확인 사항 체크 후 GitHub에서 배포를 승인합니다.\n    - 승인 절차 확인 (이미지 없음)\n        1. 팀즈 [배포 승인 알림]채널에 관련 알림이 발송됩니다.\n        2. 링크를 클릭하면 다음과 같은 화면이 보입니다.\n        `Review deployments` 버튼을 클릭해 주세요.\n        3. `Approve and deploy` 버튼을 클릭하시면 승인이 완료되고, 배포 절차가 진행됩니다.\n            \n## **7. hotfix (필요 시)**\n\n- 운영 환경에서 긴급 버그가 발생하면, GitHub Issue를 생성하고, `main` 브랜치에서 `hotfix/{이슈번호 또는 버그명}` 브랜치를 생성합니다.\n- `hotfix` 브랜치에서 버그를 수정하고 테스트합니다.\n- `hotfix` 브랜치에서 `main`브랜치로 Pull Request를 생성합니다.\n- 코드 리뷰 및 테스트를 거쳐 `main`에 병합합니다.\n- `release/*` 브랜치에 수정 사항을 cherry-pick 합니다.\n\n# 롤백\n\n## **롤백 사유**\n\n- 운영 환경에 배포된 새로운 버전에서 심각한 버그 또는 장애가 발생하여 긴급하게 이전 버전으로 복구해야 하는 경우\n- 새로운 버전의 성능이 이전 버전보다 현저히 떨어지거나, 주요 기능이 정상적으로 동작하지 않는 경우\n- 사용자로부터 심각한 불만 사항이 접수되어 긴급 조치가 필요한 경우\n\n## **롤백 절차**\n\n1. **롤백 결정:**\n    - 운영 환경의 문제 상황을 신속하게 파악하고, 롤백 여부를 결정합니다.\n    - 롤백을 결정하기 전에, 가능한 경우 hotfix를 통한 수정 가능 여부를 검토합니다.\n    - 롤백 결정 시, 관련 팀(개발, 운영, QA 등)과 충분히 협의하고, 롤백의 영향도를 분석합니다.\n2. **release 브랜치 롤백:**\n    - **이전 릴리즈 태그 확인:** GitHub Releases에서 롤백하고자 하는 버전의 태그를 찾습니다.\n    - **release 브랜치 복구:** release 브랜치를 롤백하고자 하는 버전의 태그로 리셋(reset)합니다. (GitHub UI 또는 CLI 사용)\n    - **주의:** release 브랜치에 대해 강제 푸시(--force)를 사용하므로, 신중하게 진행해야 합니다.\n3. **운영 환경 롤백:**\n    - GitHub Actions를 통해 release 브랜치에서 롤백된 코드를 운영 환경에 재배포합니다.\n    - CI/CD 파이프라인을 사용 중인 경우, 롤백된 버전의 태그를 사용하여 배포를 트리거할 수 있습니다.\n4. **master 브랜치 롤백 (선택적):**\n    - release에서 master으로의 자동 병합이 이루어진 경우, master 브랜치에도 롤백이 필요할 수 있습니다.\n    - master 브랜치를 롤백하는 것은 이후 개발에 영향을 줄 수 있으므로, 신중하게 결정해야 합니다.\n    - 일반적으로는 master 브랜치를 직접 롤백하기보다는, 문제가 된 커밋을 revert하는 새로운 커밋을 생성하여 master에 병합하는 것이 안전합니다.\n5. **롤백 공지 및 후속 조치:**\n    - 롤백을 수행한 경우, 사용자에게 롤백 사실과 사유를 공지합니다.\n    - 롤백의 원인이 된 문제를 분석하고, 재발 방지 대책을 수립합니다.\n    - develop, pre-release 브랜치에 롤백된 버전 이후의 커밋들이 있는지 확인하고, 필요한 경우 revert 또는 cherry-pick을 통해 release 브랜치와 동기화합니다.\n6. **롤백 시 고려 사항:**\n    - **데이터베이스 마이그레이션:** 새로운 버전에서 데이터베이스 스키마 변경(migration)이 이루어진 경우, 롤백 시 데이터베이스 롤백도 함께 고려해야 합니다.\n    - **데이터 유실:** 롤백으로 인해 새로운 버전에서 생성된 데이터가 유실될 수 있습니다. 롤백 전에 데이터 백업 및 복구 방안을 마련해야 합니다.\n    - **다운타임:** 롤백 과정에서 서비스 다운타임이 발생할 수 있습니다. 다운타임을 최소화하기 위한 방안을 고려해야 합니다. (e.g., 블루/그린 배포, 카나리 배포)\n    - **테스트:** 롤백 후에는 반드시 운영 환경과 동일한 환경에서 충분한 테스트를 수행하여, 롤백이 성공적으로 이루어졌는지 확인해야 합니다.\n\n","srcMarkdownNoYaml":"\n\n# Git Flow 브랜치 전략 가이드\n\n## Git Flow 핵심 개념\n\n**Git Flow**: 브랜치를 역할별로 체계적으로 관리하여 안정적인 개발과 배포를 가능하게 하는 브랜치 전략\n\n## 브랜치 구조 및 역할\n\n### 메인 브랜치 (영구 브랜치)\n\n**`main` (Production 브랜치)**\n- **역할**: 배포 가능한 안정적인 코드만 관리\n- **특징**: \n  - 실제 서비스되는 코드\n  - 버그가 없어야 함\n  - 직접 커밋 금지 (보호 설정 필요)\n- **병합 대상**: `release/*`, `hotfix/*`에서만 병합\n\n**`develop` (통합 개발 브랜치)**\n- **역할**: 다음 릴리스를 위한 기능들이 통합되는 브랜치\n- **특징**:\n  - 모든 기능 개발의 중심\n  - 지속적인 통합 테스트 진행\n  - `main`보다 앞선 최신 개발 상태\n- **병합 대상**: `feature/*` 브랜치들이 병합\n\n### 보조 브랜치 (임시 브랜치)\n\n**`feature/*` (기능 개발 브랜치)**\n- **역할**: 개별 기능 개발\n- **네이밍**: `feature/기능명` (예: `feature/user-login`, `feature/payment-system`)\n- **생성 위치**: `develop`에서 분기\n- **병합 대상**: `develop`으로 병합 후 삭제\n\n**`release/*` (릴리스 준비 브랜치)**\n- **역할**: 배포 버전 최종 준비 및 테스트\n- **네이밍**: `release/버전` (예: `release/v1.2.0`)\n- **생성 위치**: `develop`에서 분기\n- **병합 대상**: `main`과 `develop` 양쪽으로 병합\n\n**`hotfix/*` (긴급 수정 브랜치)**\n- **역할**: 운영 환경 긴급 버그 수정\n- **네이밍**: `hotfix/버그명` (예: `hotfix/critical-login-bug`)\n- **생성 위치**: `main`에서 분기\n- **병합 대상**: `main`과 `develop` 양쪽으로 병합\n\n## Git Flow 작업 흐름\n\n### 기능 개발 프로세스\n\n```\n1. 새 기능 시작\n   develop → feature/새기능 분기\n\n2. 기능 개발\n   feature/새기능에서 작업\n\n3. 기능 완료\n   feature/새기능 → develop 병합\n```\n\n### 릴리스 프로세스\n\n```\n1. 릴리스 준비\n   develop → release/v1.0.0 분기\n\n2. 릴리스 테스트 및 버그 수정\n   release/v1.0.0에서 작업\n\n3. 릴리스 배포\n   release/v1.0.0 → main 병합\n   release/v1.0.0 → develop 병합\n```\n\n### 핫픽스 프로세스\n\n```\n1. 긴급 수정 시작\n   main → hotfix/버그명 분기\n\n2. 버그 수정\n   hotfix/버그명에서 작업\n\n3. 긴급 배포\n   hotfix/버그명 → main 병합\n   hotfix/버그명 → develop 병합\n```\n\n## 실제 Git 명령어\n\n### 새 기능 개발 시작\n\n```bash\n# develop 브랜치로 이동 및 최신 상태 동기화\ngit checkout develop\ngit pull origin develop\n\n# 새 기능 브랜치 생성\ngit checkout -b feature/새기능명\n\n# 작업 후 커밋\ngit add .\ngit commit -m \"feat: 새 기능 구현\"\ngit push origin feature/새기능명\n```\n\n### 기능 개발 완료 (병합)\n\n```bash\n# develop으로 이동 및 최신 상태 확인\ngit checkout develop\ngit pull origin develop\n\n# feature 브랜치 병합\ngit merge feature/새기능명\ngit push origin develop\n\n# feature 브랜치 삭제\ngit branch -d feature/새기능명\ngit push origin --delete feature/새기능명\n```\n\n### 릴리스 배포\n\n```bash\n# 릴리스 브랜치 생성\ngit checkout develop\ngit checkout -b release/v1.0.0\n\n# 릴리스 테스트 및 버그 수정 후\n# main으로 병합\ngit checkout main\ngit merge release/v1.0.0\ngit tag v1.0.0\ngit push origin main --tags\n\n# develop으로도 병합\ngit checkout develop\ngit merge release/v1.0.0\ngit push origin develop\n```\n\n## 브랜치 보호 정책\n\n### main 브랜치 보호 설정 (GitHub 기준)\n\n1. **Repository Settings → Branches → Add Rule**\n2. **필수 설정**:\n   - ✅ Require pull request reviews before merging\n   - ✅ Require status checks to pass before merging\n   - ✅ Include administrators\n   - ✅ Restrict pushes that create files larger than 100MB\n\n3. **추가 권장 설정**:\n   - ✅ Require branches to be up to date before merging\n   - ✅ Require linear history\n\n## Git Flow의 장점\n\n1. **안정성**: main 브랜치 보호로 안정적인 배포 보장\n2. **협업**: 역할별 브랜치로 팀 협업 효율성 증대\n3. **추적성**: 명확한 브랜치 구조로 변경 이력 추적 용이\n4. **롤백**: 문제 발생 시 쉬운 되돌리기\n5. **병렬 개발**: 여러 기능 동시 개발 가능\n\n## 주의사항\n\n- **브랜치 네이밍**: 일관된 네이밍 컨벤션 준수\n- **정기적 동기화**: develop 브랜치와 정기적 동기화\n- **작은 단위 커밋**: 기능별 작은 단위로 커밋\n- **코드 리뷰**: PR/MR을 통한 코드 리뷰 필수\n- **브랜치 정리**: 병합 완료된 feature 브랜치는 즉시 삭제\n\n이러한 Git Flow 전략을 통해 체계적이고 안정적인 코드 관리가 가능하다.\n\n\n---\n## TL;DR\n\n1. Azure DevOps 기반으로 Feature 브랜치를 생성합니다\n2. `develop` 브랜치가 업데이트되면 dev 환경에 배포됩니다\n    1. 과정에 PR은 필요하지 않습니다\n    2. `master`와 rebase한 뒤 배포하는 것을 권장합니다\n3. `master` 브랜치로 한 번만 PR을 진행합니다\n    1. 최신 커밋은 반드시 `develop`에 배포한 이력이 있어야 합니다\n4. `master` 브랜치가 업데이트되면 stg 환경에 배포됩니다\n5. `release/*` 형태로 브랜치를 생성하면 prd 환경에 배포합니다\n    1. 배포에는 팀장 이상 직책자의 승인이 필요합니다\n6. 긴급한 수정 사항이 발생하면 `hotfix` 브랜치를 생성합니다\n    1. `master` 브랜치로 PR을 진행합니다\n    2. `release/*` 브랜치에선 수정 사항을 cherry pick 합니다\n\n## 브랜치 설명\n\n| 브랜치명 | 목적 | 제약 | 비고 |\n| --- | --- | --- | --- |\n| develop | - 개발 및 테스트를 위한 브랜치입니다\n- feature 완료 후 병합되어 dev 환경에 배포되어 테스트  |  | - 차후 개발 서버를 증설하면 이름이 변경될 수 있습니다 |\n| main(master) | - 새로운 feature 브랜치 생성의 기준이 되는 브랜치입니다\n- 배포 / 새로운 feature 생성이 항상 가능해야 하기에, 안정된 상태를 유지해야 합니다 | - PR 없이 직접 업데이트할 수 없습니다\n- PR은 리뷰 및 자동화된 테스트가 완료되어야 병합할 수 있습니다 |  |\n| feature/{이슈번호 또는 기능명} | - 새로운 기능 개발을 위한 브랜치입니다 |  |  |\n| hotfix/{이슈번호 또는 버그명} | - 긴급 버그 수정을 위한 브랜치입니다 |  |  |\n| release/{날짜 또는 버전명} | - 운영 환경 배포를 위한 브랜치입니다 |  |  |\n\n## 배포 환경\n\n| 환경 | 배포 조건 | 설명 | 제약 |\n| --- | --- | --- | --- |\n| dev | `develop` 브랜치 업데이트 | 개발 테스트 환경으로, 누구나 자유롭게 사용할 수 있습니다 | 없음 |\n| stg | `master` 브랜치 업데이트 | 최종 테스트 환경으로, 안정된 코드만 배포될 수 있습니다 | 배포에 코드 리뷰가 필요합니다 |\n| prd | `release/*` 브랜치 업데이트 | 실제 운영 환경입니다 | 배포에 팀장 이상 직책자의 승인이 필요합니다 |\n\n# 개발 및 배포 프로세스\n\n## **1. 기능 개발 시작**\n\n- GitHub Issue 생성: 새로운 기능에 대한 GitHub Issue를 생성합니다.\n- master 브랜치에서 `feature/{이슈번호 또는 기능명}` 브랜치를 생성합니다. (예: feature/123-add-login)\n\n## **2. 기능 개발 완료**\n\n- `feature` 브랜치에서 기능을 개발하고 코드를 커밋합니다.\n- 커밋 메시지는 [Conventional Commits](https://www.conventionalcommits.org/) 규약을 따르는 것을 권장합니다.\n\n## **3. 개발 테스트**\n\n- `feature` 브랜치에서 수정한 내용을 develop 브랜치를 업데이트합니다.\n    - 혹은, Pull Request를 생성하고, 해당 PR에 `/deploy` 라는 comment를 추가합니다.\n    - 이때, 자동으로 개발(dev) 환경에 배포됩니다.\n- 작업한 내용이 올바르게 동작하는지 확인합니다.\n\n### Actions\n\n- 개발자: 기능이 올바르게 동작하는지 개발 서버에서 확인합니다.\n\n## **4. main에 병합**\n\n- `feature` 브랜치에서 `main` 브랜치로 Pull Request를 생성합니다.\n    - 이때, 자동으로 테스트가 수행됩니다.\n- 팀 내에서 코드에 대한 리뷰를 진행합니다.\n    - 수정할 내용이 발생하면 2번으로 돌아갑니다.\n    - 리뷰가 완료되면, Pull Request를 병합합니다.\n        - 이때, 자동으로 검증(stg) 환경에 배포됩니다.\n\n### Actions\n\n- 개발자: 코드에 대한 오너십을 가지고 리뷰에 임합니다.\n- 리뷰어: 소스코드가 main branch에 병합되어도 될만큼 안정된 코드인지 확인합니다.\n    - 필요한 경우 `/deploy` 명령어를 통해 해당 PR에 수정된 코드가 잘 동작하는지 개발 서버에서 확인합니다.\n\n## **5. 최종 테스트**\n\n- 검증(stg) 환경에서 `main` 브랜치 코드를 기반으로 최종 테스트를 진행합니다.\n    - 수정할 내용이 발생하면 2번으로 돌아갑니다.\n\n## **6. 운영 환경 배포**\n\n- `release/*` 브랜치를 테스트가 완료된 `main` 브랜치로부터 생성합니다.\n    - 이때, 운영(prd) 환경에 배포하기 위한 준비(빌드 등)가 시작됩니다.\n    - 실제 배포(Manifest repository | Storage Account 업데이트)가 이뤄지기 위해선 팀장 이상 직책자가 GitHub에서 workflow 수행을 승인해야 합니다.\n\n### Actions\n\n- 개발자: 소스코드가 올바르게 빌드되는지 확인하고, 운영 배포 이후 이상이 없는지 모니터링합니다.\n- 직책자: 코드가 빠르고 안전하게 배포될 수 있도록 확인 사항 체크 후 GitHub에서 배포를 승인합니다.\n    - 승인 절차 확인 (이미지 없음)\n        1. 팀즈 [배포 승인 알림]채널에 관련 알림이 발송됩니다.\n        2. 링크를 클릭하면 다음과 같은 화면이 보입니다.\n        `Review deployments` 버튼을 클릭해 주세요.\n        3. `Approve and deploy` 버튼을 클릭하시면 승인이 완료되고, 배포 절차가 진행됩니다.\n            \n## **7. hotfix (필요 시)**\n\n- 운영 환경에서 긴급 버그가 발생하면, GitHub Issue를 생성하고, `main` 브랜치에서 `hotfix/{이슈번호 또는 버그명}` 브랜치를 생성합니다.\n- `hotfix` 브랜치에서 버그를 수정하고 테스트합니다.\n- `hotfix` 브랜치에서 `main`브랜치로 Pull Request를 생성합니다.\n- 코드 리뷰 및 테스트를 거쳐 `main`에 병합합니다.\n- `release/*` 브랜치에 수정 사항을 cherry-pick 합니다.\n\n# 롤백\n\n## **롤백 사유**\n\n- 운영 환경에 배포된 새로운 버전에서 심각한 버그 또는 장애가 발생하여 긴급하게 이전 버전으로 복구해야 하는 경우\n- 새로운 버전의 성능이 이전 버전보다 현저히 떨어지거나, 주요 기능이 정상적으로 동작하지 않는 경우\n- 사용자로부터 심각한 불만 사항이 접수되어 긴급 조치가 필요한 경우\n\n## **롤백 절차**\n\n1. **롤백 결정:**\n    - 운영 환경의 문제 상황을 신속하게 파악하고, 롤백 여부를 결정합니다.\n    - 롤백을 결정하기 전에, 가능한 경우 hotfix를 통한 수정 가능 여부를 검토합니다.\n    - 롤백 결정 시, 관련 팀(개발, 운영, QA 등)과 충분히 협의하고, 롤백의 영향도를 분석합니다.\n2. **release 브랜치 롤백:**\n    - **이전 릴리즈 태그 확인:** GitHub Releases에서 롤백하고자 하는 버전의 태그를 찾습니다.\n    - **release 브랜치 복구:** release 브랜치를 롤백하고자 하는 버전의 태그로 리셋(reset)합니다. (GitHub UI 또는 CLI 사용)\n    - **주의:** release 브랜치에 대해 강제 푸시(--force)를 사용하므로, 신중하게 진행해야 합니다.\n3. **운영 환경 롤백:**\n    - GitHub Actions를 통해 release 브랜치에서 롤백된 코드를 운영 환경에 재배포합니다.\n    - CI/CD 파이프라인을 사용 중인 경우, 롤백된 버전의 태그를 사용하여 배포를 트리거할 수 있습니다.\n4. **master 브랜치 롤백 (선택적):**\n    - release에서 master으로의 자동 병합이 이루어진 경우, master 브랜치에도 롤백이 필요할 수 있습니다.\n    - master 브랜치를 롤백하는 것은 이후 개발에 영향을 줄 수 있으므로, 신중하게 결정해야 합니다.\n    - 일반적으로는 master 브랜치를 직접 롤백하기보다는, 문제가 된 커밋을 revert하는 새로운 커밋을 생성하여 master에 병합하는 것이 안전합니다.\n5. **롤백 공지 및 후속 조치:**\n    - 롤백을 수행한 경우, 사용자에게 롤백 사실과 사유를 공지합니다.\n    - 롤백의 원인이 된 문제를 분석하고, 재발 방지 대책을 수립합니다.\n    - develop, pre-release 브랜치에 롤백된 버전 이후의 커밋들이 있는지 확인하고, 필요한 경우 revert 또는 cherry-pick을 통해 release 브랜치와 동기화합니다.\n6. **롤백 시 고려 사항:**\n    - **데이터베이스 마이그레이션:** 새로운 버전에서 데이터베이스 스키마 변경(migration)이 이루어진 경우, 롤백 시 데이터베이스 롤백도 함께 고려해야 합니다.\n    - **데이터 유실:** 롤백으로 인해 새로운 버전에서 생성된 데이터가 유실될 수 있습니다. 롤백 전에 데이터 백업 및 복구 방안을 마련해야 합니다.\n    - **다운타임:** 롤백 과정에서 서비스 다운타임이 발생할 수 있습니다. 다운타임을 최소화하기 위한 방안을 고려해야 합니다. (e.g., 블루/그린 배포, 카나리 배포)\n    - **테스트:** 롤백 후에는 반드시 운영 환경과 동일한 환경에서 충분한 테스트를 수행하여, 롤백이 성공적으로 이루어졌는지 확인해야 합니다.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":true,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"github","css":["../../../../../styles.css"],"toc":true,"toc-depth":3,"number-sections":true,"include-in-header":[{"text":"<style>\n.custom-footer { \n  text-align: center; \n  font-size: 0.8em; \n  color: #666; \n  margin-top: 2rem; \n}\n</style>\n"}],"include-after-body":["../../../../../js.html","../../../signup.html"],"output-file":"4.git_branch_policy.html"},"language":{"toc-title-document":"목차","toc-title-website":"목차","related-formats-title":"기타 형식","related-notebooks-title":"Notebooks","source-notebooks-prefix":"원천","other-links-title":"기타 링크","code-links-title":"코드 링크","launch-dev-container-title":"Dev 컨테이너 실행","launch-binder-title":"랜치 Binder","article-notebook-label":"기사 노트북","notebook-preview-download":"노트북 다운로드","notebook-preview-download-src":"소스 다운로드","notebook-preview-back":"기사로 돌아가기","manuscript-meca-bundle":"MECA 아카이브","section-title-abstract":"초록","section-title-appendices":"부록","section-title-footnotes":"각주","section-title-references":"참고문헌","section-title-reuse":"라이센스","section-title-copyright":"저작권","section-title-citation":"인용","appendix-attribution-cite-as":"인용방법","appendix-attribution-bibtex":"BibTeX 인용:","title-block-author-single":"저자","title-block-author-plural":"저자","title-block-affiliation-single":"소속","title-block-affiliation-plural":"소속","title-block-published":"공개","title-block-modified":"Modified","title-block-keywords":"키워드","callout-tip-title":"힌트","callout-note-title":"노트","callout-warning-title":"경고","callout-important-title":"중요","callout-caution-title":"주의","code-summary":"코드","code-tools-menu-caption":"코드","code-tools-show-all-code":"전체 코드 표시","code-tools-hide-all-code":"전체 코드 숨기기","code-tools-view-source":"소스 코드 표시","code-tools-source-code":"소스 코드","tools-share":"Share","tools-download":"Download","code-line":"선","code-lines":"윤곽","copy-button-tooltip":"클립보드 복사","copy-button-tooltip-success":"복사완료!","repo-action-links-edit":"편집","repo-action-links-source":"소스코드 보기","repo-action-links-issue":"이슈 보고","back-to-top":"맨 위로","search-no-results-text":"일치 없음","search-matching-documents-text":"일치된 문서","search-copy-link-title":"검색 링크 복사","search-hide-matches-text":"추가 검색 결과 숨기기","search-more-match-text":"추가 검색결과","search-more-matches-text":"추가 검색결과","search-clear-button-title":"제거","search-text-placeholder":"","search-detached-cancel-button-title":"취소","search-submit-button-title":"검색","search-label":"검색","toggle-section":"토글 섹션","toggle-sidebar":"사이드바 전환","toggle-dark-mode":"다크 모드 전환","toggle-reader-mode":"리더 모드 전환","toggle-navigation":"탐색 전환","crossref-fig-title":"그림","crossref-tbl-title":"표","crossref-lst-title":"목록","crossref-thm-title":"정리","crossref-lem-title":"보조정리","crossref-cor-title":"따름정리","crossref-prp-title":"명제","crossref-cnj-title":"추측","crossref-def-title":"정의","crossref-exm-title":"보기","crossref-exr-title":"예제","crossref-ch-prefix":"장","crossref-apx-prefix":"부록","crossref-sec-prefix":"섹션","crossref-eq-prefix":"방정식","crossref-lof-title":"그림 목록","crossref-lot-title":"표 목록","crossref-lol-title":"코드 목록","environment-proof-title":"증명","environment-remark-title":"주석","environment-solution-title":"해답","listing-page-order-by":"정렬","listing-page-order-by-default":"디폴트","listing-page-order-by-date-asc":"날짜(오름차순)","listing-page-order-by-date-desc":"날짜(내림차순)","listing-page-order-by-number-desc":"페이지 번호(내림차순)","listing-page-order-by-number-asc":"페이지 번호(오름차순)","listing-page-field-date":"날짜","listing-page-field-title":"제목","listing-page-field-description":"설명","listing-page-field-author":"저자","listing-page-field-filename":"파일명","listing-page-field-filemodified":"갱신일","listing-page-field-subtitle":"부제목","listing-page-field-readingtime":"읽기 시간","listing-page-field-wordcount":"단어 수","listing-page-field-categories":"분류","listing-page-minutes-compact":"{0} 분","listing-page-category-all":"전체","listing-page-no-matches":"일치 없음","listing-page-words":"{0} 단어"},"metadata":{"lang":"ko","fig-responsive":true,"quarto-version":"1.4.543","theme":{"light":["cosmo","../../../../../theme.scss"],"dark":["cosmo","../../../../../theme-dark.scss"]},"code-copy":true,"grid":{"sidebar-width":"200px","body-width":"1200px","margin-width":"200px"},"comments":{"giscus":{"repo":"kmink3225/blog","category":"Blog"}},"title-block-banner":"#EDF3F9","title-block-banner-color":"black","toc-location":"right","open-graph":true,"twitter-card":true,"search":true,"date-format":"YYYY년 MM월 DD일","title":"Git Branch Policy","subtitle":"효율적인 협업을 위한 Git 브랜치 전략 가이드","description":"다양한 Git 브랜치 전략(Git Flow, GitHub Flow, GitLab Flow)을 비교 분석하고, 각 전략의 특징, 장단점, 적합한 프로젝트 유형을 설명하여 팀에 맞는 최적의 브랜치 전략 선택을 돕는다.\n","categories":["Engineering","Git"],"author":"Kwangmin Kim","date":"05/04/2023","page-layout":"full"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}