{"title":"정규표현식 기본 규칙","markdown":{"yaml":{"title":"정규표현식 기본 규칙","subtitle":"NLP에서 활용하는 정규표현식 기초","description":"자연어 처리에서 텍스트 전처리와 패턴 매칭에 필수적인 정규표현식의 기본 규칙을 알아본다.\n","categories":["NLP"],"author":"Kwangmin Kim","date":"2025-01-03","format":{"html":{"page-layout":"full","code-fold":true,"toc":true,"number-sections":true}},"draft":false},"headingText":"정규표현식 기초","containsRefs":false,"markdown":"\n\n\n## 정규표현식이란?\n\n- 토큰화같은 텍스트 전처리에 필수적으로 사용되는 도구\n- 정규표현식(Regular Expression)은 특정한 패턴을 가진 문자열을 검색, 매칭, 치환하는 데 사용되는 형식 언어\n- 자연어 처리(NLP)에서 텍스트 전처리 단계에서 중요한 도구로 활용\n\n## 기본 문자 매칭\n\n1. 일반 문자: 문자 자체를 매칭\n2. 메타 문자: 특별한 의미를 가진 문자들 (., ^, $, *, +, ? 등)\n\n## 기본 패턴 규칙\n\n1. `.`:  임의의 한 문자와 매칭\n   - 예시: `a.c`는 \"abc\", \"adc\", \"a3c\" 등과 매칭됨\n2. `^`: 문자열의 시작\n   - 예시: `^Hello`는 \"Hello World\"와 매칭되지만 \"World Hello\"와는 매칭되지 않음  \n3. `$`: 문자열의 끝\n   - 예시: `world$`는 \"Hello world\"와 매칭되지만 \"world hello\"와는 매칭되지 않음\n4. `*`: 앞의 요소가 0번 이상 반복\n   - 예시: `ab*c`는 \"ac\", \"abc\", \"abbc\", \"abbbc\" 등과 매칭됨\n5. `+`: 앞의 요소가 1번 이상 반복\n   - 예시: `ab+c`는 \"abc\", \"abbc\", \"abbbc\" 등과 매칭되지만 \"ac\"와는 매칭되지 않음\n6. `?`: 앞의 요소가 0번 또는 1번 등장\n   - 예시: `colou?r`는 \"color\"와 \"colour\" 모두와 매칭됨\n7. `{n}`: 앞의 요소가 정확히 n번 반복\n   - 예시: `a{3}`는 \"aaa\"와 매칭됨\n8. `{n,}` - 앞의 요소가 n번 이상 반복\n   - 예시: `a{2,}`는 \"aa\", \"aaa\", \"aaaa\" 등과 매칭됨\n9. `{n,m}` - 앞의 요소가 n번 이상 m번 이하 반복\n   - 예시: `a{1,3}`는 \"a\", \"aa\", \"aaa\"와 매칭됨\n\n## 문자 클래스\n\n1. `[abc]`: a, b, c 중 하나와 매칭\n   - 예시: `[abc]at`는 \"aat\", \"bat\", \"cat\"과 매칭됨\n2. `[^abc]`: ^ 문자는 문자 클래스 [ ] 내에서 사용될 때 **부정(negation)**을 의미하며, a, b, c를 제외한 문자와 매칭\n   - 예시: `[^abc]at`는 \"dat\", \"eat\", \"fat\" 등과 매칭되지만 \"aat\", \"bat\", \"cat\"과는 매칭되지 않음\n3. `[a-z]`: - 문자는 문자 클래스 [ ] 내에서 사용될 때 **범위(range)**를 의미하며, a부터 z까지의 소문자와 매칭\n   - 예시: `[a-z]oo`는 \"foo\", \"zoo\" 등과 매칭됨\n4. `[A-Z]`: A부터 Z까지의 대문자와 매칭\n   - 예시: `[A-Z]ello`는 \"Hello\", \"Jello\" 등과 매칭됨\n5. `[0-9]` - 숫자와 매칭\n   - 예시: `page[0-9]`는 \"page0\", \"page1\" 등과 매칭됨\n6. `[_]`: 문자 클래스 [ ] 내에서 사용될 때 **문자 클래스**를 의미하며, 언더바(_)와 매칭\n   - 예시\n    ```python\n    import re\n    # [^a-zA-Z0-9_] 패턴은 영문자, 숫자, 언더스코어를 제외한 모든 문자와 일치\n    text = \"Hello_world! This-is a sample@123.\"\n    cleaned = re.sub(r'[^a-zA-Z0-9_]', ' ', text) # 특수문자만 공백으로 됨\n    print(cleaned)  # \"Hello_world  This is a sample 123 \"\n\n## 미리 정의된 문자 클래스\n\n1. `\\d` - 숫자와 매칭 (=[0-9])\n   - 예시: `\\d\\d\\d`는 \"123\", \"456\" 등 세 자리 숫자와 매칭됨\n2. `\\D` - 숫자가 아닌 문자와 매칭 (=[^0-9])\n   - 예시: `\\D\\D\\D`는 \"abc\", \"XYZ\" 등 숫자가 아닌 세 문자와 매칭됨\n3. `\\w` - 단어 문자와 매칭 (=[a-zA-Z0-9_])\n   - 예시: `\\w+`는 단어 문자가 1회 이상 반복되어야 한다.\n   - \"hello123\", \"Python_3\", \"user_name\", \"variable42\", \"data_science2023\" 등과 매칭됨\n   - 예시:\n     ```python\n     import re\n     text = \"hello123 @special! Python_3\"\n     words = re.findall(r'\\w+', text)\n     print(words)  # ['hello123', 'Python_3']\n     ```\n4. `\\W` - 단어 문자가 아닌 문자와 매칭\n   - 예시: `\\W+`는 \"!@#\", \" \" 등과 매칭됨\n5. `\\s` - 공백 문자와 매칭 (스페이스, 탭, 줄바꿈 등)\n   - 예시: `hello\\sworld`는 \"hello world\"와 매칭됨\n6. `\\S` - 공백이 아닌 문자와 매칭\n   - 예시: `\\S+`는 \"hello\", \"world\" 등 공백이 없는 문자열과 매칭됨\n\n## 그룹과 참조\n\n1. `(...)` - 그룹화 및 캡처\n   - 예시: `(ab)+`는 \"ab\", \"abab\", \"ababab\" 등과 매칭됨\n   - 예시: `(a+b+)`는 \"ab\", \"aab\", \"abb\", \"aaabbb\" 등 a가 하나 이상, b가 하나 이상 연속된 패턴과 매칭됨\n   - 예시: `(a{2}b{2})`는 \"aabb\"와 같이 정확히 a가 2번, b가 2번 반복되는 패턴과 매칭됨\n   - 예시: `(a{2,3}b{2,3})`는 \"aabb\", \"aaabb\", \"aabbb\", \"aaabbb\" 등 a가 2~3번, b가 2~3번 반복되는 패턴과 매칭됨\n2. `(?:...)` - 그룹화만 하고 캡처하지 않음 (non-capturing group)\n   - 일반 그룹 `(...)`은 패턴을 그룹화하고 매칭된 부분을 메모리에 저장(캡처)함\n   - 반면 `(?:...)`는 패턴을 그룹화하지만 매칭된 부분을 메모리에 저장하지 않음\n   - 단순히 패턴을 묶어서 처리하고 싶을 때 사용하며, 나중에 참조할 필요가 없을 때 메모리 효율을 위해 사용함\n   - 예시: `(?:ab)+c`는 \"abc\", \"ababc\", \"abababc\" 등과 매칭됨\n   - 예시: `(?:ab)+`는 \"ab\"가 1회 이상 반복됨\n   - 예시: `(?:ab)+c`는 \"ab\"가 1회 이상 반복된 후 \"c\"가 오는 패턴\n   - 예시: `ab`는 정확히 \"ab\"라는 문자열과 매칭\n   - 예시: `(ab)`는 \"ab\"를 하나의 단위로 그룹화하고 캡처함\n   - 예시: `(ab)+c`는 \"ab\"가 1회 이상 반복된 후 \"c\"가 오는 패턴\n   - 주요 차이점:\n     1. **패턴 자체의 차이**:\n        - `(?:ab)+`: \"ab\"의 반복만 매치\n        - `(ab)+c`: \"ab\"의 반복 + \"c\"를 매치\n     2. **캡처 여부**:\n        - `(?:ab)+`: 비캡처 그룹이므로 매치된 내용을 캡처하지 않음\n        - `(ab)+c`: 캡처 그룹이므로 마지막으로 매치된 \"ab\"를 캡처함\n     3. **매치되는 문자열**:\n        - `(?:ab)+`: \"ab\", \"abab\", \"ababab\"...\n        - `(ab)+c`: \"abc\", \"ababc\", \"abababc\"...\n\n    ```python\n    import re\n\n    pattern = r'(?:ab)+'\n    strings = ['ab', 'abab', 'ababab', 'a', 'abc']\n\n    for s in strings:\n        match = re.fullmatch(pattern, s)\n        if match:\n            print(f\"'{s}' 매치됨\")\n            print(f\"  그룹: {match.groups()}\")  # 빈 튜플 () - 캡처된 그룹 없음\n        else:\n            print(f\"'{s}' 매치되지 않음\")\n    # 결과\n    # 'ab' 매치됨\n    #   그룹: ()\n    # 'abab' 매치됨\n    #   그룹: ()\n    # 'ababab' 매치됨\n    #   그룹: ()\n    # 'a' 매치되지 않음\n    # 'abc' 매치되지 않음\n\n    pattern = r'(ab)+c'\n    strings = ['abc', 'ababc', 'abababc', 'ab', 'c']\n\n    for s in strings:\n        match = re.fullmatch(pattern, s)\n        if match:\n            print(f\"'{s}' 매치됨\")\n            print(f\"  그룹: {match.groups()}\")  # ('ab',) - 마지막 'ab'가 캡처됨\n        else:\n            print(f\"'{s}' 매치되지 않음\")\n    \n    # 결과:\n    # \n    # 'abc' 매치됨\n    #   그룹: ('ab',)\n    # 'ababc' 매치됨\n    #   그룹: ('ab',)\n    # 'abababc' 매치됨\n    #   그룹: ('ab',)\n    # 'ab' 매치되지 않음\n    # 'c' 매치되지 않음\n    ```\n\n3. `\\1, \\2, ...` - 이전에 캡처된 그룹을 참조하는 역참조(backreference) 기능\n   - \\1: 첫 번째 캡처 그룹과 동일한 내용을 의미\n   - \\2: 두 번째 캡처 그룹과 동일한 내용을 의미\n   - \\3: 세 번째 캡처 그룹과 동일한 내용을 의미\n   - 예시: `(\\w+) \\1`는   \n      - 첫 번째 캡처 그룹(단어)이 그대로 반복되는 패턴\n      - 매치됨: \"hello hello\", \"python python\"\n      - 매치되지 않음: \"hello world\", \"python java\"\n   - 예시: `(\\w+) (\\w+) \\2`는\n      - 첫 번째 단어 다음에 두 번째 단어가 나오고, 그 다음에 두 번째 단어가 반복되는 패턴\n      - 매치됨: \"hello world world\", \"python java java\"\n      - 매치되지 않음: \"hello hello world\", \"python python java\"\n   - 예시: `(\\w+) (\\w+) (\\w+) \\3`는\n      - 세 개의 단어가 나오고, 그 다음에 세 번째 단어가 반복되는 패턴\n      - 매치됨: \"apple banana cherry cherry\", \"one two three three\"\n      - 매치되지 않음: \"apple banana cherry banana\", \"one two three one\"\n## 경계 매칭\n\n1. `\\b`: 단어 경계\n   - 예시: `\\bcat\\b`는 \"The cat sat\" 문장에서 \"cat\"과 매칭되지만 \"category\"의 일부와는 매칭되지 않음\n2. `\\B`: 단어 경계가 아닌 위치\n   - 예시: `\\Bcat\\B`는 \"location\"의 \"cat\"과 매칭되지만 독립된 단어 \"cat\"과는 매칭되지 않음\n\n## 선택과 대안\n\n1. `|` - 대안 패턴 (OR 연산자)\n   - 예시: `cat|dog`는 \"cat\"과 \"dog\" 모두와 매칭됨\n### NLP에서의 정규표현식 활용 예시\n\n- 정규표현식은 자연어 처리(NLP)에서 다양한 텍스트 전처리 및 정보 추출 작업에 활용\n\n#### 이메일 주소 추출\n\n```python\nimport re\n\ntext = \"연락처: john.doe@example.com, support@company.co.kr, help-desk@org.net\"\n\n# 이메일 패턴\nemail_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n\n# 모든 이메일 주소 추출\nemails = re.findall(email_pattern, text)\nprint(emails)\n# 출력: ['john.doe@example.com', 'support@company.co.kr', 'help-desk@org.net']\n```\n\n#### URL 추출\n\n```python\nimport re\n\ntext = \"참고 링크는 https://example.com/page, http://test.co.kr 그리고 www.resources.org/docs 입니다.\"\n\n# URL 패턴\nurl_pattern = r'https?://[^\\s]+|www\\.[^\\s]+'\n\n# 모든 URL 추출\nurls = re.findall(url_pattern, text)\nprint(urls)\n# 출력: ['https://example.com/page', 'http://test.co.kr', 'www.resources.org/docs']\n```\n\n#### 문장 토큰화\n\n```python\nimport re\n\ntext = \"안녕하세요. 정규표현식을 배우고 있습니다! 어렵지만 유용하죠? 화이팅...\"\n\n# 문장 경계 패턴 (마침표, 느낌표, 물음표 뒤에 공백)\nsentence_pattern = r'[.!?]+\\s+'\n\n# 문장으로 분리\nsentences = re.split(sentence_pattern, text)\nprint(sentences)\n# 출력: ['안녕하세요', '정규표현식을 배우고 있습니다', '어렵지만 유용하죠', '화이팅...']\n```\n\n#### 해시태그 추출 (소셜 미디어 분석)\n\n```python\nimport re\n\ntweet = \"오늘 날씨가 좋네요 #날씨 #봄 #산책 @친구 같이 가자!\"\n\n# 해시태그 패턴\nhashtag_pattern = r'#\\w+'\n\n# 모든 해시태그 추출\nhashtags = re.findall(hashtag_pattern, tweet)\nprint(hashtags)\n# 출력: ['#날씨', '#봄', '#산책']\n```\n\n#### 날짜 형식 표준화\n\n```python\nimport re\n\ndates = [\n    \"2023-05-15\", \n    \"05/15/2023\", \n    \"15.05.2023\",\n    \"May 15, 2023\"\n]\n\n# 다양한 날짜 패턴 처리\nfor date in dates:\n    # YYYY-MM-DD 패턴\n    if re.match(r'^\\d{4}-\\d{2}-\\d{2}$', date):\n        print(f\"{date} -> 이미 표준 형식\")\n    \n    # MM/DD/YYYY 패턴\n    elif re.match(r'^\\d{2}/\\d{2}/\\d{4}$', date):\n        m, d, y = re.findall(r'(\\d{2})/(\\d{2})/(\\d{4})', date)[0]\n        print(f\"{date} -> {y}-{m}-{d}\")\n    \n    # DD.MM.YYYY 패턴\n    elif re.match(r'^\\d{2}\\.\\d{2}\\.\\d{4}$', date):\n        d, m, y = re.findall(r'(\\d{2})\\.(\\d{2})\\.(\\d{4})', date)[0]\n        print(f\"{date} -> {y}-{m}-{d}\")\n    \n    # 월 이름 패턴\n    elif re.match(r'^[A-Za-z]+ \\d{1,2}, \\d{4}$', date):\n        month_names = {\"January\": \"01\", \"February\": \"02\", \"March\": \"03\", \"April\": \"04\", \n                      \"May\": \"05\", \"June\": \"06\", \"July\": \"07\", \"August\": \"08\", \n                      \"September\": \"09\", \"October\": \"10\", \"November\": \"11\", \"December\": \"12\"}\n        \n        match = re.match(r'^([A-Za-z]+) (\\d{1,2}), (\\d{4})$', date)\n        if match:\n            month, day, year = match.groups()\n            month_num = month_names.get(month, \"00\")\n            day = day.zfill(2)  # 한 자리 숫자면 앞에 0 추가\n            print(f\"{date} -> {year}-{month_num}-{day}\")\n```\n\n#### 개체명 추출\n\n- 간단한 규칙 기반으로 정확한 원하는 답을 얻을 순 없지만 규칙을 정밀하게 보완하면 어느 정도 후보군을 추릴 수 있다.\n- 이런 규칙 기반의 텍스트 추출을 할 때 정규표현식이 필수적으로 사용된다.)\n- 예를 들어 아래의 인명을 추출하는 것은 다음과 같은 추가 조건을 추가하면 좋다.\n  - 사전 기반 접근법: 흔한 한국 성씨 목록을 사용해 필터링\n  - 문맥 분석: 이름 앞뒤로 나오는 \"씨\", \"님\", \"대표\" 등의 호칭 고려\n  - 기계학습 방식 (ex.NER, Named Entity Recognition 모델 사용)\n\n```python\nimport re\n\ntext = \"\"\"\n김철수 대표는 삼성전자에서 5년간 근무했으며, 현재 서울특별시 강남구에 거주 중입니다.\n그는 한국대학교를 졸업했고, 현재 7,500,000원의 월급을 받고 있습니다.\n\"\"\"\n\n# 인명 패턴 (성+이름) : 성이 2~4글자, 이름이 2~4글자 또는 2~5글자\nperson_pattern = r'[가-힣]{2,4}\\s[가-힣]{2,4}|[가-힣]{2,5}'\npersons = re.findall(person_pattern, text)\nprint(\"인명:\", persons) # 인명: ['김철수', '대표는', '현재', '서울특별시', '강남구에', '거주', '현재']\n\n# 기관명 패턴\norg_pattern = r'[가-힣a-zA-Z0-9]+[대학교|회사|전자|은행|그룹]'\norgs = re.findall(org_pattern, text)\nprint(\"기관:\", orgs)\n\n# 금액 패턴\nmoney_pattern = r'[0-9,]+원'\nmoney = re.findall(money_pattern, text)\nprint(\"금액:\", money)\n\n# 지역 패턴\nlocation_pattern = r'[가-힣]+[시|도|군|구](\\s[가-힣]+[시|도|군|구])?'\nlocations = re.findall(location_pattern, text)\nprint(\"지역:\", locations)\n```\n\n#### 텍스트 정제 (HTML 태그 제거)\n\n```python\nimport re\n\nhtml = \"<p>안녕하세요. <b>정규표현식</b>으로 <span style='color:red'>HTML 태그</span>를 제거합니다.</p>\"\n\n# HTML 태그 제거 패턴\nclean_text = re.sub(r'<[^>]+>', '', html)\nprint(clean_text)\n# 출력: 안녕하세요. 정규표현식으로 HTML 태그를 제거합니다.\n```\n\n#### 특수문자 정규화\n\n```python\nimport re\n\ntext = \"텍스트 정제 작업: 특수문자(!@#$%^&*)를 제거하거나 변환합니다.\"\n\n# 특수문자 제거\nclean_text = re.sub(r'[^\\w\\s]', '', text)\nprint(clean_text)\n# 출력: 텍스트 정제 작업 특수문자를 제거하거나 변환합니다\n```\n\n#### 단어 빈도 분석\n\n```python\nimport re\nfrom collections import Counter\n\ntext = \"\"\"\n자연어 처리(NLP)는 컴퓨터가 인간의 언어를 이해하고 처리하는 기술입니다.\n자연어 처리는 텍스트 분석, 기계 번역, 감성 분석 등 다양한 분야에 활용됩니다.\n\"\"\"\n\n# 단어 추출 (한글, 영문, 숫자)\nwords = re.findall(r'\\b[가-힣a-zA-Z0-9]+\\b', text)\nword_counts = Counter(words)\nprint(word_counts.most_common(5))\n```\n\n#### 전화번호 추출 및 정규화\n\n```python\nimport re\n\ntext = \"연락처 목록: 010-1234-5678, 02)987-6543, 01099998888, +82-10-5555-1234\"\n\n# 전화번호 패턴\nphone_pattern = r'(\\+\\d{1,3}[-\\s]?)?(\\d{2,3}[-\\)\\s]?)?(\\d{3,4}[-\\s]?)(\\d{4})'\nphones = re.findall(phone_pattern, text)\n\n# 전화번호 정규화\nnormalized_phones = []\nfor phone in phones:\n    country, area, first, last = phone\n    normalized = f\"{area.replace(')', '')}-{first.replace('-', '')}-{last}\"\n    normalized_phones.append(normalized)\n\nprint(normalized_phones)\n# 출력: ['010-1234-5678', '02-987-6543', '010-9999-8888', '10-5555-1234']\n```\n\n- 이러한 정규표현식 활용은 NLP 파이프라인의 전처리 단계에서 텍스트 정제, 토큰화, 정보 추출에 매우 유용하다\n- 하지만 복잡한 언어 패턴 분석에는 한계가 있어 고급 NLP 작업에는 딥러닝 모델과 함께 사용되는 경우가 많다.","srcMarkdownNoYaml":"\n\n# 정규표현식 기초\n\n## 정규표현식이란?\n\n- 토큰화같은 텍스트 전처리에 필수적으로 사용되는 도구\n- 정규표현식(Regular Expression)은 특정한 패턴을 가진 문자열을 검색, 매칭, 치환하는 데 사용되는 형식 언어\n- 자연어 처리(NLP)에서 텍스트 전처리 단계에서 중요한 도구로 활용\n\n## 기본 문자 매칭\n\n1. 일반 문자: 문자 자체를 매칭\n2. 메타 문자: 특별한 의미를 가진 문자들 (., ^, $, *, +, ? 등)\n\n## 기본 패턴 규칙\n\n1. `.`:  임의의 한 문자와 매칭\n   - 예시: `a.c`는 \"abc\", \"adc\", \"a3c\" 등과 매칭됨\n2. `^`: 문자열의 시작\n   - 예시: `^Hello`는 \"Hello World\"와 매칭되지만 \"World Hello\"와는 매칭되지 않음  \n3. `$`: 문자열의 끝\n   - 예시: `world$`는 \"Hello world\"와 매칭되지만 \"world hello\"와는 매칭되지 않음\n4. `*`: 앞의 요소가 0번 이상 반복\n   - 예시: `ab*c`는 \"ac\", \"abc\", \"abbc\", \"abbbc\" 등과 매칭됨\n5. `+`: 앞의 요소가 1번 이상 반복\n   - 예시: `ab+c`는 \"abc\", \"abbc\", \"abbbc\" 등과 매칭되지만 \"ac\"와는 매칭되지 않음\n6. `?`: 앞의 요소가 0번 또는 1번 등장\n   - 예시: `colou?r`는 \"color\"와 \"colour\" 모두와 매칭됨\n7. `{n}`: 앞의 요소가 정확히 n번 반복\n   - 예시: `a{3}`는 \"aaa\"와 매칭됨\n8. `{n,}` - 앞의 요소가 n번 이상 반복\n   - 예시: `a{2,}`는 \"aa\", \"aaa\", \"aaaa\" 등과 매칭됨\n9. `{n,m}` - 앞의 요소가 n번 이상 m번 이하 반복\n   - 예시: `a{1,3}`는 \"a\", \"aa\", \"aaa\"와 매칭됨\n\n## 문자 클래스\n\n1. `[abc]`: a, b, c 중 하나와 매칭\n   - 예시: `[abc]at`는 \"aat\", \"bat\", \"cat\"과 매칭됨\n2. `[^abc]`: ^ 문자는 문자 클래스 [ ] 내에서 사용될 때 **부정(negation)**을 의미하며, a, b, c를 제외한 문자와 매칭\n   - 예시: `[^abc]at`는 \"dat\", \"eat\", \"fat\" 등과 매칭되지만 \"aat\", \"bat\", \"cat\"과는 매칭되지 않음\n3. `[a-z]`: - 문자는 문자 클래스 [ ] 내에서 사용될 때 **범위(range)**를 의미하며, a부터 z까지의 소문자와 매칭\n   - 예시: `[a-z]oo`는 \"foo\", \"zoo\" 등과 매칭됨\n4. `[A-Z]`: A부터 Z까지의 대문자와 매칭\n   - 예시: `[A-Z]ello`는 \"Hello\", \"Jello\" 등과 매칭됨\n5. `[0-9]` - 숫자와 매칭\n   - 예시: `page[0-9]`는 \"page0\", \"page1\" 등과 매칭됨\n6. `[_]`: 문자 클래스 [ ] 내에서 사용될 때 **문자 클래스**를 의미하며, 언더바(_)와 매칭\n   - 예시\n    ```python\n    import re\n    # [^a-zA-Z0-9_] 패턴은 영문자, 숫자, 언더스코어를 제외한 모든 문자와 일치\n    text = \"Hello_world! This-is a sample@123.\"\n    cleaned = re.sub(r'[^a-zA-Z0-9_]', ' ', text) # 특수문자만 공백으로 됨\n    print(cleaned)  # \"Hello_world  This is a sample 123 \"\n\n## 미리 정의된 문자 클래스\n\n1. `\\d` - 숫자와 매칭 (=[0-9])\n   - 예시: `\\d\\d\\d`는 \"123\", \"456\" 등 세 자리 숫자와 매칭됨\n2. `\\D` - 숫자가 아닌 문자와 매칭 (=[^0-9])\n   - 예시: `\\D\\D\\D`는 \"abc\", \"XYZ\" 등 숫자가 아닌 세 문자와 매칭됨\n3. `\\w` - 단어 문자와 매칭 (=[a-zA-Z0-9_])\n   - 예시: `\\w+`는 단어 문자가 1회 이상 반복되어야 한다.\n   - \"hello123\", \"Python_3\", \"user_name\", \"variable42\", \"data_science2023\" 등과 매칭됨\n   - 예시:\n     ```python\n     import re\n     text = \"hello123 @special! Python_3\"\n     words = re.findall(r'\\w+', text)\n     print(words)  # ['hello123', 'Python_3']\n     ```\n4. `\\W` - 단어 문자가 아닌 문자와 매칭\n   - 예시: `\\W+`는 \"!@#\", \" \" 등과 매칭됨\n5. `\\s` - 공백 문자와 매칭 (스페이스, 탭, 줄바꿈 등)\n   - 예시: `hello\\sworld`는 \"hello world\"와 매칭됨\n6. `\\S` - 공백이 아닌 문자와 매칭\n   - 예시: `\\S+`는 \"hello\", \"world\" 등 공백이 없는 문자열과 매칭됨\n\n## 그룹과 참조\n\n1. `(...)` - 그룹화 및 캡처\n   - 예시: `(ab)+`는 \"ab\", \"abab\", \"ababab\" 등과 매칭됨\n   - 예시: `(a+b+)`는 \"ab\", \"aab\", \"abb\", \"aaabbb\" 등 a가 하나 이상, b가 하나 이상 연속된 패턴과 매칭됨\n   - 예시: `(a{2}b{2})`는 \"aabb\"와 같이 정확히 a가 2번, b가 2번 반복되는 패턴과 매칭됨\n   - 예시: `(a{2,3}b{2,3})`는 \"aabb\", \"aaabb\", \"aabbb\", \"aaabbb\" 등 a가 2~3번, b가 2~3번 반복되는 패턴과 매칭됨\n2. `(?:...)` - 그룹화만 하고 캡처하지 않음 (non-capturing group)\n   - 일반 그룹 `(...)`은 패턴을 그룹화하고 매칭된 부분을 메모리에 저장(캡처)함\n   - 반면 `(?:...)`는 패턴을 그룹화하지만 매칭된 부분을 메모리에 저장하지 않음\n   - 단순히 패턴을 묶어서 처리하고 싶을 때 사용하며, 나중에 참조할 필요가 없을 때 메모리 효율을 위해 사용함\n   - 예시: `(?:ab)+c`는 \"abc\", \"ababc\", \"abababc\" 등과 매칭됨\n   - 예시: `(?:ab)+`는 \"ab\"가 1회 이상 반복됨\n   - 예시: `(?:ab)+c`는 \"ab\"가 1회 이상 반복된 후 \"c\"가 오는 패턴\n   - 예시: `ab`는 정확히 \"ab\"라는 문자열과 매칭\n   - 예시: `(ab)`는 \"ab\"를 하나의 단위로 그룹화하고 캡처함\n   - 예시: `(ab)+c`는 \"ab\"가 1회 이상 반복된 후 \"c\"가 오는 패턴\n   - 주요 차이점:\n     1. **패턴 자체의 차이**:\n        - `(?:ab)+`: \"ab\"의 반복만 매치\n        - `(ab)+c`: \"ab\"의 반복 + \"c\"를 매치\n     2. **캡처 여부**:\n        - `(?:ab)+`: 비캡처 그룹이므로 매치된 내용을 캡처하지 않음\n        - `(ab)+c`: 캡처 그룹이므로 마지막으로 매치된 \"ab\"를 캡처함\n     3. **매치되는 문자열**:\n        - `(?:ab)+`: \"ab\", \"abab\", \"ababab\"...\n        - `(ab)+c`: \"abc\", \"ababc\", \"abababc\"...\n\n    ```python\n    import re\n\n    pattern = r'(?:ab)+'\n    strings = ['ab', 'abab', 'ababab', 'a', 'abc']\n\n    for s in strings:\n        match = re.fullmatch(pattern, s)\n        if match:\n            print(f\"'{s}' 매치됨\")\n            print(f\"  그룹: {match.groups()}\")  # 빈 튜플 () - 캡처된 그룹 없음\n        else:\n            print(f\"'{s}' 매치되지 않음\")\n    # 결과\n    # 'ab' 매치됨\n    #   그룹: ()\n    # 'abab' 매치됨\n    #   그룹: ()\n    # 'ababab' 매치됨\n    #   그룹: ()\n    # 'a' 매치되지 않음\n    # 'abc' 매치되지 않음\n\n    pattern = r'(ab)+c'\n    strings = ['abc', 'ababc', 'abababc', 'ab', 'c']\n\n    for s in strings:\n        match = re.fullmatch(pattern, s)\n        if match:\n            print(f\"'{s}' 매치됨\")\n            print(f\"  그룹: {match.groups()}\")  # ('ab',) - 마지막 'ab'가 캡처됨\n        else:\n            print(f\"'{s}' 매치되지 않음\")\n    \n    # 결과:\n    # \n    # 'abc' 매치됨\n    #   그룹: ('ab',)\n    # 'ababc' 매치됨\n    #   그룹: ('ab',)\n    # 'abababc' 매치됨\n    #   그룹: ('ab',)\n    # 'ab' 매치되지 않음\n    # 'c' 매치되지 않음\n    ```\n\n3. `\\1, \\2, ...` - 이전에 캡처된 그룹을 참조하는 역참조(backreference) 기능\n   - \\1: 첫 번째 캡처 그룹과 동일한 내용을 의미\n   - \\2: 두 번째 캡처 그룹과 동일한 내용을 의미\n   - \\3: 세 번째 캡처 그룹과 동일한 내용을 의미\n   - 예시: `(\\w+) \\1`는   \n      - 첫 번째 캡처 그룹(단어)이 그대로 반복되는 패턴\n      - 매치됨: \"hello hello\", \"python python\"\n      - 매치되지 않음: \"hello world\", \"python java\"\n   - 예시: `(\\w+) (\\w+) \\2`는\n      - 첫 번째 단어 다음에 두 번째 단어가 나오고, 그 다음에 두 번째 단어가 반복되는 패턴\n      - 매치됨: \"hello world world\", \"python java java\"\n      - 매치되지 않음: \"hello hello world\", \"python python java\"\n   - 예시: `(\\w+) (\\w+) (\\w+) \\3`는\n      - 세 개의 단어가 나오고, 그 다음에 세 번째 단어가 반복되는 패턴\n      - 매치됨: \"apple banana cherry cherry\", \"one two three three\"\n      - 매치되지 않음: \"apple banana cherry banana\", \"one two three one\"\n## 경계 매칭\n\n1. `\\b`: 단어 경계\n   - 예시: `\\bcat\\b`는 \"The cat sat\" 문장에서 \"cat\"과 매칭되지만 \"category\"의 일부와는 매칭되지 않음\n2. `\\B`: 단어 경계가 아닌 위치\n   - 예시: `\\Bcat\\B`는 \"location\"의 \"cat\"과 매칭되지만 독립된 단어 \"cat\"과는 매칭되지 않음\n\n## 선택과 대안\n\n1. `|` - 대안 패턴 (OR 연산자)\n   - 예시: `cat|dog`는 \"cat\"과 \"dog\" 모두와 매칭됨\n### NLP에서의 정규표현식 활용 예시\n\n- 정규표현식은 자연어 처리(NLP)에서 다양한 텍스트 전처리 및 정보 추출 작업에 활용\n\n#### 이메일 주소 추출\n\n```python\nimport re\n\ntext = \"연락처: john.doe@example.com, support@company.co.kr, help-desk@org.net\"\n\n# 이메일 패턴\nemail_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n\n# 모든 이메일 주소 추출\nemails = re.findall(email_pattern, text)\nprint(emails)\n# 출력: ['john.doe@example.com', 'support@company.co.kr', 'help-desk@org.net']\n```\n\n#### URL 추출\n\n```python\nimport re\n\ntext = \"참고 링크는 https://example.com/page, http://test.co.kr 그리고 www.resources.org/docs 입니다.\"\n\n# URL 패턴\nurl_pattern = r'https?://[^\\s]+|www\\.[^\\s]+'\n\n# 모든 URL 추출\nurls = re.findall(url_pattern, text)\nprint(urls)\n# 출력: ['https://example.com/page', 'http://test.co.kr', 'www.resources.org/docs']\n```\n\n#### 문장 토큰화\n\n```python\nimport re\n\ntext = \"안녕하세요. 정규표현식을 배우고 있습니다! 어렵지만 유용하죠? 화이팅...\"\n\n# 문장 경계 패턴 (마침표, 느낌표, 물음표 뒤에 공백)\nsentence_pattern = r'[.!?]+\\s+'\n\n# 문장으로 분리\nsentences = re.split(sentence_pattern, text)\nprint(sentences)\n# 출력: ['안녕하세요', '정규표현식을 배우고 있습니다', '어렵지만 유용하죠', '화이팅...']\n```\n\n#### 해시태그 추출 (소셜 미디어 분석)\n\n```python\nimport re\n\ntweet = \"오늘 날씨가 좋네요 #날씨 #봄 #산책 @친구 같이 가자!\"\n\n# 해시태그 패턴\nhashtag_pattern = r'#\\w+'\n\n# 모든 해시태그 추출\nhashtags = re.findall(hashtag_pattern, tweet)\nprint(hashtags)\n# 출력: ['#날씨', '#봄', '#산책']\n```\n\n#### 날짜 형식 표준화\n\n```python\nimport re\n\ndates = [\n    \"2023-05-15\", \n    \"05/15/2023\", \n    \"15.05.2023\",\n    \"May 15, 2023\"\n]\n\n# 다양한 날짜 패턴 처리\nfor date in dates:\n    # YYYY-MM-DD 패턴\n    if re.match(r'^\\d{4}-\\d{2}-\\d{2}$', date):\n        print(f\"{date} -> 이미 표준 형식\")\n    \n    # MM/DD/YYYY 패턴\n    elif re.match(r'^\\d{2}/\\d{2}/\\d{4}$', date):\n        m, d, y = re.findall(r'(\\d{2})/(\\d{2})/(\\d{4})', date)[0]\n        print(f\"{date} -> {y}-{m}-{d}\")\n    \n    # DD.MM.YYYY 패턴\n    elif re.match(r'^\\d{2}\\.\\d{2}\\.\\d{4}$', date):\n        d, m, y = re.findall(r'(\\d{2})\\.(\\d{2})\\.(\\d{4})', date)[0]\n        print(f\"{date} -> {y}-{m}-{d}\")\n    \n    # 월 이름 패턴\n    elif re.match(r'^[A-Za-z]+ \\d{1,2}, \\d{4}$', date):\n        month_names = {\"January\": \"01\", \"February\": \"02\", \"March\": \"03\", \"April\": \"04\", \n                      \"May\": \"05\", \"June\": \"06\", \"July\": \"07\", \"August\": \"08\", \n                      \"September\": \"09\", \"October\": \"10\", \"November\": \"11\", \"December\": \"12\"}\n        \n        match = re.match(r'^([A-Za-z]+) (\\d{1,2}), (\\d{4})$', date)\n        if match:\n            month, day, year = match.groups()\n            month_num = month_names.get(month, \"00\")\n            day = day.zfill(2)  # 한 자리 숫자면 앞에 0 추가\n            print(f\"{date} -> {year}-{month_num}-{day}\")\n```\n\n#### 개체명 추출\n\n- 간단한 규칙 기반으로 정확한 원하는 답을 얻을 순 없지만 규칙을 정밀하게 보완하면 어느 정도 후보군을 추릴 수 있다.\n- 이런 규칙 기반의 텍스트 추출을 할 때 정규표현식이 필수적으로 사용된다.)\n- 예를 들어 아래의 인명을 추출하는 것은 다음과 같은 추가 조건을 추가하면 좋다.\n  - 사전 기반 접근법: 흔한 한국 성씨 목록을 사용해 필터링\n  - 문맥 분석: 이름 앞뒤로 나오는 \"씨\", \"님\", \"대표\" 등의 호칭 고려\n  - 기계학습 방식 (ex.NER, Named Entity Recognition 모델 사용)\n\n```python\nimport re\n\ntext = \"\"\"\n김철수 대표는 삼성전자에서 5년간 근무했으며, 현재 서울특별시 강남구에 거주 중입니다.\n그는 한국대학교를 졸업했고, 현재 7,500,000원의 월급을 받고 있습니다.\n\"\"\"\n\n# 인명 패턴 (성+이름) : 성이 2~4글자, 이름이 2~4글자 또는 2~5글자\nperson_pattern = r'[가-힣]{2,4}\\s[가-힣]{2,4}|[가-힣]{2,5}'\npersons = re.findall(person_pattern, text)\nprint(\"인명:\", persons) # 인명: ['김철수', '대표는', '현재', '서울특별시', '강남구에', '거주', '현재']\n\n# 기관명 패턴\norg_pattern = r'[가-힣a-zA-Z0-9]+[대학교|회사|전자|은행|그룹]'\norgs = re.findall(org_pattern, text)\nprint(\"기관:\", orgs)\n\n# 금액 패턴\nmoney_pattern = r'[0-9,]+원'\nmoney = re.findall(money_pattern, text)\nprint(\"금액:\", money)\n\n# 지역 패턴\nlocation_pattern = r'[가-힣]+[시|도|군|구](\\s[가-힣]+[시|도|군|구])?'\nlocations = re.findall(location_pattern, text)\nprint(\"지역:\", locations)\n```\n\n#### 텍스트 정제 (HTML 태그 제거)\n\n```python\nimport re\n\nhtml = \"<p>안녕하세요. <b>정규표현식</b>으로 <span style='color:red'>HTML 태그</span>를 제거합니다.</p>\"\n\n# HTML 태그 제거 패턴\nclean_text = re.sub(r'<[^>]+>', '', html)\nprint(clean_text)\n# 출력: 안녕하세요. 정규표현식으로 HTML 태그를 제거합니다.\n```\n\n#### 특수문자 정규화\n\n```python\nimport re\n\ntext = \"텍스트 정제 작업: 특수문자(!@#$%^&*)를 제거하거나 변환합니다.\"\n\n# 특수문자 제거\nclean_text = re.sub(r'[^\\w\\s]', '', text)\nprint(clean_text)\n# 출력: 텍스트 정제 작업 특수문자를 제거하거나 변환합니다\n```\n\n#### 단어 빈도 분석\n\n```python\nimport re\nfrom collections import Counter\n\ntext = \"\"\"\n자연어 처리(NLP)는 컴퓨터가 인간의 언어를 이해하고 처리하는 기술입니다.\n자연어 처리는 텍스트 분석, 기계 번역, 감성 분석 등 다양한 분야에 활용됩니다.\n\"\"\"\n\n# 단어 추출 (한글, 영문, 숫자)\nwords = re.findall(r'\\b[가-힣a-zA-Z0-9]+\\b', text)\nword_counts = Counter(words)\nprint(word_counts.most_common(5))\n```\n\n#### 전화번호 추출 및 정규화\n\n```python\nimport re\n\ntext = \"연락처 목록: 010-1234-5678, 02)987-6543, 01099998888, +82-10-5555-1234\"\n\n# 전화번호 패턴\nphone_pattern = r'(\\+\\d{1,3}[-\\s]?)?(\\d{2,3}[-\\)\\s]?)?(\\d{3,4}[-\\s]?)(\\d{4})'\nphones = re.findall(phone_pattern, text)\n\n# 전화번호 정규화\nnormalized_phones = []\nfor phone in phones:\n    country, area, first, last = phone\n    normalized = f\"{area.replace(')', '')}-{first.replace('-', '')}-{last}\"\n    normalized_phones.append(normalized)\n\nprint(normalized_phones)\n# 출력: ['010-1234-5678', '02-987-6543', '010-9999-8888', '10-5555-1234']\n```\n\n- 이러한 정규표현식 활용은 NLP 파이프라인의 전처리 단계에서 텍스트 정제, 토큰화, 정보 추출에 매우 유용하다\n- 하지만 복잡한 언어 패턴 분석에는 한계가 있어 고급 NLP 작업에는 딥러닝 모델과 함께 사용되는 경우가 많다."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"github","css":["../../../../../styles.css"],"toc":true,"toc-depth":3,"number-sections":true,"include-in-header":[{"text":"<style>\n.custom-footer { \n  text-align: center; \n  font-size: 0.8em; \n  color: #666; \n  margin-top: 2rem; \n}\n</style>\n"}],"include-after-body":["../../../../../js.html","../../../signup.html"],"output-file":"3.pre_prcs_regular_expression.html"},"language":{"toc-title-document":"목차","toc-title-website":"목차","related-formats-title":"기타 형식","related-notebooks-title":"Notebooks","source-notebooks-prefix":"원천","other-links-title":"기타 링크","code-links-title":"코드 링크","launch-dev-container-title":"Dev 컨테이너 실행","launch-binder-title":"랜치 Binder","article-notebook-label":"기사 노트북","notebook-preview-download":"노트북 다운로드","notebook-preview-download-src":"소스 다운로드","notebook-preview-back":"기사로 돌아가기","manuscript-meca-bundle":"MECA 아카이브","section-title-abstract":"초록","section-title-appendices":"부록","section-title-footnotes":"각주","section-title-references":"참고문헌","section-title-reuse":"라이센스","section-title-copyright":"저작권","section-title-citation":"인용","appendix-attribution-cite-as":"인용방법","appendix-attribution-bibtex":"BibTeX 인용:","title-block-author-single":"저자","title-block-author-plural":"저자","title-block-affiliation-single":"소속","title-block-affiliation-plural":"소속","title-block-published":"공개","title-block-modified":"Modified","title-block-keywords":"키워드","callout-tip-title":"힌트","callout-note-title":"노트","callout-warning-title":"경고","callout-important-title":"중요","callout-caution-title":"주의","code-summary":"코드","code-tools-menu-caption":"코드","code-tools-show-all-code":"전체 코드 표시","code-tools-hide-all-code":"전체 코드 숨기기","code-tools-view-source":"소스 코드 표시","code-tools-source-code":"소스 코드","tools-share":"Share","tools-download":"Download","code-line":"선","code-lines":"윤곽","copy-button-tooltip":"클립보드 복사","copy-button-tooltip-success":"복사완료!","repo-action-links-edit":"편집","repo-action-links-source":"소스코드 보기","repo-action-links-issue":"이슈 보고","back-to-top":"맨 위로","search-no-results-text":"일치 없음","search-matching-documents-text":"일치된 문서","search-copy-link-title":"검색 링크 복사","search-hide-matches-text":"추가 검색 결과 숨기기","search-more-match-text":"추가 검색결과","search-more-matches-text":"추가 검색결과","search-clear-button-title":"제거","search-text-placeholder":"","search-detached-cancel-button-title":"취소","search-submit-button-title":"검색","search-label":"검색","toggle-section":"토글 섹션","toggle-sidebar":"사이드바 전환","toggle-dark-mode":"다크 모드 전환","toggle-reader-mode":"리더 모드 전환","toggle-navigation":"탐색 전환","crossref-fig-title":"그림","crossref-tbl-title":"표","crossref-lst-title":"목록","crossref-thm-title":"정리","crossref-lem-title":"보조정리","crossref-cor-title":"따름정리","crossref-prp-title":"명제","crossref-cnj-title":"추측","crossref-def-title":"정의","crossref-exm-title":"보기","crossref-exr-title":"예제","crossref-ch-prefix":"장","crossref-apx-prefix":"부록","crossref-sec-prefix":"섹션","crossref-eq-prefix":"방정식","crossref-lof-title":"그림 목록","crossref-lot-title":"표 목록","crossref-lol-title":"코드 목록","environment-proof-title":"증명","environment-remark-title":"주석","environment-solution-title":"해답","listing-page-order-by":"정렬","listing-page-order-by-default":"디폴트","listing-page-order-by-date-asc":"날짜(오름차순)","listing-page-order-by-date-desc":"날짜(내림차순)","listing-page-order-by-number-desc":"페이지 번호(내림차순)","listing-page-order-by-number-asc":"페이지 번호(오름차순)","listing-page-field-date":"날짜","listing-page-field-title":"제목","listing-page-field-description":"설명","listing-page-field-author":"저자","listing-page-field-filename":"파일명","listing-page-field-filemodified":"갱신일","listing-page-field-subtitle":"부제목","listing-page-field-readingtime":"읽기 시간","listing-page-field-wordcount":"단어 수","listing-page-field-categories":"분류","listing-page-minutes-compact":"{0} 분","listing-page-category-all":"전체","listing-page-no-matches":"일치 없음","listing-page-words":"{0} 단어"},"metadata":{"lang":"ko","fig-responsive":true,"quarto-version":"1.4.543","theme":{"light":["cosmo","../../../../../theme.scss"],"dark":["cosmo","../../../../../theme-dark.scss"]},"code-copy":true,"grid":{"sidebar-width":"200px","body-width":"1200px","margin-width":"200px"},"comments":{"giscus":{"repo":"kmink3225/blog","category":"Blog"}},"title-block-banner":"#EDF3F9","title-block-banner-color":"black","toc-location":"right","open-graph":true,"twitter-card":true,"search":true,"date-format":"YYYY년 MM월 DD일","title":"정규표현식 기본 규칙","subtitle":"NLP에서 활용하는 정규표현식 기초","description":"자연어 처리에서 텍스트 전처리와 패턴 매칭에 필수적인 정규표현식의 기본 규칙을 알아본다.\n","categories":["NLP"],"author":"Kwangmin Kim","date":"2025-01-03","draft":false,"page-layout":"full"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}