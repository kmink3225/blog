{"title":"텍스트 벡터화: 신경망 기반 방법론","markdown":{"yaml":{"title":"텍스트 벡터화: 신경망 기반 방법론","subtitle":"Word2Vec, GloVe, FastText부터 ELMo, BERT, SBERT까지 문맥을 이해하는 벡터 표현 소개","description":"정적 임베딩의 한계를 넘어, 단어의 문맥적 의미를 동적으로 포착하는 ELMo, BERT, GPT, SBERT와 같은 주요 문맥 기반 임베딩 모델들의 원리, 특징, 혁신적인 기여를 살펴본다.\n","categories":["NLP","Deep Learning"],"author":"Kwangmin Kim","date":"2025-01-20","format":{"html":{"page-layout":"full","code-fold":true,"toc":true,"number-sections":true}},"draft":false},"headingText":"요약","containsRefs":false,"markdown":"\n\n\n이 문서는 단어의 의미가 문맥에 따라 변하는 현상을 효과적으로 다루기 위해 등장한 **동적/문맥적 임베딩(Contextualized Embedding)** 방법론을 탐구한다. 정적 임베딩의 한계를 지적하고, 이를 극복하기 위한 주요 모델들의 핵심 아이디어와 특징을 소개한다.\n\n주요 내용은 다음과 같다.\n\n*   **정적 임베딩 vs. 동적 임베딩**:\n    *   정적 임베딩(예: Word2Vec, GloVe)은 단어마다 고정된 벡터를 할당하여 문맥에 따른 의미 변화(다의성)를 포착하지 못하는 한계가 있다.\n    *   동적 임베딩은 동일한 단어라도 문맥에 따라 다른 벡터 표현을 생성하여 이러한 문제를 해결한다.\n*   **주요 문맥 기반 임베딩 모델**:\n    *   **ELMo (Embeddings from Language Models)**: 양방향 LSTM(BiLSTM)의 각 계층에서 얻은 내부 상태들을 가중합하여 문맥 정보를 풍부하게 담은 임베딩을 생성한다. 문자 단위 표현부터 시작하여 다양한 수준의 정보를 결합한다.\n    *   **BERT (Bidirectional Encoder Representations from Transformers)**: 트랜스포머(Transformer)의 인코더 구조를 활용하여 문장 내 모든 단어의 양방향 문맥을 동시에 고려한다. 'Masked Language Model(MLM)'과 'Next Sentence Prediction(NSP)'이라는 두 가지 혁신적인 사전 학습(pre-training) 목표를 통해 깊은 언어 이해 능력을 학습한다. 문서 전체의 표현으로는 `[CLS]` 토큰의 출력을 사용하거나 토큰 출력들의 풀링(pooling) 결과를 활용한다.\n    *   **SBERT (Sentence-BERT)**: BERT의 출력을 문장 수준의 의미론적 벡터로 효율적으로 변환하기 위해 Siamese 또는 Triplet 네트워크 구조를 사용한다. 이를 통해 문장 간 유사도 계산 및 대규모 검색 작업의 효율성을 크게 향상시킨다.\n    *   **GPT (Generative Pre-trained Transformer)**: 트랜스포머의 디코더 구조를 기반으로 하는 단방향(autoregressive) 언어 모델이다. 이전 단어들을 바탕으로 다음 단어를 예측하도록 학습하며, 이 과정에서 문맥을 이해하고 생성하는 능력을 키운다. 특히, 가중치 업데이트 없이 프롬프트에 몇 가지 예시(few-shot)를 제공하는 것만으로 새로운 작업을 수행하는 'In-context Learning' 능력으로 주목받았다. 문서 표현으로는 첫 번째 토큰([BOS])의 출력을 활용하기도 한다.\n*   **실용적 응용 및 평가**:\n    *   이러한 모델들은 문서 분류, 정보 검색, 질의응답, 기계 번역 등 다양한 NLP 태스크에서 혁신적인 성능 향상을 가져왔다.\n    *   모델 평가는 단어 유사도나 관계 유추 같은 내재적 평가(intrinsic evaluation)와 실제 다운스트림 태스크에서의 성능을 측정하는 외재적 평가(extrinsic evaluation)로 이루어진다.\n\n이 문서를 통해 독자는 문맥을 이해하는 동적 임베딩 기술의 발전 과정과 핵심 원리를 파악하고, 다양한 NLP 문제 해결에 이를 어떻게 활용할 수 있는지에 대한 통찰을 얻을 수 있다.\n\n# 텍스트 인코딩 및 벡터화\n\n```\n텍스트 벡터화\n├── 1. 전통적 방법 (통계 기반)\n│   ├── BoW\n│   ├── DTM\n│   └── TF-IDF\n│\n├── 2. 신경망 기반 (문맥 독립)\n│   ├── 문맥 독립적 임베딩\n│   │   └── Embedding Layer (딥러닝 모델 내 구성 요소)\n│   ├── Word2Vec (CBOW, Skip-gram)\n│   ├── FastText\n│   ├── GloVe\n│   └── 기타 모델: Swivel, LexVec 등\n│\n└── 3. 문맥 기반 임베딩 (Contextual Embedding)\n    ├── RNN 계열\n    │   ├── LSTM\n    │   ├── GRU\n    │   └── ELMo\n    └── Attention 메커니즘\n        ├── Basic Attention\n        ├── Self-Attention\n        └── Multi-Head Attention\n \nTransformer 이후 생성형 모델 발전 계열\n├── Transformer 구조 (Vaswani et al., 2017)\n├── BERT 시리즈 (Google,2018~)\n|   ├── BERT\n|   ├── RoBERTa\n|   └── ALBERT\n├── GPT 시리즈 (OpenAI,2018~)\n|   ├── GPT-1~4\n|   └── ChatGPT (OpenAI,2022~)\n├── 한국어 특화: KoBERT, KoGPT, KLU-BERT 등 (Kakao,2019~)\n└── 기타 발전 모델\n    ├── T5, XLNet, ELECTRA\n    └── PaLM, LaMDA, Gemini, Claude 등\n```\n\n## 문맥을 고려한 벡터화 (2018-현재): 동적 임베딩\n\n#### ELMo (Embedding from Language Models, 2018)\n\n* ELMo 수식: $\\text{ELMo}_k^{task} = \\gamma^{task} \\sum_{j=0}^L s_j^{task} \\mathbf{h}_{k,j}^{LM}$\n   * **$\\mathbf{h}_{k,j}^{LM}$: 각 레이어의 hidden state**\n\n   ```python\n   # 예시: 3층 BiLSTM에서 \"bank\" 단어 (k번째 위치)\n   h_{bank,0} = character_embedding(\"bank\")     # 레이어 0 (입력)\n   h_{bank,1} = first_LSTM_layer_output        # 레이어 1  \n   h_{bank,2} = second_LSTM_layer_output       # 레이어 2\n   h_{bank,3} = third_LSTM_layer_output        # 레이어 3 (최상위)\n   ```\n   * **$s_j^{task}$: 학습 가능한 가중치**\n      * 각 레이어의 중요도를 태스크별로 학습\n      * 문법적 태스크 → 낮은 레이어 중시\n      * 의미적 태스크 → 높은 레이어 중시\n   * **$\\gamma^{task}$: 전체 스케일 조정**\n      * ELMo 벡터의 전체적인 크기 조정\n* 계산 예시\n\n```python\n# \"bank\" 단어의 ELMo 벡터 (감정 분석 태스크)\nh_0 = [0.1, 0.2, 0.3]  # 문자 레벨\nh_1 = [0.4, 0.5, 0.6]  # 낮은 레벨 (문법적)  \nh_2 = [0.7, 0.8, 0.9]  # 높은 레벨 (의미적)\n\ns_0 = 0.1  # 문자 레벨 가중치 (낮음)\ns_1 = 0.3  # 문법 레벨 가중치  \ns_2 = 0.6  # 의미 레벨 가중치 (높음)\n\nELMo_bank = γ × (s_0×h_0 + s_1×h_1 + s_2×h_2)\n          = 2.0 × (0.1×[0.1,0.2,0.3] + 0.3×[0.4,0.5,0.6] + 0.6×[0.7,0.8,0.9])\n          = 2.0 × [0.55, 0.65, 0.75]\n          = [1.1, 1.3, 1.5]\n```\n\n* 양방향 정보의 중요성\n   * **Forward만 사용할 경우:**\n\n   ```\n   \"The bank was closed because of ___\"\n   → \"bank\"를 이해할 때 \"The\"만 참고\n   ```\n\n   * **Backward까지 사용할 경우:**  \n\n   ```\n   \"The bank was closed because of ___\"\n   → \"bank\"를 이해할 때 \"was closed\" 정보도 참고\n   → 금융 기관으로 해석 가능성 증가\n   ```\n\n#### BERT (Bidirectional Encoder Representations from Transformers, 2018)\n\n* 양방향 문맥 동시 고려\n   * 15% 단어를 마스킹하여 예측\n   * 문장 간 관계 학습\n* **핵심 혁신:**\n   * **Transformer 기반**: 양방향 문맥 동시 고려\n      * **기존 RNN의 한계:**\n\n         ```python\n         # RNN은 순차적 처리 (병렬화 어려움)\n         h_1 = RNN(x_1)\n         h_2 = RNN(x_2, h_1)      # h_1이 완료되어야 시작 가능\n         h_3 = RNN(x_3, h_2)      # h_2가 완료되어야 시작 가능\n         ```\n\n      * **Transformer의 장점:**\n\n         ```python\n         # 모든 위치를 동시에 처리 (병렬화 가능)\n         attention_weights = compute_attention(all_words)\n         all_representations = apply_attention(all_words, attention_weights)\n         ```\n\n   * **Masked Language Model**: 15% 단어를 마스킹하여 예측\n      * BERT의 핵심 학습 방법\n         * **기본 아이디어**: 일부 단어를 숨기고 맞추게 하기\n\n         ```python\n         # 원본 문장\n         \"나는 [MASK]를 좋아한다\"\n\n         # 모델이 학습하는 것\n         P(\"사과\" | \"나는 [MASK]를 좋아한다\") = 0.7\n         P(\"바나나\" | \"나는 [MASK]를 좋아한다\") = 0.2  \n         P(\"컴퓨터\" | \"나는 [MASK]를 좋아한다\") = 0.01\n         ```\n\n         * **15% 마스킹 전략:**\n\n         ```python\n         입력 문장의 15% 단어에 대해:\n         - 80%: [MASK] 토큰으로 교체\n         - 10%: 랜덤한 다른 단어로 교체  \n         - 10%: 원래 단어 그대로 유지\n         ```\n\n         * **왜 이렇게 하는가?**\n            ```python\n            # 80% [MASK]: 메인 학습 목적\n            \"나는 [MASK]를 좋아한다\"\n\n            # 10% 랜덤 교체: 노이즈에 강한 표현 학습\n            \"나는 컴퓨터를 좋아한다\"  # 원래는 \"사과\"\n\n            # 10% 원본 유지: 실제 사용 시와 동일한 조건\n            \"나는 사과를 좋아한다\"\n            ```\n\n   * **Next Sentence Prediction**: 문장 간 관계 학습\n   \n   ```python\n   # 실제 연속된 문장 (Positive)\n   문장A: \"나는 아침에 일어났다\"\n   문장B: \"그리고 아침 식사를 했다\"\n   Label: IsNext = True\n\n   # 랜덤하게 조합된 문장 (Negative)  \n   문장A: \"나는 아침에 일어났다\"\n   문장B: \"축구는 재미있는 스포츠다\"\n   Label: IsNext = False\n   ```\n\n* **BERT의 문서 벡터화 방법:**\n   * **[CLS] 토큰**: 문장/문서 전체 표현\n\n   ```python\n   입력: \"[CLS] 문장 내용 [SEP]\"\n   출력: [CLS]_벡터가 전체 문장의 의미를 담음\n\n   # 예시\n   input_tokens = [\"[CLS]\", \"나는\", \"사과를\", \"좋아한다\", \"[SEP]\"]\n   bert_output = bert_model(input_tokens)\n   sentence_vector = bert_output[0]  # [CLS] 위치의 벡터\n   ```\n\n   * **Pooling 전략**: \n      * Mean pooling: $\\frac{1}{n}\\sum_{i=1}^n \\mathbf{h}_i$\n      * Max pooling: $\\max(\\mathbf{h}_1, ..., \\mathbf{h}_n)$\n\n      ```python\n      # 모든 토큰의 BERT 출력\n      token_representations = [\n         [0.1, 0.2, 0.3],  # [CLS]\n         [0.4, 0.5, 0.6],  # \"나는\"  \n         [0.7, 0.8, 0.9],  # \"사과를\"\n         [0.2, 0.3, 0.4],  # \"좋아한다\"\n         [0.5, 0.6, 0.7],  # [SEP]\n      ]\n\n      # Mean Pooling\n      mean_vector = mean(token_representations[1:-1])  # [CLS], [SEP] 제외\n      = (0.4+0.7+0.2)/3, (0.5+0.8+0.3)/3, (0.6+0.9+0.4)/3\n      = [0.43, 0.53, 0.63]\n\n      # Max Pooling  \n      max_vector = max(token_representations[1:-1])  # 각 차원별 최댓값\n      = [0.7, 0.8, 0.9]\n      ```\n*   **특징**:\n    *   단어의 의미적, 문법적 정보를 벡터 공간에 학습.\n    *   벡터 간 연산을 통해 단어 간 유사도, 유추 등 관계 표현 가능 (예: \"king\" - \"man\" + \"woman\" ≈ \"queen\").\n*   **중요성**: 현대 NLP 딥러닝 모델의 핵심 구성 요소로, 성능 향상에 크게 기여.\n\n\n\n#### SBERT (Sentence-BERT)\n\n* 최근 가장 보편적인 문장 또는 문서 임베딩 방법으로 SBERT가 이용된다.\n* 문서의 유사도를 구할 때는 SBERT 사용을 권장\n* 문장 벡터화 전략\n   * 문장 간 유사도 계산\n   * 문장 간 유사도 계산 시 문장 임베딩 사용\n* 기존 BERT의 한계: 문장 유사도 계산의 비효율성\n\n   ```python\n   # 1000개 문장의 유사도를 모두 구하려면\n   sentences = [\"문장1\", \"문장2\", ..., \"문장1000\"]\n\n   # 기존 BERT 방식 (비효율적)\n   for i in range(1000):\n      for j in range(i+1, 1000):\n         combined = f\"[CLS] {sentences[i]} [SEP] {sentences[j]} [SEP]\"\n         similarity = bert_classifier(combined)  # 매번 BERT 실행\n         \n   # 총 계산 횟수: 1000 × 999 / 2 = 499,500번!\n   ```\n\n   * BERT로 문장 유사도를 계산하려면:\n      * 두 문장을 [SEP]로 연결\n      * BERT에 입력하여 분류\n      * $O(n^2)$ 시간 복잡도 (n개 문장 비교 시)\n* SBERT의 해결책: Siamese Network 구조\n\n```python\n# SBERT 방식 (효율적)\n\n문장 A → BERT → Pooling → Vector A\n문장 B → BERT → Pooling → Vector B\n유사도 = cosine_similarity(Vector A, Vector B)\n\n# 1단계: 모든 문장을 미리 벡터화\nsentence_vectors = []\nfor sentence in sentences:\n    vector = sbert_model(sentence)  # 각 문장마다 1번씩만 실행\n    sentence_vectors.append(vector)\n\n# 2단계: 벡터 간 코사인 유사도로 빠른 계산\nfor i in range(1000):\n    for j in range(i+1, 1000):\n        similarity = cosine_similarity(sentence_vectors[i], sentence_vectors[j])\n        \n# 총 SBERT 실행 횟수: 1000번 (대폭 감소!)\n```\n\n* **학습 목적 함수:**\n   * **Classification**: $\\mathcal{L} = -\\sum_{i} y_i \\log(\\text{softmax}(W[\\mathbf{u}; \\mathbf{v}; |\\mathbf{u}-\\mathbf{v}|]))$\n\n   ```python\n   # 두 문장의 SBERT 벡터\n   u = sbert(\"나는 사과를 좋아한다\")      # [0.2, 0.4, 0.1, ...]\n   v = sbert(\"나는 바나나를 좋아한다\")    # [0.3, 0.5, 0.2, ...]\n\n   # 특성 벡터 구성\n   concat = [u; v]                    # 연결: [0.2, 0.4, 0.1, 0.3, 0.5, 0.2, ...]\n   abs_diff = |u - v|                # 절댓값 차이: [0.1, 0.1, 0.1, ...]\n   features = [u; v; abs_diff]        # 최종 특성 벡터\n\n   # 분류 (유사/비유사)\n   logits = W @ features + b\n   probability = softmax(logits)\n   loss = cross_entropy(probability, true_label)\n   ```\n\n   * **Regression**: $\\mathcal{L} = \\text{MSE}(\\text{cosine\\_sim}(\\mathbf{u}, \\mathbf{v}), \\text{label})$\n   \n   ```python\n   # 예측 유사도\n   predicted_sim = cosine_similarity(u, v) = 0.85\n\n   # 실제 라벨 (0~1 점수)\n   true_sim = 0.9  # 사람이 평가한 유사도\n\n   # 손실 계산\n   loss = (predicted_sim - true_sim)² = (0.85 - 0.9)² = 0.0025\n   ```\n\n* **성능 개선:**\n   * 시간 복잡도: $O(n^2) \\rightarrow O(n)$\n\n   ```python\n   # 시간 복잡도 비교\n   기존_BERT_시간 = O(n²) = 1000² = 1,000,000\n   SBERT_시간 = O(n) = 1000\n\n   속도_향상 = 1,000,000 / 1000 = 1000배!\n   ```\n   * 의미적 유사도 정확도 대폭 향상\n   * 대규모 문서 검색 시스템\n   * 실시간 문장 유사도 계산\n   * 추천 시스템에서의 텍스트 매칭\n\n#### GPT(Generative Pre-trained Transformer)\n\n* 단방향 언어 모델의 핵심 개념\n* BERT vs GPT의 근본적 차이\n* **BERT (양방향)**:\n   \n   ```\n   입력: \"나는 [MASK]를 좋아한다\"\n   모델이 보는 정보: \"나는\" + \"를 좋아한다\" (양쪽 모두)\n   예측: [MASK] = \"사과\"\n   ```\n\n* **GPT (단방향)**:\n   \n   ```\n   입력: \"나는 사과를\"\n   모델이 보는 정보: \"나는 사과를\" (왼쪽만)\n   예측: 다음 단어 = \"좋아한다\"\n   ```\n\n* 왜 단방향일까?\n   * **생성 태스크의 특성**:\n\n      ```python\n      # 실제 텍스트 생성 시\n      \"안녕하세요, 오늘 날씨가\"\n      → 모델: \"좋네요\" (미래 정보는 알 수 없음)\n\n      # 만약 양방향이라면?\n      \"안녕하세요, 오늘 날씨가 [미래정보] 입니다\"\n      → 실제 생성 시에는 미래 정보가 없으므로 불일치\n      ```\n\n* **GPT의 학습 방식: Autoregressive Language Modeling**\n   * 이전 토큰들로 다음 토큰 예측\n   * 수학적 목적 함수: $P(\\text{문장}) = \\prod_{t=1}^T P(w_t | w_1, w_2, ..., w_{t-1})$\n      * 문장의 확률 = 각 단어가 이전 단어들 조건 하에 나타날 확률의 곱\n   * 구체적 학습 예시\n      * **훈련 문장**: \"나는 사과를 좋아한다\"\n\n      ```python\n      # 학습 데이터 구성\n      입력 → 정답\n      \"나는\" → \"사과를\"\n      \"나는 사과를\" → \"좋아한다\"  \n      \"나는 사과를 좋아한다\" → \"<끝>\"\n\n      # 손실 함수\n      loss = -log P(\"사과를\" | \"나는\") \n            -log P(\"좋아한다\" | \"나는 사과를\")\n            -log P(\"<끝>\" | \"나는 사과를 좋아한다\")\n      ```\n\n   * Causal Masking (인과 마스킹)\n      * Attention에서 미래 정보 차단\n      ```python\n      # Attention Matrix (4개 단어 예시)\n              나는  사과를  좋아한다  <끝>\n      나는     ✓     ✗      ✗      ✗\n      사과를    ✓     ✓      ✗      ✗  \n      좋아한다  ✓     ✓      ✓      ✗\n      <끝>     ✓     ✓      ✓      ✓\n      \n      # ✓: 참고 가능, ✗: 마스킹 (참고 불가)\n      ```\n\n   * **코드 구현**:\n\n      ```python\n      # 마스킹 행렬\n      mask = torch.tril(torch.ones(seq_len, seq_len))\n      # 상삼각 부분을 -무한대로 설정\n      attention_scores.masked_fill_(mask == 0, -1e9)\n      attention_weights = softmax(attention_scores)\n      ```\n\n* **첫 번째 토큰을 문서 표현으로 활용**\n   * 정보 흐름의 특성\n      * 입력: \"[BOS] 문장 내용들...\"\n      * 각 토큰이 보는 정보량\n      * 토큰1 ([BOS]): 자기 자신만\n      * 토큰2: [BOS] + 토큰2  \n      * 토큰3: [BOS] + 토큰2 + 토큰3\n* **왜 첫 번째 토큰인가?**\n   * 정보 흐름의 특성\n      * 입력: \"[BOS] 문장 내용들...\"\n      * 각 토큰이 보는 정보량\n      * 토큰1 ([BOS]): 자기 자신만\n      * 토큰2: [BOS] + 토큰2  \n      * 토큰3: [BOS] + 토큰2 + 토큰3\n      * 마지막토큰: [BOS] + 전체 문장\n      * 역설적으로, [BOS]는 전체 문장을 \"예측\"해야 하므로\n      * 전체 문장 정보를 압축한 표현을 학습하게 됨\n   * 구체적 메커니즘\n      * 학습 과정에서의 압축\n\n      ```python\n      # GPT가 학습하는 것\n      P(전체_문장 | [BOS]) = P(w1|[BOS]) × P(w2|[BOS],w1) × ... × P(wn|[BOS],w1,...,wn-1)\n\n      # [BOS] 토큰은 \"이 문장이 어떤 내용일까?\"를 예측해야 함\n      # → 문장의 주제, 감정, 스타일 등을 함축하는 표현을 학습\n      ```\n\n* **실제 활용 예시**:\n\n   ```python\n   # 문서 분류\n   document = \"[BOS] 이 영화는 정말 재미있었다. 스토리도 좋고...\"\n   gpt_output = gpt_model(document)\n   document_vector = gpt_output[0]  # [BOS] 위치의 벡터\n   classification = classifier(document_vector)  # 긍정/부정 분류\n   ```\n\n* **In-context Learning 심화 분석**\n   * 기존 학습 방식과의 차이\n      * **전통적 학습 (Fine-tuning)**:\n\n         ```python\n         # 1단계: 새로운 태스크 데이터로 모델 가중치 업데이트\n         model.train()\n         for batch in task_data:\n            loss = compute_loss(model(batch.input), batch.target)\n            loss.backward()\n            optimizer.step()\n\n         # 2단계: 추론\n         prediction = model(new_input)\n         ```\n\n      * **In-context Learning**:\n\n         ```python\n         # 가중치 업데이트 없이, 입력에 예시를 포함\n         context = \"\"\"\n         번역 예시:\n         영어: Hello → 한국어: 안녕하세요\n         영어: Thank you → 한국어: 감사합니다  \n         영어: Good morning → 한국어: 좋은 아침\n\n         영어: How are you? → 한국어:\n         \"\"\"\n\n         result = gpt_model(context)  # \"어떻게 지내세요?\" 출력\n         ```\n\n* **왜 In-context Learning이 가능한가?**\n   * 패턴 인식 능력\n      * GPT가 학습 중 본 패턴들\n      * \"A는 B이다. C는 D이다. E는\"  → F 예측\n      * \"1+1=2, 2+2=4, 3+3=\" → 6 예측\n      * \"cat→고양이, dog→개, bird→\" → 새 예측\n   * 메타 학습 (Learning to Learn)\n    \n      ```python\n      # 다양한 패턴을 학습하면서 \"학습하는 방법\"을 학습\n      패턴1: 번역 (A→B 형태)\n      패턴2: 수학 (계산 규칙)  \n      패턴3: 분류 (라벨링 규칙)\n\n      # 새로운 패턴이 주어져도 빠르게 적응\n      ```\n\n* **실제 In-context Learning 예시**\n   * **감정 분석 태스크**:\n\n      ```python\n      prompt = \"\"\"\n      다음은 리뷰와 감정을 분류한 예시입니다:\n\n      리뷰: \"이 영화 정말 재미있어요!\" 감정: 긍정\n      리뷰: \"시간 낭비였습니다.\" 감정: 부정\n      리뷰: \"그냥 그래요.\" 감정: 중립\n\n      리뷰: \"배우들 연기가 훌륭했습니다!\" 감정:\n      \"\"\"\n\n      # GPT 출력: \"긍정\"\n      ```\n   * **번역 태스크**:\n   \n      ```python\n      prompt = \"\"\"\n      English to Korean translation:\n\n      English: I love programming\n      Korean: 나는 프로그래밍을 좋아합니다\n\n      English: The weather is nice today  \n      Korean: 오늘 날씨가 좋네요\n\n      English: What time is it now?\n      Korean:\n      \"\"\"\n\n      # GPT 출력: \"지금 몇 시인가요?\"\n      ```\n\n* **GPT 발전사와 특징**\n   * **GPT-1 (2018)**\n      * 크기: 117M 파라미터\n      * 특징: Transformer 디코더만 사용\n      * 성능: 간단한 텍스트 생성\n   * **GPT-2 (2019)**\n      * 크기: 1.5B 파라미터\n      * 특징: 스케일 확장의 효과 입증\n      * 성능: 일관성 있는 긴 텍스트 생성\n   * **GPT-3 (2020)**\n      * 크기: 175B 파라미터  \n      * 특징: In-context Learning의 강력한 능력\n      * 성능: Few-shot Learning으로 다양한 태스크 수행\n   * **GPT-4 (2023)**\n      * 크기: 공개되지 않음 (추정 수조 개)\n      * 특징: 멀티모달 (텍스트 + 이미지)\n      * 성능: 인간 수준에 근접한 성능\n\n* **GPT vs BERT 비교 정리**\n\n| 측면 | GPT | BERT |\n|------|-----|------|\n| **방향성** | 단방향 (왼쪽→오른쪽) | 양방향 |\n| **학습 목표** | 다음 토큰 예측 | 마스킹된 토큰 예측 |\n| **주요 용도** | 생성 태스크 | 이해 태스크 |\n| **문서 벡터** | 첫 번째 토큰 | [CLS] 토큰 |\n| **특별 능력** | In-context Learning | Fine-tuning 효율성 |\n\n* **결론**: GPT는 \"다음에 올 단어를 예측\"하는 단순한 목표로 학습하지만, 이 과정에서 언어의 패턴, 의미, 추론 능력까지 학습하게 되어 강력한 생성 및 추론 모델이 되었다.\n\n### 실용적 응용 및 평가\n\n#### 평가 지표\n\n**Intrinsic Evaluation (내재적 평가):**\n- **단어 유사도**: WordSim-353, SimLex-999 - 사람이 평가한 단어 유사도와 모델 예측의 상관관계 측정\n- **단어 관계**: \"king - man + woman = queen\" - 벡터 연산으로 의미 관계 포착 정도 평가\n\n**Extrinsic Evaluation (외재적 평가):**\n- **문서 분류 정확도**: 실제 분류 태스크에서의 성능\n- **정보 검색 성능**: NDCG, MAP - 검색 결과의 관련성 및 순위 정확도\n- **의미적 텍스트 유사도**: STS benchmark - 문장 간 의미적 유사성 예측 성능\n\n#### 모델 선택 가이드\n\n- **소규모 데이터**: FastText (OOV 처리)\n- **대규모 문서 분류**: BERT fine-tuning\n- **실시간 유사도 계산**: SBERT\n- **창작/생성 태스크**: GPT 계열\n\n#### 통계적 해석\n\n임베딩 공간에서의 기하학적 관계:\n$$\\cos(\\mathbf{v}_{\\text{similar words}}) > \\cos(\\mathbf{v}_{\\text{dissimilar words}})$$\n\n**시각화 도구**: t-SNE/UMAP을 통한 의미적 클러스터링 확인\n\n\n## 결론\n\n본 문서에서는 단어의 고정된 의미 표현을 넘어, 문맥에 따라 유연하게 변화하는 의미를 포착하는 동적 임베딩 방법론들을 심층적으로 살펴보았다. ELMo에서 시작하여 BERT, GPT, SBERT에 이르기까지, 이러한 문맥 기반 임베딩 모델들은 자연어 처리(NLP) 분야에 혁명적인 발전을 가져왔다.\n\n주요 내용을 다시 한번 정리하면 다음과 같다.\n\n*   **정적 임베딩의 한계 극복**: 초기의 워드 임베딩(Word2Vec, GloVe 등)은 단어의 의미를 단일 벡터로 표현하여 문맥에 따른 다의성을 반영하지 못했다. 동적 임베딩은 이 한계를 극복하고, 동일한 단어라도 문맥에 따라 다른 벡터 표현을 생성함으로써 보다 정교한 의미 이해를 가능하게 했다.\n\n*   **주요 모델들의 혁신과 기여**:\n    *   **ELMo**: 양방향 LSTM을 통해 문맥 정보를 통합하고, 여러 계층의 표현을 활용하여 풍부한 임베딩을 제공했다.\n    *   **BERT**: 트랜스포머 아키텍처와 Masked Language Model, Next Sentence Prediction과 같은 혁신적인 사전 학습 방식을 도입하여 양방향 문맥 이해의 새로운 지평을 열었다. 이는 다양한 NLP 다운스트림 태스크에서 SOTA(State-of-the-Art) 성능을 달성하는 데 크게 기여했다.\n    *   **GPT**: 단방향 트랜스포머 디코더를 기반으로 강력한 텍스트 생성 능력을 보여주었으며, 특히 GPT-3 이후 모델들은 In-context Learning이라는 새로운 패러다임을 제시하며 모델 활용의 유연성을 크게 확장했다.\n    *   **SBERT**: 기존 BERT 모델을 문장 임베딩 생성에 효율적으로 사용할 수 있도록 Siamese 및 Triplet 네트워크 구조를 활용하여, 의미적으로 유사한 문장 벡터를 효과적으로 생성하고 문장 간 유사도 비교 작업의 속도와 정확도를 크게 향상시켰다.\n\n*   **패러다임의 전환과 LLM의 토대**: 이러한 문맥 기반 임베딩 모델들의 발전은 단순한 특징 추출기를 넘어, 언어 자체를 깊이 이해하고 생성할 수 있는 대규모 언어 모델(Large Language Models, LLMs) 시대로 나아가는 핵심적인 발판이 되었다. 사전 학습과 미세 조정(fine-tuning) 패러다임, 그리고 최근의 프롬프트 기반 학습은 모델의 활용 범위를 크게 넓혔다.\n\n*   **적절한 전략 선택의 지속적 중요성**: 해결하고자 하는 특정 문제의 요구사항, 가용 데이터의 특성, 계산 자원 등을 고려하여 가장 적합한 임베딩 전략과 모델을 선택하는 것은 여전히 중요하다. 실용적인 응용을 위해서는 모델의 성능뿐만 아니라 효율성, 해석 가능성 등도 함께 고려해야 한다.\n\n문맥을 이해하는 텍스트 벡터화 기술은 앞으로도 계속 발전하여, 기계가 인간의 언어를 더욱 정교하게 이해하고 상호작용하는 미래를 앞당길 것이다. 이러한 기술의 발전은 정보 검색, 질의응답, 창작, 교육 등 사회 여러 분야에 걸쳐 혁신적인 변화를 주도할 잠재력을 지니고 있다.\n","srcMarkdownNoYaml":"\n\n# 요약\n\n이 문서는 단어의 의미가 문맥에 따라 변하는 현상을 효과적으로 다루기 위해 등장한 **동적/문맥적 임베딩(Contextualized Embedding)** 방법론을 탐구한다. 정적 임베딩의 한계를 지적하고, 이를 극복하기 위한 주요 모델들의 핵심 아이디어와 특징을 소개한다.\n\n주요 내용은 다음과 같다.\n\n*   **정적 임베딩 vs. 동적 임베딩**:\n    *   정적 임베딩(예: Word2Vec, GloVe)은 단어마다 고정된 벡터를 할당하여 문맥에 따른 의미 변화(다의성)를 포착하지 못하는 한계가 있다.\n    *   동적 임베딩은 동일한 단어라도 문맥에 따라 다른 벡터 표현을 생성하여 이러한 문제를 해결한다.\n*   **주요 문맥 기반 임베딩 모델**:\n    *   **ELMo (Embeddings from Language Models)**: 양방향 LSTM(BiLSTM)의 각 계층에서 얻은 내부 상태들을 가중합하여 문맥 정보를 풍부하게 담은 임베딩을 생성한다. 문자 단위 표현부터 시작하여 다양한 수준의 정보를 결합한다.\n    *   **BERT (Bidirectional Encoder Representations from Transformers)**: 트랜스포머(Transformer)의 인코더 구조를 활용하여 문장 내 모든 단어의 양방향 문맥을 동시에 고려한다. 'Masked Language Model(MLM)'과 'Next Sentence Prediction(NSP)'이라는 두 가지 혁신적인 사전 학습(pre-training) 목표를 통해 깊은 언어 이해 능력을 학습한다. 문서 전체의 표현으로는 `[CLS]` 토큰의 출력을 사용하거나 토큰 출력들의 풀링(pooling) 결과를 활용한다.\n    *   **SBERT (Sentence-BERT)**: BERT의 출력을 문장 수준의 의미론적 벡터로 효율적으로 변환하기 위해 Siamese 또는 Triplet 네트워크 구조를 사용한다. 이를 통해 문장 간 유사도 계산 및 대규모 검색 작업의 효율성을 크게 향상시킨다.\n    *   **GPT (Generative Pre-trained Transformer)**: 트랜스포머의 디코더 구조를 기반으로 하는 단방향(autoregressive) 언어 모델이다. 이전 단어들을 바탕으로 다음 단어를 예측하도록 학습하며, 이 과정에서 문맥을 이해하고 생성하는 능력을 키운다. 특히, 가중치 업데이트 없이 프롬프트에 몇 가지 예시(few-shot)를 제공하는 것만으로 새로운 작업을 수행하는 'In-context Learning' 능력으로 주목받았다. 문서 표현으로는 첫 번째 토큰([BOS])의 출력을 활용하기도 한다.\n*   **실용적 응용 및 평가**:\n    *   이러한 모델들은 문서 분류, 정보 검색, 질의응답, 기계 번역 등 다양한 NLP 태스크에서 혁신적인 성능 향상을 가져왔다.\n    *   모델 평가는 단어 유사도나 관계 유추 같은 내재적 평가(intrinsic evaluation)와 실제 다운스트림 태스크에서의 성능을 측정하는 외재적 평가(extrinsic evaluation)로 이루어진다.\n\n이 문서를 통해 독자는 문맥을 이해하는 동적 임베딩 기술의 발전 과정과 핵심 원리를 파악하고, 다양한 NLP 문제 해결에 이를 어떻게 활용할 수 있는지에 대한 통찰을 얻을 수 있다.\n\n# 텍스트 인코딩 및 벡터화\n\n```\n텍스트 벡터화\n├── 1. 전통적 방법 (통계 기반)\n│   ├── BoW\n│   ├── DTM\n│   └── TF-IDF\n│\n├── 2. 신경망 기반 (문맥 독립)\n│   ├── 문맥 독립적 임베딩\n│   │   └── Embedding Layer (딥러닝 모델 내 구성 요소)\n│   ├── Word2Vec (CBOW, Skip-gram)\n│   ├── FastText\n│   ├── GloVe\n│   └── 기타 모델: Swivel, LexVec 등\n│\n└── 3. 문맥 기반 임베딩 (Contextual Embedding)\n    ├── RNN 계열\n    │   ├── LSTM\n    │   ├── GRU\n    │   └── ELMo\n    └── Attention 메커니즘\n        ├── Basic Attention\n        ├── Self-Attention\n        └── Multi-Head Attention\n \nTransformer 이후 생성형 모델 발전 계열\n├── Transformer 구조 (Vaswani et al., 2017)\n├── BERT 시리즈 (Google,2018~)\n|   ├── BERT\n|   ├── RoBERTa\n|   └── ALBERT\n├── GPT 시리즈 (OpenAI,2018~)\n|   ├── GPT-1~4\n|   └── ChatGPT (OpenAI,2022~)\n├── 한국어 특화: KoBERT, KoGPT, KLU-BERT 등 (Kakao,2019~)\n└── 기타 발전 모델\n    ├── T5, XLNet, ELECTRA\n    └── PaLM, LaMDA, Gemini, Claude 등\n```\n\n## 문맥을 고려한 벡터화 (2018-현재): 동적 임베딩\n\n#### ELMo (Embedding from Language Models, 2018)\n\n* ELMo 수식: $\\text{ELMo}_k^{task} = \\gamma^{task} \\sum_{j=0}^L s_j^{task} \\mathbf{h}_{k,j}^{LM}$\n   * **$\\mathbf{h}_{k,j}^{LM}$: 각 레이어의 hidden state**\n\n   ```python\n   # 예시: 3층 BiLSTM에서 \"bank\" 단어 (k번째 위치)\n   h_{bank,0} = character_embedding(\"bank\")     # 레이어 0 (입력)\n   h_{bank,1} = first_LSTM_layer_output        # 레이어 1  \n   h_{bank,2} = second_LSTM_layer_output       # 레이어 2\n   h_{bank,3} = third_LSTM_layer_output        # 레이어 3 (최상위)\n   ```\n   * **$s_j^{task}$: 학습 가능한 가중치**\n      * 각 레이어의 중요도를 태스크별로 학습\n      * 문법적 태스크 → 낮은 레이어 중시\n      * 의미적 태스크 → 높은 레이어 중시\n   * **$\\gamma^{task}$: 전체 스케일 조정**\n      * ELMo 벡터의 전체적인 크기 조정\n* 계산 예시\n\n```python\n# \"bank\" 단어의 ELMo 벡터 (감정 분석 태스크)\nh_0 = [0.1, 0.2, 0.3]  # 문자 레벨\nh_1 = [0.4, 0.5, 0.6]  # 낮은 레벨 (문법적)  \nh_2 = [0.7, 0.8, 0.9]  # 높은 레벨 (의미적)\n\ns_0 = 0.1  # 문자 레벨 가중치 (낮음)\ns_1 = 0.3  # 문법 레벨 가중치  \ns_2 = 0.6  # 의미 레벨 가중치 (높음)\n\nELMo_bank = γ × (s_0×h_0 + s_1×h_1 + s_2×h_2)\n          = 2.0 × (0.1×[0.1,0.2,0.3] + 0.3×[0.4,0.5,0.6] + 0.6×[0.7,0.8,0.9])\n          = 2.0 × [0.55, 0.65, 0.75]\n          = [1.1, 1.3, 1.5]\n```\n\n* 양방향 정보의 중요성\n   * **Forward만 사용할 경우:**\n\n   ```\n   \"The bank was closed because of ___\"\n   → \"bank\"를 이해할 때 \"The\"만 참고\n   ```\n\n   * **Backward까지 사용할 경우:**  \n\n   ```\n   \"The bank was closed because of ___\"\n   → \"bank\"를 이해할 때 \"was closed\" 정보도 참고\n   → 금융 기관으로 해석 가능성 증가\n   ```\n\n#### BERT (Bidirectional Encoder Representations from Transformers, 2018)\n\n* 양방향 문맥 동시 고려\n   * 15% 단어를 마스킹하여 예측\n   * 문장 간 관계 학습\n* **핵심 혁신:**\n   * **Transformer 기반**: 양방향 문맥 동시 고려\n      * **기존 RNN의 한계:**\n\n         ```python\n         # RNN은 순차적 처리 (병렬화 어려움)\n         h_1 = RNN(x_1)\n         h_2 = RNN(x_2, h_1)      # h_1이 완료되어야 시작 가능\n         h_3 = RNN(x_3, h_2)      # h_2가 완료되어야 시작 가능\n         ```\n\n      * **Transformer의 장점:**\n\n         ```python\n         # 모든 위치를 동시에 처리 (병렬화 가능)\n         attention_weights = compute_attention(all_words)\n         all_representations = apply_attention(all_words, attention_weights)\n         ```\n\n   * **Masked Language Model**: 15% 단어를 마스킹하여 예측\n      * BERT의 핵심 학습 방법\n         * **기본 아이디어**: 일부 단어를 숨기고 맞추게 하기\n\n         ```python\n         # 원본 문장\n         \"나는 [MASK]를 좋아한다\"\n\n         # 모델이 학습하는 것\n         P(\"사과\" | \"나는 [MASK]를 좋아한다\") = 0.7\n         P(\"바나나\" | \"나는 [MASK]를 좋아한다\") = 0.2  \n         P(\"컴퓨터\" | \"나는 [MASK]를 좋아한다\") = 0.01\n         ```\n\n         * **15% 마스킹 전략:**\n\n         ```python\n         입력 문장의 15% 단어에 대해:\n         - 80%: [MASK] 토큰으로 교체\n         - 10%: 랜덤한 다른 단어로 교체  \n         - 10%: 원래 단어 그대로 유지\n         ```\n\n         * **왜 이렇게 하는가?**\n            ```python\n            # 80% [MASK]: 메인 학습 목적\n            \"나는 [MASK]를 좋아한다\"\n\n            # 10% 랜덤 교체: 노이즈에 강한 표현 학습\n            \"나는 컴퓨터를 좋아한다\"  # 원래는 \"사과\"\n\n            # 10% 원본 유지: 실제 사용 시와 동일한 조건\n            \"나는 사과를 좋아한다\"\n            ```\n\n   * **Next Sentence Prediction**: 문장 간 관계 학습\n   \n   ```python\n   # 실제 연속된 문장 (Positive)\n   문장A: \"나는 아침에 일어났다\"\n   문장B: \"그리고 아침 식사를 했다\"\n   Label: IsNext = True\n\n   # 랜덤하게 조합된 문장 (Negative)  \n   문장A: \"나는 아침에 일어났다\"\n   문장B: \"축구는 재미있는 스포츠다\"\n   Label: IsNext = False\n   ```\n\n* **BERT의 문서 벡터화 방법:**\n   * **[CLS] 토큰**: 문장/문서 전체 표현\n\n   ```python\n   입력: \"[CLS] 문장 내용 [SEP]\"\n   출력: [CLS]_벡터가 전체 문장의 의미를 담음\n\n   # 예시\n   input_tokens = [\"[CLS]\", \"나는\", \"사과를\", \"좋아한다\", \"[SEP]\"]\n   bert_output = bert_model(input_tokens)\n   sentence_vector = bert_output[0]  # [CLS] 위치의 벡터\n   ```\n\n   * **Pooling 전략**: \n      * Mean pooling: $\\frac{1}{n}\\sum_{i=1}^n \\mathbf{h}_i$\n      * Max pooling: $\\max(\\mathbf{h}_1, ..., \\mathbf{h}_n)$\n\n      ```python\n      # 모든 토큰의 BERT 출력\n      token_representations = [\n         [0.1, 0.2, 0.3],  # [CLS]\n         [0.4, 0.5, 0.6],  # \"나는\"  \n         [0.7, 0.8, 0.9],  # \"사과를\"\n         [0.2, 0.3, 0.4],  # \"좋아한다\"\n         [0.5, 0.6, 0.7],  # [SEP]\n      ]\n\n      # Mean Pooling\n      mean_vector = mean(token_representations[1:-1])  # [CLS], [SEP] 제외\n      = (0.4+0.7+0.2)/3, (0.5+0.8+0.3)/3, (0.6+0.9+0.4)/3\n      = [0.43, 0.53, 0.63]\n\n      # Max Pooling  \n      max_vector = max(token_representations[1:-1])  # 각 차원별 최댓값\n      = [0.7, 0.8, 0.9]\n      ```\n*   **특징**:\n    *   단어의 의미적, 문법적 정보를 벡터 공간에 학습.\n    *   벡터 간 연산을 통해 단어 간 유사도, 유추 등 관계 표현 가능 (예: \"king\" - \"man\" + \"woman\" ≈ \"queen\").\n*   **중요성**: 현대 NLP 딥러닝 모델의 핵심 구성 요소로, 성능 향상에 크게 기여.\n\n\n\n#### SBERT (Sentence-BERT)\n\n* 최근 가장 보편적인 문장 또는 문서 임베딩 방법으로 SBERT가 이용된다.\n* 문서의 유사도를 구할 때는 SBERT 사용을 권장\n* 문장 벡터화 전략\n   * 문장 간 유사도 계산\n   * 문장 간 유사도 계산 시 문장 임베딩 사용\n* 기존 BERT의 한계: 문장 유사도 계산의 비효율성\n\n   ```python\n   # 1000개 문장의 유사도를 모두 구하려면\n   sentences = [\"문장1\", \"문장2\", ..., \"문장1000\"]\n\n   # 기존 BERT 방식 (비효율적)\n   for i in range(1000):\n      for j in range(i+1, 1000):\n         combined = f\"[CLS] {sentences[i]} [SEP] {sentences[j]} [SEP]\"\n         similarity = bert_classifier(combined)  # 매번 BERT 실행\n         \n   # 총 계산 횟수: 1000 × 999 / 2 = 499,500번!\n   ```\n\n   * BERT로 문장 유사도를 계산하려면:\n      * 두 문장을 [SEP]로 연결\n      * BERT에 입력하여 분류\n      * $O(n^2)$ 시간 복잡도 (n개 문장 비교 시)\n* SBERT의 해결책: Siamese Network 구조\n\n```python\n# SBERT 방식 (효율적)\n\n문장 A → BERT → Pooling → Vector A\n문장 B → BERT → Pooling → Vector B\n유사도 = cosine_similarity(Vector A, Vector B)\n\n# 1단계: 모든 문장을 미리 벡터화\nsentence_vectors = []\nfor sentence in sentences:\n    vector = sbert_model(sentence)  # 각 문장마다 1번씩만 실행\n    sentence_vectors.append(vector)\n\n# 2단계: 벡터 간 코사인 유사도로 빠른 계산\nfor i in range(1000):\n    for j in range(i+1, 1000):\n        similarity = cosine_similarity(sentence_vectors[i], sentence_vectors[j])\n        \n# 총 SBERT 실행 횟수: 1000번 (대폭 감소!)\n```\n\n* **학습 목적 함수:**\n   * **Classification**: $\\mathcal{L} = -\\sum_{i} y_i \\log(\\text{softmax}(W[\\mathbf{u}; \\mathbf{v}; |\\mathbf{u}-\\mathbf{v}|]))$\n\n   ```python\n   # 두 문장의 SBERT 벡터\n   u = sbert(\"나는 사과를 좋아한다\")      # [0.2, 0.4, 0.1, ...]\n   v = sbert(\"나는 바나나를 좋아한다\")    # [0.3, 0.5, 0.2, ...]\n\n   # 특성 벡터 구성\n   concat = [u; v]                    # 연결: [0.2, 0.4, 0.1, 0.3, 0.5, 0.2, ...]\n   abs_diff = |u - v|                # 절댓값 차이: [0.1, 0.1, 0.1, ...]\n   features = [u; v; abs_diff]        # 최종 특성 벡터\n\n   # 분류 (유사/비유사)\n   logits = W @ features + b\n   probability = softmax(logits)\n   loss = cross_entropy(probability, true_label)\n   ```\n\n   * **Regression**: $\\mathcal{L} = \\text{MSE}(\\text{cosine\\_sim}(\\mathbf{u}, \\mathbf{v}), \\text{label})$\n   \n   ```python\n   # 예측 유사도\n   predicted_sim = cosine_similarity(u, v) = 0.85\n\n   # 실제 라벨 (0~1 점수)\n   true_sim = 0.9  # 사람이 평가한 유사도\n\n   # 손실 계산\n   loss = (predicted_sim - true_sim)² = (0.85 - 0.9)² = 0.0025\n   ```\n\n* **성능 개선:**\n   * 시간 복잡도: $O(n^2) \\rightarrow O(n)$\n\n   ```python\n   # 시간 복잡도 비교\n   기존_BERT_시간 = O(n²) = 1000² = 1,000,000\n   SBERT_시간 = O(n) = 1000\n\n   속도_향상 = 1,000,000 / 1000 = 1000배!\n   ```\n   * 의미적 유사도 정확도 대폭 향상\n   * 대규모 문서 검색 시스템\n   * 실시간 문장 유사도 계산\n   * 추천 시스템에서의 텍스트 매칭\n\n#### GPT(Generative Pre-trained Transformer)\n\n* 단방향 언어 모델의 핵심 개념\n* BERT vs GPT의 근본적 차이\n* **BERT (양방향)**:\n   \n   ```\n   입력: \"나는 [MASK]를 좋아한다\"\n   모델이 보는 정보: \"나는\" + \"를 좋아한다\" (양쪽 모두)\n   예측: [MASK] = \"사과\"\n   ```\n\n* **GPT (단방향)**:\n   \n   ```\n   입력: \"나는 사과를\"\n   모델이 보는 정보: \"나는 사과를\" (왼쪽만)\n   예측: 다음 단어 = \"좋아한다\"\n   ```\n\n* 왜 단방향일까?\n   * **생성 태스크의 특성**:\n\n      ```python\n      # 실제 텍스트 생성 시\n      \"안녕하세요, 오늘 날씨가\"\n      → 모델: \"좋네요\" (미래 정보는 알 수 없음)\n\n      # 만약 양방향이라면?\n      \"안녕하세요, 오늘 날씨가 [미래정보] 입니다\"\n      → 실제 생성 시에는 미래 정보가 없으므로 불일치\n      ```\n\n* **GPT의 학습 방식: Autoregressive Language Modeling**\n   * 이전 토큰들로 다음 토큰 예측\n   * 수학적 목적 함수: $P(\\text{문장}) = \\prod_{t=1}^T P(w_t | w_1, w_2, ..., w_{t-1})$\n      * 문장의 확률 = 각 단어가 이전 단어들 조건 하에 나타날 확률의 곱\n   * 구체적 학습 예시\n      * **훈련 문장**: \"나는 사과를 좋아한다\"\n\n      ```python\n      # 학습 데이터 구성\n      입력 → 정답\n      \"나는\" → \"사과를\"\n      \"나는 사과를\" → \"좋아한다\"  \n      \"나는 사과를 좋아한다\" → \"<끝>\"\n\n      # 손실 함수\n      loss = -log P(\"사과를\" | \"나는\") \n            -log P(\"좋아한다\" | \"나는 사과를\")\n            -log P(\"<끝>\" | \"나는 사과를 좋아한다\")\n      ```\n\n   * Causal Masking (인과 마스킹)\n      * Attention에서 미래 정보 차단\n      ```python\n      # Attention Matrix (4개 단어 예시)\n              나는  사과를  좋아한다  <끝>\n      나는     ✓     ✗      ✗      ✗\n      사과를    ✓     ✓      ✗      ✗  \n      좋아한다  ✓     ✓      ✓      ✗\n      <끝>     ✓     ✓      ✓      ✓\n      \n      # ✓: 참고 가능, ✗: 마스킹 (참고 불가)\n      ```\n\n   * **코드 구현**:\n\n      ```python\n      # 마스킹 행렬\n      mask = torch.tril(torch.ones(seq_len, seq_len))\n      # 상삼각 부분을 -무한대로 설정\n      attention_scores.masked_fill_(mask == 0, -1e9)\n      attention_weights = softmax(attention_scores)\n      ```\n\n* **첫 번째 토큰을 문서 표현으로 활용**\n   * 정보 흐름의 특성\n      * 입력: \"[BOS] 문장 내용들...\"\n      * 각 토큰이 보는 정보량\n      * 토큰1 ([BOS]): 자기 자신만\n      * 토큰2: [BOS] + 토큰2  \n      * 토큰3: [BOS] + 토큰2 + 토큰3\n* **왜 첫 번째 토큰인가?**\n   * 정보 흐름의 특성\n      * 입력: \"[BOS] 문장 내용들...\"\n      * 각 토큰이 보는 정보량\n      * 토큰1 ([BOS]): 자기 자신만\n      * 토큰2: [BOS] + 토큰2  \n      * 토큰3: [BOS] + 토큰2 + 토큰3\n      * 마지막토큰: [BOS] + 전체 문장\n      * 역설적으로, [BOS]는 전체 문장을 \"예측\"해야 하므로\n      * 전체 문장 정보를 압축한 표현을 학습하게 됨\n   * 구체적 메커니즘\n      * 학습 과정에서의 압축\n\n      ```python\n      # GPT가 학습하는 것\n      P(전체_문장 | [BOS]) = P(w1|[BOS]) × P(w2|[BOS],w1) × ... × P(wn|[BOS],w1,...,wn-1)\n\n      # [BOS] 토큰은 \"이 문장이 어떤 내용일까?\"를 예측해야 함\n      # → 문장의 주제, 감정, 스타일 등을 함축하는 표현을 학습\n      ```\n\n* **실제 활용 예시**:\n\n   ```python\n   # 문서 분류\n   document = \"[BOS] 이 영화는 정말 재미있었다. 스토리도 좋고...\"\n   gpt_output = gpt_model(document)\n   document_vector = gpt_output[0]  # [BOS] 위치의 벡터\n   classification = classifier(document_vector)  # 긍정/부정 분류\n   ```\n\n* **In-context Learning 심화 분석**\n   * 기존 학습 방식과의 차이\n      * **전통적 학습 (Fine-tuning)**:\n\n         ```python\n         # 1단계: 새로운 태스크 데이터로 모델 가중치 업데이트\n         model.train()\n         for batch in task_data:\n            loss = compute_loss(model(batch.input), batch.target)\n            loss.backward()\n            optimizer.step()\n\n         # 2단계: 추론\n         prediction = model(new_input)\n         ```\n\n      * **In-context Learning**:\n\n         ```python\n         # 가중치 업데이트 없이, 입력에 예시를 포함\n         context = \"\"\"\n         번역 예시:\n         영어: Hello → 한국어: 안녕하세요\n         영어: Thank you → 한국어: 감사합니다  \n         영어: Good morning → 한국어: 좋은 아침\n\n         영어: How are you? → 한국어:\n         \"\"\"\n\n         result = gpt_model(context)  # \"어떻게 지내세요?\" 출력\n         ```\n\n* **왜 In-context Learning이 가능한가?**\n   * 패턴 인식 능력\n      * GPT가 학습 중 본 패턴들\n      * \"A는 B이다. C는 D이다. E는\"  → F 예측\n      * \"1+1=2, 2+2=4, 3+3=\" → 6 예측\n      * \"cat→고양이, dog→개, bird→\" → 새 예측\n   * 메타 학습 (Learning to Learn)\n    \n      ```python\n      # 다양한 패턴을 학습하면서 \"학습하는 방법\"을 학습\n      패턴1: 번역 (A→B 형태)\n      패턴2: 수학 (계산 규칙)  \n      패턴3: 분류 (라벨링 규칙)\n\n      # 새로운 패턴이 주어져도 빠르게 적응\n      ```\n\n* **실제 In-context Learning 예시**\n   * **감정 분석 태스크**:\n\n      ```python\n      prompt = \"\"\"\n      다음은 리뷰와 감정을 분류한 예시입니다:\n\n      리뷰: \"이 영화 정말 재미있어요!\" 감정: 긍정\n      리뷰: \"시간 낭비였습니다.\" 감정: 부정\n      리뷰: \"그냥 그래요.\" 감정: 중립\n\n      리뷰: \"배우들 연기가 훌륭했습니다!\" 감정:\n      \"\"\"\n\n      # GPT 출력: \"긍정\"\n      ```\n   * **번역 태스크**:\n   \n      ```python\n      prompt = \"\"\"\n      English to Korean translation:\n\n      English: I love programming\n      Korean: 나는 프로그래밍을 좋아합니다\n\n      English: The weather is nice today  \n      Korean: 오늘 날씨가 좋네요\n\n      English: What time is it now?\n      Korean:\n      \"\"\"\n\n      # GPT 출력: \"지금 몇 시인가요?\"\n      ```\n\n* **GPT 발전사와 특징**\n   * **GPT-1 (2018)**\n      * 크기: 117M 파라미터\n      * 특징: Transformer 디코더만 사용\n      * 성능: 간단한 텍스트 생성\n   * **GPT-2 (2019)**\n      * 크기: 1.5B 파라미터\n      * 특징: 스케일 확장의 효과 입증\n      * 성능: 일관성 있는 긴 텍스트 생성\n   * **GPT-3 (2020)**\n      * 크기: 175B 파라미터  \n      * 특징: In-context Learning의 강력한 능력\n      * 성능: Few-shot Learning으로 다양한 태스크 수행\n   * **GPT-4 (2023)**\n      * 크기: 공개되지 않음 (추정 수조 개)\n      * 특징: 멀티모달 (텍스트 + 이미지)\n      * 성능: 인간 수준에 근접한 성능\n\n* **GPT vs BERT 비교 정리**\n\n| 측면 | GPT | BERT |\n|------|-----|------|\n| **방향성** | 단방향 (왼쪽→오른쪽) | 양방향 |\n| **학습 목표** | 다음 토큰 예측 | 마스킹된 토큰 예측 |\n| **주요 용도** | 생성 태스크 | 이해 태스크 |\n| **문서 벡터** | 첫 번째 토큰 | [CLS] 토큰 |\n| **특별 능력** | In-context Learning | Fine-tuning 효율성 |\n\n* **결론**: GPT는 \"다음에 올 단어를 예측\"하는 단순한 목표로 학습하지만, 이 과정에서 언어의 패턴, 의미, 추론 능력까지 학습하게 되어 강력한 생성 및 추론 모델이 되었다.\n\n### 실용적 응용 및 평가\n\n#### 평가 지표\n\n**Intrinsic Evaluation (내재적 평가):**\n- **단어 유사도**: WordSim-353, SimLex-999 - 사람이 평가한 단어 유사도와 모델 예측의 상관관계 측정\n- **단어 관계**: \"king - man + woman = queen\" - 벡터 연산으로 의미 관계 포착 정도 평가\n\n**Extrinsic Evaluation (외재적 평가):**\n- **문서 분류 정확도**: 실제 분류 태스크에서의 성능\n- **정보 검색 성능**: NDCG, MAP - 검색 결과의 관련성 및 순위 정확도\n- **의미적 텍스트 유사도**: STS benchmark - 문장 간 의미적 유사성 예측 성능\n\n#### 모델 선택 가이드\n\n- **소규모 데이터**: FastText (OOV 처리)\n- **대규모 문서 분류**: BERT fine-tuning\n- **실시간 유사도 계산**: SBERT\n- **창작/생성 태스크**: GPT 계열\n\n#### 통계적 해석\n\n임베딩 공간에서의 기하학적 관계:\n$$\\cos(\\mathbf{v}_{\\text{similar words}}) > \\cos(\\mathbf{v}_{\\text{dissimilar words}})$$\n\n**시각화 도구**: t-SNE/UMAP을 통한 의미적 클러스터링 확인\n\n\n## 결론\n\n본 문서에서는 단어의 고정된 의미 표현을 넘어, 문맥에 따라 유연하게 변화하는 의미를 포착하는 동적 임베딩 방법론들을 심층적으로 살펴보았다. ELMo에서 시작하여 BERT, GPT, SBERT에 이르기까지, 이러한 문맥 기반 임베딩 모델들은 자연어 처리(NLP) 분야에 혁명적인 발전을 가져왔다.\n\n주요 내용을 다시 한번 정리하면 다음과 같다.\n\n*   **정적 임베딩의 한계 극복**: 초기의 워드 임베딩(Word2Vec, GloVe 등)은 단어의 의미를 단일 벡터로 표현하여 문맥에 따른 다의성을 반영하지 못했다. 동적 임베딩은 이 한계를 극복하고, 동일한 단어라도 문맥에 따라 다른 벡터 표현을 생성함으로써 보다 정교한 의미 이해를 가능하게 했다.\n\n*   **주요 모델들의 혁신과 기여**:\n    *   **ELMo**: 양방향 LSTM을 통해 문맥 정보를 통합하고, 여러 계층의 표현을 활용하여 풍부한 임베딩을 제공했다.\n    *   **BERT**: 트랜스포머 아키텍처와 Masked Language Model, Next Sentence Prediction과 같은 혁신적인 사전 학습 방식을 도입하여 양방향 문맥 이해의 새로운 지평을 열었다. 이는 다양한 NLP 다운스트림 태스크에서 SOTA(State-of-the-Art) 성능을 달성하는 데 크게 기여했다.\n    *   **GPT**: 단방향 트랜스포머 디코더를 기반으로 강력한 텍스트 생성 능력을 보여주었으며, 특히 GPT-3 이후 모델들은 In-context Learning이라는 새로운 패러다임을 제시하며 모델 활용의 유연성을 크게 확장했다.\n    *   **SBERT**: 기존 BERT 모델을 문장 임베딩 생성에 효율적으로 사용할 수 있도록 Siamese 및 Triplet 네트워크 구조를 활용하여, 의미적으로 유사한 문장 벡터를 효과적으로 생성하고 문장 간 유사도 비교 작업의 속도와 정확도를 크게 향상시켰다.\n\n*   **패러다임의 전환과 LLM의 토대**: 이러한 문맥 기반 임베딩 모델들의 발전은 단순한 특징 추출기를 넘어, 언어 자체를 깊이 이해하고 생성할 수 있는 대규모 언어 모델(Large Language Models, LLMs) 시대로 나아가는 핵심적인 발판이 되었다. 사전 학습과 미세 조정(fine-tuning) 패러다임, 그리고 최근의 프롬프트 기반 학습은 모델의 활용 범위를 크게 넓혔다.\n\n*   **적절한 전략 선택의 지속적 중요성**: 해결하고자 하는 특정 문제의 요구사항, 가용 데이터의 특성, 계산 자원 등을 고려하여 가장 적합한 임베딩 전략과 모델을 선택하는 것은 여전히 중요하다. 실용적인 응용을 위해서는 모델의 성능뿐만 아니라 효율성, 해석 가능성 등도 함께 고려해야 한다.\n\n문맥을 이해하는 텍스트 벡터화 기술은 앞으로도 계속 발전하여, 기계가 인간의 언어를 더욱 정교하게 이해하고 상호작용하는 미래를 앞당길 것이다. 이러한 기술의 발전은 정보 검색, 질의응답, 창작, 교육 등 사회 여러 분야에 걸쳐 혁신적인 변화를 주도할 잠재력을 지니고 있다.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":true,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"github","css":["../../../../../styles.css"],"toc":true,"toc-depth":3,"number-sections":true,"include-in-header":[{"text":"<style>\n.custom-footer { \n  text-align: center; \n  font-size: 0.8em; \n  color: #666; \n  margin-top: 2rem; \n}\n</style>\n"}],"include-after-body":["../../../../../js.html","../../../signup.html"],"output-file":"20.transformer.html"},"language":{"toc-title-document":"목차","toc-title-website":"목차","related-formats-title":"기타 형식","related-notebooks-title":"Notebooks","source-notebooks-prefix":"원천","other-links-title":"기타 링크","code-links-title":"코드 링크","launch-dev-container-title":"Dev 컨테이너 실행","launch-binder-title":"랜치 Binder","article-notebook-label":"기사 노트북","notebook-preview-download":"노트북 다운로드","notebook-preview-download-src":"소스 다운로드","notebook-preview-back":"기사로 돌아가기","manuscript-meca-bundle":"MECA 아카이브","section-title-abstract":"초록","section-title-appendices":"부록","section-title-footnotes":"각주","section-title-references":"참고문헌","section-title-reuse":"라이센스","section-title-copyright":"저작권","section-title-citation":"인용","appendix-attribution-cite-as":"인용방법","appendix-attribution-bibtex":"BibTeX 인용:","title-block-author-single":"저자","title-block-author-plural":"저자","title-block-affiliation-single":"소속","title-block-affiliation-plural":"소속","title-block-published":"공개","title-block-modified":"Modified","title-block-keywords":"키워드","callout-tip-title":"힌트","callout-note-title":"노트","callout-warning-title":"경고","callout-important-title":"중요","callout-caution-title":"주의","code-summary":"코드","code-tools-menu-caption":"코드","code-tools-show-all-code":"전체 코드 표시","code-tools-hide-all-code":"전체 코드 숨기기","code-tools-view-source":"소스 코드 표시","code-tools-source-code":"소스 코드","tools-share":"Share","tools-download":"Download","code-line":"선","code-lines":"윤곽","copy-button-tooltip":"클립보드 복사","copy-button-tooltip-success":"복사완료!","repo-action-links-edit":"편집","repo-action-links-source":"소스코드 보기","repo-action-links-issue":"이슈 보고","back-to-top":"맨 위로","search-no-results-text":"일치 없음","search-matching-documents-text":"일치된 문서","search-copy-link-title":"검색 링크 복사","search-hide-matches-text":"추가 검색 결과 숨기기","search-more-match-text":"추가 검색결과","search-more-matches-text":"추가 검색결과","search-clear-button-title":"제거","search-text-placeholder":"","search-detached-cancel-button-title":"취소","search-submit-button-title":"검색","search-label":"검색","toggle-section":"토글 섹션","toggle-sidebar":"사이드바 전환","toggle-dark-mode":"다크 모드 전환","toggle-reader-mode":"리더 모드 전환","toggle-navigation":"탐색 전환","crossref-fig-title":"그림","crossref-tbl-title":"표","crossref-lst-title":"목록","crossref-thm-title":"정리","crossref-lem-title":"보조정리","crossref-cor-title":"따름정리","crossref-prp-title":"명제","crossref-cnj-title":"추측","crossref-def-title":"정의","crossref-exm-title":"보기","crossref-exr-title":"예제","crossref-ch-prefix":"장","crossref-apx-prefix":"부록","crossref-sec-prefix":"섹션","crossref-eq-prefix":"방정식","crossref-lof-title":"그림 목록","crossref-lot-title":"표 목록","crossref-lol-title":"코드 목록","environment-proof-title":"증명","environment-remark-title":"주석","environment-solution-title":"해답","listing-page-order-by":"정렬","listing-page-order-by-default":"디폴트","listing-page-order-by-date-asc":"날짜(오름차순)","listing-page-order-by-date-desc":"날짜(내림차순)","listing-page-order-by-number-desc":"페이지 번호(내림차순)","listing-page-order-by-number-asc":"페이지 번호(오름차순)","listing-page-field-date":"날짜","listing-page-field-title":"제목","listing-page-field-description":"설명","listing-page-field-author":"저자","listing-page-field-filename":"파일명","listing-page-field-filemodified":"갱신일","listing-page-field-subtitle":"부제목","listing-page-field-readingtime":"읽기 시간","listing-page-field-wordcount":"단어 수","listing-page-field-categories":"분류","listing-page-minutes-compact":"{0} 분","listing-page-category-all":"전체","listing-page-no-matches":"일치 없음","listing-page-words":"{0} 단어"},"metadata":{"lang":"ko","fig-responsive":true,"quarto-version":"1.4.543","theme":{"light":["cosmo","../../../../../theme.scss"],"dark":["cosmo","../../../../../theme-dark.scss"]},"code-copy":true,"grid":{"sidebar-width":"200px","body-width":"1200px","margin-width":"200px"},"comments":{"giscus":{"repo":"kmink3225/blog","category":"Blog"}},"title-block-banner":"#EDF3F9","title-block-banner-color":"black","toc-location":"right","open-graph":true,"twitter-card":true,"search":true,"date-format":"YYYY년 MM월 DD일","title":"텍스트 벡터화: 신경망 기반 방법론","subtitle":"Word2Vec, GloVe, FastText부터 ELMo, BERT, SBERT까지 문맥을 이해하는 벡터 표현 소개","description":"정적 임베딩의 한계를 넘어, 단어의 문맥적 의미를 동적으로 포착하는 ELMo, BERT, GPT, SBERT와 같은 주요 문맥 기반 임베딩 모델들의 원리, 특징, 혁신적인 기여를 살펴본다.\n","categories":["NLP","Deep Learning"],"author":"Kwangmin Kim","date":"2025-01-20","draft":false,"page-layout":"full"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}