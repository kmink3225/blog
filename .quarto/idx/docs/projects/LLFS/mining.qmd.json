{"title":"Data Mining","markdown":{"yaml":{"title":"Data Mining","subtitle":"Unsupervised Learning","description":"Data mining was performed to observe patterns of data in macroscopic observations or in the level of large data.","author":"Kwangmin Kim","date":"2023-02-25","execute":{"warning":false,"message":false,"freeze":true},"format":{"html":{"toc":true,"number-sections":true,"page-layout":"full","code-fold":true,"fig-width":7.5,"fig-height":7.5}}},"headingText":"clear objects","containsRefs":false,"markdown":"\n\n\n\n<ul class=\"nav nav-pills\" id=\"language-tab\" role=\"tablist\">\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link active\" id=\"Korean-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#Korean\" type=\"button\" role=\"tab\" aria-controls=\"Korean\" aria-selected=\"true\">Korean</button>\n  </li>\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link\" id=\"English-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#English\" type=\"button\" role=\"tab\" aria-controls=\"knitr\" aria-selected=\"false\">English</button>\n  </li>\n\n<div class=\"tab-content\" id=\"language-tabcontent\">\n\n<div class=\"tab-pane fade  show active\" id=\"Korean\" role=\"tabpanel\" aria-labelledby=\"Korean-tab\">\n\n::: {#Korean .tab-pane .fade .show .active role=\"tabpanel\" aria-labelledby=\"Korean-tab\"}\n\n\n```{r}\n#| echo: false\n\nrm(list = ls())\n\n# setting datapath\nif (grepl(\"kkm\", getwd())) {\n    datapath <- \"C:/Users/kkm/Desktop/projects/website/docs/\"\n} else {\n    datapath <- \"C:/Users/kmkim/Desktop/projects/website/docs/\"\n}\n\n# load libraries\nif (!require(janitor)) install.packages(\"janitor\")\nif (!require(tidyverse)) install.packages(\"tidyverse\")\nif (!require(tidymodels)) install.packages(\"tidymodels\")\nif (!require(glmnet)) install.packages(\"glmnet\")\nif (!require(MASS)) install.packages(\"MASS\")\nif (!require(ggpubr)) install.packages(\"ggpubr\")\nif (!require(car)) install.packages(\"car\")\nif (!require(caret)) install.packages(\"caret\")\nif (!require(plotly)) install.packages(\"plotly\")\nif (!require(mixOmics)) install.packages(\"mixOmics\")\n# if(!require(reticulate)) install.packages(\"reticulate\")\nlibrary(janitor)\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(glmnet)\nlibrary(MASS)\nlibrary(ggpubr)\nlibrary(car)\nlibrary(caret)\nlibrary(mixOmics)\nlibrary(plotly)\n# library(reticulate)\n\n# set a seed number\nset.seed(20230223)\n\n# load functions\nsource(paste0(datapath, \"functions/R/functions.r\"))\n\nknitr::opts_chunk$set(message = FALSE, warning = FALSE)\n\n# load simulation data\nsimulated_data <- read_rds(paste0(datapath, \"data/llfs_simulated_data.rds\"))\nsignificant_metabolites <- read_rds(paste0(datapath, \"data/llfs_fake_significant_metabolites.rds\"))\n# simple data pre-processing\nall_data <-\n    simulated_data %>%\n    mutate(\n        outcome = factor(outcome, levels = c(\"negative\", \"positive\")),\n        sex = ifelse(sex == 0, \"man\", \"woman\"),\n        sex = factor(sex, levels = c(\"man\", \"woman\")),\n        genotype = factor(genotype, levels = c(\"e3\", \"e2\", \"e4\"))\n    )\n\n# rename metabolite variables\npredictor_size <- 1000\nnames(all_data)[6:ncol(all_data)] <- paste0(\"meta\", 1:predictor_size)\n\n\n```\n\n## Data Mining\n\n### PCA (Principal Component Analysis)\n\n```{r}\nmetabolite_data <- all_data[, -c(1:5)]\noutcome_data <- all_data[, 2]\n\n# normalize the metaoblites\nnormalized_metabolite_data <-\n    as.data.frame(lapply(metabolite_data, function(x) scale_function(vector = x, method = \"min-max\")))\nnormalized_significant_metabolite_data <-\n    normalized_metabolite_data %>%\n    dplyr::select(all_of(significant_metabolites))\n\n# extract the latent variables (PCs: Principal Components)\npc_metabolites <-\n    prcomp(normalized_metabolite_data)\npc_significant_metabolites <-\n    prcomp(normalized_significant_metabolite_data)\n\n# calculate scores\nscores <-\n    as.data.frame(pc_metabolites$x) %>%\n    janitor::clean_names() %>%\n    mutate(row_names = 1:n())\nsignificant_scores <-\n    as.data.frame(pc_significant_metabolites$x) %>%\n    janitor::clean_names() %>%\n    mutate(row_names = 1:n())\n\ntemp <-\n    as.data.frame(pc_metabolites$rotation) %>%\n    janitor::clean_names()\nloadings <- temp %>%\n    mutate(\n        metabolites = rownames(.),\n        arrow_size_normalization = min(\n            (max(scores[, \"pc1\"]) - min(scores[, \"pc1\"]) /\n                (max(temp[, \"pc1\"]) - min(temp[, \"pc1\"]))),\n            (max(scores[, \"pc2\"]) - min(scores[, \"pc2\"]) /\n                (max(temp[, \"pc2\"]) - min(temp[, \"pc2\"]))),\n            (max(scores[, \"pc3\"]) - min(scores[, \"pc3\"]) /\n                (max(temp[, \"pc3\"]) - min(temp[, \"pc3\"])))\n        ),\n        arrow_pc1 = arrow_size_normalization * pc1,\n        arrow_pc2 = arrow_size_normalization * pc2,\n        arrow_pc3 = arrow_size_normalization * pc3\n    )\n\ntemp <-\n    as.data.frame(pc_significant_metabolites$rotation) %>%\n    janitor::clean_names()\nsignificant_loadings <- temp %>%\n    mutate(\n        metabolites = rownames(.),\n        arrow_size_normalization = min(\n            (max(scores[, \"pc1\"]) - min(scores[, \"pc1\"]) /\n                (max(temp[, \"pc1\"]) - min(temp[, \"pc1\"]))),\n            (max(scores[, \"pc2\"]) - min(scores[, \"pc2\"]) /\n                (max(temp[, \"pc2\"]) - min(temp[, \"pc2\"]))),\n            (max(scores[, \"pc3\"]) - min(scores[, \"pc3\"]) /\n                (max(temp[, \"pc3\"]) - min(temp[, \"pc3\"])))\n        ),\n        arrow_pc1 = arrow_size_normalization * pc1,\n        arrow_pc2 = arrow_size_normalization * pc2,\n        arrow_pc3 = arrow_size_normalization * pc3\n    )\n# arrow_size_normalization is a normalization factor that\n# ensures the variable loading arrows are scaled appropriately relative to the data points.\n# The min() function to find the smallest ratio between the range of the data points and\n# the range of the variable loadings along each principal component axis (pc1, pc2, and pc3).\n# The reason why I select the first 3 components is that\n# '3' is the maximum dimension that can visualize the PCA results in 3d.\n\noutcome_scores <-\n    scores %>%\n    mutate(\n        outcome = outcome_data,\n        row_names = 1:n()\n    )\noutcome_significant_scores <-\n    significant_scores %>%\n    mutate(\n        outcome = outcome_data,\n        row_names = 1:n()\n    )\n\n\n# total variance\ntotal_variance <-\n    data.frame(\n        pc = 1:length(pc_metabolites$sdev),\n        pc_variance_proportion = summary(pc_metabolites)[[\"importance\"]][\"Proportion of Variance\", ],\n        cumulative_proportion = summary(pc_metabolites)[[\"importance\"]][\"Cumulative Proportion\", ] * 100\n    )\ntotal_variance_significance <-\n    data.frame(\n        pc = 1:length(pc_significant_metabolites$sdev),\n        pc_variance_proportion = summary(pc_significant_metabolites)[[\"importance\"]][\"Proportion of Variance\", ],\n        cumulative_proportion = summary(pc_significant_metabolites)[[\"importance\"]][\"Cumulative Proportion\", ] * 100\n    )\n\nscree_plot <- function(indata) {\n    scree_plot1 <- ggplot(\n        data = indata,\n        aes(x = pc, y = pc_variance_proportion, group = 1)\n    ) +\n        geom_point() +\n        geom_line() +\n        labs(title = \"\", subtitle = paste0(\n            \"Scree Plot, Total Variance(\",\n            round(tail(indata, 1)[\"cumulative_proportion\"], 3),\n            \"%)Explained by \", nrow(indata), \" PCs\"\n        )) +\n        ylab(\"Total Variance Explained\") +\n        xlab(\"Principal Components\")\n    scree_plot2 <- ggplot(\n        data = indata %>% filter(pc < 13),\n        aes(x = pc, y = pc_variance_proportion, group = 1)\n    ) +\n        geom_point() +\n        geom_line() +\n        labs(title = \"\", subtitle = paste0(\n            \"Scree Plot, Part of Variance(\",\n            round(tail(indata %>% filter(pc < 13), 1)[\"cumulative_proportion\"], 3),\n            \"%)Explained by \", indata %>% filter(pc < 13) %>% nrow(), \" PCs\"\n        )) +\n        ylab(\"Total Variance Explained\") +\n        xlab(\"Principal Components\")\n    return(ggarrange(scree_plot1, scree_plot2, nrow = 1))\n}\n\nggarrange(scree_plot(total_variance), scree_plot(total_variance_significance),\n    labels = c(\n        paste0(\"All \", ncol(metabolite_data), \" Metabolites\"),\n        paste0(length(significant_metabolites), \" Significant Metabolites\")\n    ), nrow = 2\n)\n\n\n# 2D PCA Scatter Plots with PC1 and PC2\n\nscatter_plot <- function(in_data) {\n    p <- ggplot(\n        data = in_data,\n        aes(x = pc1, y = pc2, color = outcome)\n    ) +\n        geom_text(alpha = .5, size = 3, aes(label = row_names)) +\n        stat_ellipse(type = \"norm\", level = .99) +\n        geom_hline(aes(yintercept = 0), alpha = 0.5, size = .1) +\n        geom_vline(aes(xintercept = 0), alpha = 0.5, size = .1) +\n        scale_color_manual(values = color_function(length(unique(in_data$outcome)))) +\n        labs(\n            title = \"2D Scatter Plot of the First 2 PCs Grouped by AD status\",\n            subtitle = paste0(ncol(in_data) - 2, \" Metabolites\")\n        )\n    return(p)\n}\n\nggarrange(scatter_plot(outcome_scores),\n    scatter_plot(outcome_significant_scores),\n    nrow = 2\n)\n\n\n# biplot\nbi_plot <- function(in_data) {\n    p <-\n        ggplot(data = in_data, aes(x = pc1, y = pc2, color = outcome)) +\n        geom_text(alpha = .75, size = 3, aes(label = row_names)) +\n        geom_hline(aes(yintercept = 0), alpha = 0.5, size = .1) +\n        geom_vline(aes(xintercept = 0), alpha = 0.5, size = .1) +\n        coord_equal() +\n        scale_color_manual(values = color_function(length(unique(in_data$outcome)))) +\n        stat_ellipse(type = \"norm\", level = .99) +\n        geom_text(\n            data = loadings, aes(x = arrow_pc1, y = arrow_pc2, label = metabolites),\n            alpha = 0.5, size = 5, vjust = 1, color = \"red\"\n        ) +\n        geom_segment(\n            data = loadings, aes(x = 0, y = 0, xend = arrow_pc1, yend = arrow_pc2),\n            arrow = arrow(length = unit(0.5, \"cm\")), alpha = 0.5, color = \"red\"\n        ) +\n        labs(\n            title = \"Biplot, the Effect of Metabolites on Samples with Disease Status\",\n            subtitle = paste0(ncol(in_data) - 2, \" Metabolites\")\n        ) +\n        ylab(\"PC2\") +\n        xlab(\"PC1\")\n    return(p)\n}\nggarrange(bi_plot(outcome_scores), bi_plot(outcome_significant_scores), nrow = 2)\n\n\n\nplot_ly(\n    data = outcome_scores,\n    x = ~pc1, y = ~pc2, z = ~pc3,\n    type = \"scatter3d\", mode = \"markers\", color = ~ outcome_scores$outcome,\n    colors = color_function(2),\n    size = 2\n) %>%\n    layout(\n        title = \"Effect of 500 Metabolites on Samples with Disease Status in 3d\",\n        scene = list(\n            bgcolor = \"#e5ecf6\",\n            xaxis = list(title = \"PC1\"),\n            yaxis = list(title = \"PC2\"),\n            zaxis = list(title = \"PC3\")\n        ),\n        legend = list(title = list(text = \"Disease(AD) Status\"))\n    )\n\nplot_ly(\n    data = outcome_significant_scores,\n    x = ~pc1, y = ~pc2, z = ~pc3,\n    type = \"scatter3d\", mode = \"markers\", color = ~ outcome_scores$outcome,\n    colors = color_function(2),\n    size = 2\n) %>%\n    layout(\n        title = \"Effect of 201 Metabolites on Samples with Disease Status in 3d\",\n        scene = list(\n            bgcolor = \"#e5ecf6\",\n            xaxis = list(title = \"PC1\"),\n            yaxis = list(title = \"PC2\"),\n            zaxis = list(title = \"PC3\")\n        ),\n        legend = list(title = list(text = \"Disease(AD) Status\"))\n    )\n\n```\n\n### K-means Clustering\n\n```{r}\n\nkmean_result_list <- list(\n    \"mse_list\" = list(\n        \"all_metabolites\" = matrix(nrow = 20),\n        \"significant_metabolites\" = matrix(nrow = 20)\n    ),\n    \"cluster_sse_list\" = list(\n        \"all_metabolites\" = matrix(nrow = 20, ncol = 2),\n        \"significant_metabolites\" = matrix(nrow = 20, ncol = 2)\n    ),\n    \"Variance_Explained\" = list(\n        \"all_metabolites\" = matrix(nrow = 20),\n        \"significant_metabolites\" = matrix(nrow = 20)\n    )\n)\n\nfor (j in c(\"all_metabolites\", \"significant_metabolites\")) {\n    for (i in (1:20)) {\n        if (j == \"all_metabolites\") {\n            kmean_fit <- kmeans(normalized_metabolite_data, centers = i, iter.max = 300)\n        } else {\n            kmean_fit <- kmeans(normalized_significant_metabolite_data, centers = i, iter.max = 300)\n        }\n        kmean_result_list[[\"mse_list\"]][[j]][i] <- mean(kmean_fit$withinss) %>% round(3)\n        kmean_result_list[[\"cluster_sse_list\"]][[j]][i, 1] <- i\n        kmean_result_list[[\"cluster_sse_list\"]][[j]][i, 2] <- kmean_result_list[[\"mse_list\"]][[j]][i]\n        kmean_result_list[[\"Variance_Explained\"]][[j]][i] <- kmean_fit$betweenss / kmean_fit$totss\n        cat(\n            \"For \", j, \", K: \", i,\n            \"within-cluster MSE: \", kmean_result_list[[\"mse_list\"]][[j]][i],\n            \"Variance_Explained: \", kmean_result_list[[\"Variance_Explained\"]][[j]][i], \"\\n\"\n        )\n    }\n}\n\nkmean_mse_data <-\n    rbind(\n        data.frame(\n            metabolites = \"all_metabolites\",\n            k = kmean_result_list[[\"cluster_sse_list\"]][[\"all_metabolites\"]][, 1],\n            mse = kmean_result_list[[\"cluster_sse_list\"]][[\"all_metabolites\"]][, 2],\n            variance_exaplained = kmean_result_list[[\"Variance_Explained\"]][[\"all_metabolites\"]]\n        ),\n        data.frame(\n            metabolites = \"significant_metabolites\",\n            k = kmean_result_list[[\"cluster_sse_list\"]][[\"significant_metabolites\"]][, 1],\n            mse = kmean_result_list[[\"cluster_sse_list\"]][[\"significant_metabolites\"]][, 2],\n            variance_exaplained = kmean_result_list[[\"Variance_Explained\"]][[\"significant_metabolites\"]]\n        )\n    )\n\nggarrange(\n    ggplot(\n        data = kmean_mse_data,\n        aes(x = k, y = mse, group = metabolites, color = metabolites)\n    ) +\n        geom_line() +\n        geom_point() +\n        scale_color_manual(values = color_function(2)) +\n        labs(title = \"K Mean Clustering Result: MSE for All Metabolites vs Significant Ones\") +\n        xlab(\"Number of Clusters\") +\n        ylab(\"Mean Squared Error\"),\n    ggplot(\n        data = kmean_mse_data,\n        aes(x = k, y = variance_exaplained, group = metabolites, color = metabolites)\n    ) +\n        geom_line() +\n        geom_point() +\n        scale_color_manual(values = color_function(2)) +\n        labs(title = \"K Mean Clustering Result: Variance Explained for All Metabolites vs Significant Ones\") +\n        xlab(\"Number of Clusters\") +\n        ylab(\"Variance Exaplained\"),\n    ncol = 1\n)\n\n# K means\n\n\nkm_clustering <- kmeans(normalized_metabolite_data, centers = 2, iter.max = 300)\nkm_significant_clustering <- kmeans(normalized_significant_metabolite_data, centers = 2, iter.max = 300)\n\nconfusionMatrix(table(all_data[, 2], ifelse(km_clustering$cluster == 1, \"negative\", \"positive\")))\nconfusionMatrix(table(all_data[, 2], ifelse(km_significant_clustering$cluster == 1, \"negative\", \"positive\")))\n\noutcome_pca_km <- outcome_scores %>%\n    mutate(\n        km_clusters = km_clustering$cluster,\n        km_clusters = factor(km_clusters, levels = c(1, 2)),\n        km_significant_clusters = km_significant_clustering$cluster,\n        km_significant_clusters = factor(km_significant_clusters, levels = c(1, 2))\n    )\n\n\nggplot(\n    data = outcome_pca_km,\n    aes(x = pc1, y = pc2, color = km_clusters)\n) +\n    geom_text(alpha = .5, size = 3, aes(label = row_names)) +\n    stat_ellipse(type = \"norm\", level = .99) +\n    geom_hline(aes(yintercept = 0), alpha = 0.5, size = .1) +\n    geom_vline(aes(xintercept = 0), alpha = 0.5, size = .1) +\n    scale_color_manual(values = color_function(2)) +\n    labs(\n        title = \"2D Scatter Plot of the First 2 PCs Grouped by K Mean Clusters, AD Status\",\n        subtitle = paste0(ncol(outcome_scores) - 2, \" Metabolites\")\n    )\n\nggplot(\n    data = outcome_pca_km,\n    aes(x = pc1, y = pc2, color = km_significant_clusters)\n) +\n    geom_text(alpha = .5, size = 3, aes(label = row_names)) +\n    stat_ellipse(type = \"norm\", level = .99) +\n    geom_hline(aes(yintercept = 0), alpha = 0.5, size = .1) +\n    geom_vline(aes(xintercept = 0), alpha = 0.5, size = .1) +\n    scale_color_manual(values = color_function(2)) +\n    labs(\n        title = \"2D Scatter Plot of the First 2 PCs Grouped by K Mean Clusters, AD Status\",\n        subtitle = paste0(ncol(outcome_significant_scores) - 2, \" Metabolites\")\n    )\n\n\n\n```\n\n비지도 학습 방법인 PCA와 K-means clustering를 이용하여 차원 축소와 군집화를 시도하였으나, 이 방법을 사용하는 모든 대사체에 대해 AD 상태가 명확하게 분류되지 않는 것으로 보인다. PCA와 K-means는 EDA에서 선별된 대사산물로 군집화를 수행했을 때 전체 metabolites 보다 선별된 metabolites 에서 AD 상태에 대한 정보가 조금 더 많이 설명되는 것을 PCA를 통해 관찰할 수 있었다. K means clustering도 선별된 metabolites에 대해서 성능 향상을 보여준다. 그러나 전반적인 정확도가 매우 낮기 때문에 지도 학습을 통해 AD 상태를 잘 설명하는 대사체를 선택할 것이다.\n\nDimensionality reduction and clustering were attempted using PCA and K-means clustering, which are unsupervised learning methods, but AD status seems to not be clearly classified for all metabolites using the methods. When PCA and K means clustering were performed with the metabolites selected from EDA, it was observed through PCA that a little more information about AD status was explained with the selected metabolites than with the entire set of metaboliotes. K means clustering also showed an improvement in performance with the selected metabolites. However, the overall accuracy is very low, so we will select metabolites that explain AD status well through supervised learning.\n\n```{r}\n#| eval: false\n#| echo: false\n\n# SVD\nlibrary(svd)\n\ndigits_data <- read.csv(\"digitsdata.csv\")\n\nremove_cols <- c(\"target\")\nx_data <- digits_data[, !(names(digits_data) %in% remove_cols)]\ny_data <- digits_data[, c(\"target\")]\n\n\n\nsv2 <- svd(x_data, nu = 15)\n\nsv_check <- sv2$d\n\n# Computing the square of the singular values, which can be thought of as the vector of matrix energy\n# in order to pick top singular values which preserve at least 80% of variance explained\nenergy <- sv2$d^2\ntot_varexp <- data.frame(cumsum(energy) / sum(energy))\n\nnames(tot_varexp) <- \"cum_var_explained\"\ntot_varexp$K_value <- 1:nrow(tot_varexp)\n\nplot(tot_varexp[, 2], tot_varexp[, 1], type = \"o\", xlab = \"K_Value\", ylab = \"Prop. of Var Explained\")\ntitle(\"SVD - Prop. of Var explained with K-value\")\n\n\n```\n\n```{r}\n#| echo: false\n#| eval: false\n\nfor (i in 1:p) {\n    form <- paste(\"lm(\", paste0(var[i], collapse = \"+\"), \"~ . , data=as.data.frame(data) ) \")\n    fit <- eval(parse(text = form))\n    fit\n    lm_result[i] <- list(summary(fit))\n}\n\n```\n\n\n:::\n</div>\n\n<div class=\"tab-pane fade\" id=\"English\" role=\"tabpanel\" aria-labelledby=\"English-tab\">\n\n::: {#English .tab-pane .fade role=\"tabpanel\" aria-labelledby=\"English-tab\"}\n\n:::\n\n\n</div>\n\n\n","srcMarkdownNoYaml":"\n\n\n\n<ul class=\"nav nav-pills\" id=\"language-tab\" role=\"tablist\">\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link active\" id=\"Korean-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#Korean\" type=\"button\" role=\"tab\" aria-controls=\"Korean\" aria-selected=\"true\">Korean</button>\n  </li>\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link\" id=\"English-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#English\" type=\"button\" role=\"tab\" aria-controls=\"knitr\" aria-selected=\"false\">English</button>\n  </li>\n\n<div class=\"tab-content\" id=\"language-tabcontent\">\n\n<div class=\"tab-pane fade  show active\" id=\"Korean\" role=\"tabpanel\" aria-labelledby=\"Korean-tab\">\n\n::: {#Korean .tab-pane .fade .show .active role=\"tabpanel\" aria-labelledby=\"Korean-tab\"}\n\n\n```{r}\n#| echo: false\n\n# clear objects\nrm(list = ls())\n\n# setting datapath\nif (grepl(\"kkm\", getwd())) {\n    datapath <- \"C:/Users/kkm/Desktop/projects/website/docs/\"\n} else {\n    datapath <- \"C:/Users/kmkim/Desktop/projects/website/docs/\"\n}\n\n# load libraries\nif (!require(janitor)) install.packages(\"janitor\")\nif (!require(tidyverse)) install.packages(\"tidyverse\")\nif (!require(tidymodels)) install.packages(\"tidymodels\")\nif (!require(glmnet)) install.packages(\"glmnet\")\nif (!require(MASS)) install.packages(\"MASS\")\nif (!require(ggpubr)) install.packages(\"ggpubr\")\nif (!require(car)) install.packages(\"car\")\nif (!require(caret)) install.packages(\"caret\")\nif (!require(plotly)) install.packages(\"plotly\")\nif (!require(mixOmics)) install.packages(\"mixOmics\")\n# if(!require(reticulate)) install.packages(\"reticulate\")\nlibrary(janitor)\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(glmnet)\nlibrary(MASS)\nlibrary(ggpubr)\nlibrary(car)\nlibrary(caret)\nlibrary(mixOmics)\nlibrary(plotly)\n# library(reticulate)\n\n# set a seed number\nset.seed(20230223)\n\n# load functions\nsource(paste0(datapath, \"functions/R/functions.r\"))\n\nknitr::opts_chunk$set(message = FALSE, warning = FALSE)\n\n# load simulation data\nsimulated_data <- read_rds(paste0(datapath, \"data/llfs_simulated_data.rds\"))\nsignificant_metabolites <- read_rds(paste0(datapath, \"data/llfs_fake_significant_metabolites.rds\"))\n# simple data pre-processing\nall_data <-\n    simulated_data %>%\n    mutate(\n        outcome = factor(outcome, levels = c(\"negative\", \"positive\")),\n        sex = ifelse(sex == 0, \"man\", \"woman\"),\n        sex = factor(sex, levels = c(\"man\", \"woman\")),\n        genotype = factor(genotype, levels = c(\"e3\", \"e2\", \"e4\"))\n    )\n\n# rename metabolite variables\npredictor_size <- 1000\nnames(all_data)[6:ncol(all_data)] <- paste0(\"meta\", 1:predictor_size)\n\n\n```\n\n## Data Mining\n\n### PCA (Principal Component Analysis)\n\n```{r}\nmetabolite_data <- all_data[, -c(1:5)]\noutcome_data <- all_data[, 2]\n\n# normalize the metaoblites\nnormalized_metabolite_data <-\n    as.data.frame(lapply(metabolite_data, function(x) scale_function(vector = x, method = \"min-max\")))\nnormalized_significant_metabolite_data <-\n    normalized_metabolite_data %>%\n    dplyr::select(all_of(significant_metabolites))\n\n# extract the latent variables (PCs: Principal Components)\npc_metabolites <-\n    prcomp(normalized_metabolite_data)\npc_significant_metabolites <-\n    prcomp(normalized_significant_metabolite_data)\n\n# calculate scores\nscores <-\n    as.data.frame(pc_metabolites$x) %>%\n    janitor::clean_names() %>%\n    mutate(row_names = 1:n())\nsignificant_scores <-\n    as.data.frame(pc_significant_metabolites$x) %>%\n    janitor::clean_names() %>%\n    mutate(row_names = 1:n())\n\ntemp <-\n    as.data.frame(pc_metabolites$rotation) %>%\n    janitor::clean_names()\nloadings <- temp %>%\n    mutate(\n        metabolites = rownames(.),\n        arrow_size_normalization = min(\n            (max(scores[, \"pc1\"]) - min(scores[, \"pc1\"]) /\n                (max(temp[, \"pc1\"]) - min(temp[, \"pc1\"]))),\n            (max(scores[, \"pc2\"]) - min(scores[, \"pc2\"]) /\n                (max(temp[, \"pc2\"]) - min(temp[, \"pc2\"]))),\n            (max(scores[, \"pc3\"]) - min(scores[, \"pc3\"]) /\n                (max(temp[, \"pc3\"]) - min(temp[, \"pc3\"])))\n        ),\n        arrow_pc1 = arrow_size_normalization * pc1,\n        arrow_pc2 = arrow_size_normalization * pc2,\n        arrow_pc3 = arrow_size_normalization * pc3\n    )\n\ntemp <-\n    as.data.frame(pc_significant_metabolites$rotation) %>%\n    janitor::clean_names()\nsignificant_loadings <- temp %>%\n    mutate(\n        metabolites = rownames(.),\n        arrow_size_normalization = min(\n            (max(scores[, \"pc1\"]) - min(scores[, \"pc1\"]) /\n                (max(temp[, \"pc1\"]) - min(temp[, \"pc1\"]))),\n            (max(scores[, \"pc2\"]) - min(scores[, \"pc2\"]) /\n                (max(temp[, \"pc2\"]) - min(temp[, \"pc2\"]))),\n            (max(scores[, \"pc3\"]) - min(scores[, \"pc3\"]) /\n                (max(temp[, \"pc3\"]) - min(temp[, \"pc3\"])))\n        ),\n        arrow_pc1 = arrow_size_normalization * pc1,\n        arrow_pc2 = arrow_size_normalization * pc2,\n        arrow_pc3 = arrow_size_normalization * pc3\n    )\n# arrow_size_normalization is a normalization factor that\n# ensures the variable loading arrows are scaled appropriately relative to the data points.\n# The min() function to find the smallest ratio between the range of the data points and\n# the range of the variable loadings along each principal component axis (pc1, pc2, and pc3).\n# The reason why I select the first 3 components is that\n# '3' is the maximum dimension that can visualize the PCA results in 3d.\n\noutcome_scores <-\n    scores %>%\n    mutate(\n        outcome = outcome_data,\n        row_names = 1:n()\n    )\noutcome_significant_scores <-\n    significant_scores %>%\n    mutate(\n        outcome = outcome_data,\n        row_names = 1:n()\n    )\n\n\n# total variance\ntotal_variance <-\n    data.frame(\n        pc = 1:length(pc_metabolites$sdev),\n        pc_variance_proportion = summary(pc_metabolites)[[\"importance\"]][\"Proportion of Variance\", ],\n        cumulative_proportion = summary(pc_metabolites)[[\"importance\"]][\"Cumulative Proportion\", ] * 100\n    )\ntotal_variance_significance <-\n    data.frame(\n        pc = 1:length(pc_significant_metabolites$sdev),\n        pc_variance_proportion = summary(pc_significant_metabolites)[[\"importance\"]][\"Proportion of Variance\", ],\n        cumulative_proportion = summary(pc_significant_metabolites)[[\"importance\"]][\"Cumulative Proportion\", ] * 100\n    )\n\nscree_plot <- function(indata) {\n    scree_plot1 <- ggplot(\n        data = indata,\n        aes(x = pc, y = pc_variance_proportion, group = 1)\n    ) +\n        geom_point() +\n        geom_line() +\n        labs(title = \"\", subtitle = paste0(\n            \"Scree Plot, Total Variance(\",\n            round(tail(indata, 1)[\"cumulative_proportion\"], 3),\n            \"%)Explained by \", nrow(indata), \" PCs\"\n        )) +\n        ylab(\"Total Variance Explained\") +\n        xlab(\"Principal Components\")\n    scree_plot2 <- ggplot(\n        data = indata %>% filter(pc < 13),\n        aes(x = pc, y = pc_variance_proportion, group = 1)\n    ) +\n        geom_point() +\n        geom_line() +\n        labs(title = \"\", subtitle = paste0(\n            \"Scree Plot, Part of Variance(\",\n            round(tail(indata %>% filter(pc < 13), 1)[\"cumulative_proportion\"], 3),\n            \"%)Explained by \", indata %>% filter(pc < 13) %>% nrow(), \" PCs\"\n        )) +\n        ylab(\"Total Variance Explained\") +\n        xlab(\"Principal Components\")\n    return(ggarrange(scree_plot1, scree_plot2, nrow = 1))\n}\n\nggarrange(scree_plot(total_variance), scree_plot(total_variance_significance),\n    labels = c(\n        paste0(\"All \", ncol(metabolite_data), \" Metabolites\"),\n        paste0(length(significant_metabolites), \" Significant Metabolites\")\n    ), nrow = 2\n)\n\n\n# 2D PCA Scatter Plots with PC1 and PC2\n\nscatter_plot <- function(in_data) {\n    p <- ggplot(\n        data = in_data,\n        aes(x = pc1, y = pc2, color = outcome)\n    ) +\n        geom_text(alpha = .5, size = 3, aes(label = row_names)) +\n        stat_ellipse(type = \"norm\", level = .99) +\n        geom_hline(aes(yintercept = 0), alpha = 0.5, size = .1) +\n        geom_vline(aes(xintercept = 0), alpha = 0.5, size = .1) +\n        scale_color_manual(values = color_function(length(unique(in_data$outcome)))) +\n        labs(\n            title = \"2D Scatter Plot of the First 2 PCs Grouped by AD status\",\n            subtitle = paste0(ncol(in_data) - 2, \" Metabolites\")\n        )\n    return(p)\n}\n\nggarrange(scatter_plot(outcome_scores),\n    scatter_plot(outcome_significant_scores),\n    nrow = 2\n)\n\n\n# biplot\nbi_plot <- function(in_data) {\n    p <-\n        ggplot(data = in_data, aes(x = pc1, y = pc2, color = outcome)) +\n        geom_text(alpha = .75, size = 3, aes(label = row_names)) +\n        geom_hline(aes(yintercept = 0), alpha = 0.5, size = .1) +\n        geom_vline(aes(xintercept = 0), alpha = 0.5, size = .1) +\n        coord_equal() +\n        scale_color_manual(values = color_function(length(unique(in_data$outcome)))) +\n        stat_ellipse(type = \"norm\", level = .99) +\n        geom_text(\n            data = loadings, aes(x = arrow_pc1, y = arrow_pc2, label = metabolites),\n            alpha = 0.5, size = 5, vjust = 1, color = \"red\"\n        ) +\n        geom_segment(\n            data = loadings, aes(x = 0, y = 0, xend = arrow_pc1, yend = arrow_pc2),\n            arrow = arrow(length = unit(0.5, \"cm\")), alpha = 0.5, color = \"red\"\n        ) +\n        labs(\n            title = \"Biplot, the Effect of Metabolites on Samples with Disease Status\",\n            subtitle = paste0(ncol(in_data) - 2, \" Metabolites\")\n        ) +\n        ylab(\"PC2\") +\n        xlab(\"PC1\")\n    return(p)\n}\nggarrange(bi_plot(outcome_scores), bi_plot(outcome_significant_scores), nrow = 2)\n\n\n\nplot_ly(\n    data = outcome_scores,\n    x = ~pc1, y = ~pc2, z = ~pc3,\n    type = \"scatter3d\", mode = \"markers\", color = ~ outcome_scores$outcome,\n    colors = color_function(2),\n    size = 2\n) %>%\n    layout(\n        title = \"Effect of 500 Metabolites on Samples with Disease Status in 3d\",\n        scene = list(\n            bgcolor = \"#e5ecf6\",\n            xaxis = list(title = \"PC1\"),\n            yaxis = list(title = \"PC2\"),\n            zaxis = list(title = \"PC3\")\n        ),\n        legend = list(title = list(text = \"Disease(AD) Status\"))\n    )\n\nplot_ly(\n    data = outcome_significant_scores,\n    x = ~pc1, y = ~pc2, z = ~pc3,\n    type = \"scatter3d\", mode = \"markers\", color = ~ outcome_scores$outcome,\n    colors = color_function(2),\n    size = 2\n) %>%\n    layout(\n        title = \"Effect of 201 Metabolites on Samples with Disease Status in 3d\",\n        scene = list(\n            bgcolor = \"#e5ecf6\",\n            xaxis = list(title = \"PC1\"),\n            yaxis = list(title = \"PC2\"),\n            zaxis = list(title = \"PC3\")\n        ),\n        legend = list(title = list(text = \"Disease(AD) Status\"))\n    )\n\n```\n\n### K-means Clustering\n\n```{r}\n\nkmean_result_list <- list(\n    \"mse_list\" = list(\n        \"all_metabolites\" = matrix(nrow = 20),\n        \"significant_metabolites\" = matrix(nrow = 20)\n    ),\n    \"cluster_sse_list\" = list(\n        \"all_metabolites\" = matrix(nrow = 20, ncol = 2),\n        \"significant_metabolites\" = matrix(nrow = 20, ncol = 2)\n    ),\n    \"Variance_Explained\" = list(\n        \"all_metabolites\" = matrix(nrow = 20),\n        \"significant_metabolites\" = matrix(nrow = 20)\n    )\n)\n\nfor (j in c(\"all_metabolites\", \"significant_metabolites\")) {\n    for (i in (1:20)) {\n        if (j == \"all_metabolites\") {\n            kmean_fit <- kmeans(normalized_metabolite_data, centers = i, iter.max = 300)\n        } else {\n            kmean_fit <- kmeans(normalized_significant_metabolite_data, centers = i, iter.max = 300)\n        }\n        kmean_result_list[[\"mse_list\"]][[j]][i] <- mean(kmean_fit$withinss) %>% round(3)\n        kmean_result_list[[\"cluster_sse_list\"]][[j]][i, 1] <- i\n        kmean_result_list[[\"cluster_sse_list\"]][[j]][i, 2] <- kmean_result_list[[\"mse_list\"]][[j]][i]\n        kmean_result_list[[\"Variance_Explained\"]][[j]][i] <- kmean_fit$betweenss / kmean_fit$totss\n        cat(\n            \"For \", j, \", K: \", i,\n            \"within-cluster MSE: \", kmean_result_list[[\"mse_list\"]][[j]][i],\n            \"Variance_Explained: \", kmean_result_list[[\"Variance_Explained\"]][[j]][i], \"\\n\"\n        )\n    }\n}\n\nkmean_mse_data <-\n    rbind(\n        data.frame(\n            metabolites = \"all_metabolites\",\n            k = kmean_result_list[[\"cluster_sse_list\"]][[\"all_metabolites\"]][, 1],\n            mse = kmean_result_list[[\"cluster_sse_list\"]][[\"all_metabolites\"]][, 2],\n            variance_exaplained = kmean_result_list[[\"Variance_Explained\"]][[\"all_metabolites\"]]\n        ),\n        data.frame(\n            metabolites = \"significant_metabolites\",\n            k = kmean_result_list[[\"cluster_sse_list\"]][[\"significant_metabolites\"]][, 1],\n            mse = kmean_result_list[[\"cluster_sse_list\"]][[\"significant_metabolites\"]][, 2],\n            variance_exaplained = kmean_result_list[[\"Variance_Explained\"]][[\"significant_metabolites\"]]\n        )\n    )\n\nggarrange(\n    ggplot(\n        data = kmean_mse_data,\n        aes(x = k, y = mse, group = metabolites, color = metabolites)\n    ) +\n        geom_line() +\n        geom_point() +\n        scale_color_manual(values = color_function(2)) +\n        labs(title = \"K Mean Clustering Result: MSE for All Metabolites vs Significant Ones\") +\n        xlab(\"Number of Clusters\") +\n        ylab(\"Mean Squared Error\"),\n    ggplot(\n        data = kmean_mse_data,\n        aes(x = k, y = variance_exaplained, group = metabolites, color = metabolites)\n    ) +\n        geom_line() +\n        geom_point() +\n        scale_color_manual(values = color_function(2)) +\n        labs(title = \"K Mean Clustering Result: Variance Explained for All Metabolites vs Significant Ones\") +\n        xlab(\"Number of Clusters\") +\n        ylab(\"Variance Exaplained\"),\n    ncol = 1\n)\n\n# K means\n\n\nkm_clustering <- kmeans(normalized_metabolite_data, centers = 2, iter.max = 300)\nkm_significant_clustering <- kmeans(normalized_significant_metabolite_data, centers = 2, iter.max = 300)\n\nconfusionMatrix(table(all_data[, 2], ifelse(km_clustering$cluster == 1, \"negative\", \"positive\")))\nconfusionMatrix(table(all_data[, 2], ifelse(km_significant_clustering$cluster == 1, \"negative\", \"positive\")))\n\noutcome_pca_km <- outcome_scores %>%\n    mutate(\n        km_clusters = km_clustering$cluster,\n        km_clusters = factor(km_clusters, levels = c(1, 2)),\n        km_significant_clusters = km_significant_clustering$cluster,\n        km_significant_clusters = factor(km_significant_clusters, levels = c(1, 2))\n    )\n\n\nggplot(\n    data = outcome_pca_km,\n    aes(x = pc1, y = pc2, color = km_clusters)\n) +\n    geom_text(alpha = .5, size = 3, aes(label = row_names)) +\n    stat_ellipse(type = \"norm\", level = .99) +\n    geom_hline(aes(yintercept = 0), alpha = 0.5, size = .1) +\n    geom_vline(aes(xintercept = 0), alpha = 0.5, size = .1) +\n    scale_color_manual(values = color_function(2)) +\n    labs(\n        title = \"2D Scatter Plot of the First 2 PCs Grouped by K Mean Clusters, AD Status\",\n        subtitle = paste0(ncol(outcome_scores) - 2, \" Metabolites\")\n    )\n\nggplot(\n    data = outcome_pca_km,\n    aes(x = pc1, y = pc2, color = km_significant_clusters)\n) +\n    geom_text(alpha = .5, size = 3, aes(label = row_names)) +\n    stat_ellipse(type = \"norm\", level = .99) +\n    geom_hline(aes(yintercept = 0), alpha = 0.5, size = .1) +\n    geom_vline(aes(xintercept = 0), alpha = 0.5, size = .1) +\n    scale_color_manual(values = color_function(2)) +\n    labs(\n        title = \"2D Scatter Plot of the First 2 PCs Grouped by K Mean Clusters, AD Status\",\n        subtitle = paste0(ncol(outcome_significant_scores) - 2, \" Metabolites\")\n    )\n\n\n\n```\n\n비지도 학습 방법인 PCA와 K-means clustering를 이용하여 차원 축소와 군집화를 시도하였으나, 이 방법을 사용하는 모든 대사체에 대해 AD 상태가 명확하게 분류되지 않는 것으로 보인다. PCA와 K-means는 EDA에서 선별된 대사산물로 군집화를 수행했을 때 전체 metabolites 보다 선별된 metabolites 에서 AD 상태에 대한 정보가 조금 더 많이 설명되는 것을 PCA를 통해 관찰할 수 있었다. K means clustering도 선별된 metabolites에 대해서 성능 향상을 보여준다. 그러나 전반적인 정확도가 매우 낮기 때문에 지도 학습을 통해 AD 상태를 잘 설명하는 대사체를 선택할 것이다.\n\nDimensionality reduction and clustering were attempted using PCA and K-means clustering, which are unsupervised learning methods, but AD status seems to not be clearly classified for all metabolites using the methods. When PCA and K means clustering were performed with the metabolites selected from EDA, it was observed through PCA that a little more information about AD status was explained with the selected metabolites than with the entire set of metaboliotes. K means clustering also showed an improvement in performance with the selected metabolites. However, the overall accuracy is very low, so we will select metabolites that explain AD status well through supervised learning.\n\n```{r}\n#| eval: false\n#| echo: false\n\n# SVD\nlibrary(svd)\n\ndigits_data <- read.csv(\"digitsdata.csv\")\n\nremove_cols <- c(\"target\")\nx_data <- digits_data[, !(names(digits_data) %in% remove_cols)]\ny_data <- digits_data[, c(\"target\")]\n\n\n\nsv2 <- svd(x_data, nu = 15)\n\nsv_check <- sv2$d\n\n# Computing the square of the singular values, which can be thought of as the vector of matrix energy\n# in order to pick top singular values which preserve at least 80% of variance explained\nenergy <- sv2$d^2\ntot_varexp <- data.frame(cumsum(energy) / sum(energy))\n\nnames(tot_varexp) <- \"cum_var_explained\"\ntot_varexp$K_value <- 1:nrow(tot_varexp)\n\nplot(tot_varexp[, 2], tot_varexp[, 1], type = \"o\", xlab = \"K_Value\", ylab = \"Prop. of Var Explained\")\ntitle(\"SVD - Prop. of Var explained with K-value\")\n\n\n```\n\n```{r}\n#| echo: false\n#| eval: false\n\nfor (i in 1:p) {\n    form <- paste(\"lm(\", paste0(var[i], collapse = \"+\"), \"~ . , data=as.data.frame(data) ) \")\n    fit <- eval(parse(text = form))\n    fit\n    lm_result[i] <- list(summary(fit))\n}\n\n```\n\n\n:::\n</div>\n\n<div class=\"tab-pane fade\" id=\"English\" role=\"tabpanel\" aria-labelledby=\"English-tab\">\n\n::: {#English .tab-pane .fade role=\"tabpanel\" aria-labelledby=\"English-tab\"}\n\n:::\n\n\n</div>\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7.5,"fig-height":7.5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":true,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":true,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"github","css":["../../../styles.css"],"toc":true,"toc-depth":4,"number-sections":true,"include-in-header":[{"text":"<style>\n.custom-footer { \n  text-align: center; \n  font-size: 0.8em; \n  color: #666; \n  margin-top: 2rem; \n}\n</style>\n"}],"include-after-body":["../../../js.html"],"output-file":"mining.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","theme":{"light":["cosmo","../../../theme.scss"],"dark":["cosmo","../../../theme-dark.scss"]},"code-copy":true,"grid":{"sidebar-width":"200px","body-width":"1200px","margin-width":"200px"},"title":"Data Mining","subtitle":"Unsupervised Learning","description":"Data mining was performed to observe patterns of data in macroscopic observations or in the level of large data.","author":"Kwangmin Kim","date":"2023-02-25","page-layout":"full"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}