{
  "hash": "62a49007d495389c4663ad9913167f14",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Data Structure (3) Linked List\nsubtitle: Linked List\ndescription: |\n  Data Structure for Data Science\ncategories:\n  - Engineering\nauthor: Kwangmin Kim\ndate: 01/18/2023\ndraft: False\nformat: \n  html:\n    page-layout: full\n    code-fold: true\n---\n\n<ul class=\"nav nav-pills\" id=\"language-tab\" role=\"tablist\">\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link active\" id=\"Korean-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#Korean\" type=\"button\" role=\"tab\" aria-controls=\"Korean\" aria-selected=\"true\">Korean</button>\n  </li>\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link\" id=\"English-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#English\" type=\"button\" role=\"tab\" aria-controls=\"knitr\" aria-selected=\"false\">English</button>\n  </li>\n\n<div class=\"tab-content\" id=\"language-tabcontent\">\n\n<div class=\"tab-pane fade  show active\" id=\"Korean\" role=\"tabpanel\" aria-labelledby=\"Korean-tab\">\n\n\n## 개요\n\n- 연결 리스트는 각 노드가 한 줄로 연결되어 있는 자료 구조다.\n- 각 노드는 (데이터, 포인터) 형태를 가진다.\n- 포인터: 다음 노드의 메모리 주소를 가리키는 목적으로 사용된다.\n- 연결성: 각 노드의 포인터는 다음 혹은 이전 노드를 가리킨다.    \n- 연결 리스트를 이용하면 다양한 자료구조를 구현할 수 있다.\n  - 예시) 스택, 큐 등을 구현 가능\n- Python은 연결 리스트를 활용하는 자료구조를 제공한다.\n- 연결 리스트를 실제 구현해야 하는 경우는 적지만, 그 원리 이해는 자료 구조와 클래스를 작성하는데 도움이 된다.\n\n## 연결 리스트(Linked List) vs. 배열(Array)\n\n- 연결 리스트와 배열(array)을 비교하여 장단점을 이해할 필요가 있다.\n- 특정 위치의 데이터를 삭제할 때, 일반적인 **배열**에서는 $O(N)$ 만큼의 시간이 소요된다.\n- 하지만, **연결 리스트**를 이용하면 단순히 연결만 끊어주면 된다.\n- 따라서 삭제할 위치를 정확히 알고 있는 경우 $O(1)$ 의 시간이 소요된다.\n- 하지만 삭제할 위치를 정확히 알아내기 위해 앞의 코드를 자세히 보게 되는 소요 시간이 증가할 수 있다.\n\n### 배열의 삽입 연산\n\n- 배열에 새로운 원소를 삽입할 때, 최악의 경우 시간 복잡도를 계산하여라.\n- 예시) 배열에서 인덱스 3에 원소 “59”를 삽입할 경우, 인덱스 4 이후의 공간에 있는 데이터를 한칸씩 밀어내는 $O(n)$ 만큼 소요\n\n### 배열의 삭제 연산\n\n- 배열에 존재하는 원소를 삭제할 때, 최악의 경우 시간 복잡도를 계산하여라.\n- 예시) 배열에서 인덱스 3에 해당하는 원소를 삭제한 후 데이터를 한칸 씩 당겨 이동 시키는 $O(n)$ 만큼 소요\n- 따라서, 최악의 경우 시간 복잡도는 $O(N)$ 이다.\n\n### 연결 리스트(Linked List)의 삽입(Insert) 연산\n\n- 삽입할 위치를 알고 있다면, 물리적인 위치를 한 칸씩 옮기지 않아도 삽입할 수 있다.\n- 인덱스 2의 위치에 원소를 삽입할 경우 인덱스 1의 Node에서 인덱스 2에 위치할 데이터를 가리키고 인덱스 2의 node가 인덱스 3의 node를 가리키도록 만들면 된다.\n\n### 연결 리스트(Linked List)의 삭제(Delete) 연산\n\n- 삭제할 위치를 알고 을 경우 연결 리스트 사용\n- 인덱스 2의 위치에 원소를 삭제할 경우 인덱스 1의 Node가 인덱스 3의 node를 가리키게 만들면 됨\n\n### 연결 리스트(Linked List)의 붙이기(Append) 연산\n\n- 뒤에 붙일 때는 남는 공간에 마지막 노드의 다음 위치에 원소를 할당 시키면 된다.\n- 마지막 위치에 새로운 원소를 추가\n\n::: {#111e4e42 .cell message='false' execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nclass Node:\n    def __init__(self, data):\n        self.data = data # 데이터 할당\n        self.next = None # 다음 노드\n\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None # 첫 번째  node\n\n    # 가장 뒤에 노드 삽입\n    def append(self, data):\n        \n        if self.head == None: # 헤드(head)가 비어있는 경우\n            self.head = Node(data)\n            return\n        \n        currrent = self.head # 그렇지 않다면 마지막 노드에 새로운 노드 추가\n\n        while currrent.next is not None: # 다음 노드가 없을 때까지  \n            currrent = currrent.next # 다음 원소로 넘어감\n        currrent.next = Node(data) # 다음 노드가 없으면 새로운 데이터를 추가 \n\n    # 모든 노드를 하나씩 출력\n    def show(self):\n        currrent = self.head\n        while currrent is not None:\n            print(currrent.data, end=\" \")\n            currrent = currrent.next\n\n    # 특정 인덱스(index)의 노드 찾기\n    def search(self, index):\n        node = self.head\n        for _ in range(index):\n            node = node.next\n        return node\n\n    # 특정 인덱스(index)에 노드 삽입\n    def insert(self, index, data):\n        new = Node(data)\n        # 첫 위치에 추가하는 경우\n        if index == 0:\n            new.next = self.head\n            self.head = new\n            return\n        # 삽입할 위치의 앞 노드\n        node = self.search(index - 1)\n        next = node.next\n        node.next = new\n        new.next = next\n\n    # 특정 인덱스(index)의 노드 삭제\n    def remove(self, index):\n        # 첫 위치를 삭제하는 경우\n        if index == 0:\n            self.head = self.head.next\n            return\n        # 삭제할 위치의 앞 노드\n        front = self.search(index - 1)\n        front.next = front.next.next\n\n\nlinked_list = LinkedList()\ndata_list = [3, 5, 9, 8, 5, 6, 1, 7]\n\nfor data in data_list:\n    linked_list.append(data)\n\nprint(\"전체 노드 출력:\", end=\" \")\nlinked_list.show()\n\nlinked_list.insert(4, 4)\nprint(\"\\n전체 노드 출력:\", end=\" \")\nlinked_list.show()\n\nlinked_list.remove(7)\nprint(\"\\n전체 노드 출력:\", end=\" \")\nlinked_list.show()\n\nlinked_list.insert(7, 2)\nprint(\"\\n전체 노드 출력:\", end=\" \")\nlinked_list.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n전체 노드 출력: 3 5 9 8 5 6 1 7 \n전체 노드 출력: 3 5 9 8 4 5 6 1 7 \n전체 노드 출력: 3 5 9 8 4 5 6 7 \n전체 노드 출력: 3 5 9 8 4 5 6 2 7 \n```\n:::\n:::\n\n\n</div>\n\n<div class=\"tab-pane fade\" id=\"English\" role=\"tabpanel\" aria-labelledby=\"English-tab\">\n\n\n</div>\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}