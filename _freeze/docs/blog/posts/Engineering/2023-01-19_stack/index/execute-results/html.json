{
  "hash": "35ccedc3573f42e83b9378fdbf48b6b8",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Data Structure (5) Stack\nsubtitle: Python List\ndescription: |\n  Data Structure for Data Science\ncategories:\n  - Engineering\nauthor: Kwangmin Kim\ndate: 01/19/2023\nformat: \n  html:\n    code-fold: true\n    page-layout: full\nexecute:\n  warning: true  \ndraft: False\n---\n\n<ul class=\"nav nav-pills\" id=\"language-tab\" role=\"tablist\">\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link active\" id=\"Korean-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#Korean\" type=\"button\" role=\"tab\" aria-controls=\"Korean\" aria-selected=\"true\">Korean</button>\n  </li>\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link\" id=\"English-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#English\" type=\"button\" role=\"tab\" aria-controls=\"knitr\" aria-selected=\"false\">English</button>\n  </li>\n\n<div class=\"tab-content\" id=\"language-tabcontent\">\n\n<div class=\"tab-pane fade  show active\" id=\"Korean\" role=\"tabpanel\" aria-labelledby=\"Korean-tab\">\n\n\n## Stack\n\n* 다양한 알고리즘과 프로그램에서 사용됨\n* 스택: 먼저 들어온 데이터가 나중에 나가는 자료구조\n* 흔히 박스가 쌓인 형태를 스택(stack)이라고 한다. 예) 'Deep Learning 알고리즘의 구조가 stacked 되어 있는 구조다' 라고 표현\n  * 우리가 박스를 쌓은 뒤에 꺼낼 때는, 가장 마지막에 올렸던 박스부터 꺼내야 한다.\n* 새로운 원소를 삽입할 때는 마지막 위치에 삽입한다. (가장 최근에 삽입된 원소가 가장 끝에 위치)\n* 새로운 원소를 삭제할 때는 마지막 원소가 삭제된다. (가장 최근에 삽입된 원소가 제거됨)\n* head = 최상위 원소 = 가장 최근에 삽입이된 원소\n\n## 스택 자료구조의 중요성\n\n* 스택은 굉장히 기본적인 자료구조이다.\n* 기계 학습 분야뿐 아니라 다양한 프로그램을 개발할 때 빠지지 않고 사용된다.\n\n## 스택 자료구조의 시간 복잡도\n\n* 스택은 여러 가지 연산을 제공한다.\n\n| Number | Methods          | Time Complexity |        Description                                             |\n|--------|------------------|-----------------|----------------------------------------------------------------|\n| 1      | 삽입(Push)       | $O(1)$          | 스택에 원소를 삽입하는 연산                                      | \n| 2      | 추출(Pop)        | $O(1)$          | 스택에서 원소를 추출하는 연산                                    |\n| 3      | 최상위 원소 (Top) | $O(1)$          | 스택의 최상위 원소(마지막에 들어온 원소) 를 확인(조회)하는 연산    |\n| 4      | Empty            | $O(1)$          | 스택이 비어 있는지 확인하는 연산                                 |\n: a list of the stack functions in Python {#tbl-letters}\n\nSee @tbl-letters.\n\n## Python에서 스택을 구현하는 방법 1: 리스트 자료형\n\n* 파이썬의 기본적인 리스트 자료형은 다음의 두 가지 메서드를 제공한다.\n* append() 메서드: 마지막 위치에 원소를 삽입하며, 시간 복잡도는 $O(1)$ 이다.\n* pop() 메서드: 마지막 위치에서 원소를 추출하며, 시간 복잡도는 $O(1)$ 이다.\n* 따라서 일반적으로 스택을 구현할 때, 파이썬의 리스트(list) 자료형을 사용한다.\n\n::: {#a9dab363 .cell execution_count=1}\n``` {.python .cell-code}\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, data):\n        # 마지막 위치에 원소 삽입\n        self.stack.append(data)\n\n    def pop(self):\n        if self.is_empty():\n            return None\n        # 마지막 원소 추출\n        return self.stack.pop()\n\n    def top(self):\n        if self.is_empty():\n            return None\n        # 마지막 원소 반환\n        return self.stack[-1]\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\n\nstack = Stack()\narr = [9, 7, 2, 5, 6, 4, 2]\nfor x in arr:\n    stack.push(x)\n\nwhile not stack.is_empty():\n    print(stack.pop())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n4\n6\n5\n2\n7\n9\n```\n:::\n:::\n\n\n## 연결 리스트로 스택 구현하기\n\n* 스택을 연결 리스트로 구현하면, 삽입과 삭제에 있어서 $O(1)$ 을 보장한다.\n* 연결 리스트로 구현할 때는 머리(head)를 가리키는 하나의 포인터만 가진다.\n* 머리(head): 남아있는 원소 중 가장 마지막에 들어 온 데이터를 가리키는 포인터\n\n### 삽입 연산\n\n* 삽입할 때는 기존의 머리 뒤에 데이터가 들어가고 포인터가 가장 최근에 삽입된 데이터를 가리키도록 머리(head) 위치를 바꿔준다.\n* 삭제할 때는 머리(head) 위치에서 데이터를 꺼낸다.\n  * 즉, 포인터를 삭제할 데이터에 앞에 있는 데이터로 머리 위치를 바꾸는 것만으로 삭제는 이루어진다.\n\n### 삭제 연산\n\n* 삭제할 때는 머리(head) 위치에서 데이터를 꺼낸다.\n\n::: {#a65ebcf5 .cell execution_count=2}\n``` {.python .cell-code}\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass Stack:\n    def __init__(self):\n        self.head = None\n\n    # 원소 삽입\n    def push(self, data):\n        node = Node(data)\n        node.next = self.head\n        self.head = node\n\n    # 원소 추출하기\n    def pop(self):\n        if self.is_empty():\n            return None\n\n        # 머리(head) 위치에서 노드 꺼내기\n        data = self.head.data\n        self.head = self.head.next\n\n        return data\n\n    # 최상위 원소(top)\n    def top(self):\n        if self.is_empty():\n            return None\n        return self.head.data\n\n    # 먼저 추출할 원소부터 출력\n    def show(self):\n        cur = self.head\n        while cur:\n            print(cur.data, end=\" \")\n            cur = cur.next\n\n    # 스택이 비어있는지 확인\n    def is_empty(self):\n        return self.head is None\n\n\nstack = Stack()\narr = [9, 7, 2, 5, 6, 4, 2]\nfor x in arr:\n    stack.push(x)\nstack.show()\nprint()\n\nwhile not stack.is_empty():\n    print(stack.pop())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2 4 6 5 2 7 9 \n2\n4\n6\n5\n2\n7\n9\n```\n:::\n:::\n\n\n</div>\n\n<div class=\"tab-pane fade\" id=\"English\" role=\"tabpanel\" aria-labelledby=\"English-tab\">\n\n\n</div>\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}