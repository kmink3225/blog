{
  "hash": "efaaa584446deabbced955eb1b76666d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Data Structure (6) Queue\nsubtitle: Python List\ndescription: |\n  Data Structure for Data Science\ncategories:\n  - Engineering\nauthor: Kwangmin Kim\ndate: 01/19/2023\nformat: \n  html:\n    page-layout: full\n    code-fold: true\ndraft: False\n---\n\n<ul class=\"nav nav-pills\" id=\"language-tab\" role=\"tablist\">\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link active\" id=\"Korean-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#Korean\" type=\"button\" role=\"tab\" aria-controls=\"Korean\" aria-selected=\"true\">Korean</button>\n  </li>\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link\" id=\"English-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#English\" type=\"button\" role=\"tab\" aria-controls=\"knitr\" aria-selected=\"false\">English</button>\n  </li>\n\n<div class=\"tab-content\" id=\"language-tabcontent\">\n\n<div class=\"tab-pane fade  show active\" id=\"Korean\" role=\"tabpanel\" aria-labelledby=\"Korean-tab\">\n\n\n## Queue\n\n* 큐(queue)는 먼저 삽입된 데이터가 먼저 추출되는 자료구조(data structure)다. (First-In First-Out)\n* 딥러닝 모델에 들어가는 데이터 순서대로 들어가는데 먼저 들어간 데이터는 먼저 나오게 할때 사용되는 자료 구조이다.\n\n## 연결 리스트로 큐 구현\n\n* 큐를 연결 리스트로 구현하면, 삽입과 삭제에 있어서 $O(1)$ 을 보장할 수 있다.\n* 연결 리스트로 구현할 때는 머리(head)와 꼬리(tail) 두 개의 포인터를 가진다.\n* 머리(head): 남아있는 원소 중 가장 먼저 들어 온 데이터를 가리키는 포인터\n* 꼬리(tail): 남아있는 원소 중 가장 마지막에 들어 온 데이터를 가리키는 포인터\n\n### 삽입 연산\n\n* 삽입할 때는 꼬리(tail) 위치에 데이터를 넣는다.\n* 값으로 8을 갖는 새로운 데이터가 삽입되었을 때 예시)\n\n### 삭제 연산\n\n* 삭제할 때는 머리(head) 위치에서 데이터를 꺼낸다.\n* 하나의 데이터를 삭제할 때의 예시)\n\n::: {#9ea30114 .cell execution_count=1}\n``` {.python .cell-code}\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass Queue:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def enqueue(self, data):\n        node = Node(data)\n        if self.head == None:\n            self.head = node\n            self.tail = node\n        # 꼬리(tail) 위치에 새로운 노드 삽입\n        else:\n            self.tail.next = node\n            self.tail = self.tail.next\n\n    def dequeue(self):\n        if self.head == None:\n            return None\n\n        # 머리(head) 위치에서 노드 꺼내기\n        data = self.head.data\n        self.head = self.head.next\n\n        return data\n\n    def show(self):\n        cur = self.head\n        while cur:\n            print(cur.data, end=\" \")\n            cur = cur.next\n\n\nqueue = Queue()\ndata_list = [3, 5, 9, 8, 5, 6, 1, 7]\n\nfor data in data_list:\n    queue.enqueue(data)\n\nprint(\"\\n전체 노드 출력:\", end=\" \")\nqueue.show()\n\nprint(\"\\n[원소 삭제]\")\nprint(queue.dequeue())\nprint(queue.dequeue())\nprint(queue.dequeue())\n\nprint(\"[원소 삽입]\")\nqueue.enqueue(2)\nqueue.enqueue(5)\nqueue.enqueue(3)\n\nprint(\"전체 노드 출력:\", end=\" \")\nqueue.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n전체 노드 출력: 3 5 9 8 5 6 1 7 \n[원소 삭제]\n3\n5\n9\n[원소 삽입]\n전체 노드 출력: 8 5 6 1 7 2 5 3 \n```\n:::\n:::\n\n\n### 큐 동작 속도: 연결 리스트 vs. 리스트 자료형\n\n* 다수의 데이터를 삽입 및 삭제할 때에 대하여, 수행 시간을 측정할 수 있다.\n* 단순히 Python의 리스트 자료형을 이용할 때보다 수행 시간 관점에서 효율적이다.\n\n::: {#82846cf5 .cell execution_count=2}\n``` {.python .cell-code}\nimport time\n\ndata_list = [i for i in range(100000)]\n\nstart_time = time.time()\n\nqueue = []\nfor data in data_list:\n    queue.append(data)\nwhile queue:\n    queue.pop(0)\n\nprint(f\"Elapsed time: {time.time() - start_time} seconds.\")\nprint(queue)\n\nstart_time = time.time()\n\nqueue = Queue()\nfor data in data_list:\n    queue.enqueue(data)\nwhile queue.head != None:\n    queue.dequeue()\n\nprint(f\"Elapsed time: {time.time() - start_time} seconds.\")\nqueue.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nElapsed time: 0.936833381652832 seconds.\n[]\nElapsed time: 0.1496567726135254 seconds.\n```\n:::\n:::\n\n\n</div>\n\n<div class=\"tab-pane fade\" id=\"English\" role=\"tabpanel\" aria-labelledby=\"English-tab\">\n\n\n</div>\n\n",
    "supporting": [
      "2023-01-19_queue_files"
    ],
    "filters": [],
    "includes": {}
  }
}