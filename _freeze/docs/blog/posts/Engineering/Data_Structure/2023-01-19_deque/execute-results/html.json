{
  "hash": "0753c0b1f551949473a6e76f5d29c848",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Data Structure (7) Deque\nsubtitle: Python List\ndescription: |\n  Data Structure for Data Science\ncategories:\n  - Engineering\nauthor: Kwangmin Kim\ndate: 01/26/2023\nformat: \n  html:\n    page-layout: full\n    code-fold: true\ndraft: False\n---\n\n<ul class=\"nav nav-pills\" id=\"language-tab\" role=\"tablist\">\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link active\" id=\"Korean-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#Korean\" type=\"button\" role=\"tab\" aria-controls=\"Korean\" aria-selected=\"true\">Korean</button>\n  </li>\n  <li class=\"nav-item\" role=\"presentation\">\n    <button class=\"nav-link\" id=\"English-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#English\" type=\"button\" role=\"tab\" aria-controls=\"knitr\" aria-selected=\"false\">English</button>\n  </li>\n\n<div class=\"tab-content\" id=\"language-tabcontent\">\n\n<div class=\"tab-pane fade  show active\" id=\"Korean\" role=\"tabpanel\" aria-labelledby=\"Korean-tab\">\n\n\n## 덱(Deque)\n\n* 덱은 스택(stack)과 큐(queue)의 기능을 모두 가지고 있다.\n* 그래서, 스택과 큐대신 덱을 사용해도 괜찮음\n* 다만, 포인터 변수가 더 많이 필요하기 때문에, 메모리는 상대적으로 더 많이 필요하다.\n* Python에서는 큐(queue)의 기능이 필요할 때 간단히 덱(deque)을 사용한다.\n* 데이터의 삭제와 삽입 모두에서 $O(1)$ 의 시간 복잡도가 소요된다.\n* 덱에 여러 개의 데이터를 삽입하고 삭제하는 예시를 확인해 보자.\n\n[12개의 전체 연산]\n\n* 좌측으로부터 삽입 연산이 가능\n* 우측으로부터 삽입 연산이 가능\n* 삭제 연산시 우측/좌측 선택적 삭제가 가능\n\n## 덱(Deque)의 시간 복잡도\n\n• 데이터의 삭제와 삽입 모두에서 $O(1)$ 의 시간 복잡도가 소요된다.\n\n| Number | Methods          | Time Complexity |        Description                                             |\n|--------|------------------|-----------------|----------------------------------------------------------------|\n| 1      | append left      | $O(1)$          | 덱의 가장 왼쪽에 새 데이터를 삽입                                | \n| 2      | pop left         | $O(1)$          | 덱의 가장 왼쪽에서 데이터를 추출                                 |\n| 3      | append right     | $O(1)$          | 덱의 가장 오른쪽에 새 데이터를 삽입                              |\n| 4      | pop right        | $O(1)$          | 덱의 가장 오른쪽에서 데이터를 추출                               |\n: a list of the deque functions in Python {#tbl-letters}\n\nSee @tbl-letters.\n\n\n## 파이썬의 덱(Deque) 라이브러리\n\n* Python에서는 덱(deque) 라이브러리를 사용할 수 있다.\n* 아래의 모든 메서드는 최악의 경우 시간 복잡도 O 1 을 보장한다.\n* 우측 삽입: append()\n* 좌측 삽입: appendleft()\n* 우측 추출: pop()\n* 좌측 추출: popleft()\n\n::: {#6e2ebdc5 .cell execution_count=1}\n``` {.python .cell-code}\nfrom collections import deque\n\n\nd = deque()\narr = [5, 6, 7, 8] \nfor x in arr:\n    d.append(x) # 오른쪽 삽입\narr = [4, 3, 2, 1]\nfor x in arr:\n    d.appendleft(x) # 좌측 삽입\nprint(d)\n\nwhile d:\n    print(d.popleft()) # 좌측 삭제\n\narr = [1, 2, 3, 4, 5, 6, 7, 8]\nfor x in arr:\n    d.appendleft(x)\nprint(d)\n\nwhile True:\n    print(d.pop())\n    if not d:\n        break\n    print(d.popleft())\n    if not d:\n        break\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndeque([1, 2, 3, 4, 5, 6, 7, 8])\n1\n2\n3\n4\n5\n6\n7\n8\ndeque([8, 7, 6, 5, 4, 3, 2, 1])\n1\n8\n2\n7\n3\n6\n4\n5\n```\n:::\n:::\n\n\n### Python에서 Deque을 사용하는 경우\n\n* 기본적인 Python의 리스트 자료형은 큐(queue)의 기능을 제공하지 않는다.\n* 가능하다면 Python에서 제공하는 덱(deque) 라이브러리를 사용한다.\n* 큐(queue)의 기능이 필요할 때는 덱 라이브러리를 사용하는 것을 추천한다.\n* 삽입과 삭제에 대하여 모두 시간 복잡도 $O(1)$ 이 요구된다.\n\n\n## 연결 리스트로 덱 구현하기\n\n* 덱(deque)을 연결 리스트로 구현하면, 삽입과 삭제에 있어서 O 1 을 보장할 수 있다.\n* 연결 리스트로 구현할 때는 앞(front)과 뒤(rear) 두 개의 포인터를 가진다.\n* 앞(front): 가장 좌측에 있는 데이터를 가리키는 포인터\n* 뒤(rear): 가장 우측에 있는 데이터를 가리키는 포인터\n* 삽입과 삭제의 구현 방법은 스택 및 큐와 유사하다.\n* 앞(front)과 뒤(rear)에 대하여 대칭적으로 로직이 구현될 수 있다.\n\n### 좌측 삽입 연산\n\n* 좌측 삽입할 때는 앞(front) 위치에 데이터를 넣는다.\n* 새로운 데이터가 삽입되었을 때  front data와 연결이 먼저 된 후 front data의 이전 노드가 새로운 데이터가 되도록 설정\n\n### 좌측 삭제 연산\n\n* 삭제할 때는 앞(front) 위치에서 데이터를 꺼낸다. 즉, 그냥 front를 그 다음 데이터로 설정하면 됨\n\n::: {#01084407 .cell execution_count=2}\n``` {.python .cell-code}\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n\nclass Deque:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size = 0\n\n    def appendleft(self, data):\n        node = Node(data)\n        if self.front == None:\n            self.front = node\n            self.rear = node\n        else:\n            node.next = self.front\n            self.front.prev = node\n            self.front = node\n        self.size += 1\n\n    def append(self, data):\n        node = Node(data)\n        if self.rear == None:\n            self.front = node\n            self.rear = node\n        else:\n            node.prev = self.rear\n            self.rear.next = node\n            self.rear = node\n        self.size += 1\n\n    def popleft(self):\n        if self.size == 0:\n            return None\n        # 앞에서 노드 꺼내기\n        data = self.front.data\n        self.front = self.front.next\n        # 삭제로 인해 노드가 하나도 없는 경우\n        if self.front == None:\n            self.rear = None\n        else:\n            self.front.prev = None\n        self.size -= 1\n        return data\n\n    def pop(self):\n        if self.size == 0:\n            return None\n        # 뒤에서 노드 꺼내기\n        data = self.rear.data\n        self.rear = self.rear.prev\n        # 삭제로 인해 노드가 하나도 없는 경우\n        if self.rear == None:\n            self.front = None\n        else:\n            self.rear.next = None\n        self.size -= 1\n        return data\n\n    def front(self):\n        if self.size == 0:\n            return None\n        return self.front.data\n\n    def rear(self):\n        if self.size == 0:\n            return None\n        return self.rear.data\n\n    # 앞에서부터 원소 출력\n    def show(self):\n        cur = self.front\n        while cur:\n            print(cur.data, end=\" \")\n            cur = cur.next\n\n\nd = Deque()\narr = [5, 6, 7, 8]\nfor x in arr:\n    d.append(x)\narr = [4, 3, 2, 1]\nfor x in arr:\n    d.appendleft(x)\nd.show()\n\nprint()\nwhile d.size != 0:\n    print(d.popleft())\n\narr = [1, 2, 3, 4, 5, 6, 7, 8]\nfor x in arr:\n    d.appendleft(x)\nd.show()\n\nprint()\nwhile True:\n    print(d.pop())\n    if d.size == 0:\n        break\n    print(d.popleft())\n    if d.size == 0:\n        break\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 2 3 4 5 6 7 8 \n1\n2\n3\n4\n5\n6\n7\n8\n8 7 6 5 4 3 2 1 \n1\n8\n2\n7\n3\n6\n4\n5\n```\n:::\n:::\n\n\n</div>\n\n<div class=\"tab-pane fade\" id=\"English\" role=\"tabpanel\" aria-labelledby=\"English-tab\">\n\n\n</div>\n\n",
    "supporting": [
      "2023-01-19_deque_files"
    ],
    "filters": [],
    "includes": {}
  }
}