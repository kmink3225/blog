{
  "hash": "f36cc56d4202eb53e6741813bbc39271",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"허깅페이스 임베딩(HuggingFace Embeddings)\"\nsubtitle: 임베딩\ndescription: |\n  텍스트를 벡터로 변환하는 다양한 임베딩 모델을 다룬다.\ncategories:\n  - AI\n  - RAG\n  - LangChain\nauthor: Kwangmin Kim\ndate: 12/31/2024\nformat: \n  html:\n    page-layout: full\n    code-fold: true\n    toc: true\n    number-sections: true\ndraft: False\nexecute:\n    eval: false\n---\n\n::: {#990ec1d3 .cell execution_count=1}\n``` {.python .cell-code}\n# API KEY를 환경변수로 관리하기 위한 설정 파일\nfrom dotenv import load_dotenv\n\n# API KEY 정보로드\nload_dotenv()\n```\n:::\n\n\n::: {#a06824c9 .cell execution_count=2}\n``` {.python .cell-code}\n# LangSmith 추적을 설정합니다. https://smith.langchain.com\n# !pip install langchain-teddynote\nfrom langchain_teddynote import logging\n\n# 프로젝트 이름을 입력합니다.\nlogging.langsmith(\"CH08-Embeddings\")\n```\n:::\n\n\n::: {#33ccd53e .cell execution_count=3}\n``` {.python .cell-code}\nimport os\nimport warnings\n\n# 경고 무시\nwarnings.filterwarnings(\"ignore\")\n\n# ./cache/ 경로에 다운로드 받도록 설정\nos.environ[\"HF_HOME\"] = \"./cache/\"\n```\n:::\n\n\n## 샘플 데이터\n\n::: {#db1040e9 .cell execution_count=4}\n``` {.python .cell-code}\ntexts = [\n    \"안녕, 만나서 반가워.\",\n    \"LangChain simplifies the process of building applications with large language models\",\n    \"랭체인 한국어 튜토리얼은 LangChain의 공식 문서, cookbook 및 다양한 실용 예제를 바탕으로 하여 사용자가 LangChain을 더 쉽고 효과적으로 활용할 수 있도록 구성되어 있습니다. \",\n    \"LangChain은 초거대 언어모델로 애플리케이션을 구축하는 과정을 단순화합니다.\",\n    \"Retrieval-Augmented Generation (RAG) is an effective technique for improving AI responses.\",\n]\n```\n:::\n\n\n**참고(Reference)**\n\n![](./images/top-ranked-embeddings.png)\n\n- [(출처) Kor-IR: 한국어 검색을 위한 임베딩 벤치마크](https://github.com/teddylee777/Kor-IR?tab=readme-ov-file)\n\n## HuggingFace Endpoint Embedding\n\n`HuggingFaceEndpointEmbeddings` 는 내부적으로 InferenceClient를 사용하여 임베딩을 계산한다는 점에서 HuggingFaceEndpoint가 LLM에서 수행하는 것과 매우 유사합니다. \n\n::: {#3785ccea .cell execution_count=5}\n``` {.python .cell-code}\nfrom langchain_huggingface.embeddings import HuggingFaceEndpointEmbeddings\n\nmodel_name = \"intfloat/multilingual-e5-large-instruct\"\n\nhf_embeddings = HuggingFaceEndpointEmbeddings(\n    model=model_name,\n    task=\"feature-extraction\",\n    huggingfacehub_api_token=os.environ[\"HUGGINGFACEHUB_API_TOKEN\"],\n)\n```\n:::\n\n\nDocument 임베딩은 `embed_documents()` 를 호출하여 생성할 수 있습니다.\n\n::: {#19feff04 .cell execution_count=6}\n``` {.python .cell-code}\n%%time\n# Document Embedding 수행\nembedded_documents = hf_embeddings.embed_documents(texts)\n```\n:::\n\n\n::: {#6f0e0a05 .cell execution_count=7}\n``` {.python .cell-code}\nprint(\"[HuggingFace Endpoint Embedding]\")\nprint(f\"Model: \\t\\t{model_name}\")\nprint(f\"Dimension: \\t{len(embedded_documents[0])}\")\n```\n:::\n\n\n::: {#200d702f .cell execution_count=8}\n``` {.python .cell-code}\n# Document Embedding 수행\nembedded_query = hf_embeddings.embed_query(\"LangChain 에 대해서 알려주세요.\")\n```\n:::\n\n\n::: {#7c30abae .cell execution_count=9}\n``` {.python .cell-code}\nlen(embedded_query)\n```\n:::\n\n\n### 유사도 계산\n\n**벡터 내적을 통한 유사도 계산**\n- 벡터 내적(dot product)을 사용하여 유사도를 계산합니다. \n\n- 유사도 계산 공식:\n\n$$ \\text{similarities} = \\mathbf{query} \\cdot \\mathbf{documents}^T $$\n\n#### 벡터 내적의 수학적 의미\n\n**벡터 내적 정의**\n\n벡터 $\\mathbf{a}$와 $\\mathbf{b}$의 내적은 다음과 같이 정의됩니다:\n$$ \\mathbf{a} \\cdot \\mathbf{b} = \\sum_{i=1}^{n} a_i b_i $$\n\n**코사인 유사도와의 관계**\n\n벡터 내적은 다음과 같은 성질을 가집니다.\n$$ \\mathbf{a} \\cdot \\mathbf{b} = \\|\\mathbf{a}\\| \\|\\mathbf{b}\\| \\cos \\theta $$\n\n여기서,\n- $\\|\\mathbf{a}\\|$와 $\\|\\mathbf{b}\\|$는 각각 벡터 $\\mathbf{a}$와 $\\mathbf{b}$의 크기(노름, Euclidean norm)입니다.\n- $\\theta$는 두 벡터 사이의 각도입니다.\n- $\\cos \\theta$는 두 벡터 사이의 코사인 유사도입니다.\n\n**벡터 내적의 유사도 해석**\n내적 값이 클수록 (양의 큰 값일수록),\n- 두 벡터의 크기($\\|\\mathbf{a}\\|$와 $\\|\\mathbf{b}\\|$)가 크고,\n- 두 벡터 사이의 각도($\\theta$)가 작으며 ($\\cos \\theta$가 1에 가까움),\n\n이는 두 벡터가 유사한 방향을 가리키고, 크기가 클수록 더 유사하다는 것을 의미합니다.\n\n**벡터의 크기(노름) 계산**\n\nEuclidean norm 정의\n벡터 $\\mathbf{a} = [a_1, a_2, \\ldots, a_n]$에 대해, Euclidean norm $\\|\\mathbf{a}\\|$는 다음과 같이 정의됩니다:\n$$ \\|\\mathbf{a}\\| = \\sqrt{a_1^2 + a_2^2 + \\cdots + a_n^2} $$\n\n----\n\nquery 와 embedding_document 간의 유사도 계산\n\n::: {#5ce3f6f4 .cell execution_count=10}\n``` {.python .cell-code}\nimport numpy as np\n\n# 질문(embedded_query): LangChain 에 대해서 알려주세요.\nnp.array(embedded_query) @ np.array(embedded_documents).T\n```\n:::\n\n\n::: {#36092ffa .cell execution_count=11}\n``` {.python .cell-code}\nsorted_idx = (np.array(embedded_query) @ np.array(embedded_documents).T).argsort()[::-1]\nsorted_idx\n```\n:::\n\n\n::: {#caf483b4 .cell execution_count=12}\n``` {.python .cell-code}\nprint(\"[Query] LangChain 에 대해서 알려주세요.\\n====================================\")\nfor i, idx in enumerate(sorted_idx):\n    print(f\"[{i}] {texts[idx]}\")\n    print()\n```\n:::\n\n\n## HuggingFace Embeddings\n\n\n### `intfloat/multilingual-e5-large-instruct`\n\n- [intfloat/multilingual-e5-large-instruct](https://huggingface.co/intfloat/multilingual-e5-large-instruct)\n- [intfloat/multilingual-e5-large](https://huggingface.co/intfloat/multilingual-e5-large)\n\n::: {#7f120937 .cell execution_count=13}\n``` {.python .cell-code}\nfrom langchain_huggingface.embeddings import HuggingFaceEmbeddings\n\nmodel_name = \"intfloat/multilingual-e5-large-instruct\"\n# model_name = \"intfloat/multilingual-e5-large\"\n\nhf_embeddings = HuggingFaceEmbeddings(\n    model_name=model_name,\n    model_kwargs={\"device\": \"mps\"},  # cuda, cpu\n    encode_kwargs={\"normalize_embeddings\": True},\n)\n```\n:::\n\n\n::: {#e2f432d5 .cell execution_count=14}\n``` {.python .cell-code}\n%time\n# Document\nembedded_documents1 = hf_embeddings.embed_documents(texts)\n```\n:::\n\n\n::: {#fece5520 .cell execution_count=15}\n``` {.python .cell-code}\nprint(f\"Model: \\t\\t{model_name}\")\nprint(f\"Dimension: \\t{len(embedded_documents[0])}\")\n```\n:::\n\n\n## BGE-M3 임베딩\n\n아래의 옵션 중 에러가 발생할 수 있는 옵션 설명\n\n- `{\"device\": \"mps\"}`: GPU 대신 MPS를 사용하여 임베딩 계산을 수행합니다. (Mac 사용자)\n- `{\"device\": \"cuda\"}`: GPU를 사용하여 임베딩 계산을 수행합니다. (Linux, Windows 사용자, 단 CUDA 설치 필요)\n- `{\"device\": \"cpu\"}`: CPU를 사용하여 임베딩 계산을 수행합니다. (모든 사용자\n\n::: {#517fa7e5 .cell execution_count=16}\n``` {.python .cell-code}\nfrom langchain_huggingface import HuggingFaceEmbeddings\n\nmodel_name = \"BAAI/bge-m3\"\nmodel_kwargs = {\"device\": \"mps\"}\nencode_kwargs = {\"normalize_embeddings\": True}\nhf_embeddings = HuggingFaceEmbeddings(\n    model_name=model_name, model_kwargs=model_kwargs, encode_kwargs=encode_kwargs\n)\n```\n:::\n\n\n::: {#b8548fa2 .cell execution_count=17}\n``` {.python .cell-code}\n%time\n# Document\nembedded_documents = hf_embeddings.embed_documents(texts)\n```\n:::\n\n\n::: {#79ea1608 .cell execution_count=18}\n``` {.python .cell-code}\nprint(f\"Model: \\t\\t{model_name}\")\nprint(f\"Dimension: \\t{len(embedded_documents[0])}\")\n```\n:::\n\n\n::: {#e0aca035 .cell execution_count=19}\n``` {.python .cell-code}\nimport numpy as np\n\nembedded_query = hf_embeddings.embed_query(\"LangChain 에 대해서 알려주세요.\")\nembedded_documents = hf_embeddings.embed_documents(texts)\n\n# 질문(embedded_query): LangChain 에 대해서 알려주세요.\nnp.array(embedded_query) @ np.array(embedded_documents).T\n\nsorted_idx = (np.array(embedded_query) @ np.array(embedded_documents).T).argsort()[::-1]\n\nprint(\"[Query] LangChain 에 대해서 알려주세요.\\n====================================\")\nfor i, idx in enumerate(sorted_idx):\n    print(f\"[{i}] {texts[idx]}\")\n    print()\n```\n:::\n\n\n### `FlagEmbedding` 을 활용하는 방식\n\n**참고**\n- [FlagEmbedding - BGE-M3 Usage](https://github.com/FlagOpen/FlagEmbedding/tree/master/FlagEmbedding/BGE_M3#usage)\n\n\n`FlagEmbedding` 에서 제공하는 세 가지 접근법을 조합하면, 더욱 강력한 검색 시스템을 구축할 수 있습니다.\n\n- Dense Vector: BGE-M3의 다국어, 다중 작업 능력을 기반으로 함\n- Lexical weight를 활용한 sparse embedding으로 정확한 단어 매칭을 수행\n- ColBERT의 multi-vector 접근법으로 문맥을 고려한 세밀한 매칭 수행\n\n::: {#6e5cc92a .cell execution_count=20}\n``` {.python .cell-code}\n# FlagEmbedding 설치\n!pip install -qU FlagEmbedding\n```\n:::\n\n\n::: {#91a5cae0 .cell execution_count=21}\n``` {.python .cell-code}\nfrom FlagEmbedding import BGEM3FlagModel\n\nmodel_name = \"BAAI/bge-m3\"\nbge_embeddings = BGEM3FlagModel(\n    model_name, use_fp16=True\n)  # use_fp16을 True로 설정하면 약간의 성능 저하와 함께 계산 속도가 빨라집니다.\n\nbge_embedded = bge_embeddings.encode(\n    texts,\n    batch_size=12,\n    max_length=8192,  # 이렇게 긴 길이가 필요하지 않은 경우 더 작은 값을 설정하여 인코딩 프로세스의 속도를 높일 수 있습니다.\n)[\"dense_vecs\"]\n```\n:::\n\n\n::: {#36ccd55c .cell execution_count=22}\n``` {.python .cell-code}\nbge_embedded.shape\n```\n:::\n\n\n::: {#9210a349 .cell execution_count=23}\n``` {.python .cell-code}\nprint(f\"Model: \\t\\t{model_name}\")\nprint(f\"Dimension: \\t{len(embedded_documents[0])}\")\n```\n:::\n\n\n::: {#e457b338 .cell execution_count=24}\n``` {.python .cell-code}\nfrom FlagEmbedding import BGEM3FlagModel\n\nbge_flagmodel = BGEM3FlagModel(\n    \"BAAI/bge-m3\", use_fp16=True\n)  # use_fp16을 True로 설정하면 약간의 성능 저하와 함께 계산 속도가 빨라집니다.\nbge_encoded = bge_flagmodel.encode(texts, return_dense=True)\n```\n:::\n\n\n::: {#6cc78c7c .cell execution_count=25}\n``` {.python .cell-code}\n# 결과 출력(행, 열)\nbge_encoded[\"dense_vecs\"].shape\n```\n:::\n\n\n### Sparse Embedding (Lexical Weight)\n\nSparse embedding은 벡터의 대부분의 값이 0인 고차원 벡터를 사용하는 임베딩 방식입니다. Lexical weight를 활용한 방식은 단어의 중요도를 고려하여 임베딩을 생성합니다.\n\n**작동 방식**\n1. 각 단어에 대해 lexical weight(어휘적 가중치)를 계산합니다. 이는 TF-IDF나 BM25 같은 방법을 사용할 수 있습니다.\n2. 문서나 쿼리의 각 단어에 대해, 해당 단어의 lexical weight를 사용하여 sparse vector의 해당 차원에 값을 할당합니다.\n3. 결과적으로 문서나 쿼리는 대부분의 값이 0인 고차원 벡터로 표현됩니다.\n\n**장점**\n- 단어의 중요도를 직접적으로 반영할 수 있습니다.\n- 특정 단어나 구문을 정확히 매칭할 수 있습니다.\n- 계산이 상대적으로 빠릅니다.\n\n::: {#ef3f8a9f .cell execution_count=26}\n``` {.python .cell-code}\nbge_flagmodel = BGEM3FlagModel(\n    \"BAAI/bge-m3\", use_fp16=True\n)  # use_fp16을 True로 설정하면 약간의 성능 저하와 함께 계산 속도가 빨라집니다.\nbge_encoded = bge_flagmodel.encode(texts, return_sparse=True)\n```\n:::\n\n\n::: {#3cae87c9 .cell execution_count=27}\n``` {.python .cell-code}\nlexical_scores1 = bge_flagmodel.compute_lexical_matching_score(\n    bge_encoded[\"lexical_weights\"][0], bge_encoded[\"lexical_weights\"][0]\n)\nlexical_scores2 = bge_flagmodel.compute_lexical_matching_score(\n    bge_encoded[\"lexical_weights\"][0], bge_encoded[\"lexical_weights\"][1]\n)\n# 0 <-> 0\nprint(lexical_scores1)\n# 0 <-> 1\nprint(lexical_scores2)\n```\n:::\n\n\n### Multi-Vector (ColBERT)\n\nColBERT(Contextualized Late Interaction over BERT)는 문서 검색을 위한 효율적인 방법입니다. 이 방식은 문서와 쿼리를 여러 개의 벡터로 표현하는 multi-vector 접근법을 사용합니다.\n\n**작동 방식**\n\n1. 문서의 각 토큰에 대해 별도의 벡터를 생성합니다. 즉, 하나의 문서는 여러 개의 벡터로 표현됩니다.\n2. 쿼리도 마찬가지로 각 토큰에 대해 별도의 벡터를 생성합니다.\n3. 검색 시, 쿼리의 각 토큰 벡터와 문서의 모든 토큰 벡터 사이의 유사도를 계산합니다.\n4. 이 유사도들을 종합하여 최종 검색 점수를 계산합니다.\n\n**장점**\n- 토큰 수준의 세밀한 매칭이 가능합니다.\n- 문맥을 고려한 임베딩을 생성할 수 있습니다.\n- 긴 문서에 대해서도 효과적으로 작동합니다.\n\n::: {#90a07f15 .cell execution_count=28}\n``` {.python .cell-code}\nbge_flagmodel = BGEM3FlagModel(\n    \"BAAI/bge-m3\", use_fp16=True\n)  # use_fp16을 True로 설정하면 약간의 성능 저하와 함께 계산 속도가 빨라집니다.\nbge_encoded = bge_flagmodel.encode(texts, return_colbert_vecs=True)\n```\n:::\n\n\n::: {#1f6d9265 .cell execution_count=29}\n``` {.python .cell-code}\ncolbert_scores1 = bge_flagmodel.colbert_score(\n    bge_encoded[\"colbert_vecs\"][0], bge_encoded[\"colbert_vecs\"][0]\n)\ncolbert_scores2 = bge_flagmodel.colbert_score(\n    bge_encoded[\"colbert_vecs\"][0], bge_encoded[\"colbert_vecs\"][1]\n)\n# 0 <-> 0\nprint(colbert_scores1)\n# 0 <-> 1\nprint(colbert_scores2)\n```\n:::\n\n\n",
    "supporting": [
      "03-HuggingFaceEmbeddings_files"
    ],
    "filters": [],
    "includes": {}
  }
}