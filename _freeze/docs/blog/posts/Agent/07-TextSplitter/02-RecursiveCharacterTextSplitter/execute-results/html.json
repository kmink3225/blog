{
  "hash": "120ab5094a9a3dfed4b8e567ad32cf3e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"RecursiveCharacterTextSplitter\"\nsubtitle: 텍스트 분할\ndescription: |\n  효율적인 문서 청킹을 위한 다양한 텍스트 분할 전략을 다룬다.\ncategories:\n  - AI\n  - RAG\n  - LangChain\nauthor: Kwangmin Kim\ndate: 12/31/2024\nformat: \n  html:\n    page-layout: full\n    code-fold: true\n    toc: true\n    number-sections: true\ndraft: False\nexecute:\n    eval: false\n---\n\n이 텍스트 분할기는 일반적인 텍스트에 권장되는 방식입니다.\n\n이 분할기는 문자 목록을 매개변수로 받아 동작합니다.\n\n분할기는 청크가 충분히 작아질 때까지 주어진 문자 목록의 순서대로 텍스트를 분할하려고 시도합니다.\n\n기본 문자 목록은 `[\"\\n\\n\", \"\\n\", \" \", \"\"]`입니다.\n\n- **단락** -> **문장** -> **단어** 순서로 재귀적으로 분할합니다.\n\n이는 단락(그 다음으로 문장, 단어) 단위가 의미적으로 가장 강하게 연관된 텍스트 조각으로 간주되므로, 가능한 한 함께 유지하려는 효과가 있습니다.\n\n1. 텍스트가 분할되는 방식: 문자 목록(`[\"\\n\\n\", \"\\n\", \" \", \"\"]`) 에 의해 분할됩니다.\n\n2. 청크 크기가 측정되는 방식: 문자 수에 의해 측정됩니다.\n\n\n- `appendix-keywords.txt` 파일을 열어 내용을 읽어들입니다.\n- 읽어들인 내용을 `file` 변수에 저장합니다.\n\n::: {#66202a2b .cell execution_count=1}\n``` {.python .cell-code}\n# appendix-keywords.txt 파일을 열어서 f라는 파일 객체를 생성합니다.\nwith open(\"./data/appendix-keywords.txt\") as f:\n    file = f.read()  # 파일의 내용을 읽어서 file 변수에 저장합니다.\n```\n:::\n\n\n파일로부터 읽은 파일의 일부 내용을 출력합니다.\n\n::: {#a1cfedf5 .cell execution_count=2}\n``` {.python .cell-code}\n# 파일으로부터 읽은 내용을 일부 출력합니다.\nprint(file[:500])\n```\n:::\n\n\n::: {#fbc3bf8d .cell execution_count=3}\n``` {.python .cell-code}\nfrom langchain_text_splitters import RecursiveCharacterTextSplitter\n```\n:::\n\n\n`RecursiveCharacterTextSplitter`를 사용하여 텍스트를 작은 청크로 분할하는 예제입니다.\n\n- `chunk_size`를 250 으로 설정하여 각 청크의 크기를 제한합니다.\n- `chunk_overlap`을 50 으로 설정하여 인접한 청크 간에 50 개 문자의 중첩을 허용합니다.\n- `length_function`으로 `len` 함수를 사용하여 텍스트의 길이를 계산합니다.\n- `is_separator_regex`를 `False`로 설정하여 구분자로 정규식을 사용하지 않습니다.\n\n::: {#454098a6 .cell execution_count=4}\n``` {.python .cell-code}\ntext_splitter = RecursiveCharacterTextSplitter(\n    # 청크 크기를 매우 작게 설정합니다. 예시를 위한 설정입니다.\n    chunk_size=250,\n    # 청크 간의 중복되는 문자 수를 설정합니다.\n    chunk_overlap=50,\n    # 문자열 길이를 계산하는 함수를 지정합니다.\n    length_function=len,\n    # 구분자로 정규식을 사용할지 여부를 설정합니다.\n    is_separator_regex=False,\n)\n```\n:::\n\n\n- `text_splitter`를 사용하여 `file` 텍스트를 문서 단위로 분할합니다.\n- 분할된 문서는 `texts` 리스트에 저장됩니다.\n- `print(texts[0])`과 `print(texts[1])`을 통해 분할된 문서의 첫 번째와 두 번째 문서를 출력합니다.\n\n::: {#21928320 .cell execution_count=5}\n``` {.python .cell-code}\n# text_splitter를 사용하여 file 텍스트를 문서로 분할합니다.\ntexts = text_splitter.create_documents([file])\nprint(texts[0])  # 분할된 문서의 첫 번째 문서를 출력합니다.\nprint(\"===\" * 20)\nprint(texts[1])  # 분할된 문서의 두 번째 문서를 출력합니다.\n```\n:::\n\n\n`text_splitter.split_text()` 함수를 사용하여 `file` 텍스트를 분할합니다.\n\n::: {#0784ece8 .cell execution_count=6}\n``` {.python .cell-code}\n# 텍스트를 분할하고 분할된 텍스트의 처음 2개 요소를 반환합니다.\ntext_splitter.split_text(file)[:2]\n```\n:::\n\n\n",
    "supporting": [
      "02-RecursiveCharacterTextSplitter_files"
    ],
    "filters": [],
    "includes": {}
  }
}