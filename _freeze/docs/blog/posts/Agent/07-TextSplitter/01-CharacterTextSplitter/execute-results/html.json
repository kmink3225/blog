{
  "hash": "625079625aace00807a3229d57901a10",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"CharacterTextSplitter\"\nsubtitle: 텍스트 분할\ndescription: |\n  효율적인 문서 청킹을 위한 다양한 텍스트 분할 전략을 다룬다.\ncategories:\n  - AI\n  - RAG\n  - LangChain\nauthor: Kwangmin Kim\ndate: 12/31/2024\nformat: \n  html:\n    page-layout: full\n    code-fold: true\n    toc: true\n    number-sections: true\ndraft: False\nexecute:\n    eval: false\n---\n\n이 방법은 가장 간단한 방식입니다.\n\n기본적으로 `\"\\n\\n\"` 을 기준으로 문자 단위로 텍스트를 분할하고, 청크의 크기를 문자 수로 측정합니다.\n\n1. 텍스트 분할 방식: 단일 문자 기준\n2. 청크 크기 측정 방식: 문자 수 기준\n\n\n- `./data/appendix-keywords.txt` 파일을 열어 내용을 읽어들입니다.\n- 읽어들인 내용을 `file` 변수에 저장합니다.\n\n::: {#2b4be4ac .cell execution_count=1}\n``` {.python .cell-code}\n# data/appendix-keywords.txt 파일을 열어서 f라는 파일 객체를 생성합니다.\nwith open(\"./data/appendix-keywords.txt\") as f:\n    file = f.read()  # 파일의 내용을 읽어서 file 변수에 저장합니다.\n```\n:::\n\n\n파일로부터 읽은 파일의 일부 내용을 출력합니다.\n\n::: {#11367600 .cell execution_count=2}\n``` {.python .cell-code}\n# 파일으로부터 읽은 내용을 일부 출력합니다.\nprint(file[:500])\n```\n:::\n\n\n# CharacterTextSplitter를 사용하여 분할\n\nCharacterTextSplitter를 사용하여 텍스트를 청크(chunk)로 분할하는 코드에 대해 설명합니다.\n\n- `separator`: 분할할 기준을 설정합니다. 기본값은 `\"\\n\\n\"`입니다.\n- `chunk_size`: 각 청크의 최대 크기를 설정합니다. 예: 250자\n- `chunk_overlap`: 인접한 청크 간 중복을 허용합니다. 예: 50자\n- `length_function`: 텍스트의 길이를 계산하는 함수를 지정합니다. 예: `len`\n\n::: {#5d0e0d1f .cell execution_count=3}\n``` {.python .cell-code}\nfrom langchain_text_splitters import CharacterTextSplitter\n\n# CharacterTextSplitter를 사용하여 텍스트를 청크(chunk)로 분할하는 코드\ntext_splitter = CharacterTextSplitter(\n    # 텍스트를 분할할 때 사용할 구분자를 지정합니다. 기본값은 \"\\n\\n\"입니다.\n    separator=\"\\n\\n\",\n    # 분할된 텍스트 청크의 최대 크기를 지정합니다 (문자 수).\n    chunk_size=210,\n    # 분할된 텍스트 청크 간의 중복되는 문자 수를 지정합니다.\n    chunk_overlap=0,\n    # 텍스트의 길이를 계산하는 함수를 지정합니다.\n    length_function=len,\n)\n```\n:::\n\n\n- `text_splitter`를 사용하여 `file` 텍스트를 문서 단위로 분할합니다.\n- 분할된 문서 리스트 중 첫 번째 문서(`texts[0]`)를 출력합니다.\n\n::: {#6dc79d19 .cell execution_count=4}\n``` {.python .cell-code}\n# 텍스트를 청크로 분할합니다.\ntexts = text_splitter.create_documents([file])\nprint(len(texts[0].page_content))  # 분할된 문서의 개수를 출력합니다.\nprint(texts[0])  # 분할된 문서 중 첫 번째 문서를 출력합니다.\n```\n:::\n\n\n다음은 문서와 함께 메타데이터를 전달하는 예시입니다.\n\n메타데이터가 문서와 함께 분할되는 점에 주목해 주세요.\n\n- `create_documents` 메서드는 텍스트 데이터와 메타데이터 리스트를 인자로 받습니다.\n\n::: {#4894fd11 .cell execution_count=5}\n``` {.python .cell-code}\nmetadatas = [\n    {\"document\": 1},\n    {\"document\": 2},\n]  # 문서에 대한 메타데이터 리스트를 정의합니다.\ndocuments = text_splitter.create_documents(\n    [\n        file,\n        file,\n    ],  # 분할할 텍스트 데이터를 리스트로 전달합니다.\n    metadatas=metadatas,  # 각 문서에 해당하는 메타데이터를 전달합니다.\n)\nprint(documents[0])  # 분할된 문서 중 첫 번째 문서를 출력합니다.\n```\n:::\n\n\n::: {#b9d5928e .cell execution_count=6}\n``` {.python .cell-code}\nlen(documents)\n```\n:::\n\n\n::: {#7926b50d .cell execution_count=7}\n``` {.python .cell-code}\ndocuments[1].metadata\n```\n:::\n\n\n`split_text()` 메서드를 사용하여 텍스트를 분할합니다.\n\n- `text_splitter.split_text(file)[0]`은 `file` 텍스트를 `text_splitter`를 사용하여 분할한 후, 분할된 텍스트 조각 중 첫 번째 요소를 반환합니다.\n\n::: {#0e3530bf .cell execution_count=8}\n``` {.python .cell-code}\n# text_splitter를 사용하여 file 텍스트를 분할하고, 분할된 텍스트의 첫 번째 요소를 반환합니다.\ntext_splitter.split_text(file)[0]\n```\n:::\n\n\n::: {#fba7e08f .cell execution_count=9}\n``` {.python .cell-code}\ntext_splitter.split_documents([file])\n```\n:::\n\n\n",
    "supporting": [
      "01-CharacterTextSplitter_files"
    ],
    "filters": [],
    "includes": {}
  }
}