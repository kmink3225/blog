{
  "hash": "d562889dad2ab1d3817cb4ee998c3411",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"OutputFixingParser\"\nsubtitle: 출력 파싱\ndescription: |\n  LLM 출력을 구조화된 데이터로 변환하는 다양한 파서를 다룬다.\ncategories:\n  - AI\n  - RAG\n  - LangChain\nauthor: Kwangmin Kim\ndate: 01/24/2025\nformat: \n  html:\n    page-layout: full\n    code-fold: true\n    toc: true\n    number-sections: true\ndraft: False\nexecute:\n    eval: false\n---\n\n`OutputFixingParser`는 출력 파싱 과정에서 발생할 수 있는 오류를 자동으로 수정하는 기능을 제공합니다. 이 파서는 기본적으로 다른 파서, 예를 들어 `PydanticOutputParser` 를 래핑하고, 이 파서가 처리할 수 없는 형식의 출력이나 오류를 반환할 경우, 추가적인 LLM 호출을 통해 오류를 수정하도록 설계되었습니다.\n\n이러한 접근 방식의 핵심은, 첫 번째 시도에서 스키마를 준수하지 않는 결과가 나올 경우, `OutputFixingParser` 가 자동으로 형식이 잘못된 출력을 인식하고, 이를 수정하기 위한 새로운 명령어와 함께 모델에 다시 제출한다는 것입니다. 이 과정에서, 수정을 위한 명령어는 오류를 정확히 지적하고, 올바른 형식으로 데이터를 재구성할 수 있도록 구체적인 지시를 포함해야 합니다.\n\n예를 들어, `PydanticOutputParser` 를 사용하여 특정 데이터 스키마를 준수하는 출력을 생성하려고 했지만, 일부 필드가 누락되었거나 데이터 유형이 잘못된 경우가 발생할 수 있습니다. 이때 `OutputFixingParser` 는 다음 단계로, 해당 오류를 수정하는 지시를 포함한 새로운 요청을 LLM에 제출합니다. LLM은 이 지시를 바탕으로 오류를 수정한 새로운 출력을 생성하게 됩니다.\n\n::: {#937a7a81 .cell execution_count=1}\n``` {.python .cell-code}\n# API KEY를 환경변수로 관리하기 위한 설정 파일\nfrom dotenv import load_dotenv\n\n# API KEY 정보로드\nload_dotenv()\n```\n:::\n\n\n::: {#6929bd01 .cell execution_count=2}\n``` {.python .cell-code}\n# LangSmith 추적을 설정합니다. https://smith.langchain.com\n# !pip install langchain-teddynote\nfrom langchain_teddynote import logging\n\n# 프로젝트 이름을 입력합니다.\nlogging.langsmith(\"CH03-OutputParser\")\n```\n:::\n\n\n::: {#4eca6050 .cell execution_count=3}\n``` {.python .cell-code}\nfrom langchain_openai import ChatOpenAI\nfrom langchain.output_parsers import PydanticOutputParser\nfrom pydantic import BaseModel, Field\nfrom typing import List\n\n\nclass Actor(BaseModel):\n    name: str = Field(description=\"name of an actor\")\n    film_names: List[str] = Field(description=\"list of names of films they starred in\")\n\n\nactor_query = \"Generate the filmography for a random actor.\"\n\nparser = PydanticOutputParser(pydantic_object=Actor)\n```\n:::\n\n\n(참고) 다음의 Cell 은 오류가 발생해야 **정상** 입니다.\n\n::: {#8e009fba .cell execution_count=4}\n``` {.python .cell-code}\n# 잘못된 형식을 일부러 입력\nmisformatted = \"{'name': 'Tom Hanks', 'film_names': ['Forrest Gump']}\"\n\n# 잘못된 형식으로 입력된 데이터를 파싱하려고 시도\nparser.parse(misformatted)\n\n# 오류 출력\n```\n:::\n\n\n`OutputFixingParser` 를 사용하여 잘못된 형식을 바로 잡도록 하겠습니다.\n\n::: {#d0a937ce .cell execution_count=5}\n``` {.python .cell-code}\nfrom langchain.output_parsers import OutputFixingParser\n\nnew_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())\n```\n:::\n\n\n::: {#4d452534 .cell execution_count=6}\n``` {.python .cell-code}\n# 잘못된 형식의 출력\nmisformatted\n```\n:::\n\n\n::: {#bb9f609e .cell execution_count=7}\n``` {.python .cell-code}\n# OutputFixingParser 를 사용하여 잘못된 형식의 출력을 파싱\nactor = new_parser.parse(misformatted)\n```\n:::\n\n\n::: {#896f754b .cell execution_count=8}\n``` {.python .cell-code}\n# 파싱된 결과\nactor\n```\n:::\n\n\n",
    "supporting": [
      "08-OutputFixingParser_files"
    ],
    "filters": [],
    "includes": {}
  }
}