{
  "hash": "90b61824d129064f441f362a83b49423",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Plan-and-Execute Agent\"\nsubtitle: 복잡한 작업 계획과 실행을 위한 에이전트 패턴\ndescription: |\n  Plan-and-Execute 패턴을 활용하여 복잡한 다단계 작업을 계획하고 순차적으로 실행하는 에이전트 구현을 다룬다.\ncategories:\n  - AI\n  - RAG\n  - LangChain\nauthor: Kwangmin Kim\ndate: 11/18/2025\nformat: \n  html:\n    page-layout: full\n    code-fold: true\n    toc: true\n    number-sections: true\ndraft: False\nexecute:\n    eval: false\n---\n\n## Plan-and-Execute Agent란?\n\nPlan-and-Execute는 대규모 언어 모델(LLM)이 **계획(Planning)**과 **실행(Execution)** 단계를 분리하여 복잡한 문제를 체계적으로 해결하는 패턴이다.\n\n### ReAct와의 차이\n\n**ReAct 패턴의 한계:**\n- 각 단계마다 즉시 행동 결정\n- 복잡한 작업의 경우 비효율적인 단계 반복\n- 전체 계획이 없어 방향 혼란 가능\n\n**Plan-and-Execute의 장점:**\n- **2단계 분리**: 먼저 전체 계획 수립, 후에 실행\n- **효율성**: 불필요한 반복 작업 최소화\n- **재현성**: 같은 계획으로 다른 입력에 적용 가능\n- **추적성**: 계획 단계를 명시적으로 추적\n\n### Plan-and-Execute 작동 원리\n\n```\nPhase 1: Planning\n├─ 1. Task: \"목표 분석\"\n├─ 2. Task: \"필요 리소스 식별\"\n└─ 3. Task: \"실행 순서 결정\"\n\nPhase 2: Execution\n├─ Task 1 실행 (웹 검색)\n├─ Task 2 실행 (파일 읽기)\n├─ Task 3 실행 (데이터 분석)\n└─ 최종 결과 생성\n```\n\n### LangGraph의 Plan-and-Execute 구현\n\nLangGraph의 `create_planning_agent`를 사용하여 효과적으로 구현할 수 있다.\n\n**핵심 특징:**\n- **계획 최적화**: LLM이 한 번에 전체 계획 수립\n- **상태 관리**: 각 태스크의 진행 상황 추적\n- **에러 복구**: 특정 태스크 실패 시 재시도 또는 대체 방안\n- **결과 통합**: 각 태스크의 결과를 최종 답변으로 통합\n\n::: {#ab2b67fe .cell execution_count=1}\n``` {.python .cell-code}\n# API 키를 환경변수로 관리하기 위한 설정 파일\nfrom dotenv import load_dotenv\n\n# API 키 정보 로드\nload_dotenv()\n```\n:::\n\n\n::: {#4e744933 .cell execution_count=2}\n``` {.python .cell-code}\n# LangSmith 추적을 설정한다. https://smith.langchain.com\n# !pip install -qU langchain-teddynote\nfrom langchain_teddynote import logging\n\n# 프로젝트 이름을 입력한다.\nlogging.langsmith(\"CH16-Plan-Execute-Agent\")\n```\n:::\n\n\n## 환경 설정\n\n### 기본 구성 요소\n\nPlan-and-Execute Agent는 네 가지 핵심 요소로 구성된다:\n\n1. **Planner LLM**: 계획 수립 담당\n2. **Executor LLM**: 실제 작업 수행\n3. **도구(Tools)**: 외부 작업 수행\n4. **메모리(Memory)**: 계획 및 실행 이력 저장\n\n![Plan-and-Execute Agent 아키텍처](assets/plan_execute_agent.png)\n\n::: {#8db0de12 .cell execution_count=3}\n``` {.python .cell-code}\nfrom langchain_openai import ChatOpenAI\nfrom langchain_teddynote.tools.tavily import TavilySearch\nfrom langchain_core.messages import HumanMessage\nfrom langgraph.checkpoint.memory import MemorySaver\nfrom langgraph.prebuilt import create_react_agent\n\n# 메모리 설정 (계획 및 실행 이력 저장)\nmemory = MemorySaver()\n\n# 모델 설정\n# Planner: 복잡한 추론이 필요하므로 GPT-4o 사용\nplanner_model = ChatOpenAI(model_name=\"gpt-4o\", temperature=0)\n\n# Executor: 비용 절감을 위해 GPT-4o-mini 사용\nexecutor_model = ChatOpenAI(model_name=\"gpt-4o-mini\")\n```\n:::\n\n\n**모델 선택 전략:**\n- **Planner**: 더 강력한 모델 (복잡한 계획 수립)\n- **Executor**: 더 빠르고 저렴한 모델 (계획된 작업 수행)\n\n## 계획 작성 시스템\n\n### 계획 구조 정의\n\n::: {#72d4cb74 .cell execution_count=4}\n``` {.python .cell-code}\nfrom typing import List\nfrom pydantic import BaseModel, Field\n\nclass Task(BaseModel):\n    \"\"\"수행할 작업의 단위\"\"\"\n    id: int = Field(description=\"작업 ID (1부터 시작)\")\n    title: str = Field(description=\"작업 제목\")\n    description: str = Field(description=\"작업 상세 설명\")\n    required_tools: List[str] = Field(description=\"필요한 도구 목록\")\n    dependencies: List[int] = Field(\n        default_factory=list, \n        description=\"선행 작업 ID 목록\"\n    )\n    \n    def __str__(self) -> str:\n        return f\"Task {self.id}: {self.title}\"\n\nclass Plan(BaseModel):\n    \"\"\"전체 작업 계획\"\"\"\n    objective: str = Field(description=\"최종 목표\")\n    tasks: List[Task] = Field(description=\"수행할 작업 리스트\")\n    \n    def __str__(self) -> str:\n        task_str = \"\\n\".join(f\"  {task}\" for task in self.tasks)\n        return f\"Goal: {self.objective}\\n\\nTasks:\\n{task_str}\"\n```\n:::\n\n\n**Plan 구조의 장점:**\n- 명확한 작업 구조\n- 의존성 추적으로 순서 관리\n- 필요한 도구 사전 식별\n\n### Planner Prompt 작성\n\n::: {#048f39e1 .cell execution_count=5}\n```` {.python .cell-code}\nfrom langchain_core.prompts import ChatPromptTemplate\n\nplanner_prompt = ChatPromptTemplate.from_messages([\n    (\n        \"system\",\n        \"\"\"당신은 전문적인 작업 계획가(Project Manager)입니다.\n        \n사용자의 요청을 분석하여 다음 규칙에 따라 상세한 작업 계획을 수립하세요:\n\n1. **작업 분해**: 복잡한 요청을 논리적인 소 작업들로 분해\n2. **순차성**: 선행 작업이 필요한 경우 dependencies에 명시\n3. **도구 식별**: 각 작업에 필요한 도구 명시 (web_search, file_management, pdf_retriever 등)\n4. **명확성**: 각 작업의 목표가 명확하고 측정 가능하도록 작성\n\n사용 가능한 도구:\n- web_search: 웹 검색 (최신 정보 필요시)\n- file_write: 파일 작성\n- file_read: 파일 읽기\n- pdf_retriever: PDF 문서 검색\n- data_analysis: 데이터 분석\n\n응답 형식은 다음 JSON 스키마를 따르세요:\n```json\n{{\n    \"objective\": \"최종 목표\",\n    \"tasks\": [\n        {{\n            \"id\": 1,\n            \"title\": \"작업 제목\",\n            \"description\": \"작업 상세 설명\",\n            \"required_tools\": [\"tool1\", \"tool2\"],\n            \"dependencies\": []\n        }}\n    ]\n}}\n```\"\"\",\n    ),\n    (\"human\", \"{input}\"),\n])\n````\n:::\n\n\n**Prompt 설계 팁:**\n- 구조화된 출력 형식 명시\n- 사용 가능한 도구 목록 제공\n- 작업 분해의 기준 설명\n\n## 도구 설정\n\n### 웹 검색 도구\n\n::: {#fcbb019f .cell execution_count=6}\n``` {.python .cell-code}\nfrom langchain_teddynote.tools.tavily import TavilySearch\n\n# 웹 검색 도구 생성\nweb_search = TavilySearch(\n    topic=\"general\",\n    max_results=5,\n    include_answer=False,\n    include_raw_content=False,\n)\n\nweb_search.name = \"web_search\"\nweb_search.description = (\n    \"웹에서 정보를 검색합니다. 최신 정보, 뉴스, 통계 등이 필요할 때 사용합니다.\"\n)\n```\n:::\n\n\n### 파일 관리 도구\n\n::: {#4f92615e .cell execution_count=7}\n``` {.python .cell-code}\nfrom langchain_community.agent_toolkits import FileManagementToolkit\n\nworking_directory = \"tmp\"\n\nfile_management_tools = FileManagementToolkit(\n    root_dir=str(working_directory),\n).get_tools()\n\n# 도구 이름과 설명 업데이트\nfor tool in file_management_tools:\n    if tool.name == \"file_write\":\n        tool.description = \"파일을 작성하거나 수정합니다.\"\n    elif tool.name == \"file_read\":\n        tool.description = \"파일의 내용을 읽습니다.\"\n    elif tool.name == \"list_directory\":\n        tool.description = \"디렉토리의 파일 목록을 조회합니다.\"\n```\n:::\n\n\n### PDF 검색 도구\n\n::: {#e6fa96cd .cell execution_count=8}\n``` {.python .cell-code}\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain_community.vectorstores import FAISS\nfrom langchain_openai import OpenAIEmbeddings\nfrom langchain.document_loaders import PDFPlumberLoader\nfrom langchain_core.tools.retriever import create_retriever_tool\nfrom langchain_core.prompts import PromptTemplate\n\n# PDF 로드 및 벡터화\nloader = PDFPlumberLoader(\"data/sample_document.pdf\")\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)\nsplit_docs = loader.load_and_split(text_splitter)\nvector = FAISS.from_documents(split_docs, OpenAIEmbeddings())\npdf_retriever = vector.as_retriever()\n\n# Retriever 도구 생성\nretriever_tool = create_retriever_tool(\n    pdf_retriever,\n    \"pdf_retriever\",\n    \"내부 문서에서 정보를 검색합니다. 회사 정책, 보고서, 기술 문서 등을 조회할 수 있습니다.\",\n    document_prompt=PromptTemplate.from_template(\n        \"<document><context>{page_content}</context><metadata><source>{source}</source><page>{page}</page></metadata></document>\"\n    ),\n)\n```\n:::\n\n\n### 전체 도구 목록\n\n::: {#e8234620 .cell execution_count=9}\n``` {.python .cell-code}\n# 도구 목록 구성\ntools = [web_search, *file_management_tools, retriever_tool]\n```\n:::\n\n\n## Plan-and-Execute 에이전트 구현\n\n### Executor 에이전트 생성\n\n계획된 작업을 실행할 ReAct 에이전트를 생성한다.\n\n::: {#a1f7c755 .cell execution_count=10}\n``` {.python .cell-code}\nfrom langgraph.prebuilt import create_react_agent\n\n# Executor 에이전트: 개별 작업 수행\nexecutor = create_react_agent(\n    executor_model,\n    tools,\n    checkpointer=memory,\n)\n```\n:::\n\n\n### Plan-and-Execute 그래프 구축\n\n::: {#f8b40f90 .cell execution_count=11}\n``` {.python .cell-code}\nfrom langgraph.graph import StateGraph, START, END\nfrom langchain_core.messages import BaseMessage\nfrom typing import Annotated\nfrom langgraph.graph.message import add_messages\n\nclass PlanExecuteState(BaseModel):\n    \"\"\"계획 및 실행 상태\"\"\"\n    input: str = Field(description=\"사용자 입력\")\n    plan: Plan = Field(default=None, description=\"수립된 계획\")\n    past_steps: Annotated[List[tuple], add_messages] = Field(\n        default_factory=list,\n        description=\"완료된 작업과 결과\"\n    )\n    response: str = Field(default=\"\", description=\"최종 응답\")\n\ndef plan_step(state: PlanExecuteState) -> PlanExecuteState:\n    \"\"\"계획 수립 단계\"\"\"\n    # Planner가 계획 수립\n    planner_chain = planner_prompt | planner_model.with_structured_output(Plan)\n    plan = planner_chain.invoke({\"input\": state.input})\n    \n    return {**state, \"plan\": plan}\n\ndef execute_step(state: PlanExecuteState) -> PlanExecuteState:\n    \"\"\"작업 실행 단계\"\"\"\n    plan = state.plan\n    past_steps = state.past_steps\n    \n    # 완료되지 않은 작업 찾기\n    completed_task_ids = {step[0] for step in past_steps}\n    next_task = None\n    \n    for task in plan.tasks:\n        # 의존성이 모두 완료되었고, 아직 수행되지 않은 작업\n        if (task.id not in completed_task_ids and \n            all(dep_id in completed_task_ids for dep_id in task.dependencies)):\n            next_task = task\n            break\n    \n    if next_task is None:\n        # 모든 작업 완료\n        return state\n    \n    # 작업 실행\n    task_instruction = f\"\"\"\n    다음 작업을 수행하세요:\n    \n    제목: {next_task.title}\n    설명: {next_task.description}\n    필요 도구: {', '.join(next_task.required_tools)}\n    \n    이전 작업 결과:\n    {chr(10).join(f\"Task {task_id}: {result}\" for task_id, result in past_steps)}\n    \"\"\"\n    \n    # Executor가 작업 수행\n    result = executor.invoke(\n        {\"messages\": [(\"human\", task_instruction)]},\n        {\"configurable\": {\"thread_id\": f\"task_{next_task.id}\"}}\n    )\n    \n    # 결과 저장\n    past_steps.append((next_task.id, result[\"messages\"][-1].content))\n    \n    return {**state, \"past_steps\": past_steps}\n\ndef generate_response_step(state: PlanExecuteState) -> PlanExecuteState:\n    \"\"\"최종 응답 생성 단계\"\"\"\n    plan = state.plan\n    past_steps = state.past_steps\n    \n    # 모든 작업이 완료되었는지 확인\n    if len(past_steps) < len(plan.tasks):\n        return state\n    \n    # 결과 통합\n    summary = f\"\"\"\n    ## 작업 완료 보고서\n    \n    **목표**: {plan.objective}\n    \n    ### 수행 작업\n    \"\"\"\n    \n    for task_id, result in past_steps:\n        task = next(t for t in plan.tasks if t.id == task_id)\n        summary += f\"\\n\\n**Task {task_id}: {task.title}**\\n{result}\\n\"\n    \n    return {**state, \"response\": summary}\n\n# 그래프 구성\nworkflow = StateGraph(PlanExecuteState)\n\nworkflow.add_node(\"plan\", plan_step)\nworkflow.add_node(\"execute\", execute_step)\nworkflow.add_node(\"respond\", generate_response_step)\n\nworkflow.add_edge(START, \"plan\")\nworkflow.add_edge(\"plan\", \"execute\")\nworkflow.add_edge(\"execute\", \"execute\")  # 모든 작업 완료까지 반복\nworkflow.add_edge(\"execute\", \"respond\")\nworkflow.add_edge(\"respond\", END)\n\n# 컴파일\nplan_execute_agent = workflow.compile(checkpointer=memory)\n```\n:::\n\n\n**그래프 구조:**\n- **plan 노드**: LLM이 전체 작업 계획 수립\n- **execute 노드**: 각 작업을 순차적으로 실행 (반복)\n- **respond 노드**: 최종 응답 생성\n\n## 실행 함수 정의\n\n### 스트리밍 출력\n\n::: {#e6f35fea .cell execution_count=12}\n``` {.python .cell-code}\nfrom langchain_teddynote.messages import stream_graph\n\ndef run_plan_execute_agent(instruction: str, thread_id: str = \"main\"):\n    \"\"\"계획 및 실행 에이전트 실행\"\"\"\n    config = {\"configurable\": {\"thread_id\": thread_id}}\n    inputs = {\"messages\": [(\"human\", instruction)]}\n    \n    stream_graph(plan_execute_agent, inputs, config)\n```\n:::\n\n\n## 사용 예시\n\n### 예시 1: 시장 조사 보고서 작성\n\n::: {#bee4643e .cell execution_count=13}\n``` {.python .cell-code}\ninstruction = \"\"\"\nAI 에이전트 시장에 대한 종합 조사 보고서를 작성해주세요.\n\n다음 내용이 포함되어야 합니다:\n1. 현재 AI 에이전트 시장 규모 및 성장률\n2. 주요 플레이어 및 기술 트렌드\n3. 시장 기회 및 위험 요소 분석\n4. 향후 6개월 전망\n\n보고서는 마크다운 형식으로 작성하고 파일로 저장해주세요.\n\"\"\"\n\nrun_plan_execute_agent(instruction)\n```\n:::\n\n\n**실행 흐름:**\n\n1. **Plan 단계**:\n   - Task 1: 시장 규모 및 성장률 조사 (web_search)\n   - Task 2: 주요 플레이어 분석 (web_search)\n   - Task 3: 기술 트렌드 조사 (web_search + pdf_retriever)\n   - Task 4: 보고서 작성 (Task 1-3 결과 필요)\n   - Task 5: 파일 저장 (Task 4 결과 필요)\n\n2. **Execute 단계**:\n   - Task 1 실행 → 결과 저장\n   - Task 2 실행 → 결과 저장\n   - Task 3 실행 → 결과 저장\n   - Task 4 실행 → 결과 저장\n   - Task 5 실행 → 결과 저장\n\n3. **Respond 단계**: 최종 보고서 생성\n\n### 예시 2: 데이터 분석 및 시각화\n\n::: {#b1b3b54a .cell execution_count=14}\n``` {.python .cell-code}\ninstruction = \"\"\"\n회사의 분기별 판매 데이터를 분석하고 시각화하는 프로젝트를 진행해주세요.\n\n다음을 순서대로 수행하세요:\n1. sales_data.csv 파일 읽기\n2. 분기별 판매액, 증감율, 주요 제품 분석\n3. 분석 결과를 정리한 요약 테이블 작성\n4. 주요 통찰력을 markdown 형식으로 정리\n5. 최종 분석 보고서를 analysis_report.md로 저장\n\"\"\"\n\nrun_plan_execute_agent(instruction)\n```\n:::\n\n\n**실행 특징:**\n- Task 간 의존성 자동 관리\n- 각 Task의 결과가 다음 Task의 입력으로 사용\n- 순서 위반 불가능 (의존성으로 보호)\n\n### 예시 3: 경쟁사 분석\n\n::: {#de6165e8 .cell execution_count=15}\n``` {.python .cell-code}\ninstruction = \"\"\"\n주요 경쟁사 3곳에 대한 경쟁 분석 리포트를 작성해주세요.\n\n1. 경쟁사1, 경쟁사2, 경쟁사3의 최신 뉴스와 제품 정보 수집\n2. 각 경쟁사의 강점, 약점, 기회, 위협(SWOT) 분석\n3. 우리 회사와의 차별화 전략 도출\n4. 비교 테이블 작성\n5. 최종 보고서를 competitor_analysis.md로 저장\n\n각 경쟁사별 분석은 병렬로 수행 가능합니다.\n\"\"\"\n\nrun_plan_execute_agent(instruction)\n```\n:::\n\n\n## 고급 기법\n\n### 조건부 Task 실행\n\n::: {#95a6560a .cell execution_count=16}\n``` {.python .cell-code}\ndef should_execute_task(task: Task, previous_results: dict) -> bool:\n    \"\"\"특정 조건에서만 Task 실행\"\"\"\n    \n    # 예: 검색 결과가 충분하면 분석 Task 스킵\n    if task.id == 4 and len(previous_results.get(\"search_results\", [])) < 3:\n        return False\n    \n    # 예: 파일이 존재하면 생성 Task 스킵\n    if task.id == 5 and \"file_exists\" in previous_results:\n        return False\n    \n    return True\n```\n:::\n\n\n### Task 결과 캐싱\n\n::: {#8f4f1701 .cell execution_count=17}\n``` {.python .cell-code}\nfrom functools import lru_cache\n\n@lru_cache(maxsize=128)\ndef execute_task_cached(task_id: int, instruction: str) -> str:\n    \"\"\"동일한 Task는 캐시된 결과 사용\"\"\"\n    # 실행 로직\n    pass\n```\n:::\n\n\n### 에러 처리 및 재시도\n\n::: {#f3fd1684 .cell execution_count=18}\n``` {.python .cell-code}\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=2, max=10)\n)\ndef execute_task_with_retry(task: Task) -> str:\n    \"\"\"실패 시 지수 백오프로 재시도\"\"\"\n    # 실행 로직\n    pass\n```\n:::\n\n\n## Plan-and-Execute vs ReAct\n\n| 특성 | Plan-and-Execute | ReAct |\n|------|------------------|-------|\n| **계획 수립** | ✅ 사전 계획 수립 | ❌ 즉흥적 행동 |\n| **복잡도** | 높음 (다단계 작업) | 중간 (단일 목표) |\n| **효율성** | ✅ 불필요한 반복 최소 | ❌ 반복 가능성 높음 |\n| **유연성** | 제한적 (계획 변경 어려움) | ✅ 높음 (동적 대응) |\n| **예측성** | ✅ 높음 (계획이 명시적) | 낮음 (동적 결정) |\n| **토큰 소비** | 중간 (계획 + 실행) | 높음 (반복으로 인한 증가) |\n\n**선택 기준:**\n- **Plan-and-Execute**: 복잡하고 구조화된 작업, 예측 가능한 프로세스\n- **ReAct**: 단순하고 반복적인 작업, 높은 유연성 필요\n\n## 베스트 프랙티스\n\n### 1. 명확한 Task 정의\n\n```python\n# ❌ 나쁜 예\nTask(\n    id=1,\n    title=\"조사\",\n    description=\"뭔가 조사하기\"\n)\n\n# ✅ 좋은 예\nTask(\n    id=1,\n    title=\"AI 에이전트 시장 규모 조사\",\n    description=\"2024년 AI 에이전트 시장 규모, 성장률, 주요 플레이어를 웹 검색으로 조사\",\n    required_tools=[\"web_search\"],\n    dependencies=[]\n)\n```\n\n### 2. 적절한 Task 분해\n\n```python\n# ❌ 너무 많은 Task\n# 100개 이상의 세분화된 Task → 관리 복잡도 증가\n\n# ✅ 적절한 수준\n# 5-10개의 의미 있는 Task → 명확한 진행 추적\n```\n\n### 3. 의존성 명시\n\n```python\n# ❌ 순환 의존성 주의\nTask(id=1, dependencies=[2, 3])\nTask(id=2, dependencies=[1])  # 순환 참조 발생!\n\n# ✅ 단방향 의존성\nTask(id=1, dependencies=[])\nTask(id=2, dependencies=[1])\nTask(id=3, dependencies=[1, 2])\n```\n\n## 트러블슈팅\n\n### 문제 1: Task 순서 오류\n\n```python\n# 의존성 검증\ndef validate_plan(plan: Plan) -> bool:\n    \"\"\"계획의 의존성이 올바른지 검증\"\"\"\n    task_ids = {task.id for task in plan.tasks}\n    \n    for task in plan.tasks:\n        # 존재하지 않는 Task에 의존\n        if not all(dep_id in task_ids for dep_id in task.dependencies):\n            raise ValueError(f\"Task {task.id}: 존재하지 않는 의존성\")\n        \n        # 순환 의존성 감지\n        if task.id in task.dependencies:\n            raise ValueError(f\"Task {task.id}: 자기 자신에 의존\")\n    \n    return True\n```\n\n### 문제 2: Task 실패 처리\n\n```python\ndef handle_task_failure(task: Task, error: str, previous_results: dict):\n    \"\"\"Task 실패 시 대응\"\"\"\n    \n    # 1. 재시도\n    if task.id in [1, 2, 3]:  # 중요한 Task만 재시도\n        return \"retry\"\n    \n    # 2. 대체 Task 실행\n    if task.id == 4:  # 웹 검색 실패\n        return \"use_pdf_retriever\"\n    \n    # 3. 사용자 개입\n    return \"manual_intervention_required\"\n```\n\n### 문제 3: 토큰 오버플로우\n\n```python\ndef truncate_results(results: List[str], max_tokens: int = 2000) -> List[str]:\n    \"\"\"이전 결과 길이 제한\"\"\"\n    truncated = []\n    total_tokens = 0\n    \n    for result in results:\n        result_tokens = len(result.split())\n        if total_tokens + result_tokens > max_tokens:\n            truncated.append(result[:500] + \"...\")\n        else:\n            truncated.append(result)\n        total_tokens += result_tokens\n    \n    return truncated\n```\n\n## 참고 자료\n\n- [Plan-and-Execute Agent 논문](https://arxiv.org/abs/2305.04091)\n- [LangGraph State Management](https://langchain-ai.github.io/langgraph/concepts/low_level_concepts/)\n- [Agent Architecture Best Practices](https://langchain-ai.github.io/langgraph/tutorials/)\n\n## 다음 단계\n\nPlan-and-Execute Agent의 기본을 익혔다면, 다음 주제들을 살펴보자:\n\n- **Multi-Agent 시스템**: 여러 에이전트의 협업\n- **동적 Task 생성**: 런타임에 Task 추가/제거\n- **Agent Orchestration**: 복잡한 워크플로우 관리\n\n",
    "supporting": [
      "13-Plan-Execute-Agent_files"
    ],
    "filters": [],
    "includes": {}
  }
}