{
  "hash": "ad4220c4fef69f955ed9fec6041350b8",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Multi-Agent 시스템\"\nsubtitle: 여러 에이전트의 협업을 통한 복잡한 문제 해결\ndescription: |\n  Multi-Agent 패턴을 활용하여 각각의 전문성을 가진 여러 에이전트가 협력하여 복잡한 문제를 해결하는 시스템 구현을 다룬다.\ncategories:\n  - AI\n  - Agent\n  - LangChain\nauthor: Kwangmin Kim\ndate: 11/19/2025\nformat: \n  html:\n    page-layout: full\n    code-fold: true\n    toc: true\n    number-sections: true\ndraft: False\nexecute:\n    eval: false\n---\n\n## Multi-Agent 시스템이란?\n\nMulti-Agent 시스템은 **각각의 전문성과 역할을 가진 여러 에이전트들이 협력하여 복잡한 문제를 해결하는 아키텍처**이다.\n\n### 단일 에이전트의 한계\n\n**ReAct/Plan-and-Execute의 문제점:**\n- 하나의 모델이 모든 역할 수행\n- 도메인 전문성 부족\n- 확장성 제한\n- 오류 누적\n\n**Multi-Agent의 장점:**\n- **역할 분담**: 각 에이전트가 특화된 역할 수행\n- **전문성**: 도메인별 최적화된 모델 사용\n- **안정성**: 특정 에이전트 실패 시 다른 에이전트가 보완\n- **확장성**: 새로운 역할의 에이전트 추가 용이\n- **성능**: 병렬 처리로 전체 실행 시간 단축\n\n### Multi-Agent 작동 원리\n\n```\nUser Request\n    ↓\n[Coordinator] (요청 분석 및 작업 분배)\n    ↓\n    ├─→ [Research Agent] (정보 수집)\n    ├─→ [Analysis Agent] (데이터 분석)\n    ├─→ [Writer Agent] (문서 작성)\n    └─→ [Review Agent] (품질 검토)\n    ↓\n[Aggregator] (결과 통합)\n    ↓\nFinal Output\n```\n\n### 에이전트의 역할 유형\n\n**1. Coordinator Agent**\n- 사용자 요청 분석\n- 작업 분배\n- 에이전트 간 통신 관리\n\n**2. Specialist Agent**\n- 특정 도메인 전문 수행\n- Research, Analysis, Writing, Code Generation 등\n\n**3. Validator Agent**\n- 결과 검증\n- 품질 확인\n- 오류 감지 및 수정\n\n**4. Aggregator Agent**\n- 각 에이전트의 결과 통합\n- 최종 응답 생성\n\n::: {#1bfe3060 .cell execution_count=1}\n``` {.python .cell-code}\n# API 키를 환경변수로 관리하기 위한 설정 파일\nfrom dotenv import load_dotenv\n\n# API 키 정보 로드\nload_dotenv()\n```\n:::\n\n\n::: {#3535872a .cell execution_count=2}\n``` {.python .cell-code}\n# LangSmith 추적을 설정한다. https://smith.langchain.com\n# !pip install -qU langchain-teddynote\nfrom langchain_teddynote import logging\n\n# 프로젝트 이름을 입력한다.\nlogging.langsmith(\"CH17-Multi-Agent-System\")\n```\n:::\n\n\n## 환경 설정\n\n### 기본 구성 요소\n\nMulti-Agent 시스템은 다음 요소들로 구성된다:\n\n1. **Coordinator**: 요청 라우팅 및 작업 분배\n2. **Specialist Agents**: 각 도메인별 전문 에이전트\n3. **Communication Layer**: 에이전트 간 메시지 전달\n4. **Result Aggregator**: 결과 통합\n5. **Memory System**: 에이전트 간 상태 공유\n\n![Multi-Agent 시스템 아키텍처](assets/multi_agent_architecture.png)\n\n::: {#687831e4 .cell execution_count=3}\n``` {.python .cell-code}\nfrom langchain_openai import ChatOpenAI\nfrom langchain_teddynote.tools.tavily import TavilySearch\nfrom langchain_community.agent_toolkits import FileManagementToolkit\nfrom langchain_core.tools.retriever import create_retriever_tool\nfrom langgraph.checkpoint.memory import MemorySaver\nfrom typing import List, Dict, Any\nfrom pydantic import BaseModel, Field\n\n# 메모리 설정\nmemory = MemorySaver()\n\n# 모델들 정의 (각 역할에 따라 다른 모델 사용 가능)\ncoordinator_model = ChatOpenAI(model_name=\"gpt-4o\", temperature=0)\nresearch_model = ChatOpenAI(model_name=\"gpt-4o-mini\", temperature=0.3)\nanalysis_model = ChatOpenAI(model_name=\"gpt-4o\", temperature=0)\nwriter_model = ChatOpenAI(model_name=\"gpt-4o-mini\", temperature=0.7)\nreviewer_model = ChatOpenAI(model_name=\"gpt-4o\", temperature=0)\n```\n:::\n\n\n**모델 선택 전략:**\n- **Coordinator**: 강력한 모델 (복잡한 분석 필요)\n- **Specialist**: 역할에 맞는 모델 (Research는 정확성, Writer는 창의성)\n- **Reviewer**: 강력한 모델 (품질 평가)\n\n## 도구 설정\n\n### 웹 검색 도구\n\n::: {#80978fc5 .cell execution_count=4}\n``` {.python .cell-code}\nweb_search = TavilySearch(\n    topic=\"general\",\n    max_results=5,\n    include_answer=False,\n)\n\nweb_search.name = \"web_search\"\nweb_search.description = \"웹에서 최신 정보를 검색합니다.\"\n```\n:::\n\n\n### 파일 관리 도구\n\n::: {#34a31371 .cell execution_count=5}\n``` {.python .cell-code}\nworking_directory = \"tmp\"\nfile_tools = FileManagementToolkit(\n    root_dir=str(working_directory),\n).get_tools()\n\nfor tool in file_tools:\n    if tool.name == \"file_write\":\n        tool.description = \"파일을 작성합니다.\"\n    elif tool.name == \"file_read\":\n        tool.description = \"파일을 읽습니다.\"\n    elif tool.name == \"list_directory\":\n        tool.description = \"디렉토리를 나열합니다.\"\n```\n:::\n\n\n### PDF 검색 도구\n\n::: {#00031b1f .cell execution_count=6}\n``` {.python .cell-code}\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain_community.vectorstores import FAISS\nfrom langchain_openai import OpenAIEmbeddings\nfrom langchain.document_loaders import PDFPlumberLoader\nfrom langchain_core.prompts import PromptTemplate\n\nloader = PDFPlumberLoader(\"data/sample_document.pdf\")\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)\nsplit_docs = loader.load_and_split(text_splitter)\nvector = FAISS.from_documents(split_docs, OpenAIEmbeddings())\npdf_retriever = vector.as_retriever()\n\nretriever_tool = create_retriever_tool(\n    pdf_retriever,\n    \"pdf_retriever\",\n    \"내부 문서에서 정보를 검색합니다.\",\n    document_prompt=PromptTemplate.from_template(\n        \"<document><context>{page_content}</context><metadata><source>{source}</source><page>{page}</page></metadata></document>\"\n    ),\n)\n```\n:::\n\n\n## 에이전트 정의\n\n### 에이전트 기본 구조\n\n::: {#7902452e .cell execution_count=7}\n``` {.python .cell-code}\nfrom enum import Enum\nfrom typing import Optional\nfrom datetime import datetime\n\nclass AgentRole(str, Enum):\n    \"\"\"에이전트 역할 정의\"\"\"\n    COORDINATOR = \"coordinator\"\n    RESEARCHER = \"researcher\"\n    ANALYST = \"analyst\"\n    WRITER = \"writer\"\n    REVIEWER = \"reviewer\"\n    AGGREGATOR = \"aggregator\"\n\nclass Agent(BaseModel):\n    \"\"\"에이전트 정의\"\"\"\n    name: str = Field(description=\"에이전트 이름\")\n    role: AgentRole = Field(description=\"에이전트 역할\")\n    model: Any = Field(description=\"LLM 모델\")\n    tools: List[Any] = Field(default_factory=list, description=\"사용 가능한 도구\")\n    system_prompt: str = Field(description=\"시스템 프롬프트\")\n    \n    class Config:\n        arbitrary_types_allowed = True\n\nclass AgentMessage(BaseModel):\n    \"\"\"에이전트 메시지\"\"\"\n    agent_name: str = Field(description=\"발신 에이전트\")\n    timestamp: datetime = Field(default_factory=datetime.now)\n    content: str = Field(description=\"메시지 내용\")\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\nclass MultiAgentState(BaseModel):\n    \"\"\"멀티 에이전트 시스템 상태\"\"\"\n    user_input: str = Field(description=\"사용자 입력\")\n    coordinator_plan: Optional[Dict[str, Any]] = Field(default=None, description=\"코디네이터 계획\")\n    agent_results: Dict[str, str] = Field(default_factory=dict, description=\"각 에이전트 결과\")\n    messages: List[AgentMessage] = Field(default_factory=list, description=\"에이전트 간 메시지\")\n    final_output: str = Field(default=\"\", description=\"최종 출력\")\n    \n    def add_message(self, agent_name: str, content: str, metadata: Dict = None):\n        \"\"\"메시지 추가\"\"\"\n        self.messages.append(\n            AgentMessage(\n                agent_name=agent_name,\n                content=content,\n                metadata=metadata or {}\n            )\n        )\n```\n:::\n\n\n### Coordinator Agent\n\n사용자 요청을 분석하고 작업을 분배한다.\n\n::: {#2197e6fd .cell execution_count=8}\n```` {.python .cell-code}\nfrom langchain_core.prompts import ChatPromptTemplate\n\ncoordinator_prompt = ChatPromptTemplate.from_messages([\n    (\n        \"system\",\n        \"\"\"당신은 조직의 최고 코디네이터(Coordinator)입니다.\n        \n사용자의 요청을 분석하여 어떤 에이전트들이 필요한지, 각 에이전트의 역할이 무엇인지를 결정합니다.\n\n사용 가능한 에이전트:\n- researcher: 웹 검색을 통한 정보 수집\n- analyst: 수집된 정보의 분석 및 인사이트 도출\n- writer: 분석 결과를 바탕으로 문서 작성\n- reviewer: 최종 결과물의 품질 검증\n\n다음 JSON 형식으로 응답하세요:\n```json\n{{\n    \"required_agents\": [\"researcher\", \"analyst\", \"writer\"],\n    \"task_flow\": [\n        {{\n            \"agent\": \"researcher\",\n            \"task\": \"구체적인 작업 설명\",\n            \"dependencies\": []\n        }},\n        {{\n            \"agent\": \"analyst\",\n            \"task\": \"구체적인 작업 설명\",\n            \"dependencies\": [\"researcher\"]\n        }}\n    ],\n    \"success_criteria\": \"성공 기준 설명\"\n}}\n```\"\"\",\n    ),\n    (\"human\", \"사용자 요청: {input}\"),\n])\n\ndef coordinator_step(state: MultiAgentState) -> Dict[str, Any]:\n    \"\"\"코디네이터 실행\"\"\"\n    import json\n    \n    response = coordinator_model.invoke(\n        coordinator_prompt.format_prompt(input=state.user_input)\n    )\n    \n    # JSON 파싱\n    plan = json.loads(response.content)\n    state.add_message(\"coordinator\", f\"계획 수립 완료: {len(plan['required_agents'])}개 에이전트 필요\")\n    \n    return {\"coordinator_plan\": plan}\n````\n:::\n\n\n### Researcher Agent\n\n웹 검색을 통해 정보를 수집한다.\n\n::: {#5cbd2ec3 .cell execution_count=9}\n``` {.python .cell-code}\nresearcher_prompt = ChatPromptTemplate.from_messages([\n    (\n        \"system\",\n        \"\"\"당신은 데이터 조사 전문가(Research Agent)입니다.\n\n주어진 주제에 대해 웹 검색을 통해 신뢰할 수 있는 최신 정보를 수집합니다.\n\n다음을 고려하세요:\n1. 다양한 소스에서 정보 수집\n2. 정보의 신뢰도 평가\n3. 중요한 데이터와 통계 포함\n4. 출처 명시\n\n최종 결과는 다음 형식으로 제공하세요:\n```\n:::\n\n\n## 조사 결과\n\n### 핵심 발견사항\n- 발견사항 1\n- 발견사항 2\n\n### 참고 자료\n- [출처1](URL)\n- [출처2](URL)\n```\n\"\"\",\n    ),\n    (\"human\", \"조사 주제: {topic}\"),\n])\n\nfrom langgraph.prebuilt import create_react_agent\n\nresearcher_agent = create_react_agent(\n    research_model,\n    [web_search],\n)\n\ndef researcher_step(state: MultiAgentState, topic: str) -> str:\n    \"\"\"리서처 에이전트 실행\"\"\"\n    result = researcher_agent.invoke(\n        {\"messages\": [(\"human\", researcher_prompt.format_prompt(topic=topic).to_string())]},\n        {\"configurable\": {\"thread_id\": \"researcher\"}}\n    )\n    \n    content = result[\"messages\"][-1].content\n    state.add_message(\"researcher\", content)\n    \n    return content\n```\n\n### Analyst Agent\n\n수집된 정보를 분석한다.\n\n::: {#796d8dba .cell execution_count=10}\n``` {.python .cell-code}\nanalyst_prompt = ChatPromptTemplate.from_messages([\n    (\n        \"system\",\n        \"\"\"당신은 데이터 분석 전문가(Analysis Agent)입니다.\n\n리서처가 수집한 정보를 깊이 있게 분석합니다.\n\n분석 항목:\n1. **주요 트렌드**: 현재의 주요 변화\n2. **기회 요소**: 활용 가능한 기회\n3. **위험 요소**: 주의해야 할 위험\n4. **미래 전망**: 향후 발전 방향\n5. **통계 분석**: 수집된 데이터의 정량적 분석\n\n최종 분석은 다음 형식으로 제공하세요:\n```\n:::\n\n\n## 분석 결과\n\n### SWOT 분석\n#### 강점(Strengths)\n- 강점1\n- 강점2\n\n#### 약점(Weaknesses)\n- 약점1\n\n#### 기회(Opportunities)\n- 기회1\n\n#### 위협(Threats)\n- 위협1\n\n### 인사이트\n- 인사이트1\n- 인사이트2\n```\"\"\",\n    ),\n    (\"human\", \"분석 대상:\\n{research_data}\"),\n])\n\nanalyst_agent = create_react_agent(\n    analysis_model,\n    [pdf_retriever],\n)\n\ndef analyst_step(state: MultiAgentState, research_data: str) -> str:\n    \"\"\"분석가 에이전트 실행\"\"\"\n    result = analyst_agent.invoke(\n        {\"messages\": [(\"human\", analyst_prompt.format_prompt(research_data=research_data).to_string())]},\n        {\"configurable\": {\"thread_id\": \"analyst\"}}\n    )\n    \n    content = result[\"messages\"][-1].content\n    state.add_message(\"analyst\", content)\n    \n    return content\n```\n\n### Writer Agent\n\n분석 결과를 문서로 작성한다.\n\n::: {#3987a3a5 .cell execution_count=11}\n``` {.python .cell-code}\nwriter_prompt = ChatPromptTemplate.from_messages([\n    (\n        \"system\",\n        \"\"\"당신은 전문 작가(Writer Agent)입니다.\n\n분석된 정보를 바탕으로 높은 품질의 보고서를 작성합니다.\n\n작성 지침:\n1. **명확성**: 쉽고 명확한 표현\n2. **구조화**: 논리적인 흐름\n3. **시각화**: 테이블, 리스트 활용\n4. **설득력**: 데이터 기반의 주장\n5. **전문성**: 산업 용어 적절한 사용\n\n최종 보고서는 다음 구조를 따르세요:\n```\n:::\n\n\n# [제목]\n\n## 개요\n[간단한 요약]\n\n## 주요 내용\n[상세한 내용]\n\n## 결론\n[핵심 결론 및 권장사항]\n```\"\"\",\n    ),\n    (\"human\", \"작성 자료:\\n{analysis_data}\"),\n])\n\nwriter_agent = create_react_agent(\n    writer_model,\n    [*file_tools],\n)\n\ndef writer_step(state: MultiAgentState, analysis_data: str) -> str:\n    \"\"\"작가 에이전트 실행\"\"\"\n    result = writer_agent.invoke(\n        {\"messages\": [(\"human\", writer_prompt.format_prompt(analysis_data=analysis_data).to_string())]},\n        {\"configurable\": {\"thread_id\": \"writer\"}}\n    )\n    \n    content = result[\"messages\"][-1].content\n    state.add_message(\"writer\", content)\n    \n    return content\n```\n\n### Reviewer Agent\n\n최종 결과를 검증한다.\n\n::: {#1d97fb9c .cell execution_count=12}\n``` {.python .cell-code}\nreviewer_prompt = ChatPromptTemplate.from_messages([\n    (\n        \"system\",\n        \"\"\"당신은 품질 검토 전문가(Review Agent)입니다.\n\n최종 결과물의 품질을 검증합니다.\n\n검증 항목:\n1. **정확성**: 사실에 기반했는가\n2. **완성도**: 모든 필요한 요소를 포함했는가\n3. **일관성**: 논리적 오류는 없는가\n4. **가독성**: 읽기 쉬운가\n5. **전문성**: 전문적인 수준인가\n\n평가 결과를 다음 형식으로 제공하세요:\n```\n:::\n\n\n## 검토 결과\n\n### 종합 평가: [Pass/Revise/Reject]\n\n### 강점\n- 강점1\n- 강점2\n\n### 개선 필요 항목\n- 개선 사항1\n- 개선 사항2\n\n### 최종 의견\n[종합 의견]\n```\"\"\",\n    ),\n    (\"human\", \"검토 대상:\\n{document}\"),\n])\n\nreviewer_agent = create_react_agent(\n    reviewer_model,\n    [pdf_retriever],\n)\n\ndef reviewer_step(state: MultiAgentState, document: str) -> str:\n    \"\"\"검토자 에이전트 실행\"\"\"\n    result = reviewer_agent.invoke(\n        {\"messages\": [(\"human\", reviewer_prompt.format_prompt(document=document).to_string())]},\n        {\"configurable\": {\"thread_id\": \"reviewer\"}}\n    )\n    \n    content = result[\"messages\"][-1].content\n    state.add_message(\"reviewer\", content)\n    \n    return content\n```\n\n## Multi-Agent 시스템 그래프 구축\n\n### 상태 관리 및 실행 흐름\n\n::: {#98ffa18c .cell execution_count=13}\n``` {.python .cell-code}\nfrom langgraph.graph import StateGraph, START, END\nfrom langgraph.graph.message import add_messages\nfrom typing import Annotated\n\nclass MultiAgentGraph:\n    \"\"\"멀티 에이전트 시스템 그래프\"\"\"\n    \n    def __init__(self):\n        self.state = None\n        \n    def coordinator_node(self, state: MultiAgentState) -> Dict[str, Any]:\n        \"\"\"코디네이터 노드\"\"\"\n        plan = coordinator_step(state)\n        return {\"coordinator_plan\": plan}\n    \n    def researcher_node(self, state: MultiAgentState) -> Dict[str, str]:\n        \"\"\"리서처 노드\"\"\"\n        if not state.coordinator_plan or \"researcher\" not in state.coordinator_plan.get(\"required_agents\", []):\n            return {\"agent_results\": state.agent_results}\n        \n        # 리서처 태스크 찾기\n        task = next(\n            (t for t in state.coordinator_plan[\"task_flow\"] if t[\"agent\"] == \"researcher\"),\n            None\n        )\n        \n        if task:\n            result = researcher_step(state, task[\"task\"])\n            state.agent_results[\"researcher\"] = result\n        \n        return {\"agent_results\": state.agent_results}\n    \n    def analyst_node(self, state: MultiAgentState) -> Dict[str, str]:\n        \"\"\"분석가 노드\"\"\"\n        if \"researcher\" not in state.agent_results:\n            return {\"agent_results\": state.agent_results}\n        \n        result = analyst_step(state, state.agent_results[\"researcher\"])\n        state.agent_results[\"analyst\"] = result\n        \n        return {\"agent_results\": state.agent_results}\n    \n    def writer_node(self, state: MultiAgentState) -> Dict[str, str]:\n        \"\"\"작가 노드\"\"\"\n        if \"analyst\" not in state.agent_results:\n            return {\"agent_results\": state.agent_results}\n        \n        result = writer_step(state, state.agent_results[\"analyst\"])\n        state.agent_results[\"writer\"] = result\n        \n        return {\"agent_results\": state.agent_results}\n    \n    def reviewer_node(self, state: MultiAgentState) -> Dict[str, str]:\n        \"\"\"검토자 노드\"\"\"\n        if \"writer\" not in state.agent_results:\n            return {\"agent_results\": state.agent_results}\n        \n        result = reviewer_step(state, state.agent_results[\"writer\"])\n        state.agent_results[\"reviewer\"] = result\n        \n        return {\"agent_results\": state.agent_results}\n    \n    def aggregator_node(self, state: MultiAgentState) -> Dict[str, str]:\n        \"\"\"집계 노드\"\"\"\n        # 최종 결과 통합\n        final_output = f\"\"\"\n# 최종 보고서\n\n## 프로세스 요약\n- **조직**: {len(state.messages)}개의 에이전트 협력\n- **단계**: Coordinator → Researcher → Analyst → Writer → Reviewer\n\n## 최종 결과\n\n{state.agent_results.get('writer', '결과 없음')}\n\n## 검토 의견\n\n{state.agent_results.get('reviewer', '검토 없음')}\n\"\"\"\n        return {\"final_output\": final_output}\n    \n    def build_graph(self):\n        \"\"\"그래프 구성\"\"\"\n        workflow = StateGraph(MultiAgentState)\n        \n        # 노드 추가\n        workflow.add_node(\"coordinator\", self.coordinator_node)\n        workflow.add_node(\"researcher\", self.researcher_node)\n        workflow.add_node(\"analyst\", self.analyst_node)\n        workflow.add_node(\"writer\", self.writer_node)\n        workflow.add_node(\"reviewer\", self.reviewer_node)\n        workflow.add_node(\"aggregator\", self.aggregator_node)\n        \n        # 엣지 구성\n        workflow.add_edge(START, \"coordinator\")\n        workflow.add_edge(\"coordinator\", \"researcher\")\n        workflow.add_edge(\"researcher\", \"analyst\")\n        workflow.add_edge(\"analyst\", \"writer\")\n        workflow.add_edge(\"writer\", \"reviewer\")\n        workflow.add_edge(\"reviewer\", \"aggregator\")\n        workflow.add_edge(\"aggregator\", END)\n        \n        return workflow.compile(checkpointer=memory)\n\n# 그래프 생성\nmulti_agent_graph = MultiAgentGraph()\nmulti_agent_system = multi_agent_graph.build_graph()\n```\n:::\n\n\n**그래프 구조:**\n```\nSTART\n  ↓\n[Coordinator] - 작업 계획\n  ↓\n[Researcher] - 정보 수집\n  ↓\n[Analyst] - 데이터 분석\n  ↓\n[Writer] - 문서 작성\n  ↓\n[Reviewer] - 품질 검증\n  ↓\n[Aggregator] - 결과 통합\n  ↓\nEND\n```\n\n## 실행 및 사용 예시\n\n### 실행 함수\n\n::: {#fce659af .cell execution_count=14}\n``` {.python .cell-code}\ndef run_multi_agent_system(user_input: str, thread_id: str = \"main\") -> str:\n    \"\"\"멀티 에이전트 시스템 실행\"\"\"\n    from langchain_teddynote.messages import stream_graph\n    \n    config = {\"configurable\": {\"thread_id\": thread_id}}\n    inputs = {\"user_input\": user_input}\n    \n    result = multi_agent_system.invoke(inputs, config)\n    \n    return result[\"final_output\"]\n```\n:::\n\n\n### 예시 1: 기술 트렌드 분석 보고서\n\n::: {#264b4608 .cell execution_count=15}\n``` {.python .cell-code}\nuser_input = \"\"\"\n2024년 AI 기술 트렌드에 대한 전문 보고서를 작성해주세요.\n\n보고서는 다음을 포함해야 합니다:\n1. 현재의 주요 AI 기술 트렌드\n2. 각 기술의 시장 영향도 분석\n3. 기업에 미치는 영향\n4. 향후 6개월 전망\n\n최종 보고서는 마크다운 형식으로, \n표, 핵심 포인트 정리 등을 포함해주세요.\n\"\"\"\n\noutput = run_multi_agent_system(user_input)\nprint(output)\n```\n:::\n\n\n**실행 흐름:**\n1. **Coordinator**: \"AI 트렌드 분석 보고서\" 계획 수립\n2. **Researcher**: 최신 AI 기술 트렌드 웹 검색\n3. **Analyst**: 수집된 정보 분석 및 SWOT 분석\n4. **Writer**: 전문 보고서 작성\n5. **Reviewer**: 최종 품질 검증\n6. **Aggregator**: 최종 보고서 생성\n\n### 예시 2: 경쟁사 분석 및 전략 수립\n\n::: {#3e62d558 .cell execution_count=16}\n``` {.python .cell-code}\nuser_input = \"\"\"\n우리 회사의 주요 경쟁사 3곳에 대한 심층 분석 보고서와 \n대응 전략을 수립해주세요.\n\n분석 범위:\n1. 경쟁사별 시장 점유율 및 최신 동향\n2. 제품/서비스 비교 분석\n3. 강점 및 약점 평가\n4. 우리 회사의 차별화 전략\n\n최종 결과물:\n- 경쟁사 분석 보고서 (competitor_analysis.md)\n- 대응 전략 가이드 (strategy_guide.md)\n\"\"\"\n\noutput = run_multi_agent_system(user_input)\nprint(output)\n```\n:::\n\n\n### 예시 3: 시장 진출 타당성 검토\n\n::: {#1437fc81 .cell execution_count=17}\n``` {.python .cell-code}\nuser_input = \"\"\"\n신시장 진출의 타당성을 검토하는 종합 보고서를 작성해주세요.\n\n검토 대상: [구체적인 시장/지역/제품]\n\n포함 항목:\n1. 시장 규모 및 성장률 조사\n2. 경쟁 환경 분석\n3. 규제 및 정책 환경\n4. 진출 시 기회 및 위험\n5. 예상 수익성 분석\n6. 최종 권장사항\n\n최종 결과는 경영진 보고 형식으로 작성해주세요.\n\"\"\"\n\noutput = run_multi_agent_system(user_input)\nprint(output)\n```\n:::\n\n\n## 고급 패턴\n\n### 패턴 1: 병렬 처리\n\n여러 에이전트가 동시에 작업을 수행한다.\n\n::: {#1ba783c2 .cell execution_count=18}\n``` {.python .cell-code}\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\ndef parallel_agent_execution(tasks: Dict[str, str]) -> Dict[str, str]:\n    \"\"\"여러 에이전트 병렬 실행\"\"\"\n    \n    results = {}\n    \n    with ThreadPoolExecutor(max_workers=3) as executor:\n        futures = {}\n        \n        # 리서처 병렬 실행 (여러 주제)\n        for topic, instruction in tasks.items():\n            future = executor.submit(researcher_step, instruction)\n            futures[topic] = future\n        \n        # 결과 수집\n        for topic, future in futures.items():\n            results[topic] = future.result()\n    \n    return results\n\n# 사용 예시\nparallel_tasks = {\n    \"AI trends\": \"AI 기술 트렌드 조사\",\n    \"Market data\": \"시장 데이터 조사\",\n    \"Competitor info\": \"경쟁사 정보 조사\"\n}\n\nresults = parallel_agent_execution(parallel_tasks)\n```\n:::\n\n\n**장점:**\n- 실행 시간 단축\n- 자원 효율적 활용\n\n### 패턴 2: 조건부 에이전트 실행\n\n조건에 따라 특정 에이전트를 활성화한다.\n\n::: {#e5308c85 .cell execution_count=19}\n``` {.python .cell-code}\ndef conditional_agent_routing(state: MultiAgentState) -> str:\n    \"\"\"조건부 에이전트 라우팅\"\"\"\n    \n    # 사용자 입력의 복잡도에 따라 결정\n    if len(state.user_input.split()) > 100:\n        # 복잡한 요청: 전체 파이프라인 실행\n        return \"full_pipeline\"\n    \n    elif \"분석\" in state.user_input:\n        # 분석만 필요\n        return \"analyst_only\"\n    \n    elif \"최신 정보\" in state.user_input:\n        # 리서치만 필요\n        return \"researcher_only\"\n    \n    else:\n        # 기본 파이프라인\n        return \"default_pipeline\"\n```\n:::\n\n\n### 패턴 3: 에이전트 간 피드백 루프\n\n에이전트의 결과에 대해 다른 에이전트가 피드백을 제공한다.\n\n::: {#36915d36 .cell execution_count=20}\n``` {.python .cell-code}\ndef feedback_loop(\n    initial_result: str,\n    feedback_provider: str\n) -> str:\n    \"\"\"피드백 루프\"\"\"\n    \n    feedback = reviewer_agent.invoke({\n        \"messages\": [\n            (\"human\", f\"다음 결과를 검토하고 개선 사항을 제시하세요:\\n{initial_result}\")\n        ]\n    })\n    \n    # 개선된 버전 생성\n    improved_result = writer_agent.invoke({\n        \"messages\": [\n            (\"human\", f\"다음 피드백을 바탕으로 문서를 개선하세요:\\n{feedback['messages'][-1].content}\")\n        ]\n    })\n    \n    return improved_result[\"messages\"][-1].content\n```\n:::\n\n\n## 성능 최적화\n\n### 1. 캐싱 전략\n\n::: {#75f70658 .cell execution_count=21}\n``` {.python .cell-code}\nfrom functools import lru_cache\n\n@lru_cache(maxsize=128)\ndef cached_research(topic: str) -> str:\n    \"\"\"연구 결과 캐싱\"\"\"\n    return researcher_step(None, topic)\n\n# 사용\nresult1 = cached_research(\"AI trends\")\nresult2 = cached_research(\"AI trends\")  # 캐시에서 반환\n```\n:::\n\n\n### 2. 토큰 최적화\n\n::: {#cf84990c .cell execution_count=22}\n``` {.python .cell-code}\ndef optimize_token_usage(result: str, max_tokens: int = 1500) -> str:\n    \"\"\"토큰 사용량 최적화\"\"\"\n    \n    from langchain.text_splitter import RecursiveCharacterTextSplitter\n    \n    splitter = RecursiveCharacterTextSplitter(\n        chunk_size=max_tokens,\n        chunk_overlap=0\n    )\n    \n    chunks = splitter.split_text(result)\n    return chunks[0]  # 가장 관련성 높은 청크만 사용\n```\n:::\n\n\n### 3. 비용 절감 전략\n\n::: {#1132a1a0 .cell execution_count=23}\n``` {.python .cell-code}\ndef cost_optimized_model_selection(task_complexity: str) -> ChatOpenAI:\n    \"\"\"작업 복잡도에 따른 모델 선택\"\"\"\n    \n    if task_complexity == \"simple\":\n        return ChatOpenAI(model_name=\"gpt-4o-mini\")\n    \n    elif task_complexity == \"medium\":\n        return ChatOpenAI(model_name=\"gpt-4o-mini\")\n    \n    else:  # complex\n        return ChatOpenAI(model_name=\"gpt-4o\")\n```\n:::\n\n\n## 에러 처리 및 복구\n\n### 에이전트 실패 처리\n\n::: {#68d134b4 .cell execution_count=24}\n``` {.python .cell-code}\ndef handle_agent_failure(failed_agent: str, state: MultiAgentState) -> str:\n    \"\"\"에이전트 실패 시 대응\"\"\"\n    \n    if failed_agent == \"researcher\":\n        # 대체: PDF 문서에서 정보 검색\n        return pdf_retriever.invoke(state.user_input)\n    \n    elif failed_agent == \"analyst\":\n        # 대체: 원본 데이터 직접 사용\n        return state.agent_results.get(\"researcher\", \"\")\n    \n    elif failed_agent == \"writer\":\n        # 대체: 간단한 텍스트 형식으로 작성\n        return f\"## 분석 결과\\n{state.agent_results['analyst']}\"\n    \n    else:\n        raise Exception(f\"Unknown agent: {failed_agent}\")\n```\n:::\n\n\n### 재시도 메커니즘\n\n::: {#b53c849f .cell execution_count=25}\n``` {.python .cell-code}\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=2, max=10)\n)\ndef resilient_agent_call(agent_func, *args, **kwargs):\n    \"\"\"재시도 가능한 에이전트 호출\"\"\"\n    return agent_func(*args, **kwargs)\n```\n:::\n\n\n## 다양한 아키텍처 패턴\n\n### 패턴 1: 순차적 파이프라인 (Sequential)\n\n```\nAgent1 → Agent2 → Agent3 → Output\n```\n\n**사용 사례:** 정보 수집 → 분석 → 작성\n\n### 패턴 2: 병렬 처리 (Parallel)\n\n```\n      ├→ Agent1 ─┐\nInput ┤           ├→ Aggregator → Output\n      └→ Agent2 ─┘\n```\n\n**사용 사례:** 여러 시각에서의 분석 수행\n\n### 패턴 3: 위임 구조 (Hierarchical)\n\n```\nMaster Agent\n    ├→ Team A\n    │   ├→ Member 1\n    │   └→ Member 2\n    └→ Team B\n        ├→ Member 3\n        └→ Member 4\n```\n\n**사용 사례:** 대규모 조직 구조\n\n### 패턴 4: 피드백 루프 (Feedback Loop)\n\n```\nAgent1 → Agent2 → Reviewer ─┐\n         ↑                   ↓\n         └────── Feedback ───┘\n```\n\n**사용 사례:** 반복적 개선 및 품질 보증\n\n## Multi-Agent vs Single-Agent\n\n| 특성 | Multi-Agent | Single-Agent |\n|------|------------|-------------|\n| **전문성** | ✅ 높음 (도메인별 최적화) | ❌ 낮음 (일반화 필요) |\n| **복잡성** | 높음 (시스템 관리) | ✅ 낮음 (단순함) |\n| **확장성** | ✅ 높음 (에이전트 추가) | 제한적 |\n| **비용** | 중간 (병렬 처리로 단축) | ✅ 낮음 |\n| **안정성** | ✅ 높음 (중복성) | 낮음 (단일 실패점) |\n| **성능** | ✅ 빠름 (병렬 처리) | 느림 (순차 처리) |\n\n## 베스트 프랙티스\n\n### 1. 명확한 역할 정의\n\n```python\n# ❌ 나쁜 예\nAgent(name=\"Agent1\", role=\"모든 작업 수행\")\n\n# ✅ 좋은 예\nAgent(\n    name=\"Research Agent\",\n    role=AgentRole.RESEARCHER,\n    system_prompt=\"웹 검색을 통한 정보 수집 전문가\"\n)\n```\n\n### 2. 적절한 에이전트 수\n\n```python\n# ❌ 너무 많은 에이전트 (관리 복잡도 증가)\nagents = [Agent() for _ in range(20)]\n\n# ✅ 적절한 수 (5-7개)\nagents = [\n    coordinator, researcher, analyst, writer, reviewer\n]\n```\n\n### 3. 명확한 의사소통 프로토콜\n\n```python\n# 에이전트 간 메시지 규격화\nclass AgentMessage(BaseModel):\n    sender: str\n    recipient: str\n    content: str\n    metadata: Dict[str, Any]\n```\n\n### 4. 상태 관리\n\n```python\n# 공유 상태 정의\nclass SharedState(BaseModel):\n    user_input: str\n    intermediate_results: Dict[str, str]\n    metadata: Dict[str, Any]\n```\n\n## 참고 자료\n\n- [Multi-Agent Systems Paper](https://arxiv.org/abs/2308.00352)\n- [LangGraph Documentation](https://langchain-ai.github.io/langgraph/)\n- [Agent Design Patterns](https://langchain-ai.github.io/langgraph/tutorials/)\n- [Distributed AI Systems](https://arxiv.org/abs/2402.18658)\n\n## 다음 단계\n\nMulti-Agent 시스템의 기본을 익혔다면, 다음 주제들을 살펴보자:\n\n- **Agent Orchestration**: 복잡한 워크플로우 관리\n- **Knowledge Sharing**: 에이전트 간 지식 공유 메커니즘\n- **Performance Monitoring**: 멀티 에이전트 시스템의 모니터링 및 최적화\n- **Scalability**: 대규모 멀티 에이전트 시스템 구축\n\n",
    "supporting": [
      "14-Multi-Agent_files"
    ],
    "filters": [],
    "includes": {}
  }
}