{
  "hash": "d32a34422dd3b6778d537daaf7bbf1b4",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"앙상블 검색기(Ensemble Retriever)\"\nsubtitle: 검색기\ndescription: |\n  문서 검색을 위한 다양한 Retriever 패턴과 최적화 기법을 다룬다.\ncategories:\n  - AI\n  - RAG\n  - LangChain\n  - Agent\nauthor: Kwangmin Kim\ndate: 12/31/2024\nformat: \n  html:\n    page-layout: full\n    code-fold: true\n    toc: true\n    number-sections: true\ndraft: False\nexecute:\n    eval: false\n---\n\n`EnsembleRetriever`는 여러 검색기를 결합하여 더 강력한 검색 결과를 제공하는 LangChain의 기능이다. 다양한 검색 알고리즘의 장점을 활용하여 단일 알고리즘보다 더 나은 성능을 달성할 수 있으며, 사용자들 사이에서 높은 호평을 받고 있다. 다수의 리트리버를 사용하여 나온 결과를 Reciprocal Rank Fusion(RRF) 알고리즘으로 재순위화한 후 하나의 통합 검색 결과를 LLM의 입력으로 제공한다.\n\n**주요 특징**\n\n1. **여러 검색기 통합**: 다양한 유형의 검색기를 입력으로 받아 결과를 결합한다.\n\n2. **결과 재순위화 (Reciprocal Rank Fusion)**: [RRF](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf) 알고리즘을 사용하여 각 검색기의 결과를 단순 합집합이 아닌 지능형 순위 매김을 통해 통합한다.\n   - 각 검색기들이 검색한 유사도 높은 문서들을 단순히 합치지 않고 다시 순위를 매긴다\n   - Agent 개발자들 사이에서는 EnsembleRetriever(LangChain 용어)보다 RRF(일반 통용 용어)를 훨씬 더 일반적으로 사용한다\n   - 논문에서 거의 모든 경우에 RRF가 더 좋은 성능을 보임을 보여준다\n   - 실제 적용에서 RRF의 효과는 비슷한 특성의 리트리버를 결합할 때보다 **다양한 특성의 리트리버를 결합할 때 극대화**된다\n\n3. **하이브리드 검색**: 주로 `sparse retriever`(예: BM25)와 `dense retriever`(예: 임베딩 유사도)를 결합하여 사용한다.\n\n**각 검색기의 장점**\n\n- **Sparse Retriever (BM25)**: 키워드 기반 검색에 효과적 → 사용자의 정확한 용어에 민감하게 반응\n- **Dense Retriever (임베딩 기반)**: 의미적 유사성 기반 검색에 효과적 → 의도와 맥락을 이해한 검색\n\n이러한 상호 보완적인 특성으로 인해 `EnsembleRetriever`는 다양한 검색 시나리오에서 향상된 성능을 제공한다.\n\n자세한 내용은 [LangChain 공식 문서](https://python.langchain.com/docs/modules/data_connection/retrievers/ensemble)를 참조하자.\n\n\n## 환경 설정\n\n::: {#0fe65bdc .cell execution_count=1}\n``` {.python .cell-code}\n# API 키를 환경변수로 관리하기 위한 설정\nfrom dotenv import load_dotenv\n\n# API 키 정보 로드\nload_dotenv()\n```\n:::\n\n\n::: {#4f46fd91 .cell execution_count=2}\n``` {.python .cell-code}\n# LangSmith 추적을 설정합니다. https://smith.langchain.com\n# !pip install langchain-teddynote\nfrom langchain_teddynote import logging\n\n# 프로젝트 이름을 입력\nlogging.langsmith(\"CH10-Retriever\")\n```\n:::\n\n\n## 기본 사용법: 두 개의 검색기 결합\n\n`EnsembleRetriever`를 초기화하여 `BM25Retriever`와 `FAISS` 검색기를 결합한다. 각 검색기는 고유한 검색 방식을 사용한다:\n- `BM25Retriever`: 키워드 기반 검색 (sparse search)\n- `FAISS`: 임베딩 기반 의미 검색 (dense search)\n\n::: {#5978f2b0 .cell execution_count=3}\n``` {.python .cell-code}\nfrom langchain.retrievers import BM25Retriever, EnsembleRetriever\nfrom langchain.vectorstores import FAISS\nfrom langchain_openai import OpenAIEmbeddings\n\n# 샘플 문서 데이터셋 (Apple 관련 문서들)\ndoc_list = [\n    \"I like apples\",\n    \"I like apple company\",\n    \"I like apple's iphone\",\n    \"Apple is my favorite company\",\n    \"I like apple's ipad\",\n    \"I like apple's macbook\",\n]\n\n# BM25 Retriever 초기화 (키워드 기반 검색)\nbm25_retriever = BM25Retriever.from_texts(doc_list)\nbm25_retriever.k = 1  # 검색 결과 개수\n\n# FAISS Retriever 초기화 (의미 기반 검색)\nembedding = OpenAIEmbeddings()\nfaiss_vectorstore = FAISS.from_texts(doc_list, embedding)\nfaiss_retriever = faiss_vectorstore.as_retriever(search_kwargs={\"k\": 1})\n\n# Ensemble Retriever 생성 (가중치: BM25 70%, FAISS 30%)\nensemble_retriever = EnsembleRetriever(\n    retrievers=[bm25_retriever, faiss_retriever],\n    weights=[0.7, 0.3],  # BM25에 더 높은 가중치 부여\n)\n```\n:::\n\n\n### 예제 1: 키워드 기반 검색에 유리한 쿼리\n\n`ensemble_retriever` 객체를 사용하여 관련 문서를 검색한다. 각 검색기의 결과를 비교하면 가중치의 영향을 확인할 수 있다.\n\n::: {#88fb07f5 .cell execution_count=4}\n``` {.python .cell-code}\n# 검색 실행\nquery = \"my favorite fruit is apple\"\nensemble_result = ensemble_retriever.invoke(query)\nbm25_result = bm25_retriever.invoke(query)\nfaiss_result = faiss_retriever.invoke(query)\n\n# 결과 출력\nprint(\"[Ensemble Retriever 결과]\")\nfor doc in ensemble_result:\n    print(f\"Content: {doc.page_content}\")\n    print()\n\nprint(\"[BM25 Retriever 결과]\")\nfor doc in bm25_result:\n    print(f\"Content: {doc.page_content}\")\n    print()\n\nprint(\"[FAISS Retriever 결과]\")\nfor doc in faiss_result:\n    print(f\"Content: {doc.page_content}\")\n    print()\n```\n:::\n\n\n```\n[Ensemble Retriever 결과]\n  I like apples\n\n[BM25 Retriever 결과]\n  I like apples\n\n[FAISS Retriever 결과]\n  Apple is my favorite company\n\n```\n\n**결과 해석**: \n- BM25는 정확한 키워드 매칭(\"apple\"과 \"fruit\")으로 \"I like apples\" 문서를 찾음\n- FAISS는 의미 유사성으로 \"favorite\"과 관련된 \"Apple is my favorite company\" 문서를 찾음\n- Ensemble은 BM25 가중치(0.7)가 높아서 BM25 결과를 우선함\n\n### 예제 2: 의미 검색이 더 유용한 복잡한 쿼리\n\n더 자연스러운 문장 형태의 쿼리로 두 검색 방식의 차이를 관찰한다.\n\n::: {#e0f2f22b .cell execution_count=5}\n``` {.python .cell-code}\n# 복잡한 쿼리 실행\nquery = \"Apple company makes my favorite iphone\"\nensemble_result = ensemble_retriever.invoke(query)\nbm25_result = bm25_retriever.invoke(query)\nfaiss_result = faiss_retriever.invoke(query)\n\n# 결과 출력\nprint(\"[Ensemble Retriever 결과]\")\nfor doc in ensemble_result:\n    print(f\"Content: {doc.page_content}\")\n    print()\n\nprint(\"[BM25 Retriever]\")\nfor doc in bm25_result:\n    print(f\"Content: {doc.page_content}\")\n    print()\n\nprint(\"[FAISS Retriever 결과]\")\nfor doc in faiss_result:\n    print(f\"Content: {doc.page_content}\")\n    print()\n```\n:::\n\n\n```\n[Ensemble Retriever 결과]\n  Apple is my favorite company\n  I like apple's iphone\n\n[BM25 Retriever 결과]\n  Apple is my favorite company\n\n[FAISS Retriever 결과]\n  I like apple's iphone\n```\n\n**결과 해석**:\n- BM25는 \"Apple\"과 \"company\"라는 정확한 키워드에만 반응 → 한 문서만 반환\n- FAISS는 \"favorite\"과 \"iphone\"의 의미 관계를 이해 → 더 정확한 문서 검색\n- **Ensemble은 두 결과를 결합** → 다양한 관점에서의 정보 제공\n- 실제 사용에서는 의미 검색의 가중치를 높이는 것이 복잡한 쿼리에서 더 효과적\n\n## 고급 기능: 런타임에 가중치 동적 변경\n\n`ConfigurableField`를 사용하면 프로그램 실행 중(런타임)에 각 검색기의 가중치를 동적으로 변경할 수 있다. 이는 다양한 쿼리 유형에 대응하는 유연한 검색 시스템을 구축할 수 있다는 장점이 있다.\n\n### 동적 가중치 설정 구성\n\n::: {#09e61ba8 .cell execution_count=6}\n``` {.python .cell-code}\nfrom langchain_core.runnables import ConfigurableField\n\n# ConfigurableField를 사용한 동적 가중치 설정\nensemble_retriever = EnsembleRetriever(\n    # 리트리버 목록을 설정합니다. 여기서는 bm25_retriever와 faiss_retriever를 사용합니다.\n    retrievers=[bm25_retriever, faiss_retriever],\n).configurable_fields(\n    weights=ConfigurableField(\n        id=\"ensemble_weights\",  # 외부에서 참조할 식별자\n        name=\"Ensemble Weights\",\n        description=\"BM25와 FAISS 검색기의 가중치 비율 (합계=1.0)\",\n    )\n)\n```\n:::\n\n\n- 검색 시 `config` 매개변수를 통해 검색 설정을 지정\n  - `ensemble_weights` 옵션의 가중치를 [1, 0]으로 설정하여 **모든 검색 결과의 가중치가 BM25 retriever 에 더 많이 부여** 되도록 \n\n::: {#1dd7707d .cell execution_count=7}\n``` {.python .cell-code}\n# BM25 전용 검색 설정\nconfig = {\"configurable\": {\"ensemble_weights\": [1, 0]}}\n\n# 동일한 쿼리로 검색 실행\ndocs = ensemble_retriever.invoke(\"my favorite fruit is apple\", config=config)\n\nprint(\"[BM25만 사용 (가중치 [1.0, 0.0])]\")\nfor i, doc in enumerate(docs, 1):\n    print(f\"{i}. {doc.page_content}\")\n```\n:::\n\n\n```\n[BM25만 사용 (가중치 [1.0, 0.0])]\n1. I like apples\n```\n\n**결과 해석**: BM25만 사용할 때는 정확한 키워드 매칭만 이루어짐. \"apple\"과 \"fruit\"을 포함한 문서만 반환됨.\n\n### 케이스 2: FAISS 가중치 극대화 (의미 기반 검색)\n\nFAISS 검색기에 전체 가중치(1.0)를 할당하여 의미 기반 검색만 수행한다.\n\n::: {#70d58b63 .cell execution_count=8}\n``` {.python .cell-code}\n# FAISS 전용 검색 설정\nconfig = {\"configurable\": {\"ensemble_weights\": [0, 1]}}\n\n# 동일한 쿼리로 검색 실행\ndocs = ensemble_retriever.invoke(\"my favorite fruit is apple\", config=config)\n\nprint(\"[FAISS만 사용 (가중치 [0.0, 1.0])]\")\nfor i, doc in enumerate(docs, 1):\n    print(f\"{i}. {doc.page_content}\")\n```\n:::\n\n\n```\n[FAISS만 사용 (가중치 [0.0, 1.0])]\n1. Apple is my favorite company\n```\n\n**결과 해석**: FAISS만 사용할 때는 의미 유사성으로 검색. \"my favorite\"이라는 표현을 \"Apple is my favorite company\"에서 찾아 반환함.\n\n",
    "supporting": [
      "03-EnsembleRetriever_files"
    ],
    "filters": [],
    "includes": {}
  }
}