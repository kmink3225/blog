{
  "hash": "26371b4691d95dc5701798e885816c86",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"ReAct Agent\"\nsubtitle: Reasoning and Acting 패턴을 활용한 에이전트\ndescription: |\n  ReAct(Reasoning and Acting) 패턴을 활용하여 추론과 행동을 결합한 에이전트 구현을 다룬다.\ncategories:\n  - AI\n  - RAG\n  - LangChain\n  - ReAct\nauthor: Kwangmin Kim\ndate: 07/25/2025\nformat: \n  html:\n    page-layout: full\n    code-fold: true\n    toc: true\n    number-sections: true\ndraft: False\nexecute:\n    eval: false\n---\n\n## ReAct Agent란?\n\nReAct(Reasoning and Acting)는 대규모 언어 모델(LLM)이 **추론(Reasoning)**과 **행동(Acting)**을 결합하여 문제를 해결하는 패턴이다. \n\n### ReAct의 핵심 개념\n\n**전통적인 방식의 한계:**\n- Chain-of-Thought: 추론만 수행 (외부 정보 접근 불가)\n- Tool-only: 도구 사용만 수행 (추론 과정 부재)\n\n**ReAct의 장점:**\n- **추론 + 행동**: 각 단계에서 \"왜 이 행동을 하는가?\"를 생각하고 실행\n- **반복적 개선**: 결과를 보고 다음 행동을 결정\n- **투명성**: 추론 과정이 명시적으로 드러남\n\n### ReAct 작동 원리\n\n```\n1. Thought (생각): \"이 문제를 해결하려면 최신 정보가 필요하다\"\n2. Action (행동): 웹 검색 도구 실행\n3. Observation (관찰): 검색 결과 확인\n4. Thought (생각): \"이 정보로 답변할 수 있다\"\n5. Final Answer: 최종 답변 생성\n```\n\n### LangGraph의 ReAct 구현\n\nLangGraph의 `create_react_agent`는 ReAct 패턴을 쉽게 구현할 수 있게 해주는 사전 구축된 에이전트다.\n\n**주요 특징:**\n- 자동 루프: Thought → Action → Observation 반복\n- 메모리 지원: 이전 대화 기억\n- 멀티 도구: 여러 도구를 동시에 사용 가능\n- 스트리밍: 실시간 응답 생성\n\n::: {#e77450d0 .cell execution_count=1}\n``` {.python .cell-code}\n# API 키를 환경변수로 관리하기 위한 설정 파일\nfrom dotenv import load_dotenv\n\n# API 키 정보 로드\nload_dotenv()\n```\n:::\n\n\n::: {#367d4e05 .cell execution_count=2}\n``` {.python .cell-code}\n# LangSmith 추적을 설정한다. https://smith.langchain.com\n# !pip install -qU langchain-teddynote\nfrom langchain_teddynote import logging\n\n# 프로젝트 이름을 입력한다.\nlogging.langsmith(\"CH15-React-Agent\")\n```\n:::\n\n\n## 환경 설정\n\n### 기본 구성 요소\n\nReAct Agent는 세 가지 핵심 요소가 필요하다:\n\n1. **LLM 모델**: 추론을 담당\n2. **도구(Tools)**: 외부 작업 수행\n3. **메모리(Memory)**: 대화 이력 저장\n\n![ReAct Agent 아키텍처](assets/agent.png)\n\n::: {#270de57e .cell execution_count=3}\n``` {.python .cell-code}\nfrom langchain_openai import ChatOpenAI\nfrom langchain_teddynote.tools.tavily import TavilySearch\nfrom langchain_core.messages import HumanMessage\nfrom langgraph.checkpoint.memory import MemorySaver\nfrom langgraph.prebuilt import create_react_agent\n\n# 메모리 설정 (대화 이력 저장)\nmemory = MemorySaver()\n\n# 모델 설정 (GPT-4o-mini 사용)\nmodel = ChatOpenAI(model_name=\"gpt-4o-mini\")\n```\n:::\n\n\n**MemorySaver**: \n- 대화 컨텍스트를 메모리에 저장\n- 이전 대화를 기억하여 연속적인 대화 가능\n- Thread ID로 세션 관리\n\n## 도구 설정\n\nReAct Agent는 다양한 도구를 사용하여 복잡한 작업을 수행한다.\n\n### 웹 검색 도구\n\n**Tavily Search**: 실시간 웹 검색을 위한 도구\n\n::: {#df401fd2 .cell execution_count=4}\n``` {.python .cell-code}\nfrom langchain_teddynote.tools.tavily import TavilySearch\n\n# 웹 검색 도구 생성\nweb_search = TavilySearch(\n    topic=\"general\",  # 뉴스 주제 (general 또는 news)\n    max_results=5,  # 최대 검색 결과 수\n    include_answer=False,  # Tavily의 답변 포함 여부\n    include_raw_content=False,  # 원본 HTML 포함 여부\n    include_images=False,  # 이미지 포함 여부\n    format_output=False,  # 결과 포맷팅 여부\n)\n\n# 도구 이름 및 설명 설정 (LLM이 도구를 선택할 때 사용)\nweb_search.name = \"web_search\"\nweb_search.description = (\n    \"Use this tool to search on the web for any topic other than news.\"\n)\n```\n:::\n\n\n**웹 검색 테스트:**\n\n::: {#f8bc7630 .cell execution_count=5}\n``` {.python .cell-code}\nresult = web_search.search(\"SK AI SUMMIT 2024 관련된 정보를 찾아줘\")\nprint(result)\n```\n:::\n\n\n**왜 웹 검색이 필요한가?**\n- LLM의 지식 컷오프 날짜 이후의 최신 정보 획득\n- 실시간 데이터 (뉴스, 주가, 날씨 등) 조회\n- 팩트 체크 및 검증\n\n### 파일 관리 도구\n\n**FileManagementToolkit**: 로컬 파일 시스템 작업\n\n::: {#4f770f5a .cell execution_count=6}\n``` {.python .cell-code}\nfrom langchain_community.agent_toolkits import FileManagementToolkit\n\n# 'tmp'라는 이름의 디렉토리를 작업 디렉토리로 설정\nworking_directory = \"tmp\"\n\n# FileManagementToolkit 객체를 생성\nfile_management_tools = FileManagementToolkit(\n    root_dir=str(working_directory),\n).get_tools()\n```\n:::\n\n\n**포함된 도구들:**\n\n::: {#7a64102b .cell execution_count=7}\n``` {.python .cell-code}\n# 파일 관리 도구 출력\nfile_management_tools\n```\n:::\n\n\n**주요 기능:**\n- `write_file`: 파일 쓰기\n- `read_file`: 파일 읽기\n- `list_directory`: 디렉토리 목록 조회\n- `copy_file`: 파일 복사\n- `move_file`: 파일 이동\n- `delete_file`: 파일 삭제\n\n**사용 예시:**\n1. 웹에서 정보 수집\n2. 보고서 작성\n3. 파일로 저장\n\n## Retriever 도구\n\n**PDF 문서 검색**: RAG 시스템과 통합\n\n### PDF 문서 로드 및 벡터화\n\n::: {#64cd84b6 .cell execution_count=8}\n``` {.python .cell-code}\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain_community.vectorstores import FAISS\nfrom langchain_openai import OpenAIEmbeddings\nfrom langchain.document_loaders import PDFPlumberLoader\n\n# PDF 파일 로드. 파일의 경로 입력\nloader = PDFPlumberLoader(\"data/SPRI_AI_Brief_2023년12월호_F.pdf\")\n\n# 텍스트 분할기를 사용하여 문서를 분할\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)\n\n# 문서를 로드하고 분할\nsplit_docs = loader.load_and_split(text_splitter)\n\n# VectorStore를 생성 (FAISS 사용)\nvector = FAISS.from_documents(split_docs, OpenAIEmbeddings())\n\n# Retriever를 생성\npdf_retriever = vector.as_retriever()\n```\n:::\n\n\n**처리 과정:**\n1. **PDF 로드**: PDFPlumberLoader로 텍스트 추출\n2. **청크 분할**: 1000자 단위로 분할 (100자 오버랩)\n3. **임베딩**: OpenAI Embeddings로 벡터 변환\n4. **벡터 저장**: FAISS에 저장\n5. **Retriever 생성**: 유사도 검색 가능한 객체\n\n### Retriever를 도구로 변환\n\n::: {#953b36df .cell execution_count=9}\n``` {.python .cell-code}\nfrom langchain_core.tools.retriever import create_retriever_tool\nfrom langchain_core.prompts import PromptTemplate\n\n# PDF 문서를 기반으로 검색 도구 생성\nretriever_tool = create_retriever_tool(\n    pdf_retriever,\n    \"pdf_retriever\",\n    \"Search and return information about SPRI AI Brief PDF file. It contains useful information on recent AI trends. The document is published on Dec 2023.\",\n    document_prompt=PromptTemplate.from_template(\n        \"<document><context>{page_content}</context><metadata><source>{source}</source><page>{page}</page></metadata></document>\"\n    ),\n)\n```\n:::\n\n\n**도구 설명 작성 팁:**\n- LLM이 언제 이 도구를 사용할지 명확히 기술\n- 문서 내용 및 출판 날짜 명시\n- 검색 가능한 주제 힌트 제공\n\n### 전체 도구 목록\n\n::: {#10744946 .cell execution_count=10}\n``` {.python .cell-code}\n# 도구 목록을 정의\ntools = [web_search, *file_management_tools, retriever_tool]\ntools\n```\n:::\n\n\n**도구 조합의 장점:**\n- **웹 검색**: 최신 정보\n- **파일 관리**: 결과 저장 및 관리\n- **PDF 검색**: 내부 문서 지식\n\n## 에이전트 생성\n\n### create_react_agent\n\nLangGraph의 사전 구축된 ReAct Agent를 생성한다.\n\n::: {#7806bcd6 .cell execution_count=11}\n``` {.python .cell-code}\nfrom langgraph.prebuilt import create_react_agent\n\nagent_executor = create_react_agent(model, tools, checkpointer=memory)\n```\n:::\n\n\n**파라미터:**\n- `model`: 사용할 LLM\n- `tools`: 도구 목록\n- `checkpointer`: 메모리 저장소 (대화 이력)\n\n**내부 동작:**\n1. 사용자 입력 받기\n2. LLM이 추론 (어떤 도구를 사용할지)\n3. 도구 실행\n4. 결과 관찰\n5. 다음 행동 결정 (반복)\n6. 최종 답변 생성\n\n### 에이전트 시각화\n\n::: {#cdfef7f0 .cell execution_count=12}\n``` {.python .cell-code}\nfrom langchain_teddynote.graphs import visualize_graph\n\nvisualize_graph(agent_executor)\n```\n:::\n\n\n**그래프 구조:**\n- **agent 노드**: LLM이 추론 및 도구 선택\n- **tools 노드**: 선택된 도구 실행\n- **순환 구조**: agent ↔ tools 반복\n\n## 실행 함수 정의\n\n### 스트리밍 출력\n\n실시간으로 에이전트의 사고 과정을 확인할 수 있다.\n\n::: {#a7c8a0de .cell execution_count=13}\n``` {.python .cell-code}\nfrom langchain_teddynote.messages import stream_graph\n```\n:::\n\n\n**stream_graph 함수:**\n- 에이전트 실행을 스트리밍으로 출력\n- 각 노드의 출력을 실시간 확인\n- 디버깅 및 모니터링에 유용\n\n## 사용 예시\n\n### 예시 1: 기본 대화 (메모리 테스트)\n\n::: {#2431c47b .cell execution_count=14}\n``` {.python .cell-code}\n# Config 설정 (Thread ID로 세션 관리)\nconfig = {\"configurable\": {\"thread_id\": \"abc123\"}}\ninputs = {\"messages\": [(\"human\", \"안녕? 내 이름은 테디야\")]}\n\n# 그래프 스트림\nstream_graph(agent_executor, inputs, config, node_names=[\"agent\"])\n```\n:::\n\n\n**메모리 확인:**\n\n::: {#ecfb7bb1 .cell execution_count=15}\n``` {.python .cell-code}\nconfig = {\"configurable\": {\"thread_id\": \"abc123\"}}\ninputs = {\"messages\": [(\"human\", \"내 이름이 뭐라고?\")]}\n\n# 그래프 스트림\nstream_graph(agent_executor, inputs, config, node_names=[\"agent\"])\n```\n:::\n\n\n**기대 결과:**\n- \"테디\"라고 기억하고 답변\n- 이전 대화를 참조하여 연속적인 대화\n\n### 예시 2: PDF 문서 검색\n\n::: {#01840511 .cell execution_count=16}\n``` {.python .cell-code}\nconfig = {\"configurable\": {\"thread_id\": \"abc123\"}}\ninputs = {\n    \"messages\": [\n        (\"human\", \"AI Brief 보고서에서 Anthropic 투자 관련된 정보를 요약해줘.\")\n    ]\n}\nstream_graph(agent_executor, inputs, config, node_names=[\"agent\", \"tools\"])\n```\n:::\n\n\n**실행 흐름:**\n1. **Thought**: \"PDF 문서를 검색해야겠다\"\n2. **Action**: `pdf_retriever` 실행\n3. **Observation**: Anthropic 투자 관련 문서 청크 반환\n4. **Thought**: \"이 정보로 요약을 작성할 수 있다\"\n5. **Final Answer**: 요약 생성\n\n### 예시 3: 웹 검색\n\n::: {#fdb1e5de .cell execution_count=17}\n``` {.python .cell-code}\nconfig = {\"configurable\": {\"thread_id\": \"abc123\"}}\ninputs = {\n    \"messages\": [\n        (\n            \"human\",\n            \"한강 작가의 노벨상 수상 관련된 뉴스를 검색하고 보고서 형식에 맞게 작성해줘\",\n        )\n    ]\n}\nstream_graph(agent_executor, inputs, config, node_names=[\"agent\", \"tools\"])\n```\n:::\n\n\n**실행 흐름:**\n1. **Thought**: \"최신 뉴스를 검색해야 한다\"\n2. **Action**: `web_search` 실행\n3. **Observation**: 검색 결과 확인\n4. **Thought**: \"보고서 형식으로 정리해야 한다\"\n5. **Final Answer**: 보고서 작성\n\n### 예시 4: 복합 작업 (검색 + 작성 + 저장)\n\n::: {#bfe10ca5 .cell execution_count=18}\n``` {.python .cell-code}\ninstruction = \"\"\"\n당신의 임무는 `보도자료`를 작성하는 것이다.\n----\n다음의 내용을 순서대로 처리해 주세요.\n1. `한강 작가의 노벨상 수상` 관련된 뉴스를 검색해 주세요.\n2. 노벨상 수상 관련 뉴스를 바탕으로 보고서 / 보드자료 작성해 주세요.\n3. 단, 중간에 요점 정리를 위한 markdown 테이블 형식 요약을 적극 활용해 주세요.\n4. 출력 결과를 파일로 저장해 주세요. (파일 이름은 \"agent_press_release.md\")\n\"\"\"\n```\n:::\n\n\n::: {#ddf83aca .cell execution_count=19}\n``` {.python .cell-code}\nconfig = {\"configurable\": {\"thread_id\": \"abc123\"}}\ninputs = {\"messages\": [(\"human\", instruction)]}\nstream_graph(agent_executor, inputs, config, node_names=[\"agent\", \"tools\"])\n```\n:::\n\n\n**실행 흐름:**\n1. **웹 검색**: `web_search` 도구로 최신 뉴스 검색\n2. **보고서 작성**: 검색 결과를 바탕으로 markdown 보고서 작성\n3. **파일 저장**: `write_file` 도구로 파일 저장\n\n**멀티 도구 사용:**\n- 하나의 작업에서 여러 도구를 순차적으로 사용\n- 각 도구의 결과를 다음 단계의 입력으로 활용\n- 복잡한 워크플로우를 자동화\n\n## ReAct Agent 활용 팁\n\n### 도구 선택 최적화\n\n**명확한 도구 설명 작성:**\n```python\ntool.name = \"specific_tool_name\"\ntool.description = \"Use this tool when [specific condition]. It returns [output format].\"\n```\n\n**도구 우선순위 힌트:**\n- 시스템 프롬프트에 도구 사용 가이드 추가\n- 도구 설명에 사용 시기 명시\n\n### 에러 처리\n\n**일반적인 문제:**\n1. **무한 루프**: 최대 반복 횟수 설정\n2. **잘못된 도구 선택**: 도구 설명 개선\n3. **메모리 부족**: Thread ID 정리\n\n**해결 방법:**\n```python\nagent_executor = create_react_agent(\n    model, \n    tools, \n    checkpointer=memory,\n    # 최대 반복 횟수 제한\n    max_iterations=10,\n    # 에러 발생 시 계속 진행\n    handle_parsing_errors=True\n)\n```\n\n### 성능 최적화\n\n**모델 선택:**\n- **빠른 응답**: GPT-4o-mini\n- **복잡한 추론**: GPT-4o\n\n**도구 개수:**\n- 너무 많은 도구 → 선택 혼란\n- 권장: 3-7개 도구\n\n**메모리 관리:**\n- 긴 대화 → 토큰 소비 증가\n- 주기적으로 Thread 초기화\n\n## ReAct vs 다른 패턴\n\n| 패턴 | 추론 | 도구 사용 | 반복 | 투명성 |\n|------|------|----------|------|--------|\n| **ReAct** | ✅ | ✅ | ✅ | 높음 |\n| **Chain-of-Thought** | ✅ | ❌ | ❌ | 높음 |\n| **Tool-only** | ❌ | ✅ | ❌ | 낮음 |\n| **Plan-and-Execute** | ✅ | ✅ | 제한적 | 중간 |\n\n**ReAct의 장점:**\n- 각 단계에서 \"왜\"를 설명\n- 실패 시 재시도 가능\n- 디버깅이 쉬움\n\n**단점:**\n- 토큰 소비가 많음\n- 느린 실행 속도\n\n## 참고 자료\n\n- [ReAct 논문](https://arxiv.org/abs/2210.03629)\n- [LangGraph ReAct Agent](https://langchain-ai.github.io/langgraph/reference/prebuilt/#create_react_agent)\n- [LangChain Tools](https://python.langchain.com/docs/modules/agents/tools/)\n\n## 다음 단계\n\nReAct Agent의 기본을 익혔다면, 다음 주제들을 살펴보자:\n\n- **커스텀 도구 개발**: 특화된 도구 만들기\n- **Plan-and-Execute Agent**: 더 복잡한 작업 계획\n- **Multi-Agent 시스템**: 여러 에이전트 협업\n\n",
    "supporting": [
      "12-React-Agent_files"
    ],
    "filters": [],
    "includes": {}
  }
}